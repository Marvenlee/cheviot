diff -aurN third_party_original/newlib-4.1.0/configure third_party/newlib-4.1.0/configure
--- third_party_original/newlib-4.1.0/configure	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/configure	2024-03-17 17:47:03.827202561 +0000
@@ -3620,6 +3620,9 @@
 
 # Disable newlib and libgloss for various target OSes.
 case "${target}" in
+  arm*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   alpha*-dec-osf*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -aurN third_party_original/newlib-4.1.0/configure.ac third_party/newlib-4.1.0/configure.ac
--- third_party_original/newlib-4.1.0/configure.ac	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/configure.ac	2024-03-17 17:47:03.839202792 +0000
@@ -956,6 +956,9 @@
 
 # Disable newlib and libgloss for various target OSes.
 case "${target}" in
+  arm*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   alpha*-dec-osf*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -aurN third_party_original/newlib-4.1.0/newlib/configure.host third_party/newlib-4.1.0/newlib/configure.host
--- third_party_original/newlib-4.1.0/newlib/configure.host	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/configure.host	2024-03-17 17:47:03.723200552 +0000
@@ -471,11 +471,11 @@
 	have_crt0="no"
 	;;
   arm*-*-*)
-	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB"
+	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB -D_HAVE_STDC"
 	sys_dir=arm
-	if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
-	  have_crt0="no"
-	fi
+  newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DHAVE_GETTIMEOFDAY -DEXIT_PROVIDED -DMISSING_SYSCALL_NAMES -DHAVE_OPENDIR -DHAVE_RENAME"
+	newlib_cflags="${newlib_cflags} -D_NO_GETLOGIN -D_NO_GETPWENT -D_NO_GETUT -D_NO_GETPASS -D_NO_WORDEXP -D_NO_POPEN"
+	unix_dir=unix
 	;;
   bfin-*-*)
 	sys_dir=
@@ -698,7 +698,7 @@
 	syscall_dir=syscalls
 	;;
   arm*-*-*)
-	syscall_dir=syscalls
+	syscall_dir=
 # If newlib is supplying syscalls, select which debug protocol is being used.
 # ARM_RDP_MONITOR selects the Demon monitor.
 # ARM_RDI_MONITOR selects the Angel monitor.
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/stdlib/mallocr.c third_party/newlib-4.1.0/newlib/libc/stdlib/mallocr.c
--- third_party_original/newlib-4.1.0/newlib/libc/stdlib/mallocr.c	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/stdlib/mallocr.c	2024-03-17 17:47:03.451195299 +0000
@@ -610,7 +610,7 @@
 */
 
 #ifndef HAVE_MMAP
-#define HAVE_MMAP 1
+#define HAVE_MMAP 0
 #endif
 
 /*
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/access.c third_party/newlib-4.1.0/newlib/libc/sys/arm/access.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/access.c	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/access.c	2024-03-17 17:47:03.411194527 +0000
@@ -1,33 +1,36 @@
-/* This is file ACCESS.C */
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
 /*
- * Copyright (C) 1993 DJ Delorie
- * All rights reserved.
  *
- * Redistribution, modification, and use in source and binary forms is permitted
- * provided that the above copyright notice and following paragraph are
- * duplicated in all such forms.
- *
- * This file is distributed WITHOUT ANY WARRANTY; without even the implied
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  */
+int access(const char *path, int amode)
+{
+    int sc;
+    
+  	sc = _swi_access(path, amode);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
 
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <unistd.h>
 
-int access(const char *fn, int flags)
+/*
+ *
+ */
+mode_t umask(mode_t cmask)
 {
-  struct stat s;
-  if (stat(fn, &s))
-    return -1;
-  if (s.st_mode & S_IFDIR)
-    return 0;
-  if (flags & W_OK)
-  {
-    if (s.st_mode & S_IWRITE)
-      return 0;
-    return -1;
-  }
-  return 0;
+    mode_t mask;
+    
+  	mask = _swi_umask(cmask);
+    return mask;
 }
-	
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/acconfig.h third_party/newlib-4.1.0/newlib/libc/sys/arm/acconfig.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/acconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/acconfig.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,26 @@
+/* Name of package.  */
+#undef PACKAGE
+
+/* Version of package.  */
+#undef VERSION
+
+/* Missing syscall names */
+#undef MISSING_SYSCALL_NAMES
+
+/* Using ELF format */
+#undef HAVE_ELF
+
+/* Using GNU LD */
+#undef HAVE_GNU_LD
+
+/* .previous directive allowed */
+#undef HAVE_ASM_PREVIOUS_DIRECTIVE
+
+/* .pushsection/.popsection directives allowed */
+#undef HAVE_ASM_POPSECTION_DIRECTIVE
+
+/* support for section attributes */
+#undef HAVE_SECTION_ATTRIBUTES
+
+/* symbol prefix */
+#undef __SYMBOL_PREFIX
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/aclocal.m4 third_party/newlib-4.1.0/newlib/libc/sys/arm/aclocal.m4
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/aclocal.m4	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/aclocal.m4	2024-03-17 17:47:03.411194527 +0000
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.11.6 -*- Autoconf -*-
+# generated automatically by aclocal 1.12 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 # 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
@@ -14,20 +14,19 @@
 
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,
-[m4_warning([this file was generated for autoconf 2.68.
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,
+[m4_warning([this file was generated for autoconf 2.64.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
+To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 2002-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 8
 
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
@@ -35,10 +34,10 @@
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.11'
+[am__api_version='1.12'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.6], [],
+m4_if([$1], [1.12], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -54,24 +53,24 @@
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.6])dnl
+[AM_AUTOMAKE_VERSION([1.12])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
+# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
 #
 # Of course, Automake must honor this variable whenever it calls a
 # tool from the auxiliary directory.  The problem is that $srcdir (and
@@ -90,7 +89,7 @@
 #
 # The reason of the latter failure is that $top_srcdir and $ac_aux_dir
 # are both prefixed by $srcdir.  In an in-source build this is usually
-# harmless because $srcdir is `.', but things will broke when you
+# harmless because $srcdir is '.', but things will broke when you
 # start a VPATH build or use an absolute $srcdir.
 #
 # So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
@@ -116,22 +115,21 @@
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 9
+# serial 10
 
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
 # Define a conditional.
 AC_DEFUN([AM_CONDITIONAL],
-[AC_PREREQ(2.52)dnl
- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
-	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+[AC_PREREQ([2.52])dnl
+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
 AC_SUBST([$1_TRUE])dnl
 AC_SUBST([$1_FALSE])dnl
 _AM_SUBST_NOTMAKE([$1_TRUE])dnl
@@ -150,16 +148,15 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,
-# 2010, 2011 Free Software Foundation, Inc.
+# Copyright (C) 1999-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 12
+# serial 16
 
-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
 # will think it sees a *use*, and therefore will trigger all it's
 # C support machinery.  Also note that it means that autoscan, seeing
@@ -182,12 +179,12 @@
 AC_REQUIRE([AM_MAKE_INCLUDE])dnl
 AC_REQUIRE([AM_DEP_TRACK])dnl
 
-ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
-       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
-       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
-       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
-                   [depcc="$$1"   am_compiler_list=])
+m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
+      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
+      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
+      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                    [depcc="$$1"   am_compiler_list=])
 
 AC_CACHE_CHECK([dependency style of $depcc],
                [am_cv_$1_dependencies_compiler_type],
@@ -195,8 +192,8 @@
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -236,16 +233,16 @@
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -254,8 +251,8 @@
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -263,7 +260,7 @@
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -311,7 +308,7 @@
 # AM_SET_DEPDIR
 # -------------
 # Choose a directory name for dependency files.
-# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
 AC_DEFUN([AM_SET_DEPDIR],
 [AC_REQUIRE([AM_SET_LEADING_DOT])dnl
 AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
@@ -321,9 +318,13 @@
 # AM_DEP_TRACK
 # ------------
 AC_DEFUN([AM_DEP_TRACK],
-[AC_ARG_ENABLE(dependency-tracking,
-[  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors])
+[AC_ARG_ENABLE([dependency-tracking], [dnl
+AS_HELP_STRING(
+  [--enable-dependency-tracking],
+  [do not reject slow dependency extractors])
+AS_HELP_STRING(
+  [--disable-dependency-tracking],
+  [speeds up one-time build])])
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
@@ -338,14 +339,13 @@
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1999-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-#serial 5
+# serial 6
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
@@ -364,7 +364,7 @@
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -376,21 +376,19 @@
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
     test -z "am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`AS_DIRNAME(["$file"])`
@@ -408,7 +406,7 @@
 # This macro should only be invoked once -- use via AC_REQUIRE.
 #
 # This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each `.P' file that we will
+# is enabled.  FIXME.  This creates each '.P' file that we will
 # need in order to bootstrap the dependency handling code.
 AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 [AC_CONFIG_COMMANDS([depfiles],
@@ -418,14 +416,13 @@
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 1996-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 16
+# serial 18
 
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
@@ -476,23 +473,25 @@
  AC_SUBST([VERSION], [$2])],
 [_AM_SET_OPTIONS([$1])dnl
 dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+m4_if(
+  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
+  [ok:ok],,
   [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
  AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
  AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
 
 _AM_IF_OPTION([no-define],,
-[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
- AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
+ AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl
 
 # Some tools Automake needs.
 AC_REQUIRE([AM_SANITY_CHECK])dnl
 AC_REQUIRE([AC_ARG_PROGRAM])dnl
-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
-AM_MISSING_PROG(AUTOCONF, autoconf)
-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
-AM_MISSING_PROG(AUTOHEADER, autoheader)
-AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
+AM_MISSING_PROG([AUTOCONF], [autoconf])
+AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
+AM_MISSING_PROG([AUTOHEADER], [autoheader])
+AM_MISSING_PROG([MAKEINFO], [makeinfo])
 AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
 AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
 AC_REQUIRE([AM_PROG_MKDIR_P])dnl
@@ -506,28 +505,28 @@
 			     [_AM_PROG_TAR([v7])])])
 _AM_IF_OPTION([no-dependencies],,
 [AC_PROVIDE_IFELSE([AC_PROG_CC],
-		  [_AM_DEPENDENCIES(CC)],
+		  [_AM_DEPENDENCIES([CC])],
 		  [define([AC_PROG_CC],
-			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+			  defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_CXX],
-		  [_AM_DEPENDENCIES(CXX)],
+		  [_AM_DEPENDENCIES([CXX])],
 		  [define([AC_PROG_CXX],
-			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-		  [_AM_DEPENDENCIES(OBJC)],
+		  [_AM_DEPENDENCIES([OBJC])],
 		  [define([AC_PROG_OBJC],
-			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
 ])
 _AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
+dnl The 'parallel-tests' driver may need to know about EXEEXT, so add the
+dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
 dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
 AC_CONFIG_COMMANDS_PRE(dnl
 [m4_provide_if([_AM_COMPILER_EXEEXT],
   [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
 ])
 
-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
 dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
 dnl mangled by Autoconf and run in a shell conditional statement.
 m4_define([_AC_COMPILER_EXEEXT],
@@ -555,14 +554,13 @@
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 8
 
 # AM_PROG_INSTALL_SH
 # ------------------
@@ -577,9 +575,9 @@
     install_sh="\${SHELL} $am_aux_dir/install-sh"
   esac
 fi
-AC_SUBST(install_sh)])
+AC_SUBST([install_sh])])
 
-# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2003-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -603,20 +601,19 @@
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,
-# 2011 Free Software Foundation, Inc.
+# Copyright (C) 1996-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 7
 
 # AM_MAINTAINER_MODE([DEFAULT-MODE])
 # ----------------------------------
 # Control maintainer-specific portions of Makefiles.
-# Default is to disable them, unless `enable' is passed literally.
-# For symmetry, `disable' may be passed as well.  Anyway, the user
+# Default is to disable them, unless 'enable' is passed literally.
+# For symmetry, 'disable' may be passed as well.  Anyway, the user
 # can override the default with the --enable/--disable switch.
 AC_DEFUN([AM_MAINTAINER_MODE],
 [m4_case(m4_default([$1], [disable]),
@@ -627,10 +624,11 @@
 AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
   dnl maintainer-mode's default is 'disable' unless 'enable' is passed
   AC_ARG_ENABLE([maintainer-mode],
-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer],
-      [USE_MAINTAINER_MODE=$enableval],
-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],
+      am_maintainer_other[ make rules and dependencies not useful
+      (and sometimes confusing) to the casual installer])],
+    [USE_MAINTAINER_MODE=$enableval],
+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
   AC_MSG_RESULT([$USE_MAINTAINER_MODE])
   AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
   MAINT=$MAINTAINER_MODE_TRUE
@@ -642,13 +640,13 @@
 
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 4
+# serial 5
 
 # AM_MAKE_INCLUDE()
 # -----------------
@@ -667,7 +665,7 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -694,14 +692,13 @@
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 6
+# serial 7
 
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
@@ -731,22 +728,21 @@
   am_missing_run="$MISSING --run "
 else
   am_missing_run=
-  AC_MSG_WARN([`missing' script is too old or missing])
+  AC_MSG_WARN(['missing' script is too old or missing])
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2003-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # AM_PROG_MKDIR_P
 # ---------------
-# Check for `mkdir -p'.
+# Check for 'mkdir -p'.
 AC_DEFUN([AM_PROG_MKDIR_P],
 [AC_PREREQ([2.60])dnl
 AC_REQUIRE([AC_PROG_MKDIR_P])dnl
@@ -766,14 +762,13 @@
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 6
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -784,7 +779,7 @@
 # --------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+[m4_define(_AM_MANGLE_OPTION([$1]), [1])])
 
 # _AM_SET_OPTIONS(OPTIONS)
 # ------------------------
@@ -800,22 +795,18 @@
 
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1996-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 9
 
 # AM_SANITY_CHECK
 # ---------------
 AC_DEFUN([AM_SANITY_CHECK],
 [AC_MSG_CHECKING([whether build environment is sane])
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
@@ -826,32 +817,40 @@
 esac
 case $srcdir in
   *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$[*]" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$[*]" != "X $srcdir/configure conftest.file" \
-      && test "$[*]" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
-alias in your environment])
-   fi
-
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$[*]" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$[*]" != "X $srcdir/configure conftest.file" \
+	&& test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment])
+     fi
+     if test "$[2]" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$[2]" = conftest.file
    )
 then
@@ -861,39 +860,55 @@
    AC_MSG_ERROR([newly created file is older than distributed files!
 Check your system clock])
 fi
-AC_MSG_RESULT(yes)])
+AC_MSG_RESULT([yes])
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+AC_CONFIG_COMMANDS_PRE(
+  [AC_MSG_CHECKING([that generated files are newer than configure])
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   AC_MSG_RESULT([done])])
+rm -f conftest.file
+])
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # AM_PROG_INSTALL_STRIP
 # ---------------------
-# One issue with vendor `install' (even GNU) is that you can't
+# One issue with vendor 'install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
 # is unlikely to handle the host's binaries.
 # Fortunately install-sh will honor a STRIPPROG variable, so we
-# always use install-sh in `make install-strip', and initialize
+# always use install-sh in "make install-strip", and initialize
 # STRIPPROG with the value of the STRIP variable (set by the user).
 AC_DEFUN([AM_PROG_INSTALL_STRIP],
 [AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+# will honor the 'STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
 if test "$cross_compiling" != no; then
   AC_CHECK_TOOL([STRIP], [strip], :)
 fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
+# Copyright (C) 2006-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -914,18 +929,18 @@
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
+# Copyright (C) 2004-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_PROG_TAR(FORMAT)
 # --------------------
 # Check how to create a tarball in format FORMAT.
-# FORMAT should be one of `v7', `ustar', or `pax'.
+# FORMAT should be one of 'v7', 'ustar', or 'pax'.
 #
 # Substitute a variable $(am__tar) that is a command
 # writing to stdout a FORMAT-tarball containing the directory
@@ -948,7 +963,7 @@
 _am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
 _am_tools=${am_cv_prog_tar_$1-$_am_tools}
 # Do not fold the above two line into one, because Tru64 sh and
-# Solaris sh will not grok spaces in the rhs of `-'.
+# Solaris sh will not grok spaces in the rhs of '-'.
 for _am_tool in $_am_tools
 do
   case $_am_tool in
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/aeabi_atexit.c third_party/newlib-4.1.0/newlib/libc/sys/arm/aeabi_atexit.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/aeabi_atexit.c	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/aeabi_atexit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-#include <stdlib.h>
-
-/* forward declaration */
-extern int __cxa_atexit (void (*) (void *), void *, void *);
-
-/* Register a function to be called by exit or when a shared library
-   is unloaded.  This routine is like __cxa_atexit, but uses the
-   calling sequence required by the ARM EABI.  */
-int
-__aeabi_atexit (void *arg, void (*func) (void *), void *d)
-{
-  return __cxa_atexit (func, arg, d);
-}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/alarm.c third_party/newlib-4.1.0/newlib/libc/sys/arm/alarm.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/alarm.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/alarm.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,15 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+unsigned int alarm (unsigned int seconds)
+{
+    return _swi_alarm(seconds);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/arm.h third_party/newlib-4.1.0/newlib/libc/sys/arm/arm.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/arm.h	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/arm.h	2024-03-17 17:47:03.407194450 +0000
@@ -29,27 +29,25 @@
 #ifndef _LIBGLOSS_ARM_H
 #define _LIBGLOSS_ARM_H
 
-#include "acle-compat.h"
-
-/* Checking for targets supporting only Thumb instructions (eg. ARMv6-M) or
-   supporting Thumb-2 instructions, whether ARM instructions are available or
-   not, is done many times in libgloss/arm.  So factor it out and use
-   PREFER_THUMB instead.  */
-#if __thumb2__ || (__thumb__ && !__ARM_ARCH_ISA_ARM)
-# define PREFER_THUMB
-#endif
-
-/* Processor only capable of executing Thumb-1 instructions.  */
-#if __ARM_ARCH_ISA_THUMB == 1 && !__ARM_ARCH_ISA_ARM
-# define THUMB1_ONLY
+/* __thumb2__ stands for thumb on armva7(A/R/M/EM) architectures,
+   __ARM_ARCH_6M__ stands for armv6-M(thumb only) architecture,
+   __ARM_ARCH_7M__ stands for armv7-M(thumb only) architecture.
+   __ARM_ARCH_7EM__ stands for armv7e-M(thumb only) architecture.
+   There are some macro combinations used many times in libgloss/arm,
+   like (__thumb2__ || (__thumb__ && __ARM_ARCH_6M__)), so factor
+   it out and use THUMB_V7_V6M instead, which stands for thumb on
+   v6-m/v7 arch as the combination does.  */
+#if defined(__thumb2__) || (defined(__thumb__) && defined(__ARM_ARCH_6M__))
+# define THUMB_V7_V6M
 #endif
 
-/* M profile architectures.  This is a different set of architectures than
-   those not having ARM ISA because it does not contain ARMv7.  This macro is
-   necessary to test which architectures use bkpt as semihosting interface from
-   architectures using svc.  */
-#if !__ARM_ARCH_ISA_ARM && !__ARM_ARCH_7__
-# define THUMB_VXM
+/* The (__ARM_ARCH_7EM__ || __ARM_ARCH_7M__ || __ARM_ARCH_6M__) combination
+   stands for cortex-M profile architectures, which don't support ARM state.
+   Factor it out and use THUMB_V7M_V6M instead.  */
+#if defined(__ARM_ARCH_7M__)     \
+    || defined(__ARM_ARCH_7EM__) \
+    || defined(__ARM_ARCH_6M__)
+# define THUMB_V7M_V6M
 #endif
 
 /* Defined if this target supports the BLX Rm instruction.  */
@@ -61,30 +59,4 @@
 # define HAVE_CALL_INDIRECT
 #endif
 
-/* A and R profiles (and legacy Arm).
-	Current Program Status Register (CPSR)
-	M[4:0]		Mode bits. M[4] is always 1 for 32-bit modes.
-	T[5]			1: Thumb, 0: ARM instruction set
-	F[6]			1: disables FIQ
-	I[7]			1: disables IRQ
-	A[8]			1: disables imprecise aborts
-	E[9]			0: Little-endian, 1: Big-endian
-	J[24]			1: Jazelle instruction set
- */
-#define CPSR_M_USR			0x00	/* User mode.  */
-#define CPSR_M_FIQ			0x01	/* Fast Interrupt mode.  */
-#define CPSR_M_IRQ			0x02	/* Interrupt mode.  */
-#define CPSR_M_SVR			0x03	/* Supervisor mode.  */
-#define CPSR_M_MON			0x06	/* Monitor mode.  */
-#define CPSR_M_ABT			0x07	/* Abort mode.  */
-#define CPSR_M_HYP			0x0A	/* Hypervisor mode.  */
-#define CPSR_M_UND			0x0B	/* Undefined mode.  */
-#define CPSR_M_SYS			0x0F	/* System mode.  */
-#define CPSR_M_32BIT		0x10	/* 32-bit mode.  */
-#define CPSR_T_BIT			0x20	/* Thumb bit.  */
-#define CPSR_F_MASK			0x40	/* FIQ bit.  */
-#define CPSR_I_MASK			0x80	/* IRQ bit.  */
-
-#define CPSR_M_MASK			0x0F	/* Mode mask except M[4].  */
-
 #endif /* _LIBGLOSS_ARM_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/chmod.c third_party/newlib-4.1.0/newlib/libc/sys/arm/chmod.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/chmod.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/chmod.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,79 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+int chmod(const char *__path, mode_t __mode )
+{
+  int sc;
+  
+  sc = _swi_chmod(__path, __mode);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+/*
+ *
+ */
+int chown (const char *__path, uid_t __owner, gid_t __group )
+{
+  int sc;
+  
+  sc = _swi_chown(__path, __owner, __group);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+/*
+ *
+ */
+int fchmod(int fd, mode_t __mode )
+{
+  int sc;
+  
+  sc = _swi_fchmod(fd, __mode);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+/*
+ *
+ */
+int fchown(int fd, uid_t __owner, gid_t __group )
+{
+  int sc;
+  
+  sc = _swi_fchown(fd, __owner, __group);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/close.c third_party/newlib-4.1.0/newlib/libc/sys/arm/close.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/close.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/close.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int close (int fd)
+{
+    int sc;
+    
+    sc = _swi_close(fd);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/closedir.c third_party/newlib-4.1.0/newlib/libc/sys/arm/closedir.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/closedir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/closedir.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,32 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int closedir (DIR *dir)
+{
+    int sc;
+    	
+    if (dir == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    sc = _swi_close (dir->fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    free (dir->buf);
+    free (dir);
+    return 0;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure third_party/newlib-4.1.0/newlib/libc/sys/arm/configure
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/configure	2024-03-17 17:47:03.407194450 +0000
@@ -89,7 +89,6 @@
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -214,18 +213,11 @@
   # We cannot yet assume a decent shell, so we have to provide a
 	# neutralization value for shells without unset; and this also
 	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
 	BASH_ENV=/dev/null
 	ENV=/dev/null
 	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
 	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
 fi
 
     if test x$as_have_required = xno; then :
@@ -323,7 +315,7 @@
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -363,19 +355,19 @@
 fi # as_fn_arith
 
 
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
+# script with status $?, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
   fi
-  $as_echo "$as_me: error: $2" >&2
+  $as_echo "$as_me: error: $1" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -533,11 +525,10 @@
 as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
-test -n "$DJDIR" || exec 7<&0 </dev/null
-exec 6>&1
+exec 7<&0 </dev/null 6>&1
 
 # Name of the host.
-# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
@@ -561,7 +552,7 @@
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
-ac_unique_file="trap.S"
+ac_unique_file="virtualalloc.c"
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 sys_dir
@@ -760,9 +751,8 @@
   fi
 
   case $ac_option in
-  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *=)   ac_optarg= ;;
-  *)    ac_optarg=yes ;;
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -807,7 +797,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -833,7 +823,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1037,7 +1027,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1053,7 +1043,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1083,8 +1073,8 @@
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) as_fn_error $? "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information"
+  -*) as_fn_error "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information."
     ;;
 
   *=*)
@@ -1092,7 +1082,7 @@
     # Reject names that are not valid shell variable names.
     case $ac_envvar in #(
       '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
@@ -1102,7 +1092,7 @@
     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
     ;;
 
   esac
@@ -1110,13 +1100,13 @@
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error $? "missing argument to $ac_option"
+  as_fn_error "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1139,7 +1129,7 @@
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1153,8 +1143,8 @@
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1169,9 +1159,9 @@
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error $? "working directory cannot be determined"
+  as_fn_error "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error $? "pwd does not report name of working directory"
+  as_fn_error "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1210,11 +1200,11 @@
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1254,7 +1244,7 @@
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking ...' messages
+  -q, --quiet, --silent   do not print \`checking...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1327,10 +1317,13 @@
   --disable-newlib-io-float disable printf/scanf family float support
   --disable-newlib-supplied-syscalls disable newlib from supplying syscalls
   --disable-newlib-fno-builtin disable -fno-builtin flag to allow compiler to use builtin library functions
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-maintainer-mode  enable make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer
+  --enable-dependency-tracking
+                          do not reject slow dependency extractors
+  --disable-dependency-tracking
+                          speeds up one-time build
+  --enable-maintainer-mode
+                          enable make rules and dependencies not useful (and
+                          sometimes confusing) to the casual installer
 
 Some influential environment variables:
   CCAS        assembler compiler command (defaults to CC)
@@ -1449,8 +1442,8 @@
 
 	ac_retval=1
 fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
 
 } # ac_fn_c_try_compile
 cat >config.log <<_ACEOF
@@ -1568,9 +1561,11 @@
   {
     echo
 
-    $as_echo "## ---------------- ##
+    cat <<\_ASBOX
+## ---------------- ##
 ## Cache variables. ##
-## ---------------- ##"
+## ---------------- ##
+_ASBOX
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
@@ -1604,9 +1599,11 @@
 )
     echo
 
-    $as_echo "## ----------------- ##
+    cat <<\_ASBOX
+## ----------------- ##
 ## Output variables. ##
-## ----------------- ##"
+## ----------------- ##
+_ASBOX
     echo
     for ac_var in $ac_subst_vars
     do
@@ -1619,9 +1616,11 @@
     echo
 
     if test -n "$ac_subst_files"; then
-      $as_echo "## ------------------- ##
+      cat <<\_ASBOX
+## ------------------- ##
 ## File substitutions. ##
-## ------------------- ##"
+## ------------------- ##
+_ASBOX
       echo
       for ac_var in $ac_subst_files
       do
@@ -1635,9 +1634,11 @@
     fi
 
     if test -s confdefs.h; then
-      $as_echo "## ----------- ##
+      cat <<\_ASBOX
+## ----------- ##
 ## confdefs.h. ##
-## ----------- ##"
+## ----------- ##
+_ASBOX
       echo
       cat confdefs.h
       echo
@@ -1692,12 +1693,7 @@
 ac_site_file1=NONE
 ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  # We do not want a PATH search for config.site.
-  case $CONFIG_SITE in #((
-    -*)  ac_site_file1=./$CONFIG_SITE;;
-    */*) ac_site_file1=$CONFIG_SITE;;
-    *)   ac_site_file1=./$CONFIG_SITE;;
-  esac
+  ac_site_file1=$CONFIG_SITE
 elif test "x$prefix" != xNONE; then
   ac_site_file1=$prefix/share/config.site
   ac_site_file2=$prefix/etc/config.site
@@ -1708,22 +1704,18 @@
 for ac_site_file in "$ac_site_file1" "$ac_site_file2"
 do
   test "x$ac_site_file" = xNONE && continue
-  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+  if test -r "$ac_site_file"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file" \
-      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "failed to load site script $ac_site_file
-See \`config.log' for more details" "$LINENO" 5; }
+    . "$ac_site_file"
   fi
 done
 
 if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special files
-  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
-  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
 $as_echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
@@ -1792,7 +1784,7 @@
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
@@ -1809,22 +1801,16 @@
 
 ac_aux_dir=
 for ac_dir in ../../../.. "$srcdir"/../../../..; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
 done
 if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in ../../../.. \"$srcdir\"/../../../.." "$LINENO" 5
+  as_fn_error "cannot find install-sh, install.sh, or shtool in ../../../.. \"$srcdir\"/../../../.." "$LINENO" 5
 fi
 
 # These three variables are undocumented and unsupported,
@@ -1840,27 +1826,27 @@
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
+if test "${ac_cv_build+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_build_alias=$build_alias
 test "x$ac_build_alias" = x &&
   ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
 test "x$ac_build_alias" = x &&
-  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
 ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
 $as_echo "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
-*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -1878,14 +1864,14 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
 $as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
+if test "${ac_cv_host+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test "x$host_alias" = x; then
   ac_cv_host=$ac_cv_build
 else
   ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
@@ -1893,7 +1879,7 @@
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -1909,7 +1895,7 @@
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-am__api_version='1.11'
+am__api_version='1.12'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
@@ -1928,7 +1914,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
 $as_echo_n "checking for a BSD-compatible install... " >&6; }
 if test -z "$INSTALL"; then
-if ${ac_cv_path_install+:} false; then :
+if test "${ac_cv_path_install+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -2006,56 +1992,71 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
 $as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
 '
 case `pwd` in
   *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5;;
+    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+    as_fn_error "unsafe srcdir value: '$srcdir'" "$LINENO" 5;;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$*" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$*" != "X $srcdir/configure conftest.file" \
+	&& test "$*" != "X conftest.file $srcdir/configure"; then
 
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment" "$LINENO" 5
+     fi
+     if test "$2" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$2" = conftest.file
    )
 then
    # Ok.
    :
 else
-   as_fn_error $? "newly created file is older than distributed files!
+   as_fn_error "newly created file is older than distributed files!
 Check your system clock" "$LINENO" 5
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+
+rm -f conftest.file
+
 test "$program_prefix" != NONE &&
   program_transform_name="s&^&$program_prefix&;$program_transform_name"
 # Use a double $ so make ignores it.
@@ -2082,8 +2083,8 @@
   am_missing_run="$MISSING --run "
 else
   am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
 fi
 
 if test x"${install_sh}" != xset; then
@@ -2095,17 +2096,17 @@
   esac
 fi
 
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
+# will honor the 'STRIP' environment variable to overrule this program.
 if test "$cross_compiling" != no; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_STRIP+:} false; then :
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$STRIP"; then
@@ -2145,7 +2146,7 @@
 set dummy strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_STRIP"; then
@@ -2198,7 +2199,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
 $as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
 if test -z "$MKDIR_P"; then
-  if ${ac_cv_path_mkdir+:} false; then :
+  if test "${ac_cv_path_mkdir+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -2223,7 +2224,6 @@
 
 fi
 
-  test -d ./--version && rmdir ./--version
   if test "${ac_cv_path_mkdir+set}" = set; then
     MKDIR_P="$ac_cv_path_mkdir -p"
   else
@@ -2231,6 +2231,7 @@
     # value for MKDIR_P within a source directory, because that will
     # break other packages using the cache if that directory is
     # removed, or if the value is a relative name.
+    test -d ./--version && rmdir ./--version
     MKDIR_P="$ac_install_sh -d"
   fi
 fi
@@ -2249,7 +2250,7 @@
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AWK+:} false; then :
+if test "${ac_cv_prog_AWK+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AWK"; then
@@ -2289,7 +2290,7 @@
 $as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
 ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
@@ -2297,7 +2298,7 @@
 all:
 	@echo '@@@%%%=$(MAKE)=@@@%%%'
 _ACEOF
-# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
 case `${MAKE-make} -f conftest.make 2>/dev/null` in
   *@@@%%%=?*=@@@%%%*)
     eval ac_cv_prog_make_${ac_make}_set=yes;;
@@ -2344,7 +2345,7 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -2394,7 +2395,7 @@
   enableval=$enable_multilib; case "${enableval}" in
   yes) multilib=yes ;;
   no)  multilib=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
  esac
 else
   multilib=yes
@@ -2405,7 +2406,7 @@
   enableval=$enable_target_optspace; case "${enableval}" in
   yes) target_optspace=yes ;;
   no)  target_optspace=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for target-optspace option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for target-optspace option" "$LINENO" 5 ;;
  esac
 else
   target_optspace=
@@ -2416,7 +2417,7 @@
   enableval=$enable_malloc_debugging; case "${enableval}" in
   yes) malloc_debugging=yes ;;
   no)  malloc_debugging=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for malloc-debugging option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for malloc-debugging option" "$LINENO" 5 ;;
  esac
 else
   malloc_debugging=
@@ -2427,7 +2428,7 @@
   enableval=$enable_newlib_multithread; case "${enableval}" in
   yes) newlib_multithread=yes ;;
   no)  newlib_multithread=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-multithread option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-multithread option" "$LINENO" 5 ;;
  esac
 else
   newlib_multithread=yes
@@ -2439,7 +2440,7 @@
    case "${enableval}" in
      yes) newlib_iconv=yes ;;
      no)  newlib_iconv=no ;;
-     *)   as_fn_error $? "bad value ${enableval} for newlib-iconv option" "$LINENO" 5 ;;
+     *)   as_fn_error "bad value ${enableval} for newlib-iconv option" "$LINENO" 5 ;;
    esac
  fi
 else
@@ -2454,7 +2455,7 @@
   2)   newlib_elix_level=2 ;;
   3)   newlib_elix_level=3 ;;
   4)   newlib_elix_level=4 ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5 ;;
  esac
 else
   newlib_elix_level=0
@@ -2465,7 +2466,7 @@
   enableval=$enable_newlib_io_float; case "${enableval}" in
   yes) newlib_io_float=yes ;;
   no)  newlib_io_float=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-io-float option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-io-float option" "$LINENO" 5 ;;
  esac
 else
   newlib_io_float=yes
@@ -2476,7 +2477,7 @@
   enableval=$enable_newlib_supplied_syscalls; case "${enableval}" in
   yes) newlib_may_supply_syscalls=yes ;;
   no)  newlib_may_supply_syscalls=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5 ;;
  esac
 else
   newlib_may_supply_syscalls=yes
@@ -2496,7 +2497,7 @@
   enableval=$enable_newlib_fno_builtin; case "${enableval}" in
   yes) newlib_fno_builtin=yes ;;
   no)  newlib_fno_builtin=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-fno-builtin option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-fno-builtin option" "$LINENO" 5 ;;
  esac
 else
   newlib_fno_builtin=
@@ -2525,7 +2526,7 @@
   am__isrc=' -I$(srcdir)'
   # test to see if srcdir already configured
   if test -f $srcdir/config.status; then
-    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
   fi
 fi
 
@@ -2589,7 +2590,7 @@
 set dummy gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2627,15 +2628,15 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
 $as_echo_n "checking dependency style of $depcc... " >&6; }
-if ${am_cv_CC_dependencies_compiler_type+:} false; then :
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -2670,16 +2671,16 @@
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -2688,8 +2689,8 @@
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -2697,7 +2698,7 @@
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -2756,7 +2757,7 @@
 set dummy cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2806,12 +2807,12 @@
 fi
 
 
-  test -z "$CC" && as_fn_error $? "no acceptable cc found in \$PATH" "$LINENO" 5
+  test -z "$CC" && as_fn_error "no acceptable cc found in \$PATH" "$LINENO" 5
 fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using GNU C" >&5
 $as_echo_n "checking whether we are using GNU C... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat > conftest.c <<EOF
@@ -2841,7 +2842,7 @@
 ac_save_CFLAGS=$CFLAGS
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
+if test "${ac_cv_prog_cc_g+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
@@ -2935,7 +2936,7 @@
 set dummy ${ac_tool_prefix}as; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AS+:} false; then :
+if test "${ac_cv_prog_AS+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AS"; then
@@ -2975,7 +2976,7 @@
 set dummy as; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AS+:} false; then :
+if test "${ac_cv_prog_ac_ct_AS+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_AS"; then
@@ -3027,7 +3028,7 @@
 set dummy ${ac_tool_prefix}ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AR+:} false; then :
+if test "${ac_cv_prog_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AR"; then
@@ -3067,7 +3068,7 @@
 set dummy ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AR+:} false; then :
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_AR"; then
@@ -3119,7 +3120,7 @@
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$RANLIB"; then
@@ -3159,7 +3160,7 @@
 set dummy ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_RANLIB"; then
@@ -3211,7 +3212,7 @@
 set dummy ${ac_tool_prefix}readelf; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_READELF+:} false; then :
+if test "${ac_cv_prog_READELF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$READELF"; then
@@ -3251,7 +3252,7 @@
 set dummy readelf; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_READELF+:} false; then :
+if test "${ac_cv_prog_ac_ct_READELF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_READELF"; then
@@ -3494,21 +3495,10 @@
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
-    if test "x$cache_file" != "x/dev/null"; then
+    test "x$cache_file" != "x/dev/null" &&
       { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
-      if test ! -f "$cache_file" || test -h "$cache_file"; then
-	cat confcache >"$cache_file"
-      else
-        case $cache_file in #(
-        */* | ?:*)
-	  mv -f confcache "$cache_file"$$ &&
-	  mv -f "$cache_file"$$ "$cache_file" ;; #(
-        *)
-	  mv -f confcache "$cache_file" ;;
-	esac
-      fi
-    fi
+    cat confcache >$cache_file
   else
     { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
@@ -3560,7 +3550,6 @@
 
 ac_libobjs=
 ac_ltlibobjs=
-U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
@@ -3576,48 +3565,56 @@
 
 
 if test -z "${MAY_SUPPLY_SYSCALLS_TRUE}" && test -z "${MAY_SUPPLY_SYSCALLS_FALSE}"; then
-  as_fn_error $? "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
+  as_fn_error "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
+$as_echo_n "checking that generated files are newer than configure... " >&6; }
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
+$as_echo "done" >&6; }
 
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error $? "conditional \"AMDEP\" was never defined.
+  as_fn_error "conditional \"AMDEP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
-  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
+  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_0_TRUE}" && test -z "${ELIX_LEVEL_0_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_0\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_0\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_1_TRUE}" && test -z "${ELIX_LEVEL_1_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_1\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_1\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_2_TRUE}" && test -z "${ELIX_LEVEL_2_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_2\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_2\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_3_TRUE}" && test -z "${ELIX_LEVEL_3_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_3\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_3\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_4_TRUE}" && test -z "${ELIX_LEVEL_4_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_4\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_4\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${USE_LIBTOOL_TRUE}" && test -z "${USE_LIBTOOL_FALSE}"; then
-  as_fn_error $? "conditional \"USE_LIBTOOL\" was never defined.
+  as_fn_error "conditional \"USE_LIBTOOL\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
-: "${CONFIG_STATUS=./config.status}"
+: ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
@@ -3718,7 +3715,6 @@
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -3764,19 +3760,19 @@
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
+# script with status $?, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
   fi
-  $as_echo "$as_me: error: $2" >&2
+  $as_echo "$as_me: error: $1" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -3972,7 +3968,7 @@
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -4062,7 +4058,6 @@
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
-      --config     print configuration, then exit
   -q, --quiet, --silent
                    do not print progress messages
   -d, --debug      don't remove temporary files
@@ -4104,16 +4099,11 @@
 while test $# != 0
 do
   case $1 in
-  --*=?*)
+  --*=*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
-  --*=)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=
-    ac_shift=:
-    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -4127,15 +4117,12 @@
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
     $as_echo "$ac_cs_version"; exit ;;
-  --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -4146,7 +4133,7 @@
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) as_fn_error $? "unrecognized option: \`$1'
+  -*) as_fn_error "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
 
   *) as_fn_append ac_config_targets " $1"
@@ -4203,7 +4190,7 @@
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
 
-  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -4225,10 +4212,9 @@
 # after its creation but before its name has been assigned to `$tmp'.
 $debug ||
 {
-  tmp= ac_tmp=
+  tmp=
   trap 'exit_status=$?
-  : "${ac_tmp:=$tmp}"
-  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
 ' 0
   trap 'as_fn_exit 1' 1 2 13 15
 }
@@ -4236,13 +4222,12 @@
 
 {
   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -d "$tmp"
+  test -n "$tmp" && test -d "$tmp"
 }  ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
-ac_tmp=$tmp
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -4259,12 +4244,12 @@
 fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\\r'
+  ac_cs_awk_cr='\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
 
-echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
 _ACEOF
 
 
@@ -4273,18 +4258,18 @@
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -4292,7 +4277,7 @@
 rm -f conf$$subs.sh
 
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
 sed -n '
 h
@@ -4306,7 +4291,7 @@
 t delim
 :nl
 h
-s/\(.\{148\}\)..*/\1/
+s/\(.\{148\}\).*/\1/
 t more1
 s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
 p
@@ -4320,7 +4305,7 @@
 t nl
 :delim
 h
-s/\(.\{148\}\)..*/\1/
+s/\(.\{148\}\).*/\1/
 t more2
 s/["\\]/\\&/g; s/^/"/; s/$/"/
 p
@@ -4340,7 +4325,7 @@
 rm -f conf$$subs.awk
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
-cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
   for (key in S) S_is_set[key] = 1
   FS = ""
 
@@ -4372,29 +4357,21 @@
   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
 else
   cat
-fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
-  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
-# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
-h
-s///
-s/^/:/
-s/[	 ]*$/:/
-s/:\$(srcdir):/:/g
-s/:\${srcdir}:/:/g
-s/:@srcdir@:/:/g
-s/^:*//
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
 s/:*$//
-x
-s/\(=[	 ]*\).*/\1/
-G
-s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -4412,7 +4389,7 @@
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -4431,7 +4408,7 @@
     for ac_f
     do
       case $ac_f in
-      -) ac_f="$ac_tmp/stdin";;
+      -) ac_f="$tmp/stdin";;
       *) # Look for the file first in the build tree, then in the source tree
 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
 	 # because $ac_f cannot contain `:'.
@@ -4440,7 +4417,7 @@
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -4466,8 +4443,8 @@
     esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$ac_tmp/stdin" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -4603,24 +4580,23 @@
 s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
-  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
-      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&5
+which seems to be undefined.  Please make sure it is defined." >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&2;}
+which seems to be undefined.  Please make sure it is defined." >&2;}
 
-  rm -f "$ac_tmp/stdin"
+  rm -f "$tmp/stdin"
   case $ac_file in
-  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
-  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
   esac \
-  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
  ;;
 
 
@@ -4645,7 +4621,7 @@
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -4679,21 +4655,19 @@
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
     test -z "am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`$as_dirname -- "$file" ||
@@ -4736,7 +4710,7 @@
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -4757,7 +4731,7 @@
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit 1
+  $ac_cs_success || as_fn_exit $?
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure.in third_party/newlib-4.1.0/newlib/libc/sys/arm/configure.in
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure.in	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/configure.in	2024-03-17 17:47:03.407194450 +0000
@@ -3,7 +3,7 @@
 
 AC_PREREQ(2.59)
 AC_INIT([newlib],[NEWLIB_VERSION])
-AC_CONFIG_SRCDIR([trap.S])
+AC_CONFIG_SRCDIR([virtualalloc.c])
 
 dnl Can't be done in NEWLIB_CONFIGURE because that confuses automake. 
 AC_CONFIG_AUX_DIR(../../../..)
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure.orig third_party/newlib-4.1.0/newlib/libc/sys/arm/configure.orig
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure.orig	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/configure.orig	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,4766 @@
+#! /bin/sh
+# Guess values for system-dependent variables and create Makefiles.
+# Generated by GNU Autoconf 2.68 for newlib 4.1.0.
+#
+#
+# Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
+# Foundation, Inc.
+#
+#
+# This configure script is free software; the Free Software Foundation
+# gives unlimited permission to copy, distribute and modify it.
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+if test "x$CONFIG_SHELL" = x; then
+  as_bourne_compatible="if test -n \"\${ZSH_VERSION+set}\" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on \${1+\"\$@\"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '\${1+\"\$@\"}'='\"\$@\"'
+  setopt NO_GLOB_SUBST
+else
+  case \`(set -o) 2>/dev/null\` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+"
+  as_required="as_fn_return () { (exit \$1); }
+as_fn_success () { as_fn_return 0; }
+as_fn_failure () { as_fn_return 1; }
+as_fn_ret_success () { return 0; }
+as_fn_ret_failure () { return 1; }
+
+exitcode=0
+as_fn_success || { exitcode=1; echo as_fn_success failed.; }
+as_fn_failure && { exitcode=1; echo as_fn_failure succeeded.; }
+as_fn_ret_success || { exitcode=1; echo as_fn_ret_success failed.; }
+as_fn_ret_failure && { exitcode=1; echo as_fn_ret_failure succeeded.; }
+if ( set x; as_fn_ret_success y && test x = \"\$1\" ); then :
+
+else
+  exitcode=1; echo positional parameters were not saved.
+fi
+test x\$exitcode = x0 || exit 1"
+  as_suggested="  as_lineno_1=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_1a=\$LINENO
+  as_lineno_2=";as_suggested=$as_suggested$LINENO;as_suggested=$as_suggested" as_lineno_2a=\$LINENO
+  eval 'test \"x\$as_lineno_1'\$as_run'\" != \"x\$as_lineno_2'\$as_run'\" &&
+  test \"x\`expr \$as_lineno_1'\$as_run' + 1\`\" = \"x\$as_lineno_2'\$as_run'\"' || exit 1"
+  if (eval "$as_required") 2>/dev/null; then :
+  as_have_required=yes
+else
+  as_have_required=no
+fi
+  if test x$as_have_required = xyes && (eval "$as_suggested") 2>/dev/null; then :
+
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+as_found=false
+for as_dir in /bin$PATH_SEPARATOR/usr/bin$PATH_SEPARATOR$PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+  as_found=:
+  case $as_dir in #(
+	 /*)
+	   for as_base in sh bash ksh sh5; do
+	     # Try only shells that exist, to save several forks.
+	     as_shell=$as_dir/$as_base
+	     if { test -f "$as_shell" || test -f "$as_shell.exe"; } &&
+		    { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  CONFIG_SHELL=$as_shell as_have_required=yes
+		   if { $as_echo "$as_bourne_compatible""$as_suggested" | as_run=a "$as_shell"; } 2>/dev/null; then :
+  break 2
+fi
+fi
+	   done;;
+       esac
+  as_found=false
+done
+$as_found || { if { test -f "$SHELL" || test -f "$SHELL.exe"; } &&
+	      { $as_echo "$as_bourne_compatible""$as_required" | as_run=a "$SHELL"; } 2>/dev/null; then :
+  CONFIG_SHELL=$SHELL as_have_required=yes
+fi; }
+IFS=$as_save_IFS
+
+
+      if test "x$CONFIG_SHELL" != x; then :
+  # We cannot yet assume a decent shell, so we have to provide a
+	# neutralization value for shells without unset; and this also
+	# works around shells that cannot unset nonexistent variables.
+	# Preserve -v and -x to the replacement shell.
+	BASH_ENV=/dev/null
+	ENV=/dev/null
+	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
+	export CONFIG_SHELL
+	case $- in # ((((
+	  *v*x* | *x*v* ) as_opts=-vx ;;
+	  *v* ) as_opts=-v ;;
+	  *x* ) as_opts=-x ;;
+	  * ) as_opts= ;;
+	esac
+	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+fi
+
+    if test x$as_have_required = xno; then :
+  $as_echo "$0: This script requires a shell more modern than all"
+  $as_echo "$0: the shells that I found on your system."
+  if test x${ZSH_VERSION+set} = xset ; then
+    $as_echo "$0: In particular, zsh $ZSH_VERSION has bugs and should"
+    $as_echo "$0: be upgraded to zsh 4.3.4 or later."
+  else
+    $as_echo "$0: Please tell bug-autoconf@gnu.org about your system,
+$0: including any error possibly output before this
+$0: message. Then install a modern shell, or manually run
+$0: the script under such a shell if you do have one."
+  fi
+  exit 1
+fi
+fi
+fi
+SHELL=${CONFIG_SHELL-/bin/sh}
+export SHELL
+# Unset more variables known to interfere with behavior of common tools.
+CLICOLOR_FORCE= GREP_OPTIONS=
+unset CLICOLOR_FORCE GREP_OPTIONS
+
+## --------------------- ##
+## M4sh Shell Functions. ##
+## --------------------- ##
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+
+  as_lineno_1=$LINENO as_lineno_1a=$LINENO
+  as_lineno_2=$LINENO as_lineno_2a=$LINENO
+  eval 'test "x$as_lineno_1'$as_run'" != "x$as_lineno_2'$as_run'" &&
+  test "x`expr $as_lineno_1'$as_run' + 1`" = "x$as_lineno_2'$as_run'"' || {
+  # Blame Lee E. McMahon (1931-1989) for sed's syntax.  :-)
+  sed -n '
+    p
+    /[$]LINENO/=
+  ' <$as_myself |
+    sed '
+      s/[$]LINENO.*/&-/
+      t lineno
+      b
+      :lineno
+      N
+      :loop
+      s/[$]LINENO\([^'$as_cr_alnum'_].*\n\)\(.*\)/\2\1\2/
+      t loop
+      s/-\n.*//
+    ' >$as_me.lineno &&
+  chmod +x "$as_me.lineno" ||
+    { $as_echo "$as_me: error: cannot create $as_me.lineno; rerun with a POSIX shell" >&2; as_fn_exit 1; }
+
+  # Don't try to exec as it changes $[0], causing all sort of problems
+  # (the dirname of $[0] is not the place where we might find the
+  # original and so on.  Autoconf is especially sensitive to this).
+  . "./$as_me.lineno"
+  # Exit status is that of the last command.
+  exit
+}
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+test -n "$DJDIR" || exec 7<&0 </dev/null
+exec 6>&1
+
+# Name of the host.
+# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# so uname gets run too.
+ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
+
+#
+# Initializations.
+#
+ac_default_prefix=/usr/local
+ac_clean_files=
+ac_config_libobj_dir=.
+LIBOBJS=
+cross_compiling=no
+subdirs=
+MFLAGS=
+MAKEFLAGS=
+
+# Identity of this package.
+PACKAGE_NAME='newlib'
+PACKAGE_TARNAME='newlib'
+PACKAGE_VERSION='4.1.0'
+PACKAGE_STRING='newlib 4.1.0'
+PACKAGE_BUGREPORT=''
+PACKAGE_URL=''
+
+ac_unique_file="trap.S"
+ac_subst_vars='LTLIBOBJS
+LIBOBJS
+sys_dir
+machine_dir
+libm_machine_dir
+lpfx
+aext
+oext
+OBJEXT
+USE_LIBTOOL_FALSE
+USE_LIBTOOL_TRUE
+ELIX_LEVEL_4_FALSE
+ELIX_LEVEL_4_TRUE
+ELIX_LEVEL_3_FALSE
+ELIX_LEVEL_3_TRUE
+ELIX_LEVEL_2_FALSE
+ELIX_LEVEL_2_TRUE
+ELIX_LEVEL_1_FALSE
+ELIX_LEVEL_1_TRUE
+ELIX_LEVEL_0_FALSE
+ELIX_LEVEL_0_TRUE
+LDFLAGS
+NO_INCLUDE_LIST
+NEWLIB_CFLAGS
+CCASFLAGS
+CCAS
+MAINT
+MAINTAINER_MODE_FALSE
+MAINTAINER_MODE_TRUE
+READELF
+RANLIB
+AR
+AS
+am__fastdepCC_FALSE
+am__fastdepCC_TRUE
+CCDEPMODE
+am__nodep
+AMDEPBACKSLASH
+AMDEP_FALSE
+AMDEP_TRUE
+am__quote
+am__include
+DEPDIR
+CC
+am__untar
+am__tar
+AMTAR
+am__leading_dot
+SET_MAKE
+AWK
+mkdir_p
+MKDIR_P
+INSTALL_STRIP_PROGRAM
+STRIP
+install_sh
+MAKEINFO
+AUTOHEADER
+AUTOMAKE
+AUTOCONF
+ACLOCAL
+VERSION
+PACKAGE
+CYGPATH_W
+am__isrc
+INSTALL_DATA
+INSTALL_SCRIPT
+INSTALL_PROGRAM
+host_os
+host_vendor
+host_cpu
+host
+build_os
+build_vendor
+build_cpu
+build
+newlib_basedir
+MAY_SUPPLY_SYSCALLS_FALSE
+MAY_SUPPLY_SYSCALLS_TRUE
+target_alias
+host_alias
+build_alias
+LIBS
+ECHO_T
+ECHO_N
+ECHO_C
+DEFS
+mandir
+localedir
+libdir
+psdir
+pdfdir
+dvidir
+htmldir
+infodir
+docdir
+oldincludedir
+includedir
+localstatedir
+sharedstatedir
+sysconfdir
+datadir
+datarootdir
+libexecdir
+sbindir
+bindir
+program_transform_name
+prefix
+exec_prefix
+PACKAGE_URL
+PACKAGE_BUGREPORT
+PACKAGE_STRING
+PACKAGE_VERSION
+PACKAGE_TARNAME
+PACKAGE_NAME
+PATH_SEPARATOR
+SHELL'
+ac_subst_files=''
+ac_user_opts='
+enable_option_checking
+enable_multilib
+enable_target_optspace
+enable_malloc_debugging
+enable_newlib_multithread
+enable_newlib_iconv
+enable_newlib_elix_level
+enable_newlib_io_float
+enable_newlib_supplied_syscalls
+enable_newlib_fno_builtin
+enable_dependency_tracking
+enable_maintainer_mode
+'
+      ac_precious_vars='build_alias
+host_alias
+target_alias
+CCAS
+CCASFLAGS'
+
+
+# Initialize some variables set by options.
+ac_init_help=
+ac_init_version=false
+ac_unrecognized_opts=
+ac_unrecognized_sep=
+# The variables have the same names as the options, with
+# dashes changed to underlines.
+cache_file=/dev/null
+exec_prefix=NONE
+no_create=
+no_recursion=
+prefix=NONE
+program_prefix=NONE
+program_suffix=NONE
+program_transform_name=s,x,x,
+silent=
+site=
+srcdir=
+verbose=
+x_includes=NONE
+x_libraries=NONE
+
+# Installation directory options.
+# These are left unexpanded so users can "make install exec_prefix=/foo"
+# and all the variables that are supposed to be based on exec_prefix
+# by default will actually change.
+# Use braces instead of parens because sh, perl, etc. also accept them.
+# (The list follows the same order as the GNU Coding Standards.)
+bindir='${exec_prefix}/bin'
+sbindir='${exec_prefix}/sbin'
+libexecdir='${exec_prefix}/libexec'
+datarootdir='${prefix}/share'
+datadir='${datarootdir}'
+sysconfdir='${prefix}/etc'
+sharedstatedir='${prefix}/com'
+localstatedir='${prefix}/var'
+includedir='${prefix}/include'
+oldincludedir='/usr/include'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+infodir='${datarootdir}/info'
+htmldir='${docdir}'
+dvidir='${docdir}'
+pdfdir='${docdir}'
+psdir='${docdir}'
+libdir='${exec_prefix}/lib'
+localedir='${datarootdir}/locale'
+mandir='${datarootdir}/man'
+
+ac_prev=
+ac_dashdash=
+for ac_option
+do
+  # If the previous option needs an argument, assign it.
+  if test -n "$ac_prev"; then
+    eval $ac_prev=\$ac_option
+    ac_prev=
+    continue
+  fi
+
+  case $ac_option in
+  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *=)   ac_optarg= ;;
+  *)    ac_optarg=yes ;;
+  esac
+
+  # Accept the important Cygnus configure options, so we can diagnose typos.
+
+  case $ac_dashdash$ac_option in
+  --)
+    ac_dashdash=yes ;;
+
+  -bindir | --bindir | --bindi | --bind | --bin | --bi)
+    ac_prev=bindir ;;
+  -bindir=* | --bindir=* | --bindi=* | --bind=* | --bin=* | --bi=*)
+    bindir=$ac_optarg ;;
+
+  -build | --build | --buil | --bui | --bu)
+    ac_prev=build_alias ;;
+  -build=* | --build=* | --buil=* | --bui=* | --bu=*)
+    build_alias=$ac_optarg ;;
+
+  -cache-file | --cache-file | --cache-fil | --cache-fi \
+  | --cache-f | --cache- | --cache | --cach | --cac | --ca | --c)
+    ac_prev=cache_file ;;
+  -cache-file=* | --cache-file=* | --cache-fil=* | --cache-fi=* \
+  | --cache-f=* | --cache-=* | --cache=* | --cach=* | --cac=* | --ca=* | --c=*)
+    cache_file=$ac_optarg ;;
+
+  --config-cache | -C)
+    cache_file=config.cache ;;
+
+  -datadir | --datadir | --datadi | --datad)
+    ac_prev=datadir ;;
+  -datadir=* | --datadir=* | --datadi=* | --datad=*)
+    datadir=$ac_optarg ;;
+
+  -datarootdir | --datarootdir | --datarootdi | --datarootd | --dataroot \
+  | --dataroo | --dataro | --datar)
+    ac_prev=datarootdir ;;
+  -datarootdir=* | --datarootdir=* | --datarootdi=* | --datarootd=* \
+  | --dataroot=* | --dataroo=* | --dataro=* | --datar=*)
+    datarootdir=$ac_optarg ;;
+
+  -disable-* | --disable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--disable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=no ;;
+
+  -docdir | --docdir | --docdi | --doc | --do)
+    ac_prev=docdir ;;
+  -docdir=* | --docdir=* | --docdi=* | --doc=* | --do=*)
+    docdir=$ac_optarg ;;
+
+  -dvidir | --dvidir | --dvidi | --dvid | --dvi | --dv)
+    ac_prev=dvidir ;;
+  -dvidir=* | --dvidir=* | --dvidi=* | --dvid=* | --dvi=* | --dv=*)
+    dvidir=$ac_optarg ;;
+
+  -enable-* | --enable-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid feature name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"enable_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--enable-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval enable_$ac_useropt=\$ac_optarg ;;
+
+  -exec-prefix | --exec_prefix | --exec-prefix | --exec-prefi \
+  | --exec-pref | --exec-pre | --exec-pr | --exec-p | --exec- \
+  | --exec | --exe | --ex)
+    ac_prev=exec_prefix ;;
+  -exec-prefix=* | --exec_prefix=* | --exec-prefix=* | --exec-prefi=* \
+  | --exec-pref=* | --exec-pre=* | --exec-pr=* | --exec-p=* | --exec-=* \
+  | --exec=* | --exe=* | --ex=*)
+    exec_prefix=$ac_optarg ;;
+
+  -gas | --gas | --ga | --g)
+    # Obsolete; use --with-gas.
+    with_gas=yes ;;
+
+  -help | --help | --hel | --he | -h)
+    ac_init_help=long ;;
+  -help=r* | --help=r* | --hel=r* | --he=r* | -hr*)
+    ac_init_help=recursive ;;
+  -help=s* | --help=s* | --hel=s* | --he=s* | -hs*)
+    ac_init_help=short ;;
+
+  -host | --host | --hos | --ho)
+    ac_prev=host_alias ;;
+  -host=* | --host=* | --hos=* | --ho=*)
+    host_alias=$ac_optarg ;;
+
+  -htmldir | --htmldir | --htmldi | --htmld | --html | --htm | --ht)
+    ac_prev=htmldir ;;
+  -htmldir=* | --htmldir=* | --htmldi=* | --htmld=* | --html=* | --htm=* \
+  | --ht=*)
+    htmldir=$ac_optarg ;;
+
+  -includedir | --includedir | --includedi | --included | --include \
+  | --includ | --inclu | --incl | --inc)
+    ac_prev=includedir ;;
+  -includedir=* | --includedir=* | --includedi=* | --included=* | --include=* \
+  | --includ=* | --inclu=* | --incl=* | --inc=*)
+    includedir=$ac_optarg ;;
+
+  -infodir | --infodir | --infodi | --infod | --info | --inf)
+    ac_prev=infodir ;;
+  -infodir=* | --infodir=* | --infodi=* | --infod=* | --info=* | --inf=*)
+    infodir=$ac_optarg ;;
+
+  -libdir | --libdir | --libdi | --libd)
+    ac_prev=libdir ;;
+  -libdir=* | --libdir=* | --libdi=* | --libd=*)
+    libdir=$ac_optarg ;;
+
+  -libexecdir | --libexecdir | --libexecdi | --libexecd | --libexec \
+  | --libexe | --libex | --libe)
+    ac_prev=libexecdir ;;
+  -libexecdir=* | --libexecdir=* | --libexecdi=* | --libexecd=* | --libexec=* \
+  | --libexe=* | --libex=* | --libe=*)
+    libexecdir=$ac_optarg ;;
+
+  -localedir | --localedir | --localedi | --localed | --locale)
+    ac_prev=localedir ;;
+  -localedir=* | --localedir=* | --localedi=* | --localed=* | --locale=*)
+    localedir=$ac_optarg ;;
+
+  -localstatedir | --localstatedir | --localstatedi | --localstated \
+  | --localstate | --localstat | --localsta | --localst | --locals)
+    ac_prev=localstatedir ;;
+  -localstatedir=* | --localstatedir=* | --localstatedi=* | --localstated=* \
+  | --localstate=* | --localstat=* | --localsta=* | --localst=* | --locals=*)
+    localstatedir=$ac_optarg ;;
+
+  -mandir | --mandir | --mandi | --mand | --man | --ma | --m)
+    ac_prev=mandir ;;
+  -mandir=* | --mandir=* | --mandi=* | --mand=* | --man=* | --ma=* | --m=*)
+    mandir=$ac_optarg ;;
+
+  -nfp | --nfp | --nf)
+    # Obsolete; use --without-fp.
+    with_fp=no ;;
+
+  -no-create | --no-create | --no-creat | --no-crea | --no-cre \
+  | --no-cr | --no-c | -n)
+    no_create=yes ;;
+
+  -no-recursion | --no-recursion | --no-recursio | --no-recursi \
+  | --no-recurs | --no-recur | --no-recu | --no-rec | --no-re | --no-r)
+    no_recursion=yes ;;
+
+  -oldincludedir | --oldincludedir | --oldincludedi | --oldincluded \
+  | --oldinclude | --oldinclud | --oldinclu | --oldincl | --oldinc \
+  | --oldin | --oldi | --old | --ol | --o)
+    ac_prev=oldincludedir ;;
+  -oldincludedir=* | --oldincludedir=* | --oldincludedi=* | --oldincluded=* \
+  | --oldinclude=* | --oldinclud=* | --oldinclu=* | --oldincl=* | --oldinc=* \
+  | --oldin=* | --oldi=* | --old=* | --ol=* | --o=*)
+    oldincludedir=$ac_optarg ;;
+
+  -prefix | --prefix | --prefi | --pref | --pre | --pr | --p)
+    ac_prev=prefix ;;
+  -prefix=* | --prefix=* | --prefi=* | --pref=* | --pre=* | --pr=* | --p=*)
+    prefix=$ac_optarg ;;
+
+  -program-prefix | --program-prefix | --program-prefi | --program-pref \
+  | --program-pre | --program-pr | --program-p)
+    ac_prev=program_prefix ;;
+  -program-prefix=* | --program-prefix=* | --program-prefi=* \
+  | --program-pref=* | --program-pre=* | --program-pr=* | --program-p=*)
+    program_prefix=$ac_optarg ;;
+
+  -program-suffix | --program-suffix | --program-suffi | --program-suff \
+  | --program-suf | --program-su | --program-s)
+    ac_prev=program_suffix ;;
+  -program-suffix=* | --program-suffix=* | --program-suffi=* \
+  | --program-suff=* | --program-suf=* | --program-su=* | --program-s=*)
+    program_suffix=$ac_optarg ;;
+
+  -program-transform-name | --program-transform-name \
+  | --program-transform-nam | --program-transform-na \
+  | --program-transform-n | --program-transform- \
+  | --program-transform | --program-transfor \
+  | --program-transfo | --program-transf \
+  | --program-trans | --program-tran \
+  | --progr-tra | --program-tr | --program-t)
+    ac_prev=program_transform_name ;;
+  -program-transform-name=* | --program-transform-name=* \
+  | --program-transform-nam=* | --program-transform-na=* \
+  | --program-transform-n=* | --program-transform-=* \
+  | --program-transform=* | --program-transfor=* \
+  | --program-transfo=* | --program-transf=* \
+  | --program-trans=* | --program-tran=* \
+  | --progr-tra=* | --program-tr=* | --program-t=*)
+    program_transform_name=$ac_optarg ;;
+
+  -pdfdir | --pdfdir | --pdfdi | --pdfd | --pdf | --pd)
+    ac_prev=pdfdir ;;
+  -pdfdir=* | --pdfdir=* | --pdfdi=* | --pdfd=* | --pdf=* | --pd=*)
+    pdfdir=$ac_optarg ;;
+
+  -psdir | --psdir | --psdi | --psd | --ps)
+    ac_prev=psdir ;;
+  -psdir=* | --psdir=* | --psdi=* | --psd=* | --ps=*)
+    psdir=$ac_optarg ;;
+
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil)
+    silent=yes ;;
+
+  -sbindir | --sbindir | --sbindi | --sbind | --sbin | --sbi | --sb)
+    ac_prev=sbindir ;;
+  -sbindir=* | --sbindir=* | --sbindi=* | --sbind=* | --sbin=* \
+  | --sbi=* | --sb=*)
+    sbindir=$ac_optarg ;;
+
+  -sharedstatedir | --sharedstatedir | --sharedstatedi \
+  | --sharedstated | --sharedstate | --sharedstat | --sharedsta \
+  | --sharedst | --shareds | --shared | --share | --shar \
+  | --sha | --sh)
+    ac_prev=sharedstatedir ;;
+  -sharedstatedir=* | --sharedstatedir=* | --sharedstatedi=* \
+  | --sharedstated=* | --sharedstate=* | --sharedstat=* | --sharedsta=* \
+  | --sharedst=* | --shareds=* | --shared=* | --share=* | --shar=* \
+  | --sha=* | --sh=*)
+    sharedstatedir=$ac_optarg ;;
+
+  -site | --site | --sit)
+    ac_prev=site ;;
+  -site=* | --site=* | --sit=*)
+    site=$ac_optarg ;;
+
+  -srcdir | --srcdir | --srcdi | --srcd | --src | --sr)
+    ac_prev=srcdir ;;
+  -srcdir=* | --srcdir=* | --srcdi=* | --srcd=* | --src=* | --sr=*)
+    srcdir=$ac_optarg ;;
+
+  -sysconfdir | --sysconfdir | --sysconfdi | --sysconfd | --sysconf \
+  | --syscon | --sysco | --sysc | --sys | --sy)
+    ac_prev=sysconfdir ;;
+  -sysconfdir=* | --sysconfdir=* | --sysconfdi=* | --sysconfd=* | --sysconf=* \
+  | --syscon=* | --sysco=* | --sysc=* | --sys=* | --sy=*)
+    sysconfdir=$ac_optarg ;;
+
+  -target | --target | --targe | --targ | --tar | --ta | --t)
+    ac_prev=target_alias ;;
+  -target=* | --target=* | --targe=* | --targ=* | --tar=* | --ta=* | --t=*)
+    target_alias=$ac_optarg ;;
+
+  -v | -verbose | --verbose | --verbos | --verbo | --verb)
+    verbose=yes ;;
+
+  -version | --version | --versio | --versi | --vers | -V)
+    ac_init_version=: ;;
+
+  -with-* | --with-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--with-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=\$ac_optarg ;;
+
+  -without-* | --without-*)
+    ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
+    # Reject names that are not valid shell variable names.
+    expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
+      as_fn_error $? "invalid package name: $ac_useropt"
+    ac_useropt_orig=$ac_useropt
+    ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
+    case $ac_user_opts in
+      *"
+"with_$ac_useropt"
+"*) ;;
+      *) ac_unrecognized_opts="$ac_unrecognized_opts$ac_unrecognized_sep--without-$ac_useropt_orig"
+	 ac_unrecognized_sep=', ';;
+    esac
+    eval with_$ac_useropt=no ;;
+
+  --x)
+    # Obsolete; use --with-x.
+    with_x=yes ;;
+
+  -x-includes | --x-includes | --x-include | --x-includ | --x-inclu \
+  | --x-incl | --x-inc | --x-in | --x-i)
+    ac_prev=x_includes ;;
+  -x-includes=* | --x-includes=* | --x-include=* | --x-includ=* | --x-inclu=* \
+  | --x-incl=* | --x-inc=* | --x-in=* | --x-i=*)
+    x_includes=$ac_optarg ;;
+
+  -x-libraries | --x-libraries | --x-librarie | --x-librari \
+  | --x-librar | --x-libra | --x-libr | --x-lib | --x-li | --x-l)
+    ac_prev=x_libraries ;;
+  -x-libraries=* | --x-libraries=* | --x-librarie=* | --x-librari=* \
+  | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
+    x_libraries=$ac_optarg ;;
+
+  -*) as_fn_error $? "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information"
+    ;;
+
+  *=*)
+    ac_envvar=`expr "x$ac_option" : 'x\([^=]*\)='`
+    # Reject names that are not valid shell variable names.
+    case $ac_envvar in #(
+      '' | [0-9]* | *[!_$as_cr_alnum]* )
+      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+    esac
+    eval $ac_envvar=\$ac_optarg
+    export $ac_envvar ;;
+
+  *)
+    # FIXME: should be removed in autoconf 3.0.
+    $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
+    expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
+      $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
+    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    ;;
+
+  esac
+done
+
+if test -n "$ac_prev"; then
+  ac_option=--`echo $ac_prev | sed 's/_/-/g'`
+  as_fn_error $? "missing argument to $ac_option"
+fi
+
+if test -n "$ac_unrecognized_opts"; then
+  case $enable_option_checking in
+    no) ;;
+    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
+  esac
+fi
+
+# Check all directory arguments for consistency.
+for ac_var in	exec_prefix prefix bindir sbindir libexecdir datarootdir \
+		datadir sysconfdir sharedstatedir localstatedir includedir \
+		oldincludedir docdir infodir htmldir dvidir pdfdir psdir \
+		libdir localedir mandir
+do
+  eval ac_val=\$$ac_var
+  # Remove trailing slashes.
+  case $ac_val in
+    */ )
+      ac_val=`expr "X$ac_val" : 'X\(.*[^/]\)' \| "X$ac_val" : 'X\(.*\)'`
+      eval $ac_var=\$ac_val;;
+  esac
+  # Be sure to have absolute directory names.
+  case $ac_val in
+    [\\/$]* | ?:[\\/]* )  continue;;
+    NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
+  esac
+  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+done
+
+# There might be people who depend on the old broken behavior: `$host'
+# used to hold the argument of --host etc.
+# FIXME: To remove some day.
+build=$build_alias
+host=$host_alias
+target=$target_alias
+
+# FIXME: To remove some day.
+if test "x$host_alias" != x; then
+  if test "x$build_alias" = x; then
+    cross_compiling=maybe
+    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used" >&2
+  elif test "x$build_alias" != "x$host_alias"; then
+    cross_compiling=yes
+  fi
+fi
+
+ac_tool_prefix=
+test -n "$host_alias" && ac_tool_prefix=$host_alias-
+
+test "$silent" = yes && exec 6>/dev/null
+
+
+ac_pwd=`pwd` && test -n "$ac_pwd" &&
+ac_ls_di=`ls -di .` &&
+ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
+  as_fn_error $? "working directory cannot be determined"
+test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
+  as_fn_error $? "pwd does not report name of working directory"
+
+
+# Find the source files, if location was not specified.
+if test -z "$srcdir"; then
+  ac_srcdir_defaulted=yes
+  # Try the directory containing this script, then the parent directory.
+  ac_confdir=`$as_dirname -- "$as_myself" ||
+$as_expr X"$as_myself" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_myself" : 'X\(//\)[^/]' \| \
+	 X"$as_myself" : 'X\(//\)$' \| \
+	 X"$as_myself" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_myself" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  srcdir=$ac_confdir
+  if test ! -r "$srcdir/$ac_unique_file"; then
+    srcdir=..
+  fi
+else
+  ac_srcdir_defaulted=no
+fi
+if test ! -r "$srcdir/$ac_unique_file"; then
+  test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
+  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+fi
+ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
+ac_abs_confdir=`(
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	pwd)`
+# When building in place, set srcdir=.
+if test "$ac_abs_confdir" = "$ac_pwd"; then
+  srcdir=.
+fi
+# Remove unnecessary trailing slashes from srcdir.
+# Double slashes in file names in object file debugging info
+# mess up M-x gdb in Emacs.
+case $srcdir in
+*/) srcdir=`expr "X$srcdir" : 'X\(.*[^/]\)' \| "X$srcdir" : 'X\(.*\)'`;;
+esac
+for ac_var in $ac_precious_vars; do
+  eval ac_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_env_${ac_var}_value=\$${ac_var}
+  eval ac_cv_env_${ac_var}_set=\${${ac_var}+set}
+  eval ac_cv_env_${ac_var}_value=\$${ac_var}
+done
+
+#
+# Report the --help message.
+#
+if test "$ac_init_help" = "long"; then
+  # Omit some internal or obsolete options to make the list less imposing.
+  # This message is too long to be a string in the A/UX 3.1 sh.
+  cat <<_ACEOF
+\`configure' configures newlib 4.1.0 to adapt to many kinds of systems.
+
+Usage: $0 [OPTION]... [VAR=VALUE]...
+
+To assign environment variables (e.g., CC, CFLAGS...), specify them as
+VAR=VALUE.  See below for descriptions of some of the useful variables.
+
+Defaults for the options are specified in brackets.
+
+Configuration:
+  -h, --help              display this help and exit
+      --help=short        display options specific to this package
+      --help=recursive    display the short help of all the included packages
+  -V, --version           display version information and exit
+  -q, --quiet, --silent   do not print \`checking ...' messages
+      --cache-file=FILE   cache test results in FILE [disabled]
+  -C, --config-cache      alias for \`--cache-file=config.cache'
+  -n, --no-create         do not create output files
+      --srcdir=DIR        find the sources in DIR [configure dir or \`..']
+
+Installation directories:
+  --prefix=PREFIX         install architecture-independent files in PREFIX
+                          [$ac_default_prefix]
+  --exec-prefix=EPREFIX   install architecture-dependent files in EPREFIX
+                          [PREFIX]
+
+By default, \`make install' will install all the files in
+\`$ac_default_prefix/bin', \`$ac_default_prefix/lib' etc.  You can specify
+an installation prefix other than \`$ac_default_prefix' using \`--prefix',
+for instance \`--prefix=\$HOME'.
+
+For better control, use the options below.
+
+Fine tuning of the installation directories:
+  --bindir=DIR            user executables [EPREFIX/bin]
+  --sbindir=DIR           system admin executables [EPREFIX/sbin]
+  --libexecdir=DIR        program executables [EPREFIX/libexec]
+  --sysconfdir=DIR        read-only single-machine data [PREFIX/etc]
+  --sharedstatedir=DIR    modifiable architecture-independent data [PREFIX/com]
+  --localstatedir=DIR     modifiable single-machine data [PREFIX/var]
+  --libdir=DIR            object code libraries [EPREFIX/lib]
+  --includedir=DIR        C header files [PREFIX/include]
+  --oldincludedir=DIR     C header files for non-gcc [/usr/include]
+  --datarootdir=DIR       read-only arch.-independent data root [PREFIX/share]
+  --datadir=DIR           read-only architecture-independent data [DATAROOTDIR]
+  --infodir=DIR           info documentation [DATAROOTDIR/info]
+  --localedir=DIR         locale-dependent data [DATAROOTDIR/locale]
+  --mandir=DIR            man documentation [DATAROOTDIR/man]
+  --docdir=DIR            documentation root [DATAROOTDIR/doc/newlib]
+  --htmldir=DIR           html documentation [DOCDIR]
+  --dvidir=DIR            dvi documentation [DOCDIR]
+  --pdfdir=DIR            pdf documentation [DOCDIR]
+  --psdir=DIR             ps documentation [DOCDIR]
+_ACEOF
+
+  cat <<\_ACEOF
+
+Program names:
+  --program-prefix=PREFIX            prepend PREFIX to installed program names
+  --program-suffix=SUFFIX            append SUFFIX to installed program names
+  --program-transform-name=PROGRAM   run sed PROGRAM on installed program names
+
+System types:
+  --build=BUILD     configure for building on BUILD [guessed]
+  --host=HOST       cross-compile to build programs to run on HOST [BUILD]
+_ACEOF
+fi
+
+if test -n "$ac_init_help"; then
+  case $ac_init_help in
+     short | recursive ) echo "Configuration of newlib 4.1.0:";;
+   esac
+  cat <<\_ACEOF
+
+Optional Features:
+  --disable-option-checking  ignore unrecognized --enable/--with options
+  --disable-FEATURE       do not include FEATURE (same as --enable-FEATURE=no)
+  --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
+  --enable-multilib         build many library versions (default)
+  --enable-target-optspace  optimize for space
+  --enable-malloc-debugging indicate malloc debugging requested
+  --enable-newlib-multithread        enable support for multiple threads
+  --enable-newlib-iconv     enable iconv library support
+  --enable-newlib-elix-level         supply desired elix library level (1-4)
+  --disable-newlib-io-float disable printf/scanf family float support
+  --disable-newlib-supplied-syscalls disable newlib from supplying syscalls
+  --disable-newlib-fno-builtin disable -fno-builtin flag to allow compiler to use builtin library functions
+  --disable-dependency-tracking  speeds up one-time build
+  --enable-dependency-tracking   do not reject slow dependency extractors
+  --enable-maintainer-mode  enable make rules and dependencies not useful
+			  (and sometimes confusing) to the casual installer
+
+Some influential environment variables:
+  CCAS        assembler compiler command (defaults to CC)
+  CCASFLAGS   assembler compiler flags (defaults to CFLAGS)
+
+Use these variables to override the choices made by `configure' or to help
+it to find libraries and programs with nonstandard names/locations.
+
+Report bugs to the package provider.
+_ACEOF
+ac_status=$?
+fi
+
+if test "$ac_init_help" = "recursive"; then
+  # If there are subdirs, report their specific --help.
+  for ac_dir in : $ac_subdirs_all; do test "x$ac_dir" = x: && continue
+    test -d "$ac_dir" ||
+      { cd "$srcdir" && ac_pwd=`pwd` && srcdir=. && test -d "$ac_dir"; } ||
+      continue
+    ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+    cd "$ac_dir" || { ac_status=$?; continue; }
+    # Check for guested configure.
+    if test -f "$ac_srcdir/configure.gnu"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure.gnu" --help=recursive
+    elif test -f "$ac_srcdir/configure"; then
+      echo &&
+      $SHELL "$ac_srcdir/configure" --help=recursive
+    else
+      $as_echo "$as_me: WARNING: no configuration information is in $ac_dir" >&2
+    fi || ac_status=$?
+    cd "$ac_pwd" || { ac_status=$?; break; }
+  done
+fi
+
+test -n "$ac_init_help" && exit $ac_status
+if $ac_init_version; then
+  cat <<\_ACEOF
+newlib configure 4.1.0
+generated by GNU Autoconf 2.68
+
+Copyright (C) 2010 Free Software Foundation, Inc.
+This configure script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it.
+_ACEOF
+  exit
+fi
+
+## ------------------------ ##
+## Autoconf initialization. ##
+## ------------------------ ##
+
+# ac_fn_c_try_compile LINENO
+# --------------------------
+# Try to compile conftest.$ac_ext, and return whether this succeeded.
+ac_fn_c_try_compile ()
+{
+  as_lineno=${as_lineno-"$1"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+  rm -f conftest.$ac_objext
+  if { { ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval ac_try_echo="\"\$as_me:${as_lineno-$LINENO}: $ac_try_echo\""
+$as_echo "$ac_try_echo"; } >&5
+  (eval "$ac_compile") 2>conftest.err
+  ac_status=$?
+  if test -s conftest.err; then
+    grep -v '^ *+' conftest.err >conftest.er1
+    cat conftest.er1 >&5
+    mv -f conftest.er1 conftest.err
+  fi
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then :
+  ac_retval=0
+else
+  $as_echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	ac_retval=1
+fi
+  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
+  as_fn_set_status $ac_retval
+
+} # ac_fn_c_try_compile
+cat >config.log <<_ACEOF
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by newlib $as_me 4.1.0, which was
+generated by GNU Autoconf 2.68.  Invocation command line was
+
+  $ $0 $@
+
+_ACEOF
+exec 5>>config.log
+{
+cat <<_ASUNAME
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = `(hostname || uname -n) 2>/dev/null | sed 1q`
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null || echo unknown`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null     || echo unknown`
+
+/bin/arch              = `(/bin/arch) 2>/dev/null              || echo unknown`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null       || echo unknown`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null || echo unknown`
+/usr/bin/hostinfo      = `(/usr/bin/hostinfo) 2>/dev/null      || echo unknown`
+/bin/machine           = `(/bin/machine) 2>/dev/null           || echo unknown`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null       || echo unknown`
+/bin/universe          = `(/bin/universe) 2>/dev/null          || echo unknown`
+
+_ASUNAME
+
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    $as_echo "PATH: $as_dir"
+  done
+IFS=$as_save_IFS
+
+} >&5
+
+cat >&5 <<_ACEOF
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+_ACEOF
+
+
+# Keep a trace of the command line.
+# Strip out --no-create and --no-recursion so they do not pile up.
+# Strip out --silent because we don't want to record it for future runs.
+# Also quote any args containing shell meta-characters.
+# Make two passes to allow for proper duplicate-argument suppression.
+ac_configure_args=
+ac_configure_args0=
+ac_configure_args1=
+ac_must_keep_next=false
+for ac_pass in 1 2
+do
+  for ac_arg
+  do
+    case $ac_arg in
+    -no-create | --no-c* | -n | -no-recursion | --no-r*) continue ;;
+    -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+    | -silent | --silent | --silen | --sile | --sil)
+      continue ;;
+    *\'*)
+      ac_arg=`$as_echo "$ac_arg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    esac
+    case $ac_pass in
+    1) as_fn_append ac_configure_args0 " '$ac_arg'" ;;
+    2)
+      as_fn_append ac_configure_args1 " '$ac_arg'"
+      if test $ac_must_keep_next = true; then
+	ac_must_keep_next=false # Got value, back to normal.
+      else
+	case $ac_arg in
+	  *=* | --config-cache | -C | -disable-* | --disable-* \
+	  | -enable-* | --enable-* | -gas | --g* | -nfp | --nf* \
+	  | -q | -quiet | --q* | -silent | --sil* | -v | -verb* \
+	  | -with-* | --with-* | -without-* | --without-* | --x)
+	    case "$ac_configure_args0 " in
+	      "$ac_configure_args1"*" '$ac_arg' "* ) continue ;;
+	    esac
+	    ;;
+	  -* ) ac_must_keep_next=true ;;
+	esac
+      fi
+      as_fn_append ac_configure_args " '$ac_arg'"
+      ;;
+    esac
+  done
+done
+{ ac_configure_args0=; unset ac_configure_args0;}
+{ ac_configure_args1=; unset ac_configure_args1;}
+
+# When interrupted or exit'd, cleanup temporary files, and complete
+# config.log.  We remove comments because anyway the quotes in there
+# would cause problems or look ugly.
+# WARNING: Use '\'' to represent an apostrophe within the trap.
+# WARNING: Do not start the trap code with a newline, due to a FreeBSD 4.0 bug.
+trap 'exit_status=$?
+  # Save into config.log some information that might help in debugging.
+  {
+    echo
+
+    $as_echo "## ---------------- ##
+## Cache variables. ##
+## ---------------- ##"
+    echo
+    # The following way of writing the cache mishandles newlines in values,
+(
+  for ac_var in `(set) 2>&1 | sed -n '\''s/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'\''`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+  (set) 2>&1 |
+    case $as_nl`(ac_space='\'' '\''; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      sed -n \
+	"s/'\''/'\''\\\\'\'''\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\''\\2'\''/p"
+      ;; #(
+    *)
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+)
+    echo
+
+    $as_echo "## ----------------- ##
+## Output variables. ##
+## ----------------- ##"
+    echo
+    for ac_var in $ac_subst_vars
+    do
+      eval ac_val=\$$ac_var
+      case $ac_val in
+      *\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+      esac
+      $as_echo "$ac_var='\''$ac_val'\''"
+    done | sort
+    echo
+
+    if test -n "$ac_subst_files"; then
+      $as_echo "## ------------------- ##
+## File substitutions. ##
+## ------------------- ##"
+      echo
+      for ac_var in $ac_subst_files
+      do
+	eval ac_val=\$$ac_var
+	case $ac_val in
+	*\'\''*) ac_val=`$as_echo "$ac_val" | sed "s/'\''/'\''\\\\\\\\'\'''\''/g"`;;
+	esac
+	$as_echo "$ac_var='\''$ac_val'\''"
+      done | sort
+      echo
+    fi
+
+    if test -s confdefs.h; then
+      $as_echo "## ----------- ##
+## confdefs.h. ##
+## ----------- ##"
+      echo
+      cat confdefs.h
+      echo
+    fi
+    test "$ac_signal" != 0 &&
+      $as_echo "$as_me: caught signal $ac_signal"
+    $as_echo "$as_me: exit $exit_status"
+  } >&5
+  rm -f core *.core core.conftest.* &&
+    rm -f -r conftest* confdefs* conf$$* $ac_clean_files &&
+    exit $exit_status
+' 0
+for ac_signal in 1 2 13 15; do
+  trap 'ac_signal='$ac_signal'; as_fn_exit 1' $ac_signal
+done
+ac_signal=0
+
+# confdefs.h avoids OS command line length limits that DEFS can exceed.
+rm -f -r conftest* confdefs.h
+
+$as_echo "/* confdefs.h */" > confdefs.h
+
+# Predefined preprocessor variables.
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_NAME "$PACKAGE_NAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_TARNAME "$PACKAGE_TARNAME"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_VERSION "$PACKAGE_VERSION"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_STRING "$PACKAGE_STRING"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_BUGREPORT "$PACKAGE_BUGREPORT"
+_ACEOF
+
+cat >>confdefs.h <<_ACEOF
+#define PACKAGE_URL "$PACKAGE_URL"
+_ACEOF
+
+
+# Let the site file select an alternate cache file if it wants to.
+# Prefer an explicitly selected file to automatically selected ones.
+ac_site_file1=NONE
+ac_site_file2=NONE
+if test -n "$CONFIG_SITE"; then
+  # We do not want a PATH search for config.site.
+  case $CONFIG_SITE in #((
+    -*)  ac_site_file1=./$CONFIG_SITE;;
+    */*) ac_site_file1=$CONFIG_SITE;;
+    *)   ac_site_file1=./$CONFIG_SITE;;
+  esac
+elif test "x$prefix" != xNONE; then
+  ac_site_file1=$prefix/share/config.site
+  ac_site_file2=$prefix/etc/config.site
+else
+  ac_site_file1=$ac_default_prefix/share/config.site
+  ac_site_file2=$ac_default_prefix/etc/config.site
+fi
+for ac_site_file in "$ac_site_file1" "$ac_site_file2"
+do
+  test "x$ac_site_file" = xNONE && continue
+  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
+$as_echo "$as_me: loading site script $ac_site_file" >&6;}
+    sed 's/^/| /' "$ac_site_file" >&5
+    . "$ac_site_file" \
+      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+as_fn_error $? "failed to load site script $ac_site_file
+See \`config.log' for more details" "$LINENO" 5; }
+  fi
+done
+
+if test -r "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special files
+  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
+  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+    { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
+$as_echo "$as_me: loading cache $cache_file" >&6;}
+    case $cache_file in
+      [\\/]* | ?:[\\/]* ) . "$cache_file";;
+      *)                      . "./$cache_file";;
+    esac
+  fi
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: creating cache $cache_file" >&5
+$as_echo "$as_me: creating cache $cache_file" >&6;}
+  >$cache_file
+fi
+
+# Check that the precious variables saved in the cache have kept the same
+# value.
+ac_cache_corrupted=false
+for ac_var in $ac_precious_vars; do
+  eval ac_old_set=\$ac_cv_env_${ac_var}_set
+  eval ac_new_set=\$ac_env_${ac_var}_set
+  eval ac_old_val=\$ac_cv_env_${ac_var}_value
+  eval ac_new_val=\$ac_env_${ac_var}_value
+  case $ac_old_set,$ac_new_set in
+    set,)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was set to \`$ac_old_val' in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,set)
+      { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' was not set in the previous run" >&5
+$as_echo "$as_me: error: \`$ac_var' was not set in the previous run" >&2;}
+      ac_cache_corrupted=: ;;
+    ,);;
+    *)
+      if test "x$ac_old_val" != "x$ac_new_val"; then
+	# differences in whitespace do not lead to failure.
+	ac_old_val_w=`echo x $ac_old_val`
+	ac_new_val_w=`echo x $ac_new_val`
+	if test "$ac_old_val_w" != "$ac_new_val_w"; then
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: error: \`$ac_var' has changed since the previous run:" >&5
+$as_echo "$as_me: error: \`$ac_var' has changed since the previous run:" >&2;}
+	  ac_cache_corrupted=:
+	else
+	  { $as_echo "$as_me:${as_lineno-$LINENO}: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&5
+$as_echo "$as_me: warning: ignoring whitespace changes in \`$ac_var' since the previous run:" >&2;}
+	  eval $ac_var=\$ac_old_val
+	fi
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   former value:  \`$ac_old_val'" >&5
+$as_echo "$as_me:   former value:  \`$ac_old_val'" >&2;}
+	{ $as_echo "$as_me:${as_lineno-$LINENO}:   current value: \`$ac_new_val'" >&5
+$as_echo "$as_me:   current value: \`$ac_new_val'" >&2;}
+      fi;;
+  esac
+  # Pass precious variables to config.status.
+  if test "$ac_new_set" = set; then
+    case $ac_new_val in
+    *\'*) ac_arg=$ac_var=`$as_echo "$ac_new_val" | sed "s/'/'\\\\\\\\''/g"` ;;
+    *) ac_arg=$ac_var=$ac_new_val ;;
+    esac
+    case " $ac_configure_args " in
+      *" '$ac_arg' "*) ;; # Avoid dups.  Use of quotes ensures accuracy.
+      *) as_fn_append ac_configure_args " '$ac_arg'" ;;
+    esac
+  fi
+done
+if $ac_cache_corrupted; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
+$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
+$as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
+  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+fi
+## -------------------- ##
+## Main body of script. ##
+## -------------------- ##
+
+ac_ext=c
+ac_cpp='$CPP $CPPFLAGS'
+ac_compile='$CC -c $CFLAGS $CPPFLAGS conftest.$ac_ext >&5'
+ac_link='$CC -o conftest$ac_exeext $CFLAGS $CPPFLAGS $LDFLAGS conftest.$ac_ext $LIBS >&5'
+ac_compiler_gnu=$ac_cv_c_compiler_gnu
+
+
+
+
+ac_aux_dir=
+for ac_dir in ../../../.. "$srcdir"/../../../..; do
+  if test -f "$ac_dir/install-sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install-sh -c"
+    break
+  elif test -f "$ac_dir/install.sh"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/install.sh -c"
+    break
+  elif test -f "$ac_dir/shtool"; then
+    ac_aux_dir=$ac_dir
+    ac_install_sh="$ac_aux_dir/shtool install -c"
+    break
+  fi
+done
+if test -z "$ac_aux_dir"; then
+  as_fn_error $? "cannot find install-sh, install.sh, or shtool in ../../../.. \"$srcdir\"/../../../.." "$LINENO" 5
+fi
+
+# These three variables are undocumented and unsupported,
+# and are intended to be withdrawn in a future Autoconf release.
+# They can cause serious problems if a builder's source tree is in a directory
+# whose full name contains unusual characters.
+ac_config_guess="$SHELL $ac_aux_dir/config.guess"  # Please don't use this var.
+ac_config_sub="$SHELL $ac_aux_dir/config.sub"  # Please don't use this var.
+ac_configure="$SHELL $ac_aux_dir/configure"  # Please don't use this var.
+
+
+
+
+# Make sure we can run config.sub.
+$SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
+  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
+$as_echo_n "checking build system type... " >&6; }
+if ${ac_cv_build+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_build_alias=$build_alias
+test "x$ac_build_alias" = x &&
+  ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
+test "x$ac_build_alias" = x &&
+  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
+  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
+$as_echo "$ac_cv_build" >&6; }
+case $ac_cv_build in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+esac
+build=$ac_cv_build
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_build
+shift
+build_cpu=$1
+build_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+build_os=$*
+IFS=$ac_save_IFS
+case $build_os in *\ *) build_os=`echo "$build_os" | sed 's/ /-/g'`;; esac
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
+$as_echo_n "checking host system type... " >&6; }
+if ${ac_cv_host+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test "x$host_alias" = x; then
+  ac_cv_host=$ac_cv_build
+else
+  ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
+    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_host" >&5
+$as_echo "$ac_cv_host" >&6; }
+case $ac_cv_host in
+*-*-*) ;;
+*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+esac
+host=$ac_cv_host
+ac_save_IFS=$IFS; IFS='-'
+set x $ac_cv_host
+shift
+host_cpu=$1
+host_vendor=$2
+shift; shift
+# Remember, the first character of IFS is used to create $*,
+# except with old shells:
+host_os=$*
+IFS=$ac_save_IFS
+case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
+
+
+am__api_version='1.11'
+
+# Find a good install program.  We prefer a C program (faster),
+# so one script is as good as another.  But avoid the broken or
+# incompatible versions:
+# SysV /etc/install, /usr/sbin/install
+# SunOS /usr/etc/install
+# IRIX /sbin/install
+# AIX /bin/install
+# AmigaOS /C/install, which installs bootblocks on floppy discs
+# AIX 4 /usr/bin/installbsd, which doesn't work without a -g flag
+# AFS /usr/afsws/bin/install, which mishandles nonexistent args
+# SVR4 /usr/ucb/install, which tries to use the nonexistent group "staff"
+# OS/2's system install, which has a completely different semantic
+# ./install, which can be erroneously created by make from ./install.sh.
+# Reject install programs that cannot install multiple files.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
+$as_echo_n "checking for a BSD-compatible install... " >&6; }
+if test -z "$INSTALL"; then
+if ${ac_cv_path_install+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    # Account for people who put trailing slashes in PATH elements.
+case $as_dir/ in #((
+  ./ | .// | /[cC]/* | \
+  /etc/* | /usr/sbin/* | /usr/etc/* | /sbin/* | /usr/afsws/bin/* | \
+  ?:[\\/]os2[\\/]install[\\/]* | ?:[\\/]OS2[\\/]INSTALL[\\/]* | \
+  /usr/ucb/* ) ;;
+  *)
+    # OSF1 and SCO ODT 3.0 have their own names for install.
+    # Don't use installbsd from OSF since it installs stuff as root
+    # by default.
+    for ac_prog in ginstall scoinst install; do
+      for ac_exec_ext in '' $ac_executable_extensions; do
+	if { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; }; then
+	  if test $ac_prog = install &&
+	    grep dspmsg "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # AIX install.  It has an incompatible calling convention.
+	    :
+	  elif test $ac_prog = install &&
+	    grep pwplus "$as_dir/$ac_prog$ac_exec_ext" >/dev/null 2>&1; then
+	    # program-specific install script used by HP pwplus--don't use.
+	    :
+	  else
+	    rm -rf conftest.one conftest.two conftest.dir
+	    echo one > conftest.one
+	    echo two > conftest.two
+	    mkdir conftest.dir
+	    if "$as_dir/$ac_prog$ac_exec_ext" -c conftest.one conftest.two "`pwd`/conftest.dir" &&
+	      test -s conftest.one && test -s conftest.two &&
+	      test -s conftest.dir/conftest.one &&
+	      test -s conftest.dir/conftest.two
+	    then
+	      ac_cv_path_install="$as_dir/$ac_prog$ac_exec_ext -c"
+	      break 3
+	    fi
+	  fi
+	fi
+      done
+    done
+    ;;
+esac
+
+  done
+IFS=$as_save_IFS
+
+rm -rf conftest.one conftest.two conftest.dir
+
+fi
+  if test "${ac_cv_path_install+set}" = set; then
+    INSTALL=$ac_cv_path_install
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for INSTALL within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    INSTALL=$ac_install_sh
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $INSTALL" >&5
+$as_echo "$INSTALL" >&6; }
+
+# Use test -z because SunOS4 sh mishandles braces in ${var-val}.
+# It thinks the first close brace ends the variable substitution.
+test -z "$INSTALL_PROGRAM" && INSTALL_PROGRAM='${INSTALL}'
+
+test -z "$INSTALL_SCRIPT" && INSTALL_SCRIPT='${INSTALL}'
+
+test -z "$INSTALL_DATA" && INSTALL_DATA='${INSTALL} -m 644'
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
+$as_echo_n "checking whether build environment is sane... " >&6; }
+# Just in case
+sleep 1
+echo timestamp > conftest.file
+# Reject unsafe characters in $srcdir or the absolute working directory
+# name.  Accept space and tab only in the latter.
+am_lf='
+'
+case `pwd` in
+  *[\\\"\#\$\&\'\`$am_lf]*)
+    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5;;
+esac
+case $srcdir in
+  *[\\\"\#\$\&\'\`$am_lf\ \	]*)
+    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+esac
+
+# Do `set' in a subshell so we don't clobber the current shell's
+# arguments.  Must try -L first in case configure is actually a
+# symlink; some systems play weird games with the mod time of symlinks
+# (eg FreeBSD returns the mod time of the symlink's containing
+# directory).
+if (
+   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+   if test "$*" = "X"; then
+      # -L didn't work.
+      set X `ls -t "$srcdir/configure" conftest.file`
+   fi
+   rm -f conftest.file
+   if test "$*" != "X $srcdir/configure conftest.file" \
+      && test "$*" != "X conftest.file $srcdir/configure"; then
+
+      # If neither matched, then we have a broken ls.  This can happen
+      # if, for instance, CONFIG_SHELL is bash and it inherits a
+      # broken ls alias from the environment.  This has actually
+      # happened.  Such a system could not be considered "sane".
+      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
+alias in your environment" "$LINENO" 5
+   fi
+
+   test "$2" = conftest.file
+   )
+then
+   # Ok.
+   :
+else
+   as_fn_error $? "newly created file is older than distributed files!
+Check your system clock" "$LINENO" 5
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+test "$program_prefix" != NONE &&
+  program_transform_name="s&^&$program_prefix&;$program_transform_name"
+# Use a double $ so make ignores it.
+test "$program_suffix" != NONE &&
+  program_transform_name="s&\$&$program_suffix&;$program_transform_name"
+# Double any \ or $.
+# By default was `s,x,x', remove it if useless.
+ac_script='s/[\\$]/&&/g;s/;s,x,x,$//'
+program_transform_name=`$as_echo "$program_transform_name" | sed "$ac_script"`
+
+# expand $ac_aux_dir to an absolute path
+am_aux_dir=`cd $ac_aux_dir && pwd`
+
+if test x"${MISSING+set}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    MISSING="\${SHELL} \"$am_aux_dir/missing\"" ;;
+  *)
+    MISSING="\${SHELL} $am_aux_dir/missing" ;;
+  esac
+fi
+# Use eval to expand $SHELL
+if eval "$MISSING --run true"; then
+  am_missing_run="$MISSING --run "
+else
+  am_missing_run=
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+fi
+
+if test x"${install_sh}" != xset; then
+  case $am_aux_dir in
+  *\ * | *\	*)
+    install_sh="\${SHELL} '$am_aux_dir/install-sh'" ;;
+  *)
+    install_sh="\${SHELL} $am_aux_dir/install-sh"
+  esac
+fi
+
+# Installed binaries are usually stripped using `strip' when the user
+# run `make install-strip'.  However `strip' might not be the right
+# tool to use in cross-compilation environments, therefore Automake
+# will honor the `STRIP' environment variable to overrule this program.
+if test "$cross_compiling" != no; then
+  if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
+set dummy ${ac_tool_prefix}strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$STRIP"; then
+  ac_cv_prog_STRIP="$STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_STRIP="${ac_tool_prefix}strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+STRIP=$ac_cv_prog_STRIP
+if test -n "$STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $STRIP" >&5
+$as_echo "$STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_STRIP"; then
+  ac_ct_STRIP=$STRIP
+  # Extract the first word of "strip", so it can be a program name with args.
+set dummy strip; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_STRIP"; then
+  ac_cv_prog_ac_ct_STRIP="$ac_ct_STRIP" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_STRIP="strip"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_STRIP=$ac_cv_prog_ac_ct_STRIP
+if test -n "$ac_ct_STRIP"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_STRIP" >&5
+$as_echo "$ac_ct_STRIP" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_STRIP" = x; then
+    STRIP=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    STRIP=$ac_ct_STRIP
+  fi
+else
+  STRIP="$ac_cv_prog_STRIP"
+fi
+
+fi
+INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
+$as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
+if test -z "$MKDIR_P"; then
+  if ${ac_cv_path_mkdir+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH$PATH_SEPARATOR/opt/sfw/bin
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_prog in mkdir gmkdir; do
+	 for ac_exec_ext in '' $ac_executable_extensions; do
+	   { test -f "$as_dir/$ac_prog$ac_exec_ext" && $as_test_x "$as_dir/$ac_prog$ac_exec_ext"; } || continue
+	   case `"$as_dir/$ac_prog$ac_exec_ext" --version 2>&1` in #(
+	     'mkdir (GNU coreutils) '* | \
+	     'mkdir (coreutils) '* | \
+	     'mkdir (fileutils) '4.1*)
+	       ac_cv_path_mkdir=$as_dir/$ac_prog$ac_exec_ext
+	       break 3;;
+	   esac
+	 done
+       done
+  done
+IFS=$as_save_IFS
+
+fi
+
+  test -d ./--version && rmdir ./--version
+  if test "${ac_cv_path_mkdir+set}" = set; then
+    MKDIR_P="$ac_cv_path_mkdir -p"
+  else
+    # As a last resort, use the slow shell script.  Don't cache a
+    # value for MKDIR_P within a source directory, because that will
+    # break other packages using the cache if that directory is
+    # removed, or if the value is a relative name.
+    MKDIR_P="$ac_install_sh -d"
+  fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $MKDIR_P" >&5
+$as_echo "$MKDIR_P" >&6; }
+
+mkdir_p="$MKDIR_P"
+case $mkdir_p in
+  [\\/$]* | ?:[\\/]*) ;;
+  */*) mkdir_p="\$(top_builddir)/$mkdir_p" ;;
+esac
+
+for ac_prog in gawk mawk nawk awk
+do
+  # Extract the first word of "$ac_prog", so it can be a program name with args.
+set dummy $ac_prog; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AWK+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AWK"; then
+  ac_cv_prog_AWK="$AWK" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AWK="$ac_prog"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AWK=$ac_cv_prog_AWK
+if test -n "$AWK"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AWK" >&5
+$as_echo "$AWK" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -n "$AWK" && break
+done
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether ${MAKE-make} sets \$(MAKE)" >&5
+$as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
+set x ${MAKE-make}
+ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
+if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat >conftest.make <<\_ACEOF
+SHELL = /bin/sh
+all:
+	@echo '@@@%%%=$(MAKE)=@@@%%%'
+_ACEOF
+# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+case `${MAKE-make} -f conftest.make 2>/dev/null` in
+  *@@@%%%=?*=@@@%%%*)
+    eval ac_cv_prog_make_${ac_make}_set=yes;;
+  *)
+    eval ac_cv_prog_make_${ac_make}_set=no;;
+esac
+rm -f conftest.make
+fi
+if eval test \$ac_cv_prog_make_${ac_make}_set = yes; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
+$as_echo "yes" >&6; }
+  SET_MAKE=
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+  SET_MAKE="MAKE=${MAKE-make}"
+fi
+
+rm -rf .tst 2>/dev/null
+mkdir .tst 2>/dev/null
+if test -d .tst; then
+  am__leading_dot=.
+else
+  am__leading_dot=_
+fi
+rmdir .tst 2>/dev/null
+
+DEPDIR="${am__leading_dot}deps"
+
+ac_config_commands="$ac_config_commands depfiles"
+
+
+am_make=${MAKE-make}
+cat > confinc << 'END'
+am__doit:
+	@echo this is the am__doit target
+.PHONY: am__doit
+END
+# If we don't find an include directive, just comment out the code.
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for style of include used by $am_make" >&5
+$as_echo_n "checking for style of include used by $am_make... " >&6; }
+am__include="#"
+am__quote=
+_am_result=none
+# First try GNU make style include.
+echo "include confinc" > confmf
+# Ignore all kinds of additional output from `make'.
+case `$am_make -s -f confmf 2> /dev/null` in #(
+*the\ am__doit\ target*)
+  am__include=include
+  am__quote=
+  _am_result=GNU
+  ;;
+esac
+# Now try BSD make style include.
+if test "$am__include" = "#"; then
+   echo '.include "confinc"' > confmf
+   case `$am_make -s -f confmf 2> /dev/null` in #(
+   *the\ am__doit\ target*)
+     am__include=.include
+     am__quote="\""
+     _am_result=BSD
+     ;;
+   esac
+fi
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $_am_result" >&5
+$as_echo "$_am_result" >&6; }
+rm -f confinc confmf
+
+# Check whether --enable-dependency-tracking was given.
+if test "${enable_dependency_tracking+set}" = set; then :
+  enableval=$enable_dependency_tracking;
+fi
+
+if test "x$enable_dependency_tracking" != xno; then
+  am_depcomp="$ac_aux_dir/depcomp"
+  AMDEPBACKSLASH='\'
+  am__nodep='_no'
+fi
+ if test "x$enable_dependency_tracking" != xno; then
+  AMDEP_TRUE=
+  AMDEP_FALSE='#'
+else
+  AMDEP_TRUE='#'
+  AMDEP_FALSE=
+fi
+
+
+
+# Check whether --enable-multilib was given.
+if test "${enable_multilib+set}" = set; then :
+  enableval=$enable_multilib; case "${enableval}" in
+  yes) multilib=yes ;;
+  no)  multilib=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
+ esac
+else
+  multilib=yes
+fi
+
+# Check whether --enable-target-optspace was given.
+if test "${enable_target_optspace+set}" = set; then :
+  enableval=$enable_target_optspace; case "${enableval}" in
+  yes) target_optspace=yes ;;
+  no)  target_optspace=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for target-optspace option" "$LINENO" 5 ;;
+ esac
+else
+  target_optspace=
+fi
+
+# Check whether --enable-malloc-debugging was given.
+if test "${enable_malloc_debugging+set}" = set; then :
+  enableval=$enable_malloc_debugging; case "${enableval}" in
+  yes) malloc_debugging=yes ;;
+  no)  malloc_debugging=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for malloc-debugging option" "$LINENO" 5 ;;
+ esac
+else
+  malloc_debugging=
+fi
+
+# Check whether --enable-newlib-multithread was given.
+if test "${enable_newlib_multithread+set}" = set; then :
+  enableval=$enable_newlib_multithread; case "${enableval}" in
+  yes) newlib_multithread=yes ;;
+  no)  newlib_multithread=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-multithread option" "$LINENO" 5 ;;
+ esac
+else
+  newlib_multithread=yes
+fi
+
+# Check whether --enable-newlib-iconv was given.
+if test "${enable_newlib_iconv+set}" = set; then :
+  enableval=$enable_newlib_iconv; if test "${newlib_iconv+set}" != set; then
+   case "${enableval}" in
+     yes) newlib_iconv=yes ;;
+     no)  newlib_iconv=no ;;
+     *)   as_fn_error $? "bad value ${enableval} for newlib-iconv option" "$LINENO" 5 ;;
+   esac
+ fi
+else
+  newlib_iconv=${newlib_iconv}
+fi
+
+# Check whether --enable-newlib-elix-level was given.
+if test "${enable_newlib_elix_level+set}" = set; then :
+  enableval=$enable_newlib_elix_level; case "${enableval}" in
+  0)   newlib_elix_level=0 ;;
+  1)   newlib_elix_level=1 ;;
+  2)   newlib_elix_level=2 ;;
+  3)   newlib_elix_level=3 ;;
+  4)   newlib_elix_level=4 ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5 ;;
+ esac
+else
+  newlib_elix_level=0
+fi
+
+# Check whether --enable-newlib-io-float was given.
+if test "${enable_newlib_io_float+set}" = set; then :
+  enableval=$enable_newlib_io_float; case "${enableval}" in
+  yes) newlib_io_float=yes ;;
+  no)  newlib_io_float=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-io-float option" "$LINENO" 5 ;;
+ esac
+else
+  newlib_io_float=yes
+fi
+
+# Check whether --enable-newlib-supplied-syscalls was given.
+if test "${enable_newlib_supplied_syscalls+set}" = set; then :
+  enableval=$enable_newlib_supplied_syscalls; case "${enableval}" in
+  yes) newlib_may_supply_syscalls=yes ;;
+  no)  newlib_may_supply_syscalls=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5 ;;
+ esac
+else
+  newlib_may_supply_syscalls=yes
+fi
+
+ if test x${newlib_may_supply_syscalls} = xyes; then
+  MAY_SUPPLY_SYSCALLS_TRUE=
+  MAY_SUPPLY_SYSCALLS_FALSE='#'
+else
+  MAY_SUPPLY_SYSCALLS_TRUE='#'
+  MAY_SUPPLY_SYSCALLS_FALSE=
+fi
+
+
+# Check whether --enable-newlib-fno-builtin was given.
+if test "${enable_newlib_fno_builtin+set}" = set; then :
+  enableval=$enable_newlib_fno_builtin; case "${enableval}" in
+  yes) newlib_fno_builtin=yes ;;
+  no)  newlib_fno_builtin=no ;;
+  *)   as_fn_error $? "bad value ${enableval} for newlib-fno-builtin option" "$LINENO" 5 ;;
+ esac
+else
+  newlib_fno_builtin=
+fi
+
+
+
+test -z "${with_target_subdir}" && with_target_subdir=.
+
+if test "${srcdir}" = "."; then
+  if test "${with_target_subdir}" != "."; then
+    newlib_basedir="${srcdir}/${with_multisrctop}../../../.."
+  else
+    newlib_basedir="${srcdir}/${with_multisrctop}../../.."
+  fi
+else
+  newlib_basedir="${srcdir}/../../.."
+fi
+
+
+
+
+if test "`cd $srcdir && pwd`" != "`pwd`"; then
+  # Use -I$(srcdir) only when $(srcdir) != ., so that make's output
+  # is not polluted with repeated "-I."
+  am__isrc=' -I$(srcdir)'
+  # test to see if srcdir already configured
+  if test -f $srcdir/config.status; then
+    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+  fi
+fi
+
+# test whether we have cygpath
+if test -z "$CYGPATH_W"; then
+  if (cygpath --version) >/dev/null 2>/dev/null; then
+    CYGPATH_W='cygpath -w'
+  else
+    CYGPATH_W=echo
+  fi
+fi
+
+
+# Define the identity of the package.
+ PACKAGE='newlib'
+ VERSION='4.1.0'
+
+
+# Some tools Automake needs.
+
+ACLOCAL=${ACLOCAL-"${am_missing_run}aclocal-${am__api_version}"}
+
+
+AUTOCONF=${AUTOCONF-"${am_missing_run}autoconf"}
+
+
+AUTOMAKE=${AUTOMAKE-"${am_missing_run}automake-${am__api_version}"}
+
+
+AUTOHEADER=${AUTOHEADER-"${am_missing_run}autoheader"}
+
+
+MAKEINFO=${MAKEINFO-"${am_missing_run}makeinfo"}
+
+# We need awk for the "check" target.  The system "awk" is bad on
+# some platforms.
+# Always define AMTAR for backward compatibility.  Yes, it's still used
+# in the wild :-(  We should find a proper way to deprecate it ...
+AMTAR='$${TAR-tar}'
+
+am__tar='$${TAR-tar} chof - "$$tardir"' am__untar='$${TAR-tar} xf -'
+
+
+
+
+
+
+# FIXME: We temporarily define our own version of AC_PROG_CC.  This is
+# copied from autoconf 2.12, but does not call AC_PROG_CC_WORKS.  We
+# are probably using a cross compiler, which will not be able to fully
+# link an executable.  This should really be fixed in autoconf
+# itself.
+
+
+
+
+
+
+
+# Extract the first word of "gcc", so it can be a program name with args.
+set dummy gcc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_CC="gcc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+
+depcc="$CC"   am_compiler_list=
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
+$as_echo_n "checking dependency style of $depcc... " >&6; }
+if ${am_cv_CC_dependencies_compiler_type+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
+  # We make a subdir and do the tests there.  Otherwise we can end up
+  # making bogus files that we don't know about and never remove.  For
+  # instance it was reported that on HP-UX the gcc test will end up
+  # making a dummy file named `D' -- because `-MD' means `put the output
+  # in D'.
+  rm -rf conftest.dir
+  mkdir conftest.dir
+  # Copy depcomp to subdir because otherwise we won't find it if we're
+  # using a relative directory.
+  cp "$am_depcomp" conftest.dir
+  cd conftest.dir
+  # We will build objects and dependencies in a subdirectory because
+  # it helps to detect inapplicable dependency modes.  For instance
+  # both Tru64's cc and ICC support -MD to output dependencies as a
+  # side effect of compilation, but ICC will put the dependencies in
+  # the current directory while Tru64 will put them in the object
+  # directory.
+  mkdir sub
+
+  am_cv_CC_dependencies_compiler_type=none
+  if test "$am_compiler_list" = ""; then
+     am_compiler_list=`sed -n 's/^#*\([a-zA-Z0-9]*\))$/\1/p' < ./depcomp`
+  fi
+  am__universal=false
+  case " $depcc " in #(
+     *\ -arch\ *\ -arch\ *) am__universal=true ;;
+     esac
+
+  for depmode in $am_compiler_list; do
+    # Setup a source with many dependencies, because some compilers
+    # like to wrap large dependency lists on column 80 (with \), and
+    # we should not choose a depcomp mode which is confused by this.
+    #
+    # We need to recreate these files for each test, as the compiler may
+    # overwrite some of them when testing with obscure command lines.
+    # This happens at least with the AIX C compiler.
+    : > sub/conftest.c
+    for i in 1 2 3 4 5 6; do
+      echo '#include "conftst'$i'.h"' >> sub/conftest.c
+      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
+      # Solaris 8's {/usr,}/bin/sh.
+      touch sub/conftst$i.h
+    done
+    echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
+
+    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # mode.  It turns out that the SunPro C++ compiler does not properly
+    # handle `-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs
+    am__obj=sub/conftest.${OBJEXT-o}
+    am__minus_obj="-o $am__obj"
+    case $depmode in
+    gcc)
+      # This depmode causes a compiler race in universal mode.
+      test "$am__universal" = false || continue
+      ;;
+    nosideeffect)
+      # after this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested
+      if test "x$enable_dependency_tracking" = xyes; then
+	continue
+      else
+	break
+      fi
+      ;;
+    msvc7 | msvc7msys | msvisualcpp | msvcmsys)
+      # This compiler won't grok `-c -o', but also, the minuso test has
+      # not run yet.  These depmodes are late enough in the game, and
+      # so weak that their functioning should not be impacted.
+      am__obj=conftest.${OBJEXT-o}
+      am__minus_obj=
+      ;;
+    none) break ;;
+    esac
+    if depmode=$depmode \
+       source=sub/conftest.c object=$am__obj \
+       depfile=sub/conftest.Po tmpdepfile=sub/conftest.TPo \
+       $SHELL ./depcomp $depcc -c $am__minus_obj sub/conftest.c \
+         >/dev/null 2>conftest.err &&
+       grep sub/conftst1.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep sub/conftst6.h sub/conftest.Po > /dev/null 2>&1 &&
+       grep $am__obj sub/conftest.Po > /dev/null 2>&1 &&
+       ${MAKE-make} -s -f confmf > /dev/null 2>&1; then
+      # icc doesn't choke on unknown options, it will just issue warnings
+      # or remarks (even with -Werror).  So we grep stderr for any message
+      # that says an option was ignored or not supported.
+      # When given -MP, icc 7.0 and 7.1 complain thusly:
+      #   icc: Command line warning: ignoring option '-M'; no argument required
+      # The diagnosis changed in icc 8.0:
+      #   icc: Command line remark: option '-MP' not supported
+      if (grep 'ignoring option' conftest.err ||
+          grep 'not supported' conftest.err) >/dev/null 2>&1; then :; else
+        am_cv_CC_dependencies_compiler_type=$depmode
+        break
+      fi
+    fi
+  done
+
+  cd ..
+  rm -rf conftest.dir
+else
+  am_cv_CC_dependencies_compiler_type=none
+fi
+
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $am_cv_CC_dependencies_compiler_type" >&5
+$as_echo "$am_cv_CC_dependencies_compiler_type" >&6; }
+CCDEPMODE=depmode=$am_cv_CC_dependencies_compiler_type
+
+ if
+  test "x$enable_dependency_tracking" != xno \
+  && test "$am_cv_CC_dependencies_compiler_type" = gcc3; then
+  am__fastdepCC_TRUE=
+  am__fastdepCC_FALSE='#'
+else
+  am__fastdepCC_TRUE='#'
+  am__fastdepCC_FALSE=
+fi
+
+
+if test -z "$CC"; then
+  # Extract the first word of "cc", so it can be a program name with args.
+set dummy cc; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_CC+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$CC"; then
+  ac_cv_prog_CC="$CC" # Let the user override the test.
+else
+  ac_prog_rejected=no
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    if test "$as_dir/$ac_word$ac_exec_ext" = "/usr/ucb/cc"; then
+       ac_prog_rejected=yes
+       continue
+     fi
+    ac_cv_prog_CC="cc"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+if test $ac_prog_rejected = yes; then
+  # We found a bogon in the path, so make sure we never use it.
+  set dummy $ac_cv_prog_CC
+  shift
+  if test $# != 0; then
+    # We chose a different compiler from the bogus one.
+    # However, it has the same basename, so the bogon will be chosen
+    # first if we set CC to just the basename; use the full file name.
+    shift
+    ac_cv_prog_CC="$as_dir/$ac_word${1+' '}$@"
+  fi
+fi
+fi
+fi
+CC=$ac_cv_prog_CC
+if test -n "$CC"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $CC" >&5
+$as_echo "$CC" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+  test -z "$CC" && as_fn_error $? "no acceptable cc found in \$PATH" "$LINENO" 5
+fi
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using GNU C" >&5
+$as_echo_n "checking whether we are using GNU C... " >&6; }
+if ${ac_cv_c_compiler_gnu+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  cat > conftest.c <<EOF
+#ifdef __GNUC__
+  yes;
+#endif
+EOF
+if { ac_try='${CC-cc} -E conftest.c'
+  { { eval echo "\"\$as_me\":${as_lineno-$LINENO}: \"$ac_try\""; } >&5
+  (eval $ac_try) 2>&5
+  ac_status=$?
+  $as_echo "$as_me:${as_lineno-$LINENO}: \$? = $ac_status" >&5
+  test $ac_status = 0; }; } | egrep yes >/dev/null 2>&1; then
+  ac_cv_c_compiler_gnu=yes
+else
+  ac_cv_c_compiler_gnu=no
+fi
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_c_compiler_gnu" >&5
+$as_echo "$ac_cv_c_compiler_gnu" >&6; }
+
+if test $ac_cv_c_compiler_gnu = yes; then
+  GCC=yes
+  ac_test_CFLAGS="${CFLAGS+set}"
+  ac_save_CFLAGS="$CFLAGS"
+  ac_test_CFLAGS=${CFLAGS+set}
+ac_save_CFLAGS=$CFLAGS
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
+$as_echo_n "checking whether $CC accepts -g... " >&6; }
+if ${ac_cv_prog_cc_g+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  ac_save_c_werror_flag=$ac_c_werror_flag
+   ac_c_werror_flag=yes
+   ac_cv_prog_cc_g=no
+   CFLAGS="-g"
+   cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+else
+  CFLAGS=""
+      cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+
+else
+  ac_c_werror_flag=$ac_save_c_werror_flag
+	 CFLAGS="-g"
+	 cat confdefs.h - <<_ACEOF >conftest.$ac_ext
+/* end confdefs.h.  */
+
+int
+main ()
+{
+
+  ;
+  return 0;
+}
+_ACEOF
+if ac_fn_c_try_compile "$LINENO"; then :
+  ac_cv_prog_cc_g=yes
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+fi
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
+   ac_c_werror_flag=$ac_save_c_werror_flag
+fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_prog_cc_g" >&5
+$as_echo "$ac_cv_prog_cc_g" >&6; }
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS=$ac_save_CFLAGS
+elif test $ac_cv_prog_cc_g = yes; then
+  if test "$GCC" = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-g"
+  fi
+else
+  if test "$GCC" = yes; then
+    CFLAGS="-O2"
+  else
+    CFLAGS=
+  fi
+fi
+  if test "$ac_test_CFLAGS" = set; then
+    CFLAGS="$ac_save_CFLAGS"
+  elif test $ac_cv_prog_cc_g = yes; then
+    CFLAGS="-g -O2"
+  else
+    CFLAGS="-O2"
+  fi
+else
+  GCC=
+  test "${CFLAGS+set}" = set || CFLAGS="-g"
+fi
+
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}as", so it can be a program name with args.
+set dummy ${ac_tool_prefix}as; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AS+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AS"; then
+  ac_cv_prog_AS="$AS" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AS="${ac_tool_prefix}as"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AS=$ac_cv_prog_AS
+if test -n "$AS"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AS" >&5
+$as_echo "$AS" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AS"; then
+  ac_ct_AS=$AS
+  # Extract the first word of "as", so it can be a program name with args.
+set dummy as; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_AS+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AS"; then
+  ac_cv_prog_ac_ct_AS="$ac_ct_AS" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AS="as"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AS=$ac_cv_prog_ac_ct_AS
+if test -n "$ac_ct_AS"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AS" >&5
+$as_echo "$ac_ct_AS" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AS" = x; then
+    AS=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AS=$ac_ct_AS
+  fi
+else
+  AS="$ac_cv_prog_AS"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ar", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$AR"; then
+  ac_cv_prog_AR="$AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_AR="${ac_tool_prefix}ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+AR=$ac_cv_prog_AR
+if test -n "$AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $AR" >&5
+$as_echo "$AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_AR"; then
+  ac_ct_AR=$AR
+  # Extract the first word of "ar", so it can be a program name with args.
+set dummy ar; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_AR+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_AR"; then
+  ac_cv_prog_ac_ct_AR="$ac_ct_AR" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_AR="ar"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_AR=$ac_cv_prog_ac_ct_AR
+if test -n "$ac_ct_AR"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_AR" >&5
+$as_echo "$ac_ct_AR" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_AR" = x; then
+    AR=""
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    AR=$ac_ct_AR
+  fi
+else
+  AR="$ac_cv_prog_AR"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}ranlib", so it can be a program name with args.
+set dummy ${ac_tool_prefix}ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_RANLIB+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$RANLIB"; then
+  ac_cv_prog_RANLIB="$RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_RANLIB="${ac_tool_prefix}ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+RANLIB=$ac_cv_prog_RANLIB
+if test -n "$RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $RANLIB" >&5
+$as_echo "$RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_RANLIB"; then
+  ac_ct_RANLIB=$RANLIB
+  # Extract the first word of "ranlib", so it can be a program name with args.
+set dummy ranlib; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_RANLIB"; then
+  ac_cv_prog_ac_ct_RANLIB="$ac_ct_RANLIB" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_RANLIB="ranlib"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_RANLIB=$ac_cv_prog_ac_ct_RANLIB
+if test -n "$ac_ct_RANLIB"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_RANLIB" >&5
+$as_echo "$ac_ct_RANLIB" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_RANLIB" = x; then
+    RANLIB=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    RANLIB=$ac_ct_RANLIB
+  fi
+else
+  RANLIB="$ac_cv_prog_RANLIB"
+fi
+
+if test -n "$ac_tool_prefix"; then
+  # Extract the first word of "${ac_tool_prefix}readelf", so it can be a program name with args.
+set dummy ${ac_tool_prefix}readelf; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_READELF+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$READELF"; then
+  ac_cv_prog_READELF="$READELF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_READELF="${ac_tool_prefix}readelf"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+READELF=$ac_cv_prog_READELF
+if test -n "$READELF"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $READELF" >&5
+$as_echo "$READELF" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+
+fi
+if test -z "$ac_cv_prog_READELF"; then
+  ac_ct_READELF=$READELF
+  # Extract the first word of "readelf", so it can be a program name with args.
+set dummy readelf; ac_word=$2
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
+$as_echo_n "checking for $ac_word... " >&6; }
+if ${ac_cv_prog_ac_ct_READELF+:} false; then :
+  $as_echo_n "(cached) " >&6
+else
+  if test -n "$ac_ct_READELF"; then
+  ac_cv_prog_ac_ct_READELF="$ac_ct_READELF" # Let the user override the test.
+else
+as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    for ac_exec_ext in '' $ac_executable_extensions; do
+  if { test -f "$as_dir/$ac_word$ac_exec_ext" && $as_test_x "$as_dir/$ac_word$ac_exec_ext"; }; then
+    ac_cv_prog_ac_ct_READELF="readelf"
+    $as_echo "$as_me:${as_lineno-$LINENO}: found $as_dir/$ac_word$ac_exec_ext" >&5
+    break 2
+  fi
+done
+  done
+IFS=$as_save_IFS
+
+fi
+fi
+ac_ct_READELF=$ac_cv_prog_ac_ct_READELF
+if test -n "$ac_ct_READELF"; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_ct_READELF" >&5
+$as_echo "$ac_ct_READELF" >&6; }
+else
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: no" >&5
+$as_echo "no" >&6; }
+fi
+
+  if test "x$ac_ct_READELF" = x; then
+    READELF=":"
+  else
+    case $cross_compiling:$ac_tool_warned in
+yes:)
+{ $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: using cross tools not prefixed with host triplet" >&5
+$as_echo "$as_me: WARNING: using cross tools not prefixed with host triplet" >&2;}
+ac_tool_warned=yes ;;
+esac
+    READELF=$ac_ct_READELF
+  fi
+else
+  READELF="$ac_cv_prog_READELF"
+fi
+
+
+
+
+# Hack to ensure that INSTALL won't be set to "../" with autoconf 2.13.  */
+ac_given_INSTALL=$INSTALL
+
+
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
+$as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
+    # Check whether --enable-maintainer-mode was given.
+if test "${enable_maintainer_mode+set}" = set; then :
+  enableval=$enable_maintainer_mode; USE_MAINTAINER_MODE=$enableval
+else
+  USE_MAINTAINER_MODE=no
+fi
+
+  { $as_echo "$as_me:${as_lineno-$LINENO}: result: $USE_MAINTAINER_MODE" >&5
+$as_echo "$USE_MAINTAINER_MODE" >&6; }
+   if test $USE_MAINTAINER_MODE = yes; then
+  MAINTAINER_MODE_TRUE=
+  MAINTAINER_MODE_FALSE='#'
+else
+  MAINTAINER_MODE_TRUE='#'
+  MAINTAINER_MODE_FALSE=
+fi
+
+  MAINT=$MAINTAINER_MODE_TRUE
+
+
+# By default we simply use the C compiler to build assembly code.
+
+test "${CCAS+set}" = set || CCAS=$CC
+test "${CCASFLAGS+set}" = set || CCASFLAGS=$CFLAGS
+
+
+
+
+# We need AC_EXEEXT to keep automake happy in cygnus mode.  However,
+# at least currently, we never actually build a program, so we never
+# need to use $(EXEEXT).  Moreover, the test for EXEEXT normally
+# fails, because we are probably configuring with a cross compiler
+# which can't create executables.  So we include AC_EXEEXT to keep
+# automake happy, but we don't execute it, since we don't care about
+# the result.
+if false; then
+
+  dummy_var=1
+fi
+
+. ${newlib_basedir}/configure.host
+
+NEWLIB_CFLAGS=${newlib_cflags}
+
+
+NO_INCLUDE_LIST=${noinclude}
+
+
+LDFLAGS=${ldflags}
+
+
+ if test x${newlib_elix_level} = x0; then
+  ELIX_LEVEL_0_TRUE=
+  ELIX_LEVEL_0_FALSE='#'
+else
+  ELIX_LEVEL_0_TRUE='#'
+  ELIX_LEVEL_0_FALSE=
+fi
+
+ if test x${newlib_elix_level} = x1; then
+  ELIX_LEVEL_1_TRUE=
+  ELIX_LEVEL_1_FALSE='#'
+else
+  ELIX_LEVEL_1_TRUE='#'
+  ELIX_LEVEL_1_FALSE=
+fi
+
+ if test x${newlib_elix_level} = x2; then
+  ELIX_LEVEL_2_TRUE=
+  ELIX_LEVEL_2_FALSE='#'
+else
+  ELIX_LEVEL_2_TRUE='#'
+  ELIX_LEVEL_2_FALSE=
+fi
+
+ if test x${newlib_elix_level} = x3; then
+  ELIX_LEVEL_3_TRUE=
+  ELIX_LEVEL_3_FALSE='#'
+else
+  ELIX_LEVEL_3_TRUE='#'
+  ELIX_LEVEL_3_FALSE=
+fi
+
+ if test x${newlib_elix_level} = x4; then
+  ELIX_LEVEL_4_TRUE=
+  ELIX_LEVEL_4_FALSE='#'
+else
+  ELIX_LEVEL_4_TRUE='#'
+  ELIX_LEVEL_4_FALSE=
+fi
+
+
+ if test x${use_libtool} = xyes; then
+  USE_LIBTOOL_TRUE=
+  USE_LIBTOOL_FALSE='#'
+else
+  USE_LIBTOOL_TRUE='#'
+  USE_LIBTOOL_FALSE=
+fi
+
+
+# Emit any target-specific warnings.
+if test "x${newlib_msg_warn}" != "x"; then
+   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: ${newlib_msg_warn}" >&5
+$as_echo "$as_me: WARNING: ${newlib_msg_warn}" >&2;}
+fi
+
+# Hard-code OBJEXT.  Normally it is set by AC_OBJEXT, but we
+# use oext, which is set in configure.host based on the target platform.
+OBJEXT=${oext}
+
+
+
+
+
+
+
+
+
+
+
+ac_config_files="$ac_config_files Makefile"
+
+cat >confcache <<\_ACEOF
+# This file is a shell script that caches the results of configure
+# tests run on this system so they can be shared between configure
+# scripts and configure runs, see configure's option --config-cache.
+# It is not useful on other systems.  If it contains results you don't
+# want to keep, you may remove or edit it.
+#
+# config.status only pays attention to the cache file if you give it
+# the --recheck option to rerun configure.
+#
+# `ac_cv_env_foo' variables (set or unset) will be overridden when
+# loading this file, other *unset* `ac_cv_foo' will be assigned the
+# following values.
+
+_ACEOF
+
+# The following way of writing the cache mishandles newlines in values,
+# but we know of no workaround that is simple, portable, and efficient.
+# So, we kill variables containing newlines.
+# Ultrix sh set writes to stderr and can't be redirected directly,
+# and sets the high bit in the cache file unless we assign to the vars.
+(
+  for ac_var in `(set) 2>&1 | sed -n 's/^\([a-zA-Z_][a-zA-Z0-9_]*\)=.*/\1/p'`; do
+    eval ac_val=\$$ac_var
+    case $ac_val in #(
+    *${as_nl}*)
+      case $ac_var in #(
+      *_cv_*) { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: cache variable $ac_var contains a newline" >&5
+$as_echo "$as_me: WARNING: cache variable $ac_var contains a newline" >&2;} ;;
+      esac
+      case $ac_var in #(
+      _ | IFS | as_nl) ;; #(
+      BASH_ARGV | BASH_SOURCE) eval $ac_var= ;; #(
+      *) { eval $ac_var=; unset $ac_var;} ;;
+      esac ;;
+    esac
+  done
+
+  (set) 2>&1 |
+    case $as_nl`(ac_space=' '; set) 2>&1` in #(
+    *${as_nl}ac_space=\ *)
+      # `set' does not quote correctly, so add quotes: double-quote
+      # substitution turns \\\\ into \\, and sed turns \\ into \.
+      sed -n \
+	"s/'/'\\\\''/g;
+	  s/^\\([_$as_cr_alnum]*_cv_[_$as_cr_alnum]*\\)=\\(.*\\)/\\1='\\2'/p"
+      ;; #(
+    *)
+      # `set' quotes correctly as required by POSIX, so do not add quotes.
+      sed -n "/^[_$as_cr_alnum]*_cv_[_$as_cr_alnum]*=/p"
+      ;;
+    esac |
+    sort
+) |
+  sed '
+     /^ac_cv_env_/b end
+     t clear
+     :clear
+     s/^\([^=]*\)=\(.*[{}].*\)$/test "${\1+set}" = set || &/
+     t end
+     s/^\([^=]*\)=\(.*\)$/\1=${\1=\2}/
+     :end' >>confcache
+if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
+  if test -w "$cache_file"; then
+    if test "x$cache_file" != "x/dev/null"; then
+      { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
+$as_echo "$as_me: updating cache $cache_file" >&6;}
+      if test ! -f "$cache_file" || test -h "$cache_file"; then
+	cat confcache >"$cache_file"
+      else
+        case $cache_file in #(
+        */* | ?:*)
+	  mv -f confcache "$cache_file"$$ &&
+	  mv -f "$cache_file"$$ "$cache_file" ;; #(
+        *)
+	  mv -f confcache "$cache_file" ;;
+	esac
+      fi
+    fi
+  else
+    { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
+$as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
+  fi
+fi
+rm -f confcache
+
+test "x$prefix" = xNONE && prefix=$ac_default_prefix
+# Let make expand exec_prefix.
+test "x$exec_prefix" = xNONE && exec_prefix='${prefix}'
+
+# Transform confdefs.h into DEFS.
+# Protect against shell expansion while executing Makefile rules.
+# Protect against Makefile macro expansion.
+#
+# If the first sed substitution is executed (which looks for macros that
+# take arguments), then branch to the quote section.  Otherwise,
+# look for a macro that doesn't take arguments.
+ac_script='
+:mline
+/\\$/{
+ N
+ s,\\\n,,
+ b mline
+}
+t clear
+:clear
+s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 (][^	 (]*([^)]*)\)[	 ]*\(.*\)/-D\1=\2/g
+t quote
+s/^[	 ]*#[	 ]*define[	 ][	 ]*\([^	 ][^	 ]*\)[	 ]*\(.*\)/-D\1=\2/g
+t quote
+b any
+:quote
+s/[	 `~#$^&*(){}\\|;'\''"<>?]/\\&/g
+s/\[/\\&/g
+s/\]/\\&/g
+s/\$/$$/g
+H
+:any
+${
+	g
+	s/^\n//
+	s/\n/ /g
+	p
+}
+'
+DEFS=`sed -n "$ac_script" confdefs.h`
+
+
+ac_libobjs=
+ac_ltlibobjs=
+U=
+for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
+  # 1. Remove the extension, and $U if already installed.
+  ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
+  ac_i=`$as_echo "$ac_i" | sed "$ac_script"`
+  # 2. Prepend LIBOBJDIR.  When used with automake>=1.10 LIBOBJDIR
+  #    will be set to the directory where LIBOBJS objects are built.
+  as_fn_append ac_libobjs " \${LIBOBJDIR}$ac_i\$U.$ac_objext"
+  as_fn_append ac_ltlibobjs " \${LIBOBJDIR}$ac_i"'$U.lo'
+done
+LIBOBJS=$ac_libobjs
+
+LTLIBOBJS=$ac_ltlibobjs
+
+
+if test -z "${MAY_SUPPLY_SYSCALLS_TRUE}" && test -z "${MAY_SUPPLY_SYSCALLS_FALSE}"; then
+  as_fn_error $? "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
+  as_fn_error $? "conditional \"AMDEP\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
+  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
+  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${ELIX_LEVEL_0_TRUE}" && test -z "${ELIX_LEVEL_0_FALSE}"; then
+  as_fn_error $? "conditional \"ELIX_LEVEL_0\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${ELIX_LEVEL_1_TRUE}" && test -z "${ELIX_LEVEL_1_FALSE}"; then
+  as_fn_error $? "conditional \"ELIX_LEVEL_1\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${ELIX_LEVEL_2_TRUE}" && test -z "${ELIX_LEVEL_2_FALSE}"; then
+  as_fn_error $? "conditional \"ELIX_LEVEL_2\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${ELIX_LEVEL_3_TRUE}" && test -z "${ELIX_LEVEL_3_FALSE}"; then
+  as_fn_error $? "conditional \"ELIX_LEVEL_3\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${ELIX_LEVEL_4_TRUE}" && test -z "${ELIX_LEVEL_4_FALSE}"; then
+  as_fn_error $? "conditional \"ELIX_LEVEL_4\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+if test -z "${USE_LIBTOOL_TRUE}" && test -z "${USE_LIBTOOL_FALSE}"; then
+  as_fn_error $? "conditional \"USE_LIBTOOL\" was never defined.
+Usually this means the macro was only invoked conditionally." "$LINENO" 5
+fi
+
+: "${CONFIG_STATUS=./config.status}"
+ac_write_fail=0
+ac_clean_files_save=$ac_clean_files
+ac_clean_files="$ac_clean_files $CONFIG_STATUS"
+{ $as_echo "$as_me:${as_lineno-$LINENO}: creating $CONFIG_STATUS" >&5
+$as_echo "$as_me: creating $CONFIG_STATUS" >&6;}
+as_write_fail=0
+cat >$CONFIG_STATUS <<_ASEOF || as_write_fail=1
+#! $SHELL
+# Generated by $as_me.
+# Run this file to recreate the current configuration.
+# Compiler output produced by configure, useful for debugging
+# configure, is in config.log if it exists.
+
+debug=false
+ac_cs_recheck=false
+ac_cs_silent=false
+
+SHELL=\${CONFIG_SHELL-$SHELL}
+export SHELL
+_ASEOF
+cat >>$CONFIG_STATUS <<\_ASEOF || as_write_fail=1
+## -------------------- ##
+## M4sh Initialization. ##
+## -------------------- ##
+
+# Be more Bourne compatible
+DUALCASE=1; export DUALCASE # for MKS sh
+if test -n "${ZSH_VERSION+set}" && (emulate sh) >/dev/null 2>&1; then :
+  emulate sh
+  NULLCMD=:
+  # Pre-4.2 versions of Zsh do word splitting on ${1+"$@"}, which
+  # is contrary to our usage.  Disable this feature.
+  alias -g '${1+"$@"}'='"$@"'
+  setopt NO_GLOB_SUBST
+else
+  case `(set -o) 2>/dev/null` in #(
+  *posix*) :
+    set -o posix ;; #(
+  *) :
+     ;;
+esac
+fi
+
+
+as_nl='
+'
+export as_nl
+# Printing a long string crashes Solaris 7 /usr/bin/printf.
+as_echo='\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\'
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo
+as_echo=$as_echo$as_echo$as_echo$as_echo$as_echo$as_echo
+# Prefer a ksh shell builtin over an external printf program on Solaris,
+# but without wasting forks for bash or zsh.
+if test -z "$BASH_VERSION$ZSH_VERSION" \
+    && (test "X`print -r -- $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='print -r --'
+  as_echo_n='print -rn --'
+elif (test "X`printf %s $as_echo`" = "X$as_echo") 2>/dev/null; then
+  as_echo='printf %s\n'
+  as_echo_n='printf %s'
+else
+  if test "X`(/usr/ucb/echo -n -n $as_echo) 2>/dev/null`" = "X-n $as_echo"; then
+    as_echo_body='eval /usr/ucb/echo -n "$1$as_nl"'
+    as_echo_n='/usr/ucb/echo -n'
+  else
+    as_echo_body='eval expr "X$1" : "X\\(.*\\)"'
+    as_echo_n_body='eval
+      arg=$1;
+      case $arg in #(
+      *"$as_nl"*)
+	expr "X$arg" : "X\\(.*\\)$as_nl";
+	arg=`expr "X$arg" : ".*$as_nl\\(.*\\)"`;;
+      esac;
+      expr "X$arg" : "X\\(.*\\)" | tr -d "$as_nl"
+    '
+    export as_echo_n_body
+    as_echo_n='sh -c $as_echo_n_body as_echo'
+  fi
+  export as_echo_body
+  as_echo='sh -c $as_echo_body as_echo'
+fi
+
+# The user is always right.
+if test "${PATH_SEPARATOR+set}" != set; then
+  PATH_SEPARATOR=:
+  (PATH='/bin;/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 && {
+    (PATH='/bin:/bin'; FPATH=$PATH; sh -c :) >/dev/null 2>&1 ||
+      PATH_SEPARATOR=';'
+  }
+fi
+
+
+# IFS
+# We need space, tab and new line, in precisely that order.  Quoting is
+# there to prevent editors from complaining about space-tab.
+# (If _AS_PATH_WALK were called with IFS unset, it would disable word
+# splitting by setting IFS to empty value.)
+IFS=" ""	$as_nl"
+
+# Find who we are.  Look in the path if we contain no directory separator.
+as_myself=
+case $0 in #((
+  *[\\/]* ) as_myself=$0 ;;
+  *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
+for as_dir in $PATH
+do
+  IFS=$as_save_IFS
+  test -z "$as_dir" && as_dir=.
+    test -r "$as_dir/$0" && as_myself=$as_dir/$0 && break
+  done
+IFS=$as_save_IFS
+
+     ;;
+esac
+# We did not find ourselves, most probably we were run as `sh COMMAND'
+# in which case we are not to be found in the path.
+if test "x$as_myself" = x; then
+  as_myself=$0
+fi
+if test ! -f "$as_myself"; then
+  $as_echo "$as_myself: error: cannot find myself; rerun with an absolute file name" >&2
+  exit 1
+fi
+
+# Unset variables that we do not need and which cause bugs (e.g. in
+# pre-3.0 UWIN ksh).  But do not cause bugs in bash 2.01; the "|| exit 1"
+# suppresses any "Segmentation fault" message there.  '((' could
+# trigger a bug in pdksh 5.2.14.
+for as_var in BASH_ENV ENV MAIL MAILPATH
+do eval test x\${$as_var+set} = xset \
+  && ( (unset $as_var) || exit 1) >/dev/null 2>&1 && unset $as_var || :
+done
+PS1='$ '
+PS2='> '
+PS4='+ '
+
+# NLS nuisances.
+LC_ALL=C
+export LC_ALL
+LANGUAGE=C
+export LANGUAGE
+
+# CDPATH.
+(unset CDPATH) >/dev/null 2>&1 && unset CDPATH
+
+
+# as_fn_error STATUS ERROR [LINENO LOG_FD]
+# ----------------------------------------
+# Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
+# provided, also output the error to LOG_FD, referencing LINENO. Then exit the
+# script with STATUS, using 1 if that was 0.
+as_fn_error ()
+{
+  as_status=$1; test $as_status -eq 0 && as_status=1
+  if test "$4"; then
+    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  fi
+  $as_echo "$as_me: error: $2" >&2
+  as_fn_exit $as_status
+} # as_fn_error
+
+
+# as_fn_set_status STATUS
+# -----------------------
+# Set $? to STATUS, without forking.
+as_fn_set_status ()
+{
+  return $1
+} # as_fn_set_status
+
+# as_fn_exit STATUS
+# -----------------
+# Exit the shell with STATUS, even in a "trap 0" or "set -e" context.
+as_fn_exit ()
+{
+  set +e
+  as_fn_set_status $1
+  exit $1
+} # as_fn_exit
+
+# as_fn_unset VAR
+# ---------------
+# Portably unset VAR.
+as_fn_unset ()
+{
+  { eval $1=; unset $1;}
+}
+as_unset=as_fn_unset
+# as_fn_append VAR VALUE
+# ----------------------
+# Append the text in VALUE to the end of the definition contained in VAR. Take
+# advantage of any shell optimizations that allow amortized linear growth over
+# repeated appends, instead of the typical quadratic growth present in naive
+# implementations.
+if (eval "as_var=1; as_var+=2; test x\$as_var = x12") 2>/dev/null; then :
+  eval 'as_fn_append ()
+  {
+    eval $1+=\$2
+  }'
+else
+  as_fn_append ()
+  {
+    eval $1=\$$1\$2
+  }
+fi # as_fn_append
+
+# as_fn_arith ARG...
+# ------------------
+# Perform arithmetic evaluation on the ARGs, and store the result in the
+# global $as_val. Take advantage of shells that can avoid forks. The arguments
+# must be portable across $(()) and expr.
+if (eval "test \$(( 1 + 1 )) = 2") 2>/dev/null; then :
+  eval 'as_fn_arith ()
+  {
+    as_val=$(( $* ))
+  }'
+else
+  as_fn_arith ()
+  {
+    as_val=`expr "$@" || test $? -eq 1`
+  }
+fi # as_fn_arith
+
+
+if expr a : '\(a\)' >/dev/null 2>&1 &&
+   test "X`expr 00001 : '.*\(...\)'`" = X001; then
+  as_expr=expr
+else
+  as_expr=false
+fi
+
+if (basename -- /) >/dev/null 2>&1 && test "X`basename -- / 2>&1`" = "X/"; then
+  as_basename=basename
+else
+  as_basename=false
+fi
+
+if (as_dir=`dirname -- /` && test "X$as_dir" = X/) >/dev/null 2>&1; then
+  as_dirname=dirname
+else
+  as_dirname=false
+fi
+
+as_me=`$as_basename -- "$0" ||
+$as_expr X/"$0" : '.*/\([^/][^/]*\)/*$' \| \
+	 X"$0" : 'X\(//\)$' \| \
+	 X"$0" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X/"$0" |
+    sed '/^.*\/\([^/][^/]*\)\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\/\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+
+# Avoid depending upon Character Ranges.
+as_cr_letters='abcdefghijklmnopqrstuvwxyz'
+as_cr_LETTERS='ABCDEFGHIJKLMNOPQRSTUVWXYZ'
+as_cr_Letters=$as_cr_letters$as_cr_LETTERS
+as_cr_digits='0123456789'
+as_cr_alnum=$as_cr_Letters$as_cr_digits
+
+ECHO_C= ECHO_N= ECHO_T=
+case `echo -n x` in #(((((
+-n*)
+  case `echo 'xy\c'` in
+  *c*) ECHO_T='	';;	# ECHO_T is single tab character.
+  xy)  ECHO_C='\c';;
+  *)   echo `echo ksh88 bug on AIX 6.1` > /dev/null
+       ECHO_T='	';;
+  esac;;
+*)
+  ECHO_N='-n';;
+esac
+
+rm -f conf$$ conf$$.exe conf$$.file
+if test -d conf$$.dir; then
+  rm -f conf$$.dir/conf$$.file
+else
+  rm -f conf$$.dir
+  mkdir conf$$.dir 2>/dev/null
+fi
+if (echo >conf$$.file) 2>/dev/null; then
+  if ln -s conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s='ln -s'
+    # ... but there are two gotchas:
+    # 1) On MSYS, both `ln -s file dir' and `ln file dir' fail.
+    # 2) DJGPP < 2.04 has no symlinks; `ln -s' creates a wrapper executable.
+    # In both cases, we have to default to `cp -p'.
+    ln -s conf$$.file conf$$.dir 2>/dev/null && test ! -f conf$$.exe ||
+      as_ln_s='cp -p'
+  elif ln conf$$.file conf$$ 2>/dev/null; then
+    as_ln_s=ln
+  else
+    as_ln_s='cp -p'
+  fi
+else
+  as_ln_s='cp -p'
+fi
+rm -f conf$$ conf$$.exe conf$$.dir/conf$$.file conf$$.file
+rmdir conf$$.dir 2>/dev/null
+
+
+# as_fn_mkdir_p
+# -------------
+# Create "$as_dir" as a directory, including parents if necessary.
+as_fn_mkdir_p ()
+{
+
+  case $as_dir in #(
+  -*) as_dir=./$as_dir;;
+  esac
+  test -d "$as_dir" || eval $as_mkdir_p || {
+    as_dirs=
+    while :; do
+      case $as_dir in #(
+      *\'*) as_qdir=`$as_echo "$as_dir" | sed "s/'/'\\\\\\\\''/g"`;; #'(
+      *) as_qdir=$as_dir;;
+      esac
+      as_dirs="'$as_qdir' $as_dirs"
+      as_dir=`$as_dirname -- "$as_dir" ||
+$as_expr X"$as_dir" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$as_dir" : 'X\(//\)[^/]' \| \
+	 X"$as_dir" : 'X\(//\)$' \| \
+	 X"$as_dir" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$as_dir" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      test -d "$as_dir" && break
+    done
+    test -z "$as_dirs" || eval "mkdir $as_dirs"
+  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+
+
+} # as_fn_mkdir_p
+if mkdir -p . 2>/dev/null; then
+  as_mkdir_p='mkdir -p "$as_dir"'
+else
+  test -d ./-p && rmdir ./-p
+  as_mkdir_p=false
+fi
+
+if test -x / >/dev/null 2>&1; then
+  as_test_x='test -x'
+else
+  if ls -dL / >/dev/null 2>&1; then
+    as_ls_L_option=L
+  else
+    as_ls_L_option=
+  fi
+  as_test_x='
+    eval sh -c '\''
+      if test -d "$1"; then
+	test -d "$1/.";
+      else
+	case $1 in #(
+	-*)set "./$1";;
+	esac;
+	case `ls -ld'$as_ls_L_option' "$1" 2>/dev/null` in #((
+	???[sx]*):;;*)false;;esac;fi
+    '\'' sh
+  '
+fi
+as_executable_p=$as_test_x
+
+# Sed expression to map a string onto a valid CPP name.
+as_tr_cpp="eval sed 'y%*$as_cr_letters%P$as_cr_LETTERS%;s%[^_$as_cr_alnum]%_%g'"
+
+# Sed expression to map a string onto a valid variable name.
+as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
+
+
+exec 6>&1
+## ----------------------------------- ##
+## Main body of $CONFIG_STATUS script. ##
+## ----------------------------------- ##
+_ASEOF
+test $as_write_fail = 0 && chmod +x $CONFIG_STATUS || ac_write_fail=1
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# Save the log message, to keep $0 and so on meaningful, and to
+# report actual input values of CONFIG_FILES etc. instead of their
+# values after options handling.
+ac_log="
+This file was extended by newlib $as_me 4.1.0, which was
+generated by GNU Autoconf 2.68.  Invocation command line was
+
+  CONFIG_FILES    = $CONFIG_FILES
+  CONFIG_HEADERS  = $CONFIG_HEADERS
+  CONFIG_LINKS    = $CONFIG_LINKS
+  CONFIG_COMMANDS = $CONFIG_COMMANDS
+  $ $0 $@
+
+on `(hostname || uname -n) 2>/dev/null | sed 1q`
+"
+
+_ACEOF
+
+case $ac_config_files in *"
+"*) set x $ac_config_files; shift; ac_config_files=$*;;
+esac
+
+
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+# Files that config.status was made for.
+config_files="$ac_config_files"
+config_commands="$ac_config_commands"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+ac_cs_usage="\
+\`$as_me' instantiates files and other configuration actions
+from templates according to the current configuration.  Unless the files
+and actions are specified as TAGs, all are instantiated by default.
+
+Usage: $0 [OPTION]... [TAG]...
+
+  -h, --help       print this help, then exit
+  -V, --version    print version number and configuration settings, then exit
+      --config     print configuration, then exit
+  -q, --quiet, --silent
+                   do not print progress messages
+  -d, --debug      don't remove temporary files
+      --recheck    update $as_me by reconfiguring in the same conditions
+      --file=FILE[:TEMPLATE]
+                   instantiate the configuration file FILE
+
+Configuration files:
+$config_files
+
+Configuration commands:
+$config_commands
+
+Report bugs to the package provider."
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ac_cs_version="\\
+newlib config.status 4.1.0
+configured by $0, generated by GNU Autoconf 2.68,
+  with options \\"\$ac_cs_config\\"
+
+Copyright (C) 2010 Free Software Foundation, Inc.
+This config.status script is free software; the Free Software Foundation
+gives unlimited permission to copy, distribute and modify it."
+
+ac_pwd='$ac_pwd'
+srcdir='$srcdir'
+INSTALL='$INSTALL'
+MKDIR_P='$MKDIR_P'
+AWK='$AWK'
+test -n "\$AWK" || AWK=awk
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# The default lists apply if the user does not specify any file.
+ac_need_defaults=:
+while test $# != 0
+do
+  case $1 in
+  --*=?*)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
+    ac_shift=:
+    ;;
+  --*=)
+    ac_option=`expr "X$1" : 'X\([^=]*\)='`
+    ac_optarg=
+    ac_shift=:
+    ;;
+  *)
+    ac_option=$1
+    ac_optarg=$2
+    ac_shift=shift
+    ;;
+  esac
+
+  case $ac_option in
+  # Handling of the options.
+  -recheck | --recheck | --rechec | --reche | --rech | --rec | --re | --r)
+    ac_cs_recheck=: ;;
+  --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
+    $as_echo "$ac_cs_version"; exit ;;
+  --config | --confi | --conf | --con | --co | --c )
+    $as_echo "$ac_cs_config"; exit ;;
+  --debug | --debu | --deb | --de | --d | -d )
+    debug=: ;;
+  --file | --fil | --fi | --f )
+    $ac_shift
+    case $ac_optarg in
+    *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
+    '') as_fn_error $? "missing file argument" ;;
+    esac
+    as_fn_append CONFIG_FILES " '$ac_optarg'"
+    ac_need_defaults=false;;
+  --he | --h |  --help | --hel | -h )
+    $as_echo "$ac_cs_usage"; exit ;;
+  -q | -quiet | --quiet | --quie | --qui | --qu | --q \
+  | -silent | --silent | --silen | --sile | --sil | --si | --s)
+    ac_cs_silent=: ;;
+
+  # This is an error.
+  -*) as_fn_error $? "unrecognized option: \`$1'
+Try \`$0 --help' for more information." ;;
+
+  *) as_fn_append ac_config_targets " $1"
+     ac_need_defaults=false ;;
+
+  esac
+  shift
+done
+
+ac_configure_extra_args=
+
+if $ac_cs_silent; then
+  exec 6>/dev/null
+  ac_configure_extra_args="$ac_configure_extra_args --silent"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+if \$ac_cs_recheck; then
+  set X '$SHELL' '$0' $ac_configure_args \$ac_configure_extra_args --no-create --no-recursion
+  shift
+  \$as_echo "running CONFIG_SHELL=$SHELL \$*" >&6
+  CONFIG_SHELL='$SHELL'
+  export CONFIG_SHELL
+  exec "\$@"
+fi
+
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+exec 5>>config.log
+{
+  echo
+  sed 'h;s/./-/g;s/^.../## /;s/...$/ ##/;p;x;p;x' <<_ASBOX
+## Running $as_me. ##
+_ASBOX
+  $as_echo "$ac_log"
+} >&5
+
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+#
+# INIT-COMMANDS
+#
+AMDEP_TRUE="$AMDEP_TRUE" ac_aux_dir="$ac_aux_dir"
+
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+
+# Handling of arguments.
+for ac_config_target in $ac_config_targets
+do
+  case $ac_config_target in
+    "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
+    "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
+
+  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  esac
+done
+
+
+# If the user did not use the arguments to specify the items to instantiate,
+# then the envvar interface is used.  Set only those that are not.
+# We use the long form for the default assignment because of an extremely
+# bizarre bug on SunOS 4.1.3.
+if $ac_need_defaults; then
+  test "${CONFIG_FILES+set}" = set || CONFIG_FILES=$config_files
+  test "${CONFIG_COMMANDS+set}" = set || CONFIG_COMMANDS=$config_commands
+fi
+
+# Have a temporary directory for convenience.  Make it in the build tree
+# simply because there is no reason against having it here, and in addition,
+# creating and moving files from /tmp can sometimes cause problems.
+# Hook for its removal unless debugging.
+# Note that there is a small window in which the directory will not be cleaned:
+# after its creation but before its name has been assigned to `$tmp'.
+$debug ||
+{
+  tmp= ac_tmp=
+  trap 'exit_status=$?
+  : "${ac_tmp:=$tmp}"
+  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+' 0
+  trap 'as_fn_exit 1' 1 2 13 15
+}
+# Create a (secure) tmp directory for tmp files.
+
+{
+  tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
+  test -d "$tmp"
+}  ||
+{
+  tmp=./conf$$-$RANDOM
+  (umask 077 && mkdir "$tmp")
+} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
+ac_tmp=$tmp
+
+# Set up the scripts for CONFIG_FILES section.
+# No need to generate them if there are no CONFIG_FILES.
+# This happens for instance with `./config.status config.h'.
+if test -n "$CONFIG_FILES"; then
+
+
+ac_cr=`echo X | tr X '\015'`
+# On cygwin, bash can eat \r inside `` if the user requested igncr.
+# But we know of no other shell where ac_cr would be empty at this
+# point, so we can use a bashism as a fallback.
+if test "x$ac_cr" = x; then
+  eval ac_cr=\$\'\\r\'
+fi
+ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
+if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
+  ac_cs_awk_cr='\\r'
+else
+  ac_cs_awk_cr=$ac_cr
+fi
+
+echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+_ACEOF
+
+
+{
+  echo "cat >conf$$subs.awk <<_ACEOF" &&
+  echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
+  echo "_ACEOF"
+} >conf$$subs.sh ||
+  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+ac_delim='%!_!# '
+for ac_last_try in false false false false false :; do
+  . ./conf$$subs.sh ||
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+
+  ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
+  if test $ac_delim_n = $ac_delim_num; then
+    break
+  elif $ac_last_try; then
+    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+  else
+    ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
+  fi
+done
+rm -f conf$$subs.sh
+
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+_ACEOF
+sed -n '
+h
+s/^/S["/; s/!.*/"]=/
+p
+g
+s/^[^!]*!//
+:repl
+t repl
+s/'"$ac_delim"'$//
+t delim
+:nl
+h
+s/\(.\{148\}\)..*/\1/
+t more1
+s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
+p
+n
+b repl
+:more1
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t nl
+:delim
+h
+s/\(.\{148\}\)..*/\1/
+t more2
+s/["\\]/\\&/g; s/^/"/; s/$/"/
+p
+b
+:more2
+s/["\\]/\\&/g; s/^/"/; s/$/"\\/
+p
+g
+s/.\{148\}//
+t delim
+' <conf$$subs.awk | sed '
+/^[^""]/{
+  N
+  s/\n//
+}
+' >>$CONFIG_STATUS || ac_write_fail=1
+rm -f conf$$subs.awk
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+_ACAWK
+cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+  for (key in S) S_is_set[key] = 1
+  FS = ""
+
+}
+{
+  line = $ 0
+  nfields = split(line, field, "@")
+  substed = 0
+  len = length(field[1])
+  for (i = 2; i < nfields; i++) {
+    key = field[i]
+    keylen = length(key)
+    if (S_is_set[key]) {
+      value = S[key]
+      line = substr(line, 1, len) "" value "" substr(line, len + keylen + 3)
+      len += length(value) + length(field[++i])
+      substed = 1
+    } else
+      len += 1 + keylen
+  }
+
+  print line
+}
+
+_ACAWK
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+if sed "s/$ac_cr//" < /dev/null > /dev/null 2>&1; then
+  sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
+else
+  cat
+fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
+  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+_ACEOF
+
+# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
+# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# trailing colons and then remove the whole line if VPATH becomes empty
+# (actually we leave an empty line to preserve line numbers).
+if test "x$srcdir" = x.; then
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
+h
+s///
+s/^/:/
+s/[	 ]*$/:/
+s/:\$(srcdir):/:/g
+s/:\${srcdir}:/:/g
+s/:@srcdir@:/:/g
+s/^:*//
+s/:*$//
+x
+s/\(=[	 ]*\).*/\1/
+G
+s/\n//
+s/^[^=]*=[	 ]*$//
+}'
+fi
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+fi # test -n "$CONFIG_FILES"
+
+
+eval set X "  :F $CONFIG_FILES      :C $CONFIG_COMMANDS"
+shift
+for ac_tag
+do
+  case $ac_tag in
+  :[FHLC]) ac_mode=$ac_tag; continue;;
+  esac
+  case $ac_mode$ac_tag in
+  :[FHL]*:*);;
+  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :[FH]-) ac_tag=-:-;;
+  :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
+  esac
+  ac_save_IFS=$IFS
+  IFS=:
+  set x $ac_tag
+  IFS=$ac_save_IFS
+  shift
+  ac_file=$1
+  shift
+
+  case $ac_mode in
+  :L) ac_source=$1;;
+  :[FH])
+    ac_file_inputs=
+    for ac_f
+    do
+      case $ac_f in
+      -) ac_f="$ac_tmp/stdin";;
+      *) # Look for the file first in the build tree, then in the source tree
+	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
+	 # because $ac_f cannot contain `:'.
+	 test -f "$ac_f" ||
+	   case $ac_f in
+	   [\\/$]*) false;;
+	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
+	   esac ||
+	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+      esac
+      case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
+      as_fn_append ac_file_inputs " '$ac_f'"
+    done
+
+    # Let's still pretend it is `configure' which instantiates (i.e., don't
+    # use $as_me), people would be surprised to read:
+    #    /* config.h.  Generated by config.status.  */
+    configure_input='Generated from '`
+	  $as_echo "$*" | sed 's|^[^:]*/||;s|:[^:]*/|, |g'
+	`' by configure.'
+    if test x"$ac_file" != x-; then
+      configure_input="$ac_file.  $configure_input"
+      { $as_echo "$as_me:${as_lineno-$LINENO}: creating $ac_file" >&5
+$as_echo "$as_me: creating $ac_file" >&6;}
+    fi
+    # Neutralize special characters interpreted by sed in replacement strings.
+    case $configure_input in #(
+    *\&* | *\|* | *\\* )
+       ac_sed_conf_input=`$as_echo "$configure_input" |
+       sed 's/[\\\\&|]/\\\\&/g'`;; #(
+    *) ac_sed_conf_input=$configure_input;;
+    esac
+
+    case $ac_tag in
+    *:-:* | *:-) cat >"$ac_tmp/stdin" \
+      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    esac
+    ;;
+  esac
+
+  ac_dir=`$as_dirname -- "$ac_file" ||
+$as_expr X"$ac_file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$ac_file" : 'X\(//\)[^/]' \| \
+	 X"$ac_file" : 'X\(//\)$' \| \
+	 X"$ac_file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$ac_file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+  as_dir="$ac_dir"; as_fn_mkdir_p
+  ac_builddir=.
+
+case "$ac_dir" in
+.) ac_dir_suffix= ac_top_builddir_sub=. ac_top_build_prefix= ;;
+*)
+  ac_dir_suffix=/`$as_echo "$ac_dir" | sed 's|^\.[\\/]||'`
+  # A ".." for each directory in $ac_dir_suffix.
+  ac_top_builddir_sub=`$as_echo "$ac_dir_suffix" | sed 's|/[^\\/]*|/..|g;s|/||'`
+  case $ac_top_builddir_sub in
+  "") ac_top_builddir_sub=. ac_top_build_prefix= ;;
+  *)  ac_top_build_prefix=$ac_top_builddir_sub/ ;;
+  esac ;;
+esac
+ac_abs_top_builddir=$ac_pwd
+ac_abs_builddir=$ac_pwd$ac_dir_suffix
+# for backward compatibility:
+ac_top_builddir=$ac_top_build_prefix
+
+case $srcdir in
+  .)  # We are building in place.
+    ac_srcdir=.
+    ac_top_srcdir=$ac_top_builddir_sub
+    ac_abs_top_srcdir=$ac_pwd ;;
+  [\\/]* | ?:[\\/]* )  # Absolute name.
+    ac_srcdir=$srcdir$ac_dir_suffix;
+    ac_top_srcdir=$srcdir
+    ac_abs_top_srcdir=$srcdir ;;
+  *) # Relative name.
+    ac_srcdir=$ac_top_build_prefix$srcdir$ac_dir_suffix
+    ac_top_srcdir=$ac_top_build_prefix$srcdir
+    ac_abs_top_srcdir=$ac_pwd/$srcdir ;;
+esac
+ac_abs_srcdir=$ac_abs_top_srcdir$ac_dir_suffix
+
+
+  case $ac_mode in
+  :F)
+  #
+  # CONFIG_FILE
+  #
+
+  case $INSTALL in
+  [\\/$]* | ?:[\\/]* ) ac_INSTALL=$INSTALL ;;
+  *) ac_INSTALL=$ac_top_build_prefix$INSTALL ;;
+  esac
+  ac_MKDIR_P=$MKDIR_P
+  case $MKDIR_P in
+  [\\/$]* | ?:[\\/]* ) ;;
+  */*) ac_MKDIR_P=$ac_top_build_prefix$MKDIR_P ;;
+  esac
+_ACEOF
+
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+# If the template does not know about datarootdir, expand it.
+# FIXME: This hack should be removed a few years after 2.60.
+ac_datarootdir_hack=; ac_datarootdir_seen=
+ac_sed_dataroot='
+/datarootdir/ {
+  p
+  q
+}
+/@datadir@/p
+/@docdir@/p
+/@infodir@/p
+/@localedir@/p
+/@mandir@/p'
+case `eval "sed -n \"\$ac_sed_dataroot\" $ac_file_inputs"` in
+*datarootdir*) ac_datarootdir_seen=yes;;
+*@datadir@*|*@docdir@*|*@infodir@*|*@localedir@*|*@mandir@*)
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&5
+$as_echo "$as_me: WARNING: $ac_file_inputs seems to ignore the --datarootdir setting" >&2;}
+_ACEOF
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+  ac_datarootdir_hack='
+  s&@datadir@&$datadir&g
+  s&@docdir@&$docdir&g
+  s&@infodir@&$infodir&g
+  s&@localedir@&$localedir&g
+  s&@mandir@&$mandir&g
+  s&\\\${datarootdir}&$datarootdir&g' ;;
+esac
+_ACEOF
+
+# Neutralize VPATH when `$srcdir' = `.'.
+# Shell code in configure.ac might set extrasub.
+# FIXME: do we really want to maintain this feature?
+cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+ac_sed_extra="$ac_vpsub
+$extrasub
+_ACEOF
+cat >>$CONFIG_STATUS <<\_ACEOF || ac_write_fail=1
+:t
+/@[a-zA-Z_][a-zA-Z_0-9]*@/!b
+s|@configure_input@|$ac_sed_conf_input|;t t
+s&@top_builddir@&$ac_top_builddir_sub&;t t
+s&@top_build_prefix@&$ac_top_build_prefix&;t t
+s&@srcdir@&$ac_srcdir&;t t
+s&@abs_srcdir@&$ac_abs_srcdir&;t t
+s&@top_srcdir@&$ac_top_srcdir&;t t
+s&@abs_top_srcdir@&$ac_abs_top_srcdir&;t t
+s&@builddir@&$ac_builddir&;t t
+s&@abs_builddir@&$ac_abs_builddir&;t t
+s&@abs_top_builddir@&$ac_abs_top_builddir&;t t
+s&@INSTALL@&$ac_INSTALL&;t t
+s&@MKDIR_P@&$ac_MKDIR_P&;t t
+$ac_datarootdir_hack
+"
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
+  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+
+test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
+      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&5
+$as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
+which seems to be undefined.  Please make sure it is defined" >&2;}
+
+  rm -f "$ac_tmp/stdin"
+  case $ac_file in
+  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
+  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  esac \
+  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+ ;;
+
+
+  :C)  { $as_echo "$as_me:${as_lineno-$LINENO}: executing $ac_file commands" >&5
+$as_echo "$as_me: executing $ac_file commands" >&6;}
+ ;;
+  esac
+
+
+  case $ac_file$ac_mode in
+    "depfiles":C) test x"$AMDEP_TRUE" != x"" || {
+  # Autoconf 2.62 quotes --file arguments for eval, but not when files
+  # are listed without --file.  Let's play safe and only enable the eval
+  # if we detect the quoting.
+  case $CONFIG_FILES in
+  *\'*) eval set x "$CONFIG_FILES" ;;
+  *)   set x $CONFIG_FILES ;;
+  esac
+  shift
+  for mf
+  do
+    # Strip MF so we end up with the name of the file.
+    mf=`echo "$mf" | sed -e 's/:.*$//'`
+    # Check whether this is an Automake generated Makefile or not.
+    # We used to match only the files named `Makefile.in', but
+    # some people rename them; so instead we look at the file content.
+    # Grep'ing the first line is not enough: some people post-process
+    # each Makefile.in and add a new line on top of each file to say so.
+    # Grep'ing the whole file is not good either: AIX grep has a line
+    # limit of 2048, but all sed's we know have understand at least 4000.
+    if sed -n 's,^#.*generated by automake.*,X,p' "$mf" | grep X >/dev/null 2>&1; then
+      dirpart=`$as_dirname -- "$mf" ||
+$as_expr X"$mf" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$mf" : 'X\(//\)[^/]' \| \
+	 X"$mf" : 'X\(//\)$' \| \
+	 X"$mf" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$mf" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+    else
+      continue
+    fi
+    # Extract the definition of DEPDIR, am__include, and am__quote
+    # from the Makefile without running `make'.
+    DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
+    test -z "$DEPDIR" && continue
+    am__include=`sed -n 's/^am__include = //p' < "$mf"`
+    test -z "am__include" && continue
+    am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
+    # When using ansi2knr, U may be empty or an underscore; expand it
+    U=`sed -n 's/^U = //p' < "$mf"`
+    # Find all dependency output files, they are included files with
+    # $(DEPDIR) in their names.  We invoke sed twice because it is the
+    # simplest approach to changing $(DEPDIR) to its actual value in the
+    # expansion.
+    for file in `sed -n "
+      s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+      # Make sure the directory exists.
+      test -f "$dirpart/$file" && continue
+      fdir=`$as_dirname -- "$file" ||
+$as_expr X"$file" : 'X\(.*[^/]\)//*[^/][^/]*/*$' \| \
+	 X"$file" : 'X\(//\)[^/]' \| \
+	 X"$file" : 'X\(//\)$' \| \
+	 X"$file" : 'X\(/\)' \| . 2>/dev/null ||
+$as_echo X"$file" |
+    sed '/^X\(.*[^/]\)\/\/*[^/][^/]*\/*$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)[^/].*/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\/\)$/{
+	    s//\1/
+	    q
+	  }
+	  /^X\(\/\).*/{
+	    s//\1/
+	    q
+	  }
+	  s/.*/./; q'`
+      as_dir=$dirpart/$fdir; as_fn_mkdir_p
+      # echo "creating $dirpart/$file"
+      echo '# dummy' > "$dirpart/$file"
+    done
+  done
+}
+ ;;
+
+  esac
+done # for ac_tag
+
+
+as_fn_exit 0
+_ACEOF
+ac_clean_files=$ac_clean_files_save
+
+test $ac_write_fail = 0 ||
+  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+
+
+# configure is writing to config.log, and then calls config.status.
+# config.status does its own redirection, appending to config.log.
+# Unfortunately, on DOS this fails, as config.log is still kept open
+# by configure, so config.status won't be able to write to it; its
+# output is simply discarded.  So we exec the FD to /dev/null,
+# effectively closing config.log, so it can be properly (re)opened and
+# appended to by config.status.  When coming back to configure, we
+# need to make the FD available again.
+if test "$no_create" != yes; then
+  ac_cs_success=:
+  ac_config_status_args=
+  test "$silent" = yes &&
+    ac_config_status_args="$ac_config_status_args --quiet"
+  exec 5>/dev/null
+  $SHELL $CONFIG_STATUS $ac_config_status_args || ac_cs_success=false
+  exec 5>>config.log
+  # Use ||, not &&, to avoid exiting from the if with $? = 1, which
+  # would make configure fail if this is the last instruction.
+  $ac_cs_success || as_fn_exit 1
+fi
+if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
+$as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2;}
+fi
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure.rej third_party/newlib-4.1.0/newlib/libc/sys/arm/configure.rej
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/configure.rej	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/configure.rej	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,65 @@
+--- newlib/libc/sys/arm/configure	2020-01-02 19:56:24.000000000 +0000
++++ newlib/libc/sys/arm/configure	2022-06-29 14:50:02.721940993 +0100
+@@ -1,13 +1,11 @@
+ #! /bin/sh
+ # Guess values for system-dependent variables and create Makefiles.
+-# Generated by GNU Autoconf 2.68 for newlib 3.2.0.
+-#
++# Generated by GNU Autoconf 2.64 for newlib 3.2.0.
+ #
+ # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
+-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
++# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
+ # Foundation, Inc.
+ #
+-#
+ # This configure script is free software; the Free Software Foundation
+ # gives unlimited permission to copy, distribute and modify it.
+ ## -------------------- ##
+@@ -1396,9 +1387,9 @@
+ if $ac_init_version; then
+   cat <<\_ACEOF
+ newlib configure 3.2.0
+-generated by GNU Autoconf 2.68
++generated by GNU Autoconf 2.64
+ 
+-Copyright (C) 2010 Free Software Foundation, Inc.
++Copyright (C) 2009 Free Software Foundation, Inc.
+ This configure script is free software; the Free Software Foundation
+ gives unlimited permission to copy, distribute and modify it.
+ _ACEOF
+@@ -1451,7 +1442,7 @@
+ running configure, to aid debugging if configure makes a mistake.
+ 
+ It was created by newlib $as_me 3.2.0, which was
+-generated by GNU Autoconf 2.68.  Invocation command line was
++generated by GNU Autoconf 2.64.  Invocation command line was
+ 
+   $ $0 $@
+ 
+@@ -4022,7 +4016,7 @@
+ # values after options handling.
+ ac_log="
+ This file was extended by newlib $as_me 3.2.0, which was
+-generated by GNU Autoconf 2.68.  Invocation command line was
++generated by GNU Autoconf 2.64.  Invocation command line was
+ 
+   CONFIG_FILES    = $CONFIG_FILES
+   CONFIG_HEADERS  = $CONFIG_HEADERS
+@@ -4075,13 +4068,12 @@
+ 
+ _ACEOF
+ cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
+-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
+ ac_cs_version="\\
+ newlib config.status 3.2.0
+-configured by $0, generated by GNU Autoconf 2.68,
+-  with options \\"\$ac_cs_config\\"
++configured by $0, generated by GNU Autoconf 2.64,
++  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
+ 
+-Copyright (C) 2010 Free Software Foundation, Inc.
++Copyright (C) 2009 Free Software Foundation, Inc.
+ This config.status script is free software; the Free Software Foundation
+ gives unlimited permission to copy, distribute and modify it."
+ 
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/creat.c third_party/newlib-4.1.0/newlib/libc/sys/arm/creat.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/creat.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/creat.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,12 @@
+#include <fcntl.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int creat (const char *path, mode_t mode)
+{
+    return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/crt0.S third_party/newlib-4.1.0/newlib/libc/sys/arm/crt0.S
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/crt0.S	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/crt0.S	2024-03-17 17:47:03.411194527 +0000
@@ -1,6 +1,7 @@
 #include "newlib.h"
 #include "arm.h"
-#include "swi.h"
+
+.extern environ
 
 /* ANSI concatenation macros.  */
 #define CONCAT(a, b) CONCAT2(a, b)
@@ -12,6 +13,7 @@
 #error __USER_LABEL_PREFIX is not defined
 #endif
 
+
 #ifdef HAVE_INITFINI_ARRAY
 #define _init	__libc_init_array
 #define _fini	__libc_fini_array
@@ -41,38 +43,25 @@
 #endif
 #endif
 
+
+
 /* .text is used instead of .section .text so it works with arm-aout too.  */
 	.text
 	.syntax unified
-#ifdef PREFER_THUMB
+#ifdef THUMB_V7_V6M
 	.thumb
 .macro FUNC_START name
 	.global \name
 	.thumb_func
 \name:
-.endm
+.endm	
 #else
 	.code 32
 .macro FUNC_START name
-	.global \name
+	.global	\name
 \name:
-.endm
-#endif
-
-/* Annotation for EABI unwinding tables.  */
-.macro FN_EH_START
-#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
-	.fnstart
+.endm	
 #endif
-.endm
-
-.macro FN_EH_END
-#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
-	/* Protect against unhandled exceptions.  */
-	.cantunwind
-	.fnend
-#endif
-.endm
 
 .macro indirect_call reg
 #ifdef HAVE_CALL_INDIRECT
@@ -83,552 +72,74 @@
 #endif
 .endm
 
-/* For armv4t and newer, toolchains will transparently convert
-   'bx lr' to 'mov pc, lr' if needed. GCC has deprecated support
-   for anything older than armv4t, but this should handle that
-   corner case in case anyone needs it anyway.  */
-.macro  FN_RETURN
-#if __ARM_ARCH <= 4 && __ARM_ARCH_ISA_THUMB == 0
-	mov	pc, lr
-#else
-	bx	lr
-#endif
-.endm
 
 
 
-/******************************************************************************
-* User mode only:           This routine makes default target specific Stack
-*   +-----+ <- SL_sys,    Pointer initialization for different processor modes:
-*   |     |    SL_usr     FIQ, Abort, IRQ, Undefined, Supervisor, System (User)
-*   | SYS |               and setups a default Stack Limit in-case the code has
-*   | USR | -=0x10000     been compiled with "-mapcs-stack-check" for FIQ and
-*   |     |               System (User) modes.
-*   |     |
-*   +-----+ <- initial SP,
-*           becomes SP_sys   Hard-wiring SL value is not ideal, since there is
-*           and SL_usr     currently no support for checking that the heap and
-*                          stack have not collided, or that this default 64k is
-* All modes:               is enough for the program being executed. However,
-*   +-----+ <- SL_sys,     it ensures that this simple crt0 world will not
-*   |     |    SL_usr      immediately cause an overflow event.
-*   | SYS |
-*   | USR | -=0x10000        We go through all execution modes and set up SP
-*   |     |                for each of them.
-*   +-----+ <- SP_sys,
-*   |     |    SP_usr      Notes:
-*   | SVC | -= 0x8000       - This code will not work as intended if the system
-*   |     |                   starts in secure mode. In particular the methods
-*   +-----+ <- SP_svc         of getting in and out of secure state are not as
-*   |     |                   simple as writing to the CPSR mode bits.
-*   | IRQ | -= 0x2000       - Mode switch via CPSR is not allowed once in
-*   |     |                   non-privileged mode, so we take care not to enter
-* ^ +-----+ <- SP_und         "User" to set up its SP, and also skip most
-* s |     |                   operations if already in that mode.
-* t | UND | -= 0x1000
-* a |     |                Input parameters:
-* c +-----+ <- SP_und       - sp - Initialized SP
-* k |     |                 - r2 - May contain SL value from semihosting
-*   | ABT | -= 0x1000              SYS_HEAPINFO call
-* g |     |                Scratch registers:
-* r +-----+ <- SP_abt,      - r1 - new value of CPSR
-* o |     |    SL_fiq       - r2 - intermediate value (in standalone mode)
-* w | FIQ | -= 0x1000       - r3 - new SP value
-* t |     |                 - r4 - save/restore CPSR on entry/exit
-* h +-----+ <- initial SP,
-*           becomes SP_fiq   Declared as "weak" so that user can write and use
-*                          his own implementation if current doesn't fit.
-*
-******************************************************************************/
-	.align	0
-	FUNC_START	_stack_init
-	.weak FUNCTION (_stack_init)
-	FN_EH_START
-
-	/* M profile doesn't have CPSR register.  */
-#if (__ARM_ARCH_PROFILE != 'M')
-	/* Following code is compatible for both ARM and Thumb ISA.  */
-	mrs	r4, CPSR
-	/* Test mode bits - in User of all are 0.  */
-	tst	r4, #(CPSR_M_MASK)
-	/* "eq" means r4 AND #0x0F is 0.  */
-	beq	.Lskip_cpu_modes
-
-	mov	r3, sp /* Save input SP value.  */
-
-	/* FIQ mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_FIQ|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	sl, sp, #0x1000	/* FIQ mode has its own SL.  */
-
-	/* Abort mode, interrupts disabled.  */
-	mov	r3, sl
-	mov	r1, #(CPSR_M_ABT|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x1000
-
-	/* Undefined mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_UND|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x1000
-
-	/* IRQ mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_IRQ|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x2000
-
-	/* Supervisory mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_SVR|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-
-	sub	r3, r3, #0x8000	/* Min size 32k.  */
-	bic	r3, r3, #0x00FF	/* Align with current 64k block.  */
-	bic	r3, r3, #0xFF00
-
-# if __ARM_ARCH >= 4
-	/* System (shares regs with User) mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_SYS|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-# else
-	/* Keep this for ARMv3, but GCC actually dropped it.  */
-	/* Move value into user mode SP without changing modes,  */
-	/* via '^' form of ldm.  */
-	str	r3, [r3, #-4]
-	ldmdb	r3, {sp}^
-# endif
-
-	/* Back to original mode, presumably SVC, with diabled FIQ/IRQ.  */
-	orr	r4, r4, #(CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r4
 
-.Lskip_cpu_modes:
-#endif
-
-	/* Set SL register.  */
-#if defined (ARM_RDI_MONITOR) /* semihosting */
-	cmp	r2, #0
-	beq	.Lsl_forced_zero
-	/* Allow slop for stack overflow handling and small frames.  */
-# ifdef THUMB1_ONLY
-	adds	r2, #128
-	adds	r2, #128
-	mov	sl, r2
-# else
-	add	sl, r2, #256
-# endif
-.Lsl_forced_zero:
-
-#else /* standalone */
-	/* r3 contains SP for System/User mode. Set SL = SP - 0x10000.  */
-	#ifdef THUMB1_ONLY
-	movs	r2, #64
-	lsls	r2, r2, #10
-	subs	r2, r3, r2
-	mov	sl, r2
-	#else
-	/* Still assumes 256bytes below SL.  */
-	sub	sl, r3, #64 << 10
-	#endif
-#endif
-
-	FN_RETURN
-	FN_EH_END
 
+.balign 	16
 
-/*******************************************************************************
-* Main library startup code.
-*******************************************************************************/
-	.align 	0
 	FUNC_START	_mainCRTStartup
 	FUNC_START	_start
-	FN_EH_START
+	FUNC_START	start
 
-/* Start by setting up a stack.  */
-#ifdef ARM_RDP_MONITOR
-	/*  Issue Demon SWI to read stack info.  */
-	swi	SWI_GetEnv	/*  Returns command line in r0.  */
-	mov	sp,r1		/*  and the highest memory address in r1.  */
-
-	/*  Stack limit is at end of data.  */
-	/*  Allow slop for stack overflow handling and small frames.  */
-#ifdef THUMB1_ONLY
-	ldr	r0, .LC2
-	adds	r0, #128
-	adds	r0, #128
-	mov	sl, r0
-#else
-	ldr	sl, .LC2
-	add	sl, sl, #256
-#endif
-#else
-#ifdef ARM_RDI_MONITOR
-	/*  Issue Angel SWI to read stack info.  */
-	movs	r0, #AngelSWI_Reason_HeapInfo
-	adr	r1, .LC0	/*  Point at ptr to 4 words to receive data.  */
-#ifdef THUMB_VXM
-	bkpt	AngelSWI
-#elif defined(__thumb2__)
-	/*  We are in thumb mode for startup on armv7 architectures.  */
-	AngelSWIAsm	AngelSWI
-#else
-	/*  We are always in ARM mode for startup on pre armv7 archs.  */
-	AngelSWIAsm	AngelSWI_ARM
-#endif
-	ldr	r0, .LC0	/*  Point at values read.  */
-
-	/* Set __heap_limit.  */
-	ldr     r1, [r0, #4]
-	cmp     r1, #0
-	beq     .LC33
-	ldr     r2, =__heap_limit
-	str     r1, [r2]
-.LC33:
-	ldr     r1, [r0, #0]
-	cmp     r1, #0
-	bne     .LC32
-	/* If the heap base value [r0, #0] is 0 then the heap base is actually 
-	   at the end of program data (i.e. __end__). See:
-           http://infocenter.arm.com/help/topic/com.arm.doc.dui0471-/Bacbefaa.html
-	   for more information.  */
-	ldr     r1, .LC31
-	str     r1, [r0, #0]
-.LC32:	
-	ldr	r1, [r0, #8]
-	ldr	r2, [r0, #12]
-	/*  We skip setting SP/SL if 0 returned from semihosting.
-	    - According to semihosting docs, if 0 returned from semihosting,
-	      the system was unable to calculate the real value, so it's ok
-	      to skip setting SP/SL to 0 here.
-	    - Considering M-profile processors, We might want to initialize
-	      SP by the first entry of vector table and return 0 to SYS_HEAPINFO
-	      semihosting call, which will be skipped here.
-	    - Considering R-profile processors there is no automatic SP init by hardware
-	      so we need to initialize it by default value.  */
-	ldr	r3, .Lstack
-	cmp	r1, #0
-	beq	.LC26
-	mov	r3, r1
-.LC26:
-	mov	sp, r3
-
-	/* r2 (SL value) will be used in _stack_init.  */
-	bl FUNCTION (_stack_init)
-
-
-#else /* standalone */
-	/*  Set up the stack pointer to a fixed value. */
-	/*  Changes by toralf:
-	    - Allow linker script to provide stack via __stack symbol - see
-	      defintion of .Lstack
-	    - Provide "hooks" that may be used by the application to add
-	      custom init code - see .Lhwinit and .Lswinit.  */
-
-	ldr	r3, .Lstack
-	cmp	r3, #0
-#ifdef __thumb2__
-	it	eq
-#endif	
-#ifdef THUMB1_ONLY
-	bne	.LC28
-	ldr	r3, .LC0
-.LC28:
-#else
-	ldreq	r3, .LC0
-#endif
-	/* Note: This 'mov' is essential when starting in User, and ensures we
-		 always get *some* SP value for the initial mode, even if we
-		 have somehow missed it below (in which case it gets the same
-		 value as FIQ - not ideal, but better than nothing).  */
-	mov	sp, r3
+// r0 argc
+// r1 argv
+// r2 envc
+// r3 envv
 
-	/* We don't care of r2 value in standalone.  */
-	bl FUNCTION (_stack_init)
+    ldr r4, =environ
+    str r3, [r4]
 
+#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+	/* Annotation for EABI unwinding tables.  */
+	.fnstart
 #endif
-#endif
-	/* Zero the memory in the .bss section.  */
-	movs 	a2, #0			/* Second arg: fill value.  */
-	mov	fp, a2			/* Null frame pointer.  */
-	mov	r7, a2			/* Null frame pointer for Thumb.  */
-	
-	ldr	a1, .LC1		/* First arg: start of memory block.  */
-	ldr	a3, .LC2	
-	subs	a3, a3, a1		/* Third arg: length of block.  */
-	
-
-#if __thumb__ && !defined(PREFER_THUMB)
-	/* Enter Thumb mode...  */
-	add	a4, pc, #1	/* Get the address of the Thumb block.  */
-	bx	a4		/* Go there and start Thumb decoding.  */
 
-	.code 16
-	.global __change_mode
-	.thumb_func
-__change_mode:	
-#endif
-	
-	bl	FUNCTION (memset)
-#if !defined (ARM_RDP_MONITOR) && !defined (ARM_RDI_MONITOR)
-/* Changes by toralf: Taken from libgloss/m68k/crt0.S
-   initialize target specific stuff. Only execute these
-   functions it they exist.  */
-	ldr	r3, .Lhwinit
-	cmp	r3, #0
-	beq	.LC24
-	indirect_call r3
-.LC24:	
-	ldr	r3, .Lswinit
-	cmp	r3, #0
-	beq	.LC25
-	indirect_call r3
-
-.LC25:	
-	movs	r0, #0		/* No arguments.  */
-	movs	r1, #0		/* No argv either.  */
-#else
-	/* Need to set up standard file handles.  */
-	bl	FUNCTION (initialise_monitor_handles)
-	
-#ifdef ARM_RDP_MONITOR
-	swi	SWI_GetEnv	/* Sets r0 to point to the command line.  */
-	movs	r1, r0
-#else
-	movs	r0, #AngelSWI_Reason_GetCmdLine
-	ldr	r1, .LC30	/* Space for command line.  */
-#ifdef THUMB_VXM
-	bkpt	AngelSWI
-#else
- 	AngelSWIAsm	AngelSWI
-#endif
-	ldr	r1, .LC30
-	ldr	r1, [r1]
-#endif
-	/*  Parse string at r1.  */
-	movs	r0, #0		/* Count of arguments so far.  */
-	/* Push a NULL argument onto the end of the list.  */
-#ifdef __thumb__
-	push	{r0}
-#else
-	stmfd	sp!, {r0}
-#endif
-.LC10:
-/*  Skip leading blanks.  */
-#ifdef __thumb__
-	ldrb	r3, [r1]
-	adds	r1, #1
-#else
-	ldrb	r3, [r1], #1
-#endif
-	cmp	r3, #0
-	beq	.LC12
-	cmp	r3, #' '
-	beq	.LC10
-
-/* See whether we are scanning a string.  */
-	cmp	r3, #'\"'
-#ifdef __thumb__
-	beq	.LC20
-	cmp	r3, #'\''
-	bne	.LC21
-.LC20:
-	movs	r2, r3
-	b	.LC22
-
-.LC21:
-	movs	r2, #' '	/* Terminator type.  */
-	subs	r1, r1, #1	/* Adjust back to point at start char.  */
-.LC22:
-#else
-	cmpne	r3, #'\''
-	moveq	r2, r3
-	movne	r2, #' '	/* Terminator type.  */
-	subne	r1, r1, #1	/* Adjust back to point at start char.  */
-#endif
 
-/*  Stack a pointer to the current argument.  */
-#ifdef __thumb__
-	push	{r1}
-#else
-	stmfd	sp!, {r1}
-#endif
-	adds	r0, r0, #1
-.LC11:
-#ifdef __thumb__
-	ldrb	r3, [r1]
-	adds	r1, #1
-#else
-	ldrb	r3, [r1], #1
-#endif
-	cmp	r3, #0
-	beq	.LC12
-	cmp	r2, r3		/* Reached terminator ?  */
-	bne	.LC11
-	movs	r2, #0
-	subs	r3, r1, #1
-	strb	r2, [r3]	/* Terminate the arg string.  */
-	b	.LC10
-
-.LC12:
-	mov	r1, sp		/* Point at stacked arg pointers.  */
-	/* We've now got the stacked args in order, reverse them.  */
-#ifdef __thumb__
-	movs	r2, r0
-	lsls	r2, #2
-	add	r2, sp
-	mov	r3, sp
-.LC15:	cmp	r2, r3
-	bls	.LC14
-	subs	r2, #4
-	ldr	r4, [r2]
-	ldr	r5, [r3]
-	str	r5, [r2]
-	str	r4, [r3]
-	adds	r3, #4
-	b	.LC15
-.LC14:	
-	/* Ensure doubleword stack alignment.  */
-	mov	r4, sp
-	movs	r5, #7
-	bics	r4, r5
-	mov	sp, r4
-#else
-	add	r2, sp, r0, LSL #2	/* End of args.  */
-	mov	r3, sp			/* Start of args.  */
-.LC13:	cmp	r2, r3
-	ldrhi	r4,[r2, #-4]		/* Reverse ends of list.  */
-	ldrhi	r5, [r3]
-	strhi	r5, [r2, #-4]!
-	strhi	r4, [r3], #4
-	bhi	.LC13
-	/* Ensure doubleword stack alignment.  */
-	bic	sp, sp, #7
-#endif
-#endif
+// FIXME:  Assumes bss/common is clear.
 
 #ifdef __USES_INITFINI__
-	/* Some arm/elf targets use the .init and .fini sections
-	   to create constructors and destructors, and for these
-	   targets we need to call the _init function and arrange
-	   for _fini to be called at program exit.  */
 	movs	r4, r0
 	movs	r5, r1
-#ifdef _LITE_EXIT
-	/* Make reference to atexit weak to avoid unconditionally pulling in
-	   support code.  Refer to comments in __atexit.c for more details.  */
-	.weak	FUNCTION(atexit)
-	ldr	r0, .Latexit
-	cmp	r0, #0
-	beq	.Lweak_atexit
-#endif
 	ldr	r0, .Lfini
 	bl	FUNCTION (atexit)
-.Lweak_atexit:
 	bl	FUNCTION (_init)
 	movs	r0, r4
 	movs	r1, r5
-#endif
+#endif	
 	bl	FUNCTION (main)
-
 	bl	FUNCTION (exit)		/* Should not return.  */
 
-#if __thumb__ && !defined(PREFER_THUMB)
-	/* Come out of Thumb mode.  This code should be redundant.  */
-	mov	a4, pc
-	bx	a4
 
-	.code 32
-	.global change_back
-change_back:
-	/* Halt the execution.  This code should never be executed.  */
-	/* With no debug monitor, this probably aborts (eventually).
-	   With a Demon debug monitor, this halts cleanly.
-	   With an Angel debug monitor, this will report 'Unknown SWI'.  */
-	swi	SWI_Exit
-#endif
-	
-	FN_EH_END
 
-	/* For Thumb, constants must be after the code since only 
-	   positive offsets are supported for PC relative addresses.  */
-	.align 0
-.LC0:
-#ifdef ARM_RDI_MONITOR
-	.word	HeapBase
-#else
-#ifndef ARM_RDP_MONITOR
-	/* Changes by toralf: Provide alternative "stack" variable whose value
-	   may be defined externally; .Lstack will be used instead of .LC0 if
-	   it points to a non-0 value. Also set up references to "hooks" that
-           may be used by the application to provide additional init code.  */
-#ifdef __pe__
-	.word	0x800000
-#else
-	.word	0x80000			/* Top of RAM on the PIE board.  */
-#endif
-.Lhwinit:	
-	.word	FUNCTION (hardware_init_hook)
-.Lswinit:
-	.word	FUNCTION (software_init_hook)
-
-	/* Set up defaults for the above variables in the form of weak symbols
-	   - so that application will link correctly, and get value 0 in
-	   runtime (meaning "ignore setting") for the variables, when the user
-	   does not provide the symbols. (The linker uses a weak symbol if,
-	   and only if, a normal version of the same symbol isn't provided
-	   e.g. by a linker script or another object file.)  */
 
-	.weak FUNCTION (hardware_init_hook) 
-	.weak FUNCTION (software_init_hook)
-#endif
-	
+
+
+
+
+
+.balign 16
+
+
+#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+	/* Protect against unhandled exceptions.  */
+	.cantunwind
+	.fnend
 #endif
 
-.Lstack:
-	.word	__stack
-	.weak	__stack
 
 .LC1:
 	.word	__bss_start__
 .LC2:
 	.word	__bss_end__
-#ifdef __USES_INITFINI__
-#ifdef _LITE_EXIT
-.Latexit:
-	.word	FUNCTION(atexit)
 
-	/* Weak reference _fini in case of lite exit.  */
-	.weak	FUNCTION(_fini)
-#endif
+
+#ifdef __USES_INITFINI__
 .Lfini:
 	.word	FUNCTION(_fini)
 #endif
-#ifdef ARM_RDI_MONITOR
-.LC30:
-	.word	AngelSWIArgs
-.LC31:
-	.word	__end__
-
-/*  Workspace for Angel calls.  */
-	.data
-/*  Data returned by monitor SWI.  */
-.global	__stack_base__
-HeapBase:	.word	0
-HeapLimit:	.word	0
-__stack_base__:	.word	0
-StackLimit:	.word	0
-CommandLine:	.space	256,0	/*  Maximum length of 255 chars handled.  */
-AngelSWIArgs:
-	.word	CommandLine
-	.word	255
-#endif
-	
-#ifdef __pe__
-	.section .idata$3
-	.long	0,0,0,0,0,0,0,0
-#endif
+
+
+.balign 16
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/debug.c third_party/newlib-4.1.0/newlib/libc/sys/arm/debug.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/debug.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,31 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/debug.h>
+#include <stdarg.h>
+#include <string.h>
+
+uint32_t canary1 = 0xdeadbeef;
+static char __klog_buf[100];
+uint32_t canary2 = 0xdeadbeef;
+
+/*
+ *
+ */
+void debug_printf(const char *format, ...) {
+    va_list ap;
+
+		if (canary1 != 0xdeadbeef || canary2 != 0xdeadbeef) {
+			_swi_debug("** debug_printf canary trampled **");
+			exit(-1);
+		}
+
+    va_start(ap, format);
+
+    vsnprintf(__klog_buf, sizeof __klog_buf - 10, format, ap);
+    _swi_debug(__klog_buf);
+
+    va_end(ap);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/dir.c third_party/newlib-4.1.0/newlib/libc/sys/arm/dir.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/dir.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,104 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+#include <sys/param.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+char *getwd (char *__buf )
+{
+    return getcwd (__buf, MAXPATHLEN);
+}
+
+/*
+ *
+ */
+int chroot(const char *path)
+{
+    int sc;
+    
+    sc = _swi_chroot(path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int chdir (const char *path)
+{
+    int sc;
+    
+    sc = _swi_chdir(path);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return 0;
+}
+
+/*
+ *
+ */
+int fchdir (int fd)
+{
+    int sc;
+    
+    sc = _swi_fchdir (fd);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	  return 0;
+}
+
+/*
+ *
+ */
+int mkdir (const char *path, mode_t mode)
+{
+    int sc;
+    
+    sc = _swi_mkdir (path, mode);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	  return 0;
+}
+
+/*
+ *
+ */
+int rmdir (const char *path)
+{
+    int sc;
+    
+    sc = _swi_rmdir (path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	  return 0;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/dirname.c third_party/newlib-4.1.0/newlib/libc/sys/arm/dirname.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/dirname.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/dirname.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,37 @@
+#ifndef _NO_DIRNAME
+
+/* Copyright 2005 Shaun Jackman
+ * Permission to use, copy, modify, and distribute this software
+ * is freely granted, provided that this notice is preserved.
+ */
+
+#include <libgen.h>
+#include <string.h>
+
+char *
+_DEFUN (dirname, (path),
+	char *path)
+{
+	char *p;
+	if( path == NULL || *path == '\0' ) {
+		return ".";
+	}
+	
+	p = path + strlen(path) - 1;
+	
+	while( *p == '/' ) {
+		if( p == path ) {
+			return path;
+		}
+		
+		*p-- = '\0';
+	}
+	
+	while( p >= path && *p != '/' ) {
+		p--;
+  }
+  
+	return p < path ? "." : p == path ? "/" : (*p = '\0', path);
+}
+
+#endif /* !_NO_DIRNAME  */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/dup.c third_party/newlib-4.1.0/newlib/libc/sys/arm/dup.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/dup.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/dup.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,37 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int dup(int fd) {
+    int dfd;
+
+    dfd = _swi_dup(fd);
+    if (dfd < 0) {
+        errno = -dfd;
+        return -1;
+    }
+
+    return dfd;
+}
+
+/*
+ *
+ */
+int dup2(int fd1, int fd2) {
+    int dfd;
+
+    dfd = _swi_dup2(fd1, fd2);
+    if (dfd < 0) {
+        errno = -dfd;
+        return -1;
+    }
+
+    return dfd;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/environ.c third_party/newlib-4.1.0/newlib/libc/sys/arm/environ.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/environ.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/environ.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,9 @@
+/*
+ * Version of environ for no OS.
+ */
+
+char *__env[1] = { 0 }; 
+char **environ = __env;
+int __argc = 0;
+char **__argv;
+int __envc = 0;
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/err.c third_party/newlib-4.1.0/newlib/libc/sys/arm/err.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/err.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/err.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,7 @@
+
+void err (int c, char *str)
+{
+}
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/errx.c third_party/newlib-4.1.0/newlib/libc/sys/arm/errx.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/errx.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/errx.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,63 @@
+/*	$NetBSD: errx.c,v 1.14 2007/06/18 14:13:54 ginsbach Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: errx.c,v 1.14 2007/06/18 14:13:54 ginsbach Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+
+#ifdef __weak_alias
+__weak_alias(errx, _errx)
+#endif
+
+#if !HAVE_ERR_H
+__dead void
+errx(int eval, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	verrx(eval, fmt, ap);
+	va_end(ap);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execl.c third_party/newlib-4.1.0/newlib/libc/sys/arm/execl.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execl.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/execl.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,34 @@
+/* execl.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+
+/* Only deal with a pointer to environ, to work around subtle bugs with shared
+   libraries and/or small data systems where the user declares his own
+   'environ'.  */
+static char ***p_environ = &environ;
+
+
+#include <stdarg.h>
+
+int execl (const char *path, const char *arg0, ...)
+{
+    int i;
+    va_list args;
+    const char *argv[256];
+
+    va_start (args, arg0);
+    argv[0] = arg0;
+    i = 1;
+
+    do {
+        argv[i] = va_arg (args, char *);
+    } while (argv[i++] != NULL);
+
+    va_end (args);
+
+    return execve (path, (char * const  *) argv, *p_environ);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execle.c third_party/newlib-4.1.0/newlib/libc/sys/arm/execle.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execle.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/execle.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,33 @@
+/* execle.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+/*
+ *
+ */
+int execle (const char *path, const char *arg0, ...)
+{
+    int i;
+    va_list args;
+    const char * const *envp;
+    const char *argv[256];
+
+    va_start (args, arg0);
+    argv[0] = arg0;
+    i = 1;
+
+    do {
+       argv[i] = va_arg (args, const char *);
+    } while (argv[i++] != NULL);
+
+    envp = va_arg (args, const char * const *);
+    va_end (args);
+
+    return execve (path, (char * const *) argv, (char * const *) envp);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execlp.c third_party/newlib-4.1.0/newlib/libc/sys/arm/execlp.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execlp.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/execlp.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,31 @@
+/* execlp.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+
+/*
+ *
+ */
+int execlp (const char *path, const char *arg0, ...)
+{
+    int i;
+    va_list args;
+    const char *argv[256];
+
+    va_start (args, arg0);
+    argv[0] = arg0;
+    i = 1;
+
+    do {
+        argv[i] = va_arg (args, const char *);
+    } while (argv[i++] != NULL);
+
+    va_end (args);
+
+    return execvp (path, (char * const *) argv);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execv.c third_party/newlib-4.1.0/newlib/libc/sys/arm/execv.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execv.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/execv.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,17 @@
+#include <_ansi.h>
+#include <unistd.h>
+
+/*
+ *
+ */
+static char ***p_environ = &environ;
+
+
+/*
+ *
+ */
+int execv (const char *path, char * const argv[])
+{
+    return execve (path, (char **) argv, *p_environ);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execve.c third_party/newlib-4.1.0/newlib/libc/sys/arm/execve.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execve.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/execve.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,43 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/unistd.h>
+#include <sys/execargs.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+/*
+ *
+ */ 
+int execve (const char *__path, char * const __argv[], char * const __envp[] )
+{
+    struct execargs args;
+    int argc = 0;
+    int envc = 0;
+    int sc;
+    
+    if (__argv != NULL) {
+        for (argc = 0; __argv[argc] != NULL; argc++);
+    }
+    
+    if (__envp != NULL) {
+        for (envc = 0; __envp[envc] != NULL; envc++);
+    }
+        
+    args.argc = argc;
+    args.envc = envc;    
+    args.envv = (char **)__envp;
+    args.argv = (char **)__argv;
+    args.total_size = 0;
+    sc = _swi_exec(__path, &args);
+
+    // It can only be an error if it fails.
+    errno = -sc;
+    return -1;
+}
+
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execvp.c third_party/newlib-4.1.0/newlib/libc/sys/arm/execvp.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/execvp.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/execvp.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,68 @@
+/* execvp.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#define PATH_DELIM ':'
+
+/*
+ * Copy string, until c or <nul> is encountered.
+ * NUL-terminate the destination string (s1).
+ */
+
+static char *strccpy (char *s1, char *s2, char c)
+{
+    char *dest = s1;
+
+    while (*s2 && *s2 != c) {
+        *s1++ = *s2++;
+    }
+    *s1 = 0;
+
+    return dest;
+}
+
+/*
+ *
+ */
+int execvp (const char *file, char * const argv[])
+{
+  char *path = getenv ("PATH");
+  char buf[MAXNAMLEN];
+
+  if (!path)
+    return execv (file, argv);
+
+  if (strchr (file, '/'))
+    return execv (file, argv);
+
+  while (*path) {
+      strccpy (buf, path, PATH_DELIM);
+
+      if (*buf != 0 && buf[strlen(buf) - 1] != '/')
+          strcat (buf, "/");
+      
+      strcat (buf, file);
+      
+      if (execv (buf, argv) == -1 && errno != ENOENT)
+          return -1;
+      
+      while (*path && *path != PATH_DELIM) {
+        path++;
+      }
+      
+      if (*path == PATH_DELIM)
+         path++;
+  }
+
+  return -1;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/_exit.c third_party/newlib-4.1.0/newlib/libc/sys/arm/_exit.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/_exit.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/_exit.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,20 @@
+#include <limits.h>
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/debug.h>
+
+
+
+
+/*
+ * Exit, flushing stdio buffers if necessary.
+ */
+
+void _exit (int rc)
+{
+	  _swi_exit (rc);
+	  while (1);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/expand_number.c third_party/newlib-4.1.0/newlib/libc/sys/arm/expand_number.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/expand_number.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/expand_number.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,94 @@
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 2007 Eric Anderson <anderson@FreeBSD.org>
+ * Copyright (c) 2007 Pawel Jakub Dawidek <pjd@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <ctype.h>
+#include <errno.h>
+#include <inttypes.h>
+#include <stdint.h>
+
+int
+expand_number(const char *buf, uint64_t *num)
+{
+	char *endptr;
+	uintmax_t umaxval;
+	uint64_t number;
+	unsigned shift;
+	int serrno;
+
+	serrno = errno;
+	errno = 0;
+	umaxval = strtoumax(buf, &endptr, 0);
+	if (umaxval > UINT64_MAX)
+		errno = ERANGE;
+	if (errno != 0)
+		return (-1);
+	errno = serrno;
+	number = umaxval;
+
+	switch (tolower((unsigned char)*endptr)) {
+	case 'e':
+		shift = 60;
+		break;
+	case 'p':
+		shift = 50;
+		break;
+	case 't':
+		shift = 40;
+		break;
+	case 'g':
+		shift = 30;
+		break;
+	case 'm':
+		shift = 20;
+		break;
+	case 'k':
+		shift = 10;
+		break;
+	case 'b':
+	case '\0': /* No unit. */
+		*num = number;
+		return (0);
+	default:
+		/* Unrecognized unit. */
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if ((number << shift) >> shift != number) {
+		/* Overflow */
+		errno = ERANGE;
+		return (-1);
+	}
+	*num = number << shift;
+	return (0);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fcntl.c third_party/newlib-4.1.0/newlib/libc/sys/arm/fcntl.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fcntl.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/fcntl.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,55 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+
+
+/*
+ * fcntl();
+ */
+int fcntl(int fd, int cmd, ...)
+{
+    va_list ap;
+    int arg;
+    int rc;
+
+    va_start(ap, cmd);
+
+    switch (cmd) {
+	      case F_DUPFD:
+	      case F_SETFD:
+	      case F_SETFL:
+	      case F_SETOWN:
+		        arg = va_arg(ap, int);
+		        rc = _swi_fcntl(fd, cmd, arg);
+		
+		        if (rc < 0) {
+		          errno = -rc;
+		          rc = -1;
+		        }
+		
+		        break;
+
+	      case F_GETFD:
+	      case F_GETFL:
+	      case F_GETOWN:
+		        rc = _swi_fcntl(fd, cmd, 0);
+
+		        if (rc < 0) {
+		          errno = -rc;
+		          rc = -1;
+		        }
+
+		        break;
+
+	      default:
+		        errno = EINVAL;
+		        rc = -1;
+    }
+
+    va_end(ap);
+    return rc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fnmatch.c third_party/newlib-4.1.0/newlib/libc/sys/arm/fnmatch.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fnmatch.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/fnmatch.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,222 @@
+/*	$NetBSD: fnmatch.c,v 1.26 2014/10/12 22:32:33 christos Exp $	*/
+
+/*
+ * Copyright (c) 1989, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Guido van Rossum.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)fnmatch.c	8.2 (Berkeley) 4/16/94";
+#else
+__RCSID("$NetBSD: fnmatch.c,v 1.26 2014/10/12 22:32:33 christos Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+/*
+ * Function fnmatch() as specified in POSIX 1003.2-1992, section B.6.
+ * Compares a filename or pathname to a pattern.
+ */
+
+#include "namespace.h"
+
+#include <assert.h>
+#include <ctype.h>
+#include <fnmatch.h>
+#include <string.h>
+
+#ifdef __weak_alias
+__weak_alias(fnmatch,_fnmatch)
+#endif
+
+#define	EOS	'\0'
+
+static inline int
+foldcase(int ch, int flags)
+{
+
+	if ((flags & FNM_CASEFOLD) != 0 && isupper(ch))
+		return tolower(ch);
+	return ch;
+}
+
+#define	FOLDCASE(ch, flags)	foldcase((unsigned char)(ch), (flags))
+
+static const char *
+rangematch(const char *pattern, int test, int flags)
+{
+	int negate, ok, need;
+	char c, c2;
+
+	_DIAGASSERT(pattern != NULL);
+
+	/*
+	 * A bracket expression starting with an unquoted circumflex
+	 * character produces unspecified results (IEEE 1003.2-1992,
+	 * 3.13.2).  This implementation treats it like '!', for
+	 * consistency with the regular expression syntax.
+	 * J.T. Conklin (conklin@ngai.kaleida.com)
+	 */
+	if ((negate = (*pattern == '!' || *pattern == '^')) != 0)
+		++pattern;
+	
+	need = 1;
+	for (ok = 0; (c = FOLDCASE(*pattern++, flags)) != ']' || need;) {
+		need = 0;
+		if (c == '/')
+			return (void *)-1;
+		if (c == '\\' && !(flags & FNM_NOESCAPE))
+			c = FOLDCASE(*pattern++, flags);
+		if (c == EOS)
+			return NULL;
+		if (*pattern == '-' 
+		    && (c2 = FOLDCASE(*(pattern + 1), flags)) != EOS &&
+		        c2 != ']') {
+			pattern += 2;
+			if (c2 == '\\' && !(flags & FNM_NOESCAPE))
+				c2 = FOLDCASE(*pattern++, flags);
+			if (c2 == EOS)
+				return NULL;
+			if (c <= test && test <= c2)
+				ok = 1;
+		} else if (c == test)
+			ok = 1;
+	}
+	return ok == negate ? NULL : pattern;
+}
+
+
+static int
+fnmatchx(const char *pattern, const char *string, int flags, size_t recursion)
+{
+	const char *stringstart, *r;
+	char c, test;
+
+	_DIAGASSERT(pattern != NULL);
+	_DIAGASSERT(string != NULL);
+
+	if (recursion-- == 0)
+		return FNM_NORES;
+
+	for (stringstart = string;;) {
+		switch (c = FOLDCASE(*pattern++, flags)) {
+		case EOS:
+			if ((flags & FNM_LEADING_DIR) && *string == '/')
+				return 0;
+			return *string == EOS ? 0 : FNM_NOMATCH;
+		case '?':
+			if (*string == EOS)
+				return FNM_NOMATCH;
+			if (*string == '/' && (flags & FNM_PATHNAME))
+				return FNM_NOMATCH;
+			if (*string == '.' && (flags & FNM_PERIOD) &&
+			    (string == stringstart ||
+			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
+				return FNM_NOMATCH;
+			++string;
+			break;
+		case '*':
+			c = FOLDCASE(*pattern, flags);
+			/* Collapse multiple stars. */
+			while (c == '*')
+				c = FOLDCASE(*++pattern, flags);
+
+			if (*string == '.' && (flags & FNM_PERIOD) &&
+			    (string == stringstart ||
+			    ((flags & FNM_PATHNAME) && *(string - 1) == '/')))
+				return FNM_NOMATCH;
+
+			/* Optimize for pattern with * at end or before /. */
+			if (c == EOS) {
+				if (flags & FNM_PATHNAME)
+					return (flags & FNM_LEADING_DIR) ||
+					    strchr(string, '/') == NULL ?
+					    0 : FNM_NOMATCH;
+				else
+					return 0;
+			} else if (c == '/' && flags & FNM_PATHNAME) {
+				if ((string = strchr(string, '/')) == NULL)
+					return FNM_NOMATCH;
+				break;
+			}
+
+			/* General case, use recursion. */
+			while ((test = FOLDCASE(*string, flags)) != EOS) {
+				int e;
+				switch ((e = fnmatchx(pattern, string,
+				    flags & ~FNM_PERIOD, recursion))) {
+				case FNM_NOMATCH:
+					break;
+				default:
+					return e;
+				}
+				if (test == '/' && flags & FNM_PATHNAME)
+					break;
+				++string;
+			}
+			return FNM_NOMATCH;
+		case '[':
+			if (*string == EOS)
+				return FNM_NOMATCH;
+			if (*string == '/' && flags & FNM_PATHNAME)
+				return FNM_NOMATCH;
+			if ((r = rangematch(pattern,
+			    FOLDCASE(*string, flags), flags)) == NULL)
+				return FNM_NOMATCH;
+			if (r == (void *)-1) {
+				if (*string != '[')
+					return FNM_NOMATCH;
+			} else
+				pattern = r;
+			++string;
+			break;
+		case '\\':
+			if (!(flags & FNM_NOESCAPE)) {
+				if ((c = FOLDCASE(*pattern++, flags)) == EOS) {
+					c = '\0';
+					--pattern;
+				}
+			}
+			/* FALLTHROUGH */
+		default:
+			if (c != FOLDCASE(*string++, flags))
+				return FNM_NOMATCH;
+			break;
+		}
+	}
+	/* NOTREACHED */
+}
+
+int
+fnmatch(const char *pattern, const char *string, int flags)
+{
+	return fnmatchx(pattern, string, flags, 64);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fork.c third_party/newlib-4.1.0/newlib/libc/sys/arm/fork.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fork.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/fork.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int fork(void)
+{
+    int pid;
+    
+    pid = _swi_fork();
+    
+    if (pid < 0) {
+        errno = -pid;
+        return -1;
+    }
+    
+    return pid;    
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/format.c third_party/newlib-4.1.0/newlib/libc/sys/arm/format.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/format.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/format.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,16 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscall.h>
+
+
+/*
+ *
+ */
+int kos_format (char *mount, char *label, unsigned long flags, unsigned long cluster_size)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fstat.c third_party/newlib-4.1.0/newlib/libc/sys/arm/fstat.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/fstat.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/fstat.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,11 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <stdio.h>
+
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getbsize.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getbsize.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getbsize.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getbsize.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,106 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__SCCSID("@(#)getbsize.c	8.1 (Berkeley) 6/4/93");
+__FBSDID("$FreeBSD$");
+
+#include <err.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+char *
+getbsize(int *headerlenp, long *blocksizep)
+{
+	static char header[20];
+	long n, max, mul, blocksize;
+	char *ep, *p;
+	const char *form;
+
+#define	KB	(1024L)
+#define	MB	(1024L * 1024L)
+#define	GB	(1024L * 1024L * 1024L)
+#define	MAXB	GB		/* No tera, peta, nor exa. */
+	form = "";
+	if ((p = getenv("BLOCKSIZE")) != NULL && *p != '\0') {
+		if ((n = strtol(p, &ep, 10)) < 0)
+			goto underflow;
+		if (n == 0)
+			n = 1;
+		if (*ep && ep[1])
+			goto fmterr;
+		switch (*ep) {
+		case 'G': case 'g':
+			form = "G";
+			max = MAXB / GB;
+			mul = GB;
+			break;
+		case 'K': case 'k':
+			form = "K";
+			max = MAXB / KB;
+			mul = KB;
+			break;
+		case 'M': case 'm':
+			form = "M";
+			max = MAXB / MB;
+			mul = MB;
+			break;
+		case '\0':
+			max = MAXB;
+			mul = 1;
+			break;
+		default:
+fmterr:			warnx("%s: unknown blocksize", p);
+			n = 512;
+			max = MAXB;
+			mul = 1;
+			break;
+		}
+		if (n > max) {
+			warnx("maximum blocksize is %ldG", MAXB / GB);
+			n = max;
+		}
+		if ((blocksize = n * mul) < 512) {
+underflow:		warnx("minimum blocksize is 512");
+			form = "";
+			blocksize = n = 512;
+		}
+	} else
+		blocksize = n = 512;
+
+	(void)snprintf(header, sizeof(header), "%ld%s-blocks", n, form);
+	*headerlenp = strlen(header);
+	*blocksizep = blocksize;
+	return (header);
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getentropy.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getentropy.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getentropy.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getentropy.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,27 @@
+#include <errno.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <paths.h>
+
+
+#define MAX_ENTROPY     256
+
+int getentropy(void *buf, size_t buflen)
+{
+  int ret = -1;
+
+	if (buflen > MAX_ENTROPY) {
+		errno = -EIO;
+		return -1;
+	}
+
+	int fd = open(_PATH_RANDOM, O_RDONLY);
+	if (fd >= 0) {
+		ret = read(fd, buf, buflen);
+		close(fd);
+	}
+
+  return (ret == buflen) ? 0 : -1;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getgrent.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getgrent.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getgrent.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getgrent.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,1976 @@
+/*	$NetBSD: getgrent.c,v 1.67 2012/08/29 18:50:35 dholland Exp $	*/
+
+/*-
+ * Copyright (c) 1999-2000, 2004-2005 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Portions Copyright (c) 1994, Jason Downs. All Rights Reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/debug.h>
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)getgrent.c	8.2 (Berkeley) 3/21/94";
+#else
+__RCSID("$NetBSD: getgrent.c,v 1.67 2012/08/29 18:50:35 dholland Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include "reentrant.h"
+
+#include <sys/param.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <grp.h>
+#include <limits.h>
+#include <nsswitch.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+//#include <syslog.h>
+#include <sys/debug.h>
+
+#ifdef HESIOD
+#include <hesiod.h>
+#endif
+
+#ifdef YP
+#include <rpc/rpc.h>
+#include <rpcsvc/yp_prot.h>
+#include <rpcsvc/ypclnt.h>
+#endif
+
+#include "gr_private.h"
+
+#ifdef __weak_alias
+__weak_alias(endgrent,_endgrent)
+__weak_alias(getgrent,_getgrent)
+__weak_alias(getgrent_r,_getgrent_r)
+__weak_alias(getgrgid,_getgrgid)
+__weak_alias(getgrgid_r,_getgrgid_r)
+__weak_alias(getgrnam,_getgrnam)
+__weak_alias(getgrnam_r,_getgrnam_r)
+__weak_alias(setgrent,_setgrent)
+__weak_alias(setgroupent,_setgroupent)
+#endif
+
+#ifdef _REENTRANT
+mutex_t	__grmutex = MUTEX_INITIALIZER;
+#endif
+
+/*
+ * _gr_memfrombuf
+ *	Obtain want bytes from buffer (of size buflen) and return a pointer
+ *	to the available memory after adjusting buffer/buflen.
+ *	Returns NULL if there is insufficient space.
+ */
+static char *
+_gr_memfrombuf(size_t want, char **buffer, size_t *buflen)
+{
+	char	*rv;
+
+	if (want > *buflen) {
+		errno = ERANGE;
+		return NULL;
+	}
+	rv = *buffer;
+	*buffer += want;
+	*buflen -= want;
+	return rv;
+}
+
+/*
+ * _gr_parse
+ *	Parses entry as a line per group(5) (without the trailing \n)
+ *	and fills in grp with corresponding values; memory for strings
+ *	and arrays will be allocated from buf (of size buflen).
+ *	Returns 1 if parsed successfully, 0 on parse failure.
+ */
+static int
+_gr_parse(const char *entry, struct group *grp, char *buf, size_t buflen)
+{
+	unsigned long	id;
+	const char	*bp;
+	char		*ep;
+	size_t		count;
+	int		memc;
+
+	_DIAGASSERT(entry != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buf != NULL);
+
+#define COPYTOBUF(to) \
+	do { \
+		(to) = _gr_memfrombuf(count+1, &buf, &buflen); \
+		if ((to) == NULL) \
+			return 0; \
+		memmove((to), entry, count); \
+		to[count] = '\0'; \
+	} while (0)	/* LINTED */
+
+#if 0
+	if (*entry == '+')			/* fail on compat `+' token */
+		return 0;
+#endif
+
+	count = strcspn(entry, ":");		/* parse gr_name */
+	if (entry[count] == '\0')
+		return 0;
+	COPYTOBUF(grp->gr_name);
+	entry += count + 1;
+
+	count = strcspn(entry, ":");		/* parse gr_passwd */
+	if (entry[count] == '\0')
+		return 0;
+	COPYTOBUF(grp->gr_passwd);
+	entry += count + 1;
+
+	count = strcspn(entry, ":");		/* parse gr_gid */
+	if (entry[count] == '\0')
+		return 0;
+	id = strtoul(entry, &ep, 10);
+	if (id > GID_MAX || *ep != ':')
+		return 0;
+	grp->gr_gid = (gid_t)id;
+	entry += count + 1;
+
+	memc = 1;				/* for final NULL */
+	if (*entry != '\0')
+		memc++;				/* for first item */
+	for (bp = entry; *bp != '\0'; bp++) {
+		if (*bp == ',')
+			memc++;
+	}
+				/* grab ALIGNed char **gr_mem from buf */
+	ep = _gr_memfrombuf(memc * sizeof(char *) + ALIGNBYTES, &buf, &buflen);
+	if (ep == NULL)
+		return 0;
+	grp->gr_mem = (char **)ALIGN(ep);
+
+	for (memc = 0; *entry != '\0'; memc++) {
+		count = strcspn(entry, ",");	/* parse member */
+		COPYTOBUF(grp->gr_mem[memc]);
+		entry += count;
+		if (*entry == ',')
+			entry++;
+	}
+
+#undef COPYTOBUF
+
+	grp->gr_mem[memc] = NULL;
+	return 1;
+}
+
+/*
+ * _gr_copy
+ *	Copy the contents of fromgrp to grp; memory for strings
+ *	and arrays will be allocated from buf (of size buflen).
+ *	Returns 1 if copied successfully, 0 on copy failure.
+ *	NOTE: fromgrp must not use buf for its own pointers.
+ */
+static int
+_gr_copy(struct group *fromgrp, struct group *grp, char *buf, size_t buflen)
+{
+	char	*ep;
+	int	memc;
+
+	_DIAGASSERT(fromgrp != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buf != NULL);
+
+#define COPYSTR(to, from) \
+	do { \
+		size_t count = strlen((from)); \
+		(to) = _gr_memfrombuf(count+1, &buf, &buflen); \
+		if ((to) == NULL) \
+			return 0; \
+		memmove((to), (from), count); \
+		to[count] = '\0'; \
+	} while (0)	/* LINTED */
+
+	COPYSTR(grp->gr_name, fromgrp->gr_name);
+	COPYSTR(grp->gr_passwd, fromgrp->gr_passwd);
+	grp->gr_gid = fromgrp->gr_gid;
+
+	if (fromgrp->gr_mem == NULL)
+		return 0;
+
+	for (memc = 0; fromgrp->gr_mem[memc]; memc++)
+		continue;
+	memc++;					/* for final NULL */
+
+				/* grab ALIGNed char **gr_mem from buf */
+	ep = _gr_memfrombuf(memc * sizeof(char *) + ALIGNBYTES, &buf, &buflen);
+	grp->gr_mem = (char **)ALIGN(ep);
+	if (grp->gr_mem == NULL)
+		return 0;
+
+	for (memc = 0; fromgrp->gr_mem[memc]; memc++) {
+		COPYSTR(grp->gr_mem[memc], fromgrp->gr_mem[memc]);
+	}
+
+#undef COPYSTR
+
+	grp->gr_mem[memc] = NULL;
+	return 1;
+}
+
+		/*
+		 *	files methods
+		 */
+
+int
+__grstart_files(struct __grstate_files *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	if (state->fp == NULL) {
+		state->fp = fopen(_PATH_GROUP, "re");
+		if (state->fp == NULL)
+			return NS_UNAVAIL;
+	} else {
+		rewind(state->fp);
+	}
+	return NS_SUCCESS;
+}
+
+int
+__grend_files(struct __grstate_files *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	if (state->fp) {
+		(void) fclose(state->fp);
+		state->fp = NULL;
+	}
+	return NS_SUCCESS;
+}
+
+/*
+ * __grscan_files
+ *	Scan state->fp for the next desired entry.
+ *	If search is zero, return the next entry.
+ *	If search is non-zero, look for a specific name (if name != NULL),
+ *	or a specific gid (if name == NULL).
+ *	Sets *retval to the errno if the result is not NS_SUCCESS
+ *	or NS_NOTFOUND.
+ */
+int
+__grscan_files(int *retval, struct group *grp, char *buffer, size_t buflen,
+	struct __grstate_files *state, int search, const char *name, gid_t gid)
+{
+	int	rv;
+	char	filebuf[_SC_GETGR_R_SIZE_MAX], *ep;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	/* name is NULL to indicate searching for gid */
+
+	*retval = 0;
+
+	if (state->fp == NULL) {	/* only start if file not open yet */
+		rv = __grstart_files(state);
+		if (rv != NS_SUCCESS)
+			goto filesgrscan_out;
+	}
+
+	rv = NS_NOTFOUND;
+
+							/* scan line by line */
+	while (fgets(filebuf, (int)sizeof(filebuf), state->fp) != NULL) {
+		ep = strchr(filebuf, '\n');
+		if (ep == NULL) {	/* skip lines that are too big */
+			int ch;
+
+			while ((ch = getc(state->fp)) != '\n' && ch != EOF)
+				continue;
+			continue;
+		}
+		*ep = '\0';				/* clear trailing \n */
+
+		if (filebuf[0] == '+')			/* skip compat line */
+			continue;
+
+							/* validate line */
+		if (! _gr_parse(filebuf, grp, buffer, buflen)) {
+			continue;			/* skip bad lines */
+		}
+		if (! search) {				/* just want this one */
+			rv = NS_SUCCESS;
+			break;
+		}
+							/* want specific */
+		if ((name && strcmp(name, grp->gr_name) == 0) ||
+		    (!name && gid == grp->gr_gid)) {
+			rv = NS_SUCCESS;
+			break;
+		}
+	}
+
+ filesgrscan_out:
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	return rv;
+}
+
+
+static struct __grstate_files	_files_state;
+					/* storage for non _r functions */
+static struct group		_files_group;
+static char			_files_groupbuf[_SC_GETGR_R_SIZE_MAX];
+
+/*ARGSUSED*/
+static int
+_files_setgrent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_files_state.stayopen = 0;
+	return __grstart_files(&_files_state);
+}
+
+/*ARGSUSED*/
+static int
+_files_setgroupent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	_files_state.stayopen = stayopen;
+	rv = __grstart_files(&_files_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_endgrent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_files_state.stayopen = 0;
+	return __grend_files(&_files_state);
+}
+
+/*ARGSUSED*/
+static int
+_files_getgrent(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grscan_files(&rerror, &_files_group,
+	    _files_groupbuf, sizeof(_files_groupbuf),
+	    &_files_state, 0, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*retval = &_files_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getgrent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	rv = __grscan_files(retval, grp, buffer, buflen,
+	    &_files_state, 0, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	else
+		*result = NULL;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getgrgid(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	gid_t		 gid	= va_arg(ap, gid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_files(&_files_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_files(&rerror, &_files_group,
+	    _files_groupbuf, sizeof(_files_groupbuf),
+	    &_files_state, 1, NULL, gid);
+	if (!_files_state.stayopen)
+		__grend_files(&_files_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_files_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getgrgid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	gid_t		 gid	= va_arg(ap, gid_t);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_files state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = __grscan_files(retval, grp, buffer, buflen, &state, 1, NULL, gid);
+	__grend_files(&state);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getgrnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_files(&_files_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_files(&rerror, &_files_group,
+	    _files_groupbuf, sizeof(_files_groupbuf),
+	    &_files_state, 1, name, 0);
+	if (!_files_state.stayopen)
+		__grend_files(&_files_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_files_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getgrnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_files state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = __grscan_files(retval, grp, buffer, buflen, &state, 1, name, 0);
+	__grend_files(&state);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+
+#ifdef HESIOD
+		/*
+		 *	dns methods
+		 */
+
+int
+__grstart_dns(struct __grstate_dns *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->num = 0;
+	if (state->context == NULL) {			/* setup Hesiod */
+		if (hesiod_init(&state->context) == -1)
+			return NS_UNAVAIL;
+	}
+
+	return NS_SUCCESS;
+}
+
+int
+__grend_dns(struct __grstate_dns *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->num = 0;
+	if (state->context) {
+		hesiod_end(state->context);
+		state->context = NULL;
+	}
+	return NS_SUCCESS;
+}
+
+/*
+ * __grscan_dns
+ *	Search Hesiod for the next desired entry.
+ *	If search is zero, return the next entry.
+ *	If search is non-zero, look for a specific name (if name != NULL),
+ *	or a specific gid (if name == NULL).
+ */
+int
+__grscan_dns(int *retval, struct group *grp, char *buffer, size_t buflen,
+	struct __grstate_dns *state, int search, const char *name, gid_t gid)
+{
+	const char	**curzone;
+	char		**hp, *ep;
+	int		rv;
+
+	static const char *zones_gid_group[] = {
+		"gid",
+		"group",
+		NULL
+	};
+
+	static const char *zones_group[] = {
+		"group",
+		NULL
+	};
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	/* name is NULL to indicate searching for gid */
+
+	*retval = 0;
+
+	if (state->context == NULL) {	/* only start if Hesiod not setup */
+		rv = __grstart_dns(state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+ next_dns_entry:
+	hp = NULL;
+	rv = NS_NOTFOUND;
+
+	if (! search) {			/* find next entry */
+		if (state->num == -1)		/* exhausted search */
+			return NS_NOTFOUND;
+						/* find group-NNN */
+		snprintf(buffer, buflen, "group-%u", state->num);
+		state->num++;
+		curzone = zones_group;
+	} else if (name) {		/* find group name */
+		snprintf(buffer, buflen, "%s", name);
+		curzone = zones_group;
+	} else {			/* find gid */
+		snprintf(buffer, buflen, "%u", (unsigned int)gid);
+		curzone = zones_gid_group;
+	}
+
+	for (; *curzone; curzone++) {		/* search zones */
+		hp = hesiod_resolve(state->context, buffer, *curzone);
+		if (hp != NULL)
+			break;
+		if (errno != ENOENT) {
+			rv = NS_UNAVAIL;
+			goto dnsgrscan_out;
+		}
+	}
+	if (*curzone == NULL) {
+		if (! search)
+			state->num = -1;
+		goto dnsgrscan_out;
+	}
+
+	if ((ep = strchr(hp[0], '\n')) != NULL)
+		*ep = '\0';				/* clear trailing \n */
+	if (_gr_parse(hp[0], grp, buffer, buflen)) {	/* validate line */
+		if (! search) {				/* just want this one */
+			rv = NS_SUCCESS;
+		} else if ((name && strcmp(name, grp->gr_name) == 0) ||
+		    (!name && gid == grp->gr_gid)) {	/* want specific */
+			rv = NS_SUCCESS;
+		}
+	} else {					/* dodgy entry */
+		if (!search) {			/* try again if ! searching */
+			hesiod_free_list(state->context, hp);
+			goto next_dns_entry;
+		}
+	}
+
+ dnsgrscan_out:
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	if (hp)
+		hesiod_free_list(state->context, hp);
+	return rv;
+}
+
+static struct __grstate_dns	_dns_state;
+					/* storage for non _r functions */
+static struct group		_dns_group;
+static char			_dns_groupbuf[_SC_GETGR_R_SIZE_MAX];
+
+/*ARGSUSED*/
+static int
+_dns_setgrent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_dns_state.stayopen = 0;
+	return __grstart_dns(&_dns_state);
+}
+
+/*ARGSUSED*/
+static int
+_dns_setgroupent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	_dns_state.stayopen = stayopen;
+	rv = __grstart_dns(&_dns_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_endgrent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_dns_state.stayopen = 0;
+	return __grend_dns(&_dns_state);
+}
+
+/*ARGSUSED*/
+static int
+_dns_getgrent(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+
+	int	  rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grscan_dns(&rerror, &_dns_group,
+	    _dns_groupbuf, sizeof(_dns_groupbuf), &_dns_state, 0, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*retval = &_dns_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getgrent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	rv = __grscan_dns(retval, grp, buffer, buflen,
+	    &_dns_state, 0, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	else
+		*result = NULL;
+	return rv;
+}
+/*ARGSUSED*/
+static int
+_dns_getgrgid(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	gid_t		 gid	= va_arg(ap, gid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_dns(&_dns_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_dns(&rerror, &_dns_group,
+	    _dns_groupbuf, sizeof(_dns_groupbuf), &_dns_state, 1, NULL, gid);
+	if (!_dns_state.stayopen)
+		__grend_dns(&_dns_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_dns_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getgrgid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	gid_t		 gid	= va_arg(ap, gid_t);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_dns state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = __grscan_dns(retval, grp, buffer, buflen, &state, 1, NULL, gid);
+	__grend_dns(&state);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getgrnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_dns(&_dns_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_dns(&rerror, &_dns_group,
+	    _dns_groupbuf, sizeof(_dns_groupbuf), &_dns_state, 1, name, 0);
+	if (!_dns_state.stayopen)
+		__grend_dns(&_dns_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_dns_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getgrnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_dns state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = __grscan_dns(retval, grp, buffer, buflen, &state, 1, name, 0);
+	__grend_dns(&state);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+#endif /* HESIOD */
+
+
+#ifdef YP
+		/*
+		 *	nis methods
+		 */
+
+int
+__grstart_nis(struct __grstate_nis *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->done = 0;
+	if (state->current) {
+		free(state->current);
+		state->current = NULL;
+	}
+	if (state->domain == NULL) {			/* setup NIS */
+		switch (yp_get_default_domain(&state->domain)) {
+		case 0:
+			break;
+		case YPERR_RESRC:
+			return NS_TRYAGAIN;
+		default:
+			return NS_UNAVAIL;
+		}
+	}
+	return NS_SUCCESS;
+}
+
+int
+__grend_nis(struct __grstate_nis *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	if (state->domain) {
+		state->domain = NULL;
+	}
+	state->done = 0;
+	if (state->current) {
+		free(state->current);
+		state->current = NULL;
+	}
+	return NS_SUCCESS;
+}
+
+/*
+ * __grscan_nis
+ *	Search NIS for the next desired entry.
+ *	If search is zero, return the next entry.
+ *	If search is non-zero, look for a specific name (if name != NULL),
+ *	or a specific gid (if name == NULL).
+ */
+int
+__grscan_nis(int *retval, struct group *grp, char *buffer, size_t buflen,
+	struct __grstate_nis *state, int search, const char *name, gid_t gid)
+{
+	const char *map;
+	char	*key, *data;
+	int	nisr, rv, keylen, datalen;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	/* name is NULL to indicate searching for gid */
+
+	*retval = 0;
+
+	if (state->domain == NULL) {	/* only start if NIS not setup */
+		rv = __grstart_nis(state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+ next_nis_entry:
+	key = NULL;
+	data = NULL;
+	rv = NS_SUCCESS;
+
+	if (! search) 	{			/* find next entry */
+		if (state->done)			/* exhausted search */
+			return NS_NOTFOUND;
+		map = "group.byname";
+		if (state->current) {			/* already searching */
+			nisr = yp_next(state->domain, map,
+			    state->current, state->currentlen,
+			    &key, &keylen, &data, &datalen);
+			free(state->current);
+			state->current = NULL;
+			switch (nisr) {
+			case 0:
+				state->current = key;
+				state->currentlen = keylen;
+				key = NULL;
+				break;
+			case YPERR_NOMORE:
+				rv = NS_NOTFOUND;
+				state->done = 1;
+				break;
+			default:
+				rv = NS_UNAVAIL;
+				break;
+			}
+		} else {				/* new search */
+			if (yp_first(state->domain, map,
+			    &state->current, &state->currentlen,
+			    &data, &datalen)) {
+				rv = NS_UNAVAIL;
+			}
+		}
+	} else {				/* search for specific item */
+		if (name) {			/* find group name */
+			snprintf(buffer, buflen, "%s", name);
+			map = "group.byname";
+		} else {			/* find gid */
+			snprintf(buffer, buflen, "%u", (unsigned int)gid);
+			map = "group.bygid";
+		}
+		nisr = yp_match(state->domain, map, buffer, (int)strlen(buffer),
+		    &data, &datalen);
+		switch (nisr) {
+		case 0:
+			break;
+		case YPERR_KEY:
+			rv = NS_NOTFOUND;
+			break;
+		default:
+			rv = NS_UNAVAIL;
+			break;
+		}
+	}
+	if (rv == NS_SUCCESS) {				/* validate data */
+		data[datalen] = '\0';			/* clear trailing \n */
+		if (_gr_parse(data, grp, buffer, buflen)) {
+			if (! search) {			/* just want this one */
+				rv = NS_SUCCESS;
+			} else if ((name && strcmp(name, grp->gr_name) == 0) ||
+			    (!name && gid == grp->gr_gid)) {
+							/* want specific */
+				rv = NS_SUCCESS;
+			}
+		} else {				/* dodgy entry */
+			if (!search) {		/* try again if ! searching */
+				free(data);
+				goto next_nis_entry;
+			}
+		}
+	}
+
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	if (key)
+		free(key);
+	if (data)
+		free(data);
+	return rv;
+}
+
+static struct __grstate_nis	_nis_state;
+					/* storage for non _r functions */
+static struct group		_nis_group;
+static char			_nis_groupbuf[_SC_GETGR_R_SIZE_MAX];
+
+/*ARGSUSED*/
+static int
+_nis_setgrent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_nis_state.stayopen = 0;
+	return __grstart_nis(&_nis_state);
+}
+
+/*ARGSUSED*/
+static int
+_nis_setgroupent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	_nis_state.stayopen = stayopen;
+	rv = __grstart_nis(&_nis_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_endgrent(void *nsrv, void *nscb, va_list ap)
+{
+
+	return __grend_nis(&_nis_state);
+}
+
+/*ARGSUSED*/
+static int
+_nis_getgrent(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grscan_nis(&rerror, &_nis_group,
+	    _nis_groupbuf, sizeof(_nis_groupbuf), &_nis_state, 0, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*retval = &_nis_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getgrent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	rv = __grscan_nis(retval, grp, buffer, buflen,
+	    &_nis_state, 0, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	else
+		*result = NULL;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getgrgid(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	gid_t		 gid	= va_arg(ap, gid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_nis(&_nis_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_nis(&rerror, &_nis_group,
+	    _nis_groupbuf, sizeof(_nis_groupbuf), &_nis_state, 1, NULL, gid);
+	if (!_nis_state.stayopen)
+		__grend_nis(&_nis_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_nis_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getgrgid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	gid_t		 gid	= va_arg(ap, gid_t);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_nis state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+/* remark: we run under a global mutex inside of this module ... */
+	if (_nis_state.stayopen)
+	  { /* use global state only if stayopen is set - otherwiese we would blow up getgrent_r() ... */
+	     rv = __grscan_nis(retval, grp, buffer, buflen, &_nis_state, 1, NULL, gid);
+	  }
+	else
+	  {
+	    memset(&state, 0, sizeof(state));
+	    rv = __grscan_nis(retval, grp, buffer, buflen, &state, 1, NULL, gid);
+	    __grend_nis(&state);
+	  }
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getgrnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_nis(&_nis_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_nis(&rerror, &_nis_group,
+	    _nis_groupbuf, sizeof(_nis_groupbuf), &_nis_state, 1, name, 0);
+	if (!_nis_state.stayopen)
+		__grend_nis(&_nis_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_nis_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getgrnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_nis state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+/* remark: we run under a global mutex inside of this module ... */
+	if (_nis_state.stayopen)
+	  { /* use global state only if stayopen is set - otherwiese we would blow up getgrent_r() ... */
+	     rv = __grscan_nis(retval, grp, buffer, buflen, &_nis_state, 1, name, 0);
+	  }
+	else
+	  {
+	    memset(&state, 0, sizeof(state));
+	    rv = __grscan_nis(retval, grp, buffer, buflen, &state, 1, name, 0);
+	    __grend_nis(&state);
+	  }
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+#endif /* YP */
+
+
+#ifdef _GROUP_COMPAT
+		/*
+		 *	compat methods
+		 */
+
+int
+__grstart_compat(struct __grstate_compat *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	if (state->fp == NULL) {
+		state->fp = fopen(_PATH_GROUP, "re");
+		if (state->fp == NULL)
+			return NS_UNAVAIL;
+	} else {
+		rewind(state->fp);
+	}
+	return NS_SUCCESS;
+}
+
+int
+__grend_compat(struct __grstate_compat *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	if (state->name) {
+		free(state->name);
+		state->name = NULL;
+	}
+	if (state->fp) {
+		(void) fclose(state->fp);
+		state->fp = NULL;
+	}
+	return NS_SUCCESS;
+}
+
+
+/*
+ * __grbad_compat
+ *	log an error if "files" or "compat" is specified in
+ *	group_compat database
+ */
+/*ARGSUSED*/
+int
+__grbad_compat(void *nsrv, void *nscb, va_list ap)
+{
+	static int warned;
+
+	_DIAGASSERT(nsrv != NULL);
+	_DIAGASSERT(nscb != NULL);
+
+	if (!warned) {
+		log_error("nsswitch.conf group_compat database can't use '%s'",
+			(const char *)nscb);
+	}
+	warned = 1;
+	return NS_UNAVAIL;
+}
+
+/*
+ * __grscan_compat
+ *	Scan state->fp for the next desired entry.
+ *	If search is zero, return the next entry.
+ *	If search is non-zero, look for a specific name (if name != NULL),
+ *	or a specific gid (if name == NULL).
+ *	Sets *retval to the errno if the result is not NS_SUCCESS or
+ *	NS_NOTFOUND.
+ *
+ *	searchfunc is invoked when a compat "+" lookup is required;
+ *	searchcookie is passed as the first argument to searchfunc,
+ *	the second argument is the group result.
+ *	This should return NS_NOTFOUND when "no more groups" from compat src.
+ *	If searchfunc is NULL then nsdispatch of getgrent is used.
+ *	This is primarily intended for getgroupmembership(3)'s compat backend.
+ */
+int
+__grscan_compat(int *retval, struct group *grp, char *buffer, size_t buflen,
+	struct __grstate_compat *state, int search, const char *name, gid_t gid,
+	int (*searchfunc)(void *, struct group **), void *searchcookie)
+{
+	int		rv;
+	char		filebuf[_SC_GETGR_R_SIZE_MAX], *ep;
+
+	static const ns_dtab compatentdtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_getgrent_r, NULL)
+		NS_NIS_CB(_nis_getgrent_r, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+	static const ns_dtab compatgiddtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_getgrgid_r, NULL)
+		NS_NIS_CB(_nis_getgrgid_r, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+	static const ns_dtab compatnamdtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_getgrnam_r, NULL)
+		NS_NIS_CB(_nis_getgrnam_r, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	/* name is NULL to indicate searching for gid */
+
+	*retval = 0;
+
+	if (state->fp == NULL) {	/* only start if file not open yet */
+		rv = __grstart_compat(state);
+		if (rv != NS_SUCCESS)
+			goto compatgrscan_out;
+	}
+	rv = NS_NOTFOUND;
+
+	for (;;) {					/* loop through file */
+		if (state->name != NULL) {
+					/* processing compat entry */
+			int		crv, cretval;
+			struct group	cgrp, *cgrpres;
+
+			if (state->name[0]) {		/* specific +group: */
+				crv = nsdispatch(NULL, compatnamdtab,
+				    NSDB_GROUP_COMPAT, "getgrnam_r",
+				    __nsdefaultnis,
+				    &cretval, state->name,
+				    &cgrp, filebuf, sizeof(filebuf), &cgrpres);
+				free(state->name);	/* (only check 1 grp) */
+				state->name = NULL;
+			} else if (!search) {		/* any group */
+				if (searchfunc) {
+					crv = searchfunc(searchcookie,
+					    &cgrpres);
+				} else {
+					crv = nsdispatch(NULL, compatentdtab,
+					    NSDB_GROUP_COMPAT, "getgrent_r",
+					    __nsdefaultnis,
+					    &cretval, &cgrp, filebuf,
+					    sizeof(filebuf), &cgrpres);
+				}
+			} else if (name) {		/* specific group */
+				crv = nsdispatch(NULL, compatnamdtab,
+				    NSDB_GROUP_COMPAT, "getgrnam_r",
+				    __nsdefaultnis,
+				    &cretval, name,
+				    &cgrp, filebuf, sizeof(filebuf), &cgrpres);
+			} else {			/* specific gid */
+				crv = nsdispatch(NULL, compatgiddtab,
+				    NSDB_GROUP_COMPAT, "getgrgid_r",
+				    __nsdefaultnis,
+				    &cretval, gid,
+				    &cgrp, filebuf, sizeof(filebuf), &cgrpres);
+			}
+			if (crv != NS_SUCCESS) {	/* not found */
+				free(state->name);
+				state->name = NULL;
+				continue;		/* try next line */
+			}
+			if (!_gr_copy(cgrpres, grp, buffer, buflen)) {
+				rv = NS_UNAVAIL;
+				break;
+			}
+			goto compatgrscan_cmpgrp;	/* skip to grp test */
+		}
+
+							/* get next file line */
+		if (fgets(filebuf, (int)sizeof(filebuf), state->fp) == NULL)
+			break;
+
+		ep = strchr(filebuf, '\n');
+		if (ep == NULL) {	/* skip lines that are too big */
+			int ch;
+
+			while ((ch = getc(state->fp)) != '\n' && ch != EOF)
+				continue;
+			continue;
+		}
+		*ep = '\0';				/* clear trailing \n */
+
+		if (filebuf[0] == '+') {		/* parse compat line */
+			if (state->name)
+				free(state->name);
+			state->name = NULL;
+			switch(filebuf[1]) {
+			case ':':
+			case '\0':
+				state->name = strdup("");
+				break;
+			default:
+				ep = strchr(filebuf + 1, ':');
+				if (ep == NULL)
+					break;
+				*ep = '\0';
+				state->name = strdup(filebuf + 1);
+				break;
+			}
+			if (state->name == NULL) {
+				rv = NS_UNAVAIL;
+				break;
+			}
+			continue;
+		}
+
+							/* validate line */
+		if (! _gr_parse(filebuf, grp, buffer, buflen)) {
+			continue;			/* skip bad lines */
+		}
+
+ compatgrscan_cmpgrp:
+		if (! search) {				/* just want this one */
+			rv = NS_SUCCESS;
+			break;
+		}
+							/* want specific */
+		if ((name && strcmp(name, grp->gr_name) == 0) ||
+		    (!name && gid == grp->gr_gid)) {
+			rv = NS_SUCCESS;
+			break;
+		}
+
+	}
+
+ compatgrscan_out:
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	return rv;
+}
+
+static struct __grstate_compat	_compat_state;
+					/* storage for non _r functions */
+static struct group		_compat_group;
+static char			_compat_groupbuf[_SC_GETGR_R_SIZE_MAX];
+
+/*ARGSUSED*/
+static int
+_compat_setgrent(void *nsrv, void *nscb, va_list ap)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_setgrent, NULL)
+		NS_NIS_CB(_nis_setgrent, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+
+					/* force group_compat setgrent() */
+	(void) nsdispatch(NULL, dtab, NSDB_GROUP_COMPAT, "setgrent",
+	    __nsdefaultnis_forceall);
+
+					/* reset state, keep fp open */
+	_compat_state.stayopen = 0;
+	return __grstart_compat(&_compat_state);
+}
+
+/*ARGSUSED*/
+static int
+_compat_setgroupent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_setgroupent, NULL)
+		NS_NIS_CB(_nis_setgroupent, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+
+					/* force group_compat setgroupent() */
+	(void) nsdispatch(NULL, dtab, NSDB_GROUP_COMPAT, "setgroupent",
+	    __nsdefaultnis_forceall, &rv, stayopen);
+
+	_compat_state.stayopen = stayopen;
+	rv = __grstart_compat(&_compat_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_endgrent(void *nsrv, void *nscb, va_list ap)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_endgrent, NULL)
+		NS_NIS_CB(_nis_endgrent, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+
+					/* force group_compat endgrent() */
+	(void) nsdispatch(NULL, dtab, NSDB_GROUP_COMPAT, "endgrent",
+	    __nsdefaultnis_forceall);
+
+					/* reset state, close fp */
+	_compat_state.stayopen = 0;
+	return __grend_compat(&_compat_state);
+}
+
+/*ARGSUSED*/
+static int
+_compat_getgrent(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grscan_compat(&rerror, &_compat_group,
+	    _compat_groupbuf, sizeof(_compat_groupbuf),
+	    &_compat_state, 0, NULL, 0, NULL, NULL);
+	if (rv == NS_SUCCESS)
+		*retval = &_compat_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getgrent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	rv = __grscan_compat(retval, grp, buffer, buflen,
+	    &_compat_state, 0, NULL, 0, NULL, NULL);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	else
+		*result = NULL;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getgrgid(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	gid_t		 gid	= va_arg(ap, gid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_compat(&_compat_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_compat(&rerror, &_compat_group,
+	    _compat_groupbuf, sizeof(_compat_groupbuf),
+	    &_compat_state, 1, NULL, gid, NULL, NULL);
+	if (!_compat_state.stayopen)
+		__grend_compat(&_compat_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_compat_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getgrgid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	gid_t		 gid	= va_arg(ap, gid_t);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_compat	state;
+	int		rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = __grscan_compat(retval, grp, buffer, buflen, &state,
+	    1, NULL, gid, NULL, NULL);
+	__grend_compat(&state);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getgrnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct group	**retval = va_arg(ap, struct group **);
+	const char	*name	= va_arg(ap, const char *);
+
+//	log_info("getgrnam");
+
+	return -1; /* FIXME */
+	/* FIXME: FIXME: */
+
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = __grstart_compat(&_compat_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = __grscan_compat(&rerror, &_compat_group,
+	    _compat_groupbuf, sizeof(_compat_groupbuf),
+	    &_compat_state, 1, name, 0, NULL, NULL);
+	if (!_compat_state.stayopen)
+		__grend_compat(&_compat_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_compat_group;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getgrnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct group	*grp	= va_arg(ap, struct group *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct group   **result	= va_arg(ap, struct group **);
+
+	struct __grstate_compat	state;
+	int		rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = __grscan_compat(retval, grp, buffer, buflen, &state,
+	    1, name, 0, NULL, NULL);
+	__grend_compat(&state);
+	if (rv == NS_SUCCESS)
+		*result = grp;
+	return rv;
+}
+
+#endif	/* _GROUP_COMPAT */
+
+
+		/*
+		 *	public functions
+		 */
+
+struct group *
+getgrent(void)
+{
+	int		rv;
+	struct group	*retval;
+
+//	log_info("getgrent");
+
+	return NULL; /* FIXME */
+	/* FIXME: FIXME: */
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgrent, NULL)
+		NS_DNS_CB(_dns_getgrent, NULL)
+		NS_NIS_CB(_nis_getgrent, NULL)
+		NS_COMPAT_CB(_compat_getgrent, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&__grmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "getgrent", __nsdefaultcompat,
+	    &retval);
+	mutex_unlock(&__grmutex);
+	return (rv == NS_SUCCESS) ? retval : NULL;
+}
+
+int
+getgrent_r(struct group *grp, char *buffer, size_t buflen,
+    struct group **result)
+{
+	int		rv, retval;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgrent_r, NULL)
+		NS_DNS_CB(_dns_getgrent_r, NULL)
+		NS_NIS_CB(_nis_getgrent_r, NULL)
+		NS_COMPAT_CB(_compat_getgrent_r, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&__grmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "getgrent_r", __nsdefaultcompat,
+	    &retval, grp, buffer, buflen, result);
+	mutex_unlock(&__grmutex);
+	switch (rv) {
+	case NS_SUCCESS:
+	case NS_NOTFOUND:
+		return 0;
+	default:
+		return retval;
+	}
+}
+
+
+struct group *
+getgrgid(gid_t gid)
+{
+	int		rv;
+	struct group	*retval;
+
+//	log_info("getgrgid");
+
+	return NULL; /* FIXME */
+	/* FIXME: FIXME: */
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgrgid, NULL)
+		NS_DNS_CB(_dns_getgrgid, NULL)
+		NS_NIS_CB(_nis_getgrgid, NULL)
+		NS_COMPAT_CB(_compat_getgrgid, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&__grmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "getgrgid", __nsdefaultcompat,
+	    &retval, gid);
+	mutex_unlock(&__grmutex);
+	return (rv == NS_SUCCESS) ? retval : NULL;
+}
+
+int
+getgrgid_r(gid_t gid, struct group *grp, char *buffer, size_t buflen,
+	struct group **result)
+{
+	int	rv, retval;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgrgid_r, NULL)
+		NS_DNS_CB(_dns_getgrgid_r, NULL)
+		NS_NIS_CB(_nis_getgrgid_r, NULL)
+		NS_COMPAT_CB(_compat_getgrgid_r, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	retval = 0;
+	mutex_lock(&__grmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "getgrgid_r", __nsdefaultcompat,
+	    &retval, gid, grp, buffer, buflen, result);
+	mutex_unlock(&__grmutex);
+	switch (rv) {
+	case NS_SUCCESS:
+	case NS_NOTFOUND:
+		return 0;
+	default:
+		return retval;
+	}
+}
+
+struct group *
+getgrnam(const char *name)
+{
+	int		rv;
+	struct group	*retval;
+
+//	log_info("getgrnam");
+
+	return NULL; /* FIXME */
+	/* FIXME: FIXME: */
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgrnam, NULL)
+		NS_DNS_CB(_dns_getgrnam, NULL)
+		NS_NIS_CB(_nis_getgrnam, NULL)
+		NS_COMPAT_CB(_compat_getgrnam, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&__grmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "getgrnam", __nsdefaultcompat,
+	    &retval, name);
+	mutex_unlock(&__grmutex);
+	return (rv == NS_SUCCESS) ? retval : NULL;
+}
+
+int
+getgrnam_r(const char *name, struct group *grp, char *buffer, size_t buflen,
+	struct group **result)
+{
+	int	rv, retval;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgrnam_r, NULL)
+		NS_DNS_CB(_dns_getgrnam_r, NULL)
+		NS_NIS_CB(_nis_getgrnam_r, NULL)
+		NS_COMPAT_CB(_compat_getgrnam_r, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(name != NULL);
+	_DIAGASSERT(grp != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	retval = 0;
+	mutex_lock(&__grmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "getgrnam_r", __nsdefaultcompat,
+	    &retval, name, grp, buffer, buflen, result);
+	mutex_unlock(&__grmutex);
+	switch (rv) {
+	case NS_SUCCESS:
+	case NS_NOTFOUND:
+		return 0;
+	default:
+		return retval;
+	}
+}
+
+void
+endgrent(void)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_endgrent, NULL)
+		NS_DNS_CB(_dns_endgrent, NULL)
+		NS_NIS_CB(_nis_endgrent, NULL)
+		NS_COMPAT_CB(_compat_endgrent, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&__grmutex);
+					/* force all endgrent() methods */
+	(void) nsdispatch(NULL, dtab, NSDB_GROUP, "endgrent",
+	    __nsdefaultcompat_forceall);
+	mutex_unlock(&__grmutex);
+}
+
+int
+setgroupent(int stayopen)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_setgroupent, NULL)
+		NS_DNS_CB(_dns_setgroupent, NULL)
+		NS_NIS_CB(_nis_setgroupent, NULL)
+		NS_COMPAT_CB(_compat_setgroupent, NULL)
+		NS_NULL_CB
+	};
+	int	rv, retval;
+
+	mutex_lock(&__grmutex);
+					/* force all setgroupent() methods */
+	rv = nsdispatch(NULL, dtab, NSDB_GROUP, "setgroupent",
+	    __nsdefaultcompat_forceall, &retval, stayopen);
+	mutex_unlock(&__grmutex);
+	return (rv == NS_SUCCESS) ? retval : 0;
+}
+
+void
+setgrent(void)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_setgrent, NULL)
+		NS_DNS_CB(_dns_setgrent, NULL)
+		NS_NIS_CB(_nis_setgrent, NULL)
+		NS_COMPAT_CB(_compat_setgrent, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&__grmutex);
+					/* force all setgrent() methods */
+	(void) nsdispatch(NULL, dtab, NSDB_GROUP, "setgrent",
+	    __nsdefaultcompat_forceall);
+	mutex_unlock(&__grmutex);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getgrouplist.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getgrouplist.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getgrouplist.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getgrouplist.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,70 @@
+/*	$NetBSD: getgrouplist.c,v 1.22 2008/04/28 20:22:59 martin Exp $	*/
+
+/*-
+ * Copyright (c) 2004-2005 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)getgrouplist.c	8.2 (Berkeley) 12/8/94";
+#else
+__RCSID("$NetBSD: getgrouplist.c,v 1.22 2008/04/28 20:22:59 martin Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+/*
+ * calculate group access list
+ */
+
+#include "namespace.h"
+#include <sys/param.h>
+
+#include <assert.h>
+//#include <nsswitch.h>
+#include <stdarg.h>
+#include <unistd.h>
+
+#ifdef __weak_alias
+__weak_alias(getgrouplist,_getgrouplist)
+#endif
+
+int
+getgrouplist(const char *uname, gid_t agroup, gid_t *groups, int *grpcnt)
+{
+	int	rv, groupc;
+
+	_DIAGASSERT(uname != NULL);
+	/* groups may be NULL if just sizing when invoked with *grpcnt = 0 */
+	_DIAGASSERT(grpcnt != NULL);
+
+	groupc = 0;
+	rv = getgroupmembership(uname, agroup, groups, *grpcnt, &groupc);
+	*grpcnt = groupc;	/* set groupc to the actual # of groups */
+	return rv;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getgroupmembership.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getgroupmembership.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getgroupmembership.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getgroupmembership.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,406 @@
+/*	$NetBSD: getgroupmembership.c,v 1.4 2008/04/28 20:22:59 martin Exp $	*/
+
+/*-
+ * Copyright (c) 2004-2005 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: getgroupmembership.c,v 1.4 2008/04/28 20:22:59 martin Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+/*
+ * calculate group access list
+ */
+
+#include "namespace.h"
+#include "reentrant.h"
+
+#include <sys/param.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <grp.h>
+#include <limits.h>
+#include <nsswitch.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/unistd.h>
+
+#ifdef HESIOD
+#include <hesiod.h>
+#endif
+
+#include "gr_private.h"
+
+#ifdef __weak_alias
+__weak_alias(getgroupmembership,_getgroupmembership)
+#endif
+
+/*
+ * __gr_addgid
+ *	Add gid to the groups array (of maxgrp size) at the position
+ *	indicated by *groupc, unless it already exists or *groupc is
+ *	past &groups[maxgrp].
+ *	Returns 1 upon success (including duplicate suppression), 0 otherwise.
+ */
+static int
+__gr_addgid(gid_t gid, gid_t *groups, int maxgrp, int *groupc)
+{
+	int	ret, dupc;
+
+	_DIAGASSERT(groupc != NULL);
+	_DIAGASSERT(groups != NULL);
+
+						/* skip duplicates */
+	for (dupc = 0; dupc < MIN(maxgrp, *groupc); dupc++) {
+		if (groups[dupc] == gid)
+			return 1;
+	}
+
+	ret = 1;
+	if (*groupc < maxgrp)			/* add this gid */
+		groups[*groupc] = gid;
+	else
+		ret = 0;
+	(*groupc)++;
+	return ret;
+}
+
+
+/*ARGSUSED*/
+static int
+_files_getgroupmembership(void *retval, void *cb_data, va_list ap)
+{
+	int		*result	= va_arg(ap, int *);
+	const char 	*uname	= va_arg(ap, const char *);
+	gid_t		 agroup	= va_arg(ap, gid_t);
+	gid_t		*groups	= va_arg(ap, gid_t *);
+	int		 maxgrp	= va_arg(ap, int);
+	int		*groupc	= va_arg(ap, int *);
+
+	struct __grstate_files	state;
+	struct group		grp;
+	char			grpbuf[_SC_GETGR_R_SIZE_MAX];
+	int			rv, i;
+
+	_DIAGASSERT(result != NULL);
+	_DIAGASSERT(uname != NULL);
+	/* groups may be NULL if just sizing when invoked with maxgrp = 0 */
+	_DIAGASSERT(groupc != NULL);
+
+						/* install primary group */
+	(void) __gr_addgid(agroup, groups, maxgrp, groupc);
+
+	memset(&state, 0, sizeof(state));
+	while (__grscan_files(&rv, &grp, grpbuf, sizeof(grpbuf), &state,
+				0, NULL, 0) == NS_SUCCESS) {
+						/* scan members */
+		for (i = 0; grp.gr_mem[i]; i++) {
+			if (strcmp(grp.gr_mem[i], uname) != 0)
+				continue;
+			if (! __gr_addgid(grp.gr_gid, groups, maxgrp, groupc))
+				*result = -1;
+			break;
+		}
+	}
+	__grend_files(&state);
+	return NS_NOTFOUND;
+}
+
+
+#ifdef HESIOD
+
+/*ARGSUSED*/
+static int
+_dns_getgroupmembership(void *retval, void *cb_data, va_list ap)
+{
+	int		*result	= va_arg(ap, int *);
+	const char 	*uname	= va_arg(ap, const char *);
+	gid_t		 agroup	= va_arg(ap, gid_t);
+	gid_t		*groups	= va_arg(ap, gid_t *);
+	int		 maxgrp	= va_arg(ap, int);
+	int		*groupc	= va_arg(ap, int *);
+
+	struct __grstate_dns	state;
+	struct group		grp;
+	char			grpbuf[_SC_GETGR_R_SIZE_MAX];
+	unsigned long		id;
+	void			*context;
+	char			**hp, *cp, *ep;
+	int			rv, i;
+
+	_DIAGASSERT(result != NULL);
+	_DIAGASSERT(uname != NULL);
+	/* groups may be NULL if just sizing when invoked with maxgrp = 0 */
+	_DIAGASSERT(groupc != NULL);
+
+						/* install primary group */
+	(void) __gr_addgid(agroup, groups, maxgrp, groupc);
+
+	hp = NULL;
+	rv = NS_NOTFOUND;
+
+	if (hesiod_init(&context) == -1)		/* setup hesiod */
+		return NS_UNAVAIL;
+
+	hp = hesiod_resolve(context, uname, "grplist");	/* find grplist */
+	if (hp == NULL) {
+		if (errno != ENOENT) {			/* wasn't "not found"*/
+			rv = NS_UNAVAIL;
+			goto dnsgroupmembers_out;
+		}
+			/* grplist not found, fallback to _dns_grscan */
+		memset(&state, 0, sizeof(state));
+		while (__grscan_dns(&rv, &grp, grpbuf, sizeof(grpbuf), &state,
+					0, NULL, 0) == NS_SUCCESS) {
+							/* scan members */
+			for (i = 0; grp.gr_mem[i]; i++) {
+				if (strcmp(grp.gr_mem[i], uname) != 0)
+					continue;
+				if (! __gr_addgid(grp.gr_gid, groups, maxgrp,
+				    groupc))
+					*result = -1;
+				break;
+			}
+		}
+		__grend_dns(&state);
+		rv = NS_NOTFOUND;
+		goto dnsgroupmembers_out;
+	}
+
+	if ((ep = strchr(hp[0], '\n')) != NULL)
+		*ep = '\0';				/* clear trailing \n */
+
+	for (cp = hp[0]; *cp != '\0'; ) {		/* parse grplist */
+		if ((cp = strchr(cp, ':')) == NULL)	/* skip grpname */
+			break;
+		cp++;
+		id = strtoul(cp, &ep, 10);		/* parse gid */
+		if (id > GID_MAX || (*ep != ':' && *ep != '\0')) {
+			rv = NS_UNAVAIL;
+			goto dnsgroupmembers_out;
+		}
+		cp = ep;
+		if (*cp == ':')
+			cp++;
+
+							/* add gid */
+		if (! __gr_addgid((gid_t)id, groups, maxgrp, groupc))
+			*result = -1;
+	}
+
+	rv = NS_NOTFOUND;
+
+ dnsgroupmembers_out:
+	if (hp)
+		hesiod_free_list(context, hp);
+	hesiod_end(context);
+	return rv;
+}
+
+#endif /* HESIOD */
+
+
+#ifdef YP
+
+/*ARGSUSED*/
+static int
+_nis_getgroupmembership(void *retval, void *cb_data, va_list ap)
+{
+	int		*result	= va_arg(ap, int *);
+	const char 	*uname	= va_arg(ap, const char *);
+	gid_t		 agroup	= va_arg(ap, gid_t);
+	gid_t		*groups	= va_arg(ap, gid_t *);
+	int		 maxgrp	= va_arg(ap, int);
+	int		*groupc	= va_arg(ap, int *);
+
+	struct __grstate_nis	state;
+	struct group		grp;
+	char			grpbuf[_SC_GETGR_R_SIZE_MAX];
+	int			rv, i;
+
+	_DIAGASSERT(result != NULL);
+	_DIAGASSERT(uname != NULL);
+	/* groups may be NULL if just sizing when invoked with maxgrp = 0 */
+	_DIAGASSERT(groupc != NULL);
+
+						/* install primary group */
+	(void) __gr_addgid(agroup, groups, maxgrp, groupc);
+
+	memset(&state, 0, sizeof(state));
+	while (__grscan_nis(&rv, &grp, grpbuf, sizeof(grpbuf), &state,
+				0, NULL, 0) == NS_SUCCESS) {
+						/* scan members */
+		for (i = 0; grp.gr_mem[i]; i++) {
+			if (strcmp(grp.gr_mem[i], uname) != 0)
+				continue;
+			if (! __gr_addgid(grp.gr_gid, groups, maxgrp, groupc))
+				*result = -1;
+			break;
+		}
+	}
+	__grend_nis(&state);
+
+	return NS_NOTFOUND;
+}
+
+#endif /* YP */
+
+
+#ifdef _GROUP_COMPAT
+
+struct __compatggm {
+	const char	*uname;		/* user to search for */
+	gid_t		*groups;
+	gid_t		 agroup;
+	int		 maxgrp;
+	int		*groupc;
+};
+
+static int
+_compat_ggm_search(void *cookie, struct group **groupres)
+{
+	struct __compatggm	*cp;
+	int			rerror, crv;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(__grbad_compat, "files")
+		NS_DNS_CB(_dns_getgroupmembership, NULL)
+		NS_NIS_CB(_nis_getgroupmembership, NULL)
+		NS_COMPAT_CB(__grbad_compat, "compat")
+		NS_NULL_CB
+	};
+
+	*groupres = NULL;	/* we don't care about this */
+	cp = (struct __compatggm *)cookie;
+
+	crv = nsdispatch(NULL, dtab,
+	    NSDB_GROUP_COMPAT, "getgroupmembership",
+	    __nsdefaultnis,
+	    &rerror, cp->uname, cp->agroup, cp->groups, cp->maxgrp, cp->groupc);
+
+	if (crv == NS_SUCCESS)
+		crv = NS_NOTFOUND;	/* indicate "no more +: entries" */
+
+	return crv;
+}
+
+/* ARGSUSED */
+static int
+_compat_getgroupmembership(void *retval, void *cb_data, va_list ap)
+{
+	int		*result	= va_arg(ap, int *);
+	const char 	*uname	= va_arg(ap, const char *);
+	gid_t		 agroup	= va_arg(ap, gid_t);
+	gid_t		*groups	= va_arg(ap, gid_t *);
+	int		 maxgrp	= va_arg(ap, int);
+	int		*groupc	= va_arg(ap, int *);
+
+	struct __grstate_compat	state;
+	struct __compatggm	ggmstate;
+	struct group		grp;
+	char			grpbuf[_SC_GETGR_R_SIZE_MAX];
+	int			rv, i;
+
+	_DIAGASSERT(result != NULL);
+	_DIAGASSERT(uname != NULL);
+	/* groups may be NULL if just sizing when invoked with maxgrp = 0 */
+	_DIAGASSERT(groupc != NULL);
+
+						/* install primary group */
+	(void) __gr_addgid(agroup, groups, maxgrp, groupc);
+
+	memset(&state, 0, sizeof(state));
+	memset(&ggmstate, 0, sizeof(ggmstate));
+	ggmstate.uname = uname;
+	ggmstate.groups = groups;
+	ggmstate.agroup = agroup;
+	ggmstate.maxgrp = maxgrp;
+	ggmstate.groupc = groupc;
+
+	while (__grscan_compat(&rv, &grp, grpbuf, sizeof(grpbuf), &state,
+				0, NULL, 0, _compat_ggm_search, &ggmstate)
+		== NS_SUCCESS) {
+						/* scan members */
+		for (i = 0; grp.gr_mem[i]; i++) {
+			if (strcmp(grp.gr_mem[i], uname) != 0)
+				continue;
+			if (! __gr_addgid(grp.gr_gid, groups, maxgrp, groupc))
+				*result = -1;
+			break;
+		}
+	}
+
+	__grend_compat(&state);
+	return NS_NOTFOUND;
+}
+
+#endif	/* _GROUP_COMPAT */
+
+
+int
+getgroupmembership(const char *uname, gid_t agroup,
+    gid_t *groups, int maxgrp, int *groupc)
+{
+	int	rerror;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getgroupmembership, NULL)
+		NS_DNS_CB(_dns_getgroupmembership, NULL)
+		NS_NIS_CB(_nis_getgroupmembership, NULL)
+		NS_COMPAT_CB(_compat_getgroupmembership, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(uname != NULL);
+	/* groups may be NULL if just sizing when invoked with maxgrp = 0 */
+	_DIAGASSERT(groupc != NULL);
+
+	*groupc = 0;
+
+	mutex_lock(&__grmutex);
+			/*
+			 * Call each backend.
+			 * For compatibility with getgrent(3) semantics,
+			 * a backend should return NS_NOTFOUND even upon
+			 * completion, to allow result merging to occur.
+			 */
+	(void) nsdispatch(NULL, dtab, NSDB_GROUP, "getgroupmembership",
+	    __nsdefaultcompat,
+	    &rerror, uname, agroup, groups, maxgrp, groupc);
+	mutex_unlock(&__grmutex);
+
+	if (*groupc > maxgrp)			/* too many groups found */
+		return -1;
+	else
+		return 0;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/gethostname.c third_party/newlib-4.1.0/newlib/libc/sys/arm/gethostname.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/gethostname.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/gethostname.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,62 @@
+/*	$NetBSD: gethostname.c,v 1.13 2012/06/25 22:32:43 abs Exp $	*/
+
+/*
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)gethostname.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: gethostname.c,v 1.13 2012/06/25 22:32:43 abs Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <sys/param.h>
+//#include <sys/sysctl.h>
+
+#include <assert.h>
+#include <errno.h>
+#include <unistd.h>
+
+#ifdef __weak_alias
+__weak_alias(gethostname,_gethostname)
+#endif
+
+int
+gethostname(char *name, size_t namelen)
+{
+	if(namelen < 8) {
+		return -1;
+	}
+	
+	strcpy(name, "Cheviot");
+	return 0;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/__getlogin.c third_party/newlib-4.1.0/newlib/libc/sys/arm/__getlogin.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/__getlogin.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/__getlogin.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,29 @@
+/*  getlogin(3)
+ *
+ *  Author: Terrence W. Holm          Aug. 1988
+ */
+
+#include <sys/cdefs.h>
+#include "namespace.h"
+//#include <lib.h>
+
+#include <pwd.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdio.h>
+//#include "extern.h"
+
+
+
+int __getlogin(char *logname, size_t sz)
+{
+  struct passwd *pw_entry;
+
+  pw_entry = getpwuid(getuid());
+
+  if (pw_entry == (struct passwd *)NULL)
+    return 0; 
+    
+  strncpy(logname, pw_entry->pw_name, sz);
+  return sz;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getlogin.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getlogin.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getlogin.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getlogin.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,138 @@
+/*	$NetBSD: getlogin.c,v 1.15 2009/01/11 02:46:27 christos Exp $	*/
+
+/*-
+ * Copyright (c) 2008 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)getlogin.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: getlogin.c,v 1.15 2009/01/11 02:46:27 christos Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <sys/param.h>
+#include <pwd.h>
+#include <utmp.h>
+#include <stdio.h>
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+#include "reentrant.h"
+#include "extern.h"
+
+#ifdef __weak_alias
+__weak_alias(getlogin,_getlogin)
+__weak_alias(getlogin_r,_getlogin_r)
+#if !defined(__cheviotos)
+__weak_alias(setlogin,_setlogin)
+#endif /* !defined(__minix) */
+#endif
+
+int	__logname_valid;		/* known to setlogin() */
+static char logname[MAXLOGNAME + 1];
+
+#ifdef _REENTRANT
+static mutex_t	logname_mutex = MUTEX_INITIALIZER;
+#endif
+
+char *
+getlogin(void)
+{
+	char *rv;
+
+	mutex_lock(&logname_mutex);
+	if (__logname_valid == 0) {
+		if (__getlogin(logname, sizeof(logname) - 1) < 0) {
+			mutex_unlock(&logname_mutex);
+			return ((char *)NULL);
+		}
+		__logname_valid = 1;
+	}
+	rv = (*logname ? logname : (char *)NULL);
+	mutex_unlock(&logname_mutex);
+
+	return rv;
+}
+
+int
+getlogin_r(char *name, size_t namelen)
+{
+	size_t len;
+	int rv;
+
+	mutex_lock(&logname_mutex);
+	if (__logname_valid == 0) {
+		if (__getlogin(logname, sizeof(logname) - 1) < 0) {
+			rv = errno;
+			mutex_unlock(&logname_mutex);
+			return (rv);
+		}
+		__logname_valid = 1;
+	}
+	len = strlen(logname) + 1;
+	if (len > namelen) {
+		rv = ERANGE;
+	} else {
+		strncpy(name, logname, len);
+		rv = 0;
+	}
+	mutex_unlock(&logname_mutex);
+
+	return (rv);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getnetgrent.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getnetgrent.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getnetgrent.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getnetgrent.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,990 @@
+/*	$NetBSD: getnetgrent.c,v 1.42 2012/03/20 16:36:05 matt Exp $	*/
+
+/*
+ * Copyright (c) 1994 Christos Zoulas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: getnetgrent.c,v 1.42 2012/03/20 16:36:05 matt Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <sys/types.h>
+
+#include <assert.h>
+#include <ctype.h>
+#include <db.h>
+#include <err.h>
+#include <fcntl.h>
+#define _NETGROUP_PRIVATE
+#include <stringlist.h>
+#include <netgroup.h>
+#include <nsswitch.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef YP
+#include <rpc/rpc.h>
+#include <rpcsvc/ypclnt.h>
+#include <rpcsvc/yp_prot.h>
+#endif
+
+#ifdef __weak_alias
+__weak_alias(endnetgrent,_endnetgrent)
+__weak_alias(getnetgrent,_getnetgrent)
+__weak_alias(innetgr,_innetgr)
+__weak_alias(setnetgrent,_setnetgrent)
+#endif
+
+#define _NG_STAR(s)	(((s) == NULL || *(s) == '\0') ? _ngstar : s)
+#define _NG_EMPTY(s)	((s) == NULL ? "" : s)
+#define _NG_ISSPACE(p)	(isspace((unsigned char) (p)) || (p) == '\n')
+
+static const char _ngstar[] = "*";
+static struct netgroup *_nghead = NULL;
+static struct netgroup *_nglist = NULL;
+static DB *_ng_db;
+
+static int getstring(char **, int, __aconst char **);
+static struct netgroup *getnetgroup(char **);
+static int lookup(char *, char **, int);
+static int addgroup(StringList *, char *);
+static int in_check(const char *, const char *, const char *,
+    struct netgroup *);
+static int in_find(StringList *, char *, const char *, const char *,
+    const char *);
+static char *in_lookup1(const char *, const char *, int);
+static int in_lookup(const char *, const char *, const char *, int);
+
+#ifdef NSSRC_FILES
+static const ns_src default_files_nis[] = {
+	{ NSSRC_FILES,	NS_SUCCESS | NS_NOTFOUND },
+#ifdef YP
+	{ NSSRC_NIS,	NS_SUCCESS },
+#endif
+	{ 0, 0 },
+};
+#endif
+
+/*
+ * getstring(): Get a string delimited by the character, skipping leading and
+ * trailing blanks and advancing the pointer
+ */
+static int
+getstring(char **pp, int del, char __aconst **str)
+{
+	size_t len;
+	char *sp, *ep, *dp;
+
+	_DIAGASSERT(pp != NULL);
+	_DIAGASSERT(str != NULL);
+
+	/* skip leading blanks */
+	for (sp = *pp; *sp && _NG_ISSPACE(*sp); sp++)
+		continue;
+
+	/* accumulate till delimiter or space */
+	for (ep = sp; *ep && *ep != del && !_NG_ISSPACE(*ep); ep++)
+		continue;
+
+	/* hunt for the delimiter */
+	for (dp = ep; *dp && *dp != del && _NG_ISSPACE(*dp); dp++)
+		continue;
+
+	if (*dp != del) {
+		*str = NULL;
+		return 0;
+	}
+
+	*pp = ++dp;
+
+	len = (ep - sp) + 1;
+	if (len > 1) {
+		dp = malloc(len);
+		if (dp == NULL)
+			return 0;
+		(void)memcpy(dp, sp, len);
+		dp[len - 1] = '\0';
+	} else
+		dp = NULL;
+
+	*str = dp;
+	return 1;
+}
+
+
+/*
+ * getnetgroup(): Parse a netgroup, and advance the pointer
+ */
+static struct netgroup *
+getnetgroup(char **pp)
+{
+	struct netgroup *ng;
+
+	_DIAGASSERT(pp != NULL);
+	_DIAGASSERT(*pp != NULL);
+
+	ng = malloc(sizeof(struct netgroup));
+	if (ng == NULL)
+		return NULL;
+
+	(*pp)++;	/* skip '(' */
+	if (!getstring(pp, ',', &ng->ng_host))
+		goto badhost;
+
+	if (!getstring(pp, ',', &ng->ng_user))
+		goto baduser;
+
+	if (!getstring(pp, ')', &ng->ng_domain))
+		goto baddomain;
+
+#ifdef DEBUG_NG
+	{
+		char buf[1024];
+		(void) fprintf(stderr, "netgroup %s\n",
+		    _ng_print(buf, sizeof(buf), ng));
+	}
+#endif
+	return ng;
+
+baddomain:
+	if (ng->ng_user)
+		free(ng->ng_user);
+baduser:
+	if (ng->ng_host)
+		free(ng->ng_host);
+badhost:
+	free(ng);
+	return NULL;
+}
+
+void
+_ng_cycle(const char *grp, const StringList *sl)
+{
+	size_t i;
+	warnx("netgroup: Cycle in group `%s'", grp);
+	(void)fprintf(stderr, "groups: ");
+	for (i = 0; i < sl->sl_cur; i++)
+		(void)fprintf(stderr, "%s ", sl->sl_str[i]);
+	(void)fprintf(stderr, "\n");
+}
+
+static int _local_lookup(void *, void *, va_list);
+
+/*ARGSUSED*/
+static int
+_local_lookup(void *rv, void *cb_data, va_list ap)
+{
+	char	 *name = va_arg(ap, char *);
+	char	**line = va_arg(ap, char **);
+	int	  bywhat = va_arg(ap, int);
+
+	DBT	 key, data;
+	size_t	 len;
+	char	*ks;
+	int	 r;
+
+	if (_ng_db == NULL)
+		return NS_UNAVAIL;
+
+	len = strlen(name) + 2;
+	ks = malloc(len);
+	if (ks == NULL)
+		return NS_UNAVAIL;
+
+	ks[0] = bywhat;
+	(void)memcpy(&ks[1], name, len - 1);
+
+	key.data = (u_char *)ks;
+	key.size = len;
+
+	r = (*_ng_db->get)(_ng_db, &key, &data, 0);
+	free(ks);
+	switch (r) {
+	case 0:
+		break;
+	case 1:
+		return NS_NOTFOUND;
+	case -1:
+			/* XXX: call endnetgrent() here ? */
+		return NS_UNAVAIL;
+	}
+
+	*line = strdup(data.data);
+	if (*line == NULL)
+		return NS_UNAVAIL;
+	return NS_SUCCESS;
+}
+
+#ifdef YP
+static int _nis_lookup(void *, void *, va_list);
+
+/*ARGSUSED*/
+static int
+_nis_lookup(void *rv, void *cb_data, va_list ap)
+{
+	char	 *name = va_arg(ap, char *);
+	char	**line = va_arg(ap, char **);
+	int	  bywhat = va_arg(ap, int);
+
+	static char	*__ypdomain;
+	int              i;
+	const char      *map = NULL;
+
+	if(__ypdomain == NULL) {
+		switch (yp_get_default_domain(&__ypdomain)) {
+		case 0:
+			break;
+		case YPERR_RESRC:
+			return NS_TRYAGAIN;
+		default:
+			return NS_UNAVAIL;
+		}
+	}
+
+	switch (bywhat) {
+	case _NG_KEYBYNAME:
+		map = "netgroup";
+		break;
+
+	case _NG_KEYBYUSER:
+		map = "netgroup.byuser";
+		break;
+
+	case _NG_KEYBYHOST:
+		map = "netgroup.byhost";
+		break;
+
+	default:
+		abort();
+	}
+
+	*line = NULL;
+	switch (yp_match(__ypdomain, map, name, (int)strlen(name), line, &i)) {
+	case 0:
+		return NS_SUCCESS;
+	case YPERR_KEY:
+		if (*line)
+			free(*line);
+		return NS_NOTFOUND;
+	default:
+		if (*line)
+			free(*line);
+		return NS_UNAVAIL;
+	}
+	/* NOTREACHED */
+}
+#endif
+
+#ifdef NSSRC_FILES
+/*
+ * lookup(): Find the given key in the database or yp, and return its value
+ * in *line; returns 1 if key was found, 0 otherwise
+ */
+static int
+lookup(char *name, char	**line, int bywhat)
+{
+	int		r;
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_local_lookup, NULL)
+		NS_NIS_CB(_nis_lookup, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(name != NULL);
+	_DIAGASSERT(line != NULL);
+
+	r = nsdispatch(NULL, dtab, NSDB_NETGROUP, "lookup", default_files_nis,
+	    name, line, bywhat);
+	return (r == NS_SUCCESS) ? 1 : 0;
+}
+#else
+static int
+_local_lookupv(int *rv, void *cbdata, ...)
+{
+	int e;
+	va_list ap;
+	va_start(ap, cbdata);
+	e = _local_lookup(rv, cbdata, ap);
+	va_end(ap);
+	return e;
+}
+
+static int
+lookup(name, line, bywhat)
+	char	 *name;
+	char	**line;
+	int	  bywhat;
+{
+	return _local_lookupv(NULL, NULL, name, line, bywhat) == NS_SUCCESS;
+}
+#endif
+
+/*
+ * _ng_parse(): Parse a line and return: _NG_ERROR: Syntax Error _NG_NONE:
+ * line was empty or a comment _NG_GROUP: line had a netgroup definition,
+ * returned in ng _NG_NAME:  line had a netgroup name, returned in name
+ * 
+ * Public since used by netgroup_mkdb
+ */
+int
+_ng_parse(char **p, char **name, struct netgroup **ng)
+{
+
+	_DIAGASSERT(p != NULL);
+	_DIAGASSERT(*p != NULL);
+	_DIAGASSERT(name != NULL);
+	_DIAGASSERT(ng != NULL);
+
+	while (**p) {
+		if (**p == '#')
+			/* comment */
+			return _NG_NONE;
+
+		while (**p && _NG_ISSPACE(**p))
+			/* skipblank */
+			(*p)++;
+
+		if (**p == '(') {
+			if ((*ng = getnetgroup(p)) == NULL)
+				return _NG_ERROR;
+			return _NG_GROUP;
+		} else {
+			char	*np;
+			size_t	i;
+
+			for (np = *p; **p && !_NG_ISSPACE(**p); (*p)++)
+				continue;
+			if (np != *p) {
+				i = (*p - np) + 1;
+				*name = malloc(i);
+				if (*name == NULL)
+					return _NG_ERROR;
+				(void)memcpy(*name, np, i);
+				(*name)[i - 1] = '\0';
+				return _NG_NAME;
+			}
+		}
+	}
+	return _NG_NONE;
+}
+
+
+/*
+ * addgroup(): Recursively add all the members of the netgroup to this group.
+ * returns 0 upon failure, nonzero upon success.
+ * grp is not a valid pointer after return (either free(3)ed or allocated
+ * to a stringlist). in either case, it shouldn't be used again.
+ */
+static int
+addgroup(StringList *sl, char *grp)
+{
+	char		*line, *p;
+	struct netgroup	*ng;
+	char		*name;
+
+	_DIAGASSERT(sl != NULL);
+	_DIAGASSERT(grp != NULL);
+
+#ifdef DEBUG_NG
+	(void)fprintf(stderr, "addgroup(%s)\n", grp);
+#endif
+	/* check for cycles */
+	if (sl_find(sl, grp) != NULL) {
+		_ng_cycle(grp, sl);
+		free(grp);
+		return 0;
+	}
+	if (sl_add(sl, grp) == -1) {
+		free(grp);
+		return 0;
+	}
+
+	/* Lookup this netgroup */
+	line = NULL;
+	if (!lookup(grp, &line, _NG_KEYBYNAME)) {
+		if (line)
+			free(line);
+		return 0;
+	}
+
+	p = line;
+
+	for (;;) {
+		switch (_ng_parse(&p, &name, &ng)) {
+		case _NG_NONE:
+			/* Done with the line */
+			free(line);
+			return 1;
+
+		case _NG_GROUP:
+			/* new netgroup */
+			/* add to the list */
+			ng->ng_next = _nglist;
+			_nglist = ng;
+			break;
+
+		case _NG_NAME:
+			/* netgroup name */
+			if (!addgroup(sl, name))
+				return 0;
+			break;
+
+		case _NG_ERROR:
+			return 0;
+
+		default:
+			abort();
+		}
+	}
+}
+
+
+/*
+ * in_check(): Compare the spec with the netgroup
+ */
+static int
+in_check(const char *host, const char *user, const char *domain,
+    struct netgroup *ng)
+{
+
+	/* host may be NULL */
+	/* user may be NULL */
+	/* domain may be NULL */
+	_DIAGASSERT(ng != NULL);
+
+	if ((host != NULL) && (ng->ng_host != NULL)
+	    && strcmp(ng->ng_host, host) != 0)
+		return 0;
+
+	if ((user != NULL) && (ng->ng_user != NULL)
+	    && strcmp(ng->ng_user, user) != 0)
+		return 0;
+
+	if ((domain != NULL) && (ng->ng_domain != NULL)
+	    && strcmp(ng->ng_domain, domain) != 0)
+		return 0;
+
+	return 1;
+}
+
+
+/*
+ * in_find(): Find a match for the host, user, domain spec.
+ * grp is not a valid pointer after return (either free(3)ed or allocated
+ * to a stringlist). in either case, it shouldn't be used again.
+ */
+static int
+in_find(StringList *sl, char *grp, const char *host, const char *user,
+    const char *domain)
+{
+	char		*line, *p;
+	int		 i;
+	struct netgroup	*ng;
+	char		*name;
+
+	_DIAGASSERT(sl != NULL);
+	_DIAGASSERT(grp != NULL);
+	/* host may be NULL */
+	/* user may be NULL */
+	/* domain may be NULL */
+
+#ifdef DEBUG_NG
+	(void)fprintf(stderr, "in_find(%s)\n", grp);
+#endif
+	/* check for cycles */
+	if (sl_find(sl, grp) != NULL) {
+		_ng_cycle(grp, sl);
+		free(grp);
+		return 0;
+	}
+	if (sl_add(sl, grp) == -1) {
+		free(grp);
+		return 0;
+	}
+
+	/* Lookup this netgroup */
+	line = NULL;
+	if (!lookup(grp, &line, _NG_KEYBYNAME)) {
+		if (line)
+			free(line);
+		return 0;
+	}
+
+	p = line;
+
+	for (;;) {
+		switch (_ng_parse(&p, &name, &ng)) {
+		case _NG_NONE:
+			/* Done with the line */
+			free(line);
+			return 0;
+
+		case _NG_GROUP:
+			/* new netgroup */
+			i = in_check(host, user, domain, ng);
+			if (ng->ng_host != NULL)
+				free(ng->ng_host);
+			if (ng->ng_user != NULL)
+				free(ng->ng_user);
+			if (ng->ng_domain != NULL)
+				free(ng->ng_domain);
+			free(ng);
+			if (i) {
+				free(line);
+				return 1;
+			}
+			break;
+
+		case _NG_NAME:
+			/* netgroup name */
+			if (in_find(sl, name, host, user, domain)) {
+				free(line);
+				return 1;
+			}
+			break;
+
+		case _NG_ERROR:
+			free(line);
+			return 0;
+
+		default:
+			abort();
+		}
+	}
+}
+
+/*
+ * _ng_makekey(): Make a key from the two names given. The key is of the form
+ * <name1>.<name2> Names strings are replaced with * if they are empty;
+ * Returns NULL if there's a problem.
+ */
+char *
+_ng_makekey(const char *s1, const char *s2, size_t len)
+{
+	char *buf;
+
+	/* s1 may be NULL */
+	/* s2 may be NULL */
+
+	buf = malloc(len);
+	if (buf != NULL)
+		(void)snprintf(buf, len, "%s.%s", _NG_STAR(s1), _NG_STAR(s2));
+	return buf;
+}
+
+void
+_ng_print(char *buf, size_t len, const struct netgroup *ng)
+{
+	_DIAGASSERT(buf != NULL);
+	_DIAGASSERT(ng != NULL);
+
+	(void)snprintf(buf, len, "(%s,%s,%s)", _NG_EMPTY(ng->ng_host),
+	    _NG_EMPTY(ng->ng_user), _NG_EMPTY(ng->ng_domain));
+}
+
+
+/*
+ * in_lookup1(): Fast lookup for a key in the appropriate map
+ */
+static char *
+in_lookup1(const char *key, const char *domain, int map)
+{
+	char	*line;
+	size_t	 len;
+	char	*ptr;
+	int	 res;
+
+	/* key may be NULL */
+	/* domain may be NULL */
+
+	len = (key ? strlen(key) : 1) + (domain ? strlen(domain) : 1) + 2;
+	ptr = _ng_makekey(key, domain, len);
+	if (ptr == NULL)
+		return NULL;
+	res = lookup(ptr, &line, map);
+	free(ptr);
+	return res ? line : NULL;
+}
+
+
+/*
+ * in_lookup(): Fast lookup for a key in the appropriate map
+ */
+static int
+in_lookup(const char *group, const char *key, const char *domain, int map)
+{
+	size_t	 len;
+	char	*ptr, *line;
+
+	_DIAGASSERT(group != NULL);
+	/* key may be NULL */
+	/* domain may be NULL */
+
+	if (domain != NULL) {
+		/* Domain specified; look in "group.domain" and "*.domain" */
+		if ((line = in_lookup1(key, domain, map)) == NULL)
+			line = in_lookup1(NULL, domain, map);
+	} else 
+		line = NULL;
+
+	if (line == NULL) {
+	    /* 
+	     * domain not specified or domain lookup failed; look in
+	     * "group.*" and "*.*"
+	     */
+	    if (((line = in_lookup1(key, NULL, map)) == NULL) &&
+		((line = in_lookup1(NULL, NULL, map)) == NULL))
+		return 0;
+	}
+
+	len = strlen(group);
+
+	for (ptr = line; (ptr = strstr(ptr, group)) != NULL;)
+		/* Make sure we did not find a substring */
+		if ((ptr != line && ptr[-1] != ',') ||
+		    (ptr[len] != '\0' && strchr("\n\t ,", ptr[len]) == NULL))
+			ptr++;
+		else {
+			free(line);
+			return 1;
+		}
+
+	free(line);
+	return 0;
+}
+
+/*ARGSUSED*/
+static int
+_local_endnetgrent(void *rv, void *cb_data, va_list ap)
+{
+	for (_nglist = _nghead; _nglist != NULL; _nglist = _nghead) {
+		_nghead = _nglist->ng_next;
+		if (_nglist->ng_host != NULL)
+			free(_nglist->ng_host);
+		if (_nglist->ng_user != NULL)
+			free(_nglist->ng_user);
+		if (_nglist->ng_domain != NULL)
+			free(_nglist->ng_domain);
+		free(_nglist);
+	}
+
+	if (_ng_db) {
+		(void)(*_ng_db->close)(_ng_db);
+		_ng_db = NULL;
+	}
+
+	return NS_SUCCESS;
+}
+
+/*ARGSUSED*/
+static int
+_local_setnetgrent(void *rv, void *cb_data, va_list ap)
+{
+	const char	*ng = va_arg(ap, const char *);
+	StringList	*sl;
+	char		*ng_copy;
+
+	_DIAGASSERT(ng != NULL);
+
+	sl = sl_init();
+	if (sl == NULL)
+		return NS_TRYAGAIN;
+
+	/* Cleanup any previous storage */
+	if (_nghead != NULL)
+		endnetgrent();
+
+	if (_ng_db == NULL)
+		_ng_db = dbopen(_PATH_NETGROUP_DB, O_RDONLY, 0, DB_HASH, NULL);
+
+	ng_copy = strdup(ng);
+	if (ng_copy != NULL)
+		addgroup(sl, ng_copy);
+	_nghead = _nglist;
+	sl_free(sl, 1);
+
+	return NS_SUCCESS;
+}
+
+/*ARGSUSED*/
+static int
+_local_getnetgrent(void *rv, void *cb_data, va_list ap)
+{
+	int *retval = va_arg(ap, int *);
+	const char **host = va_arg(ap, const char **);
+	const char **user = va_arg(ap, const char **);
+	const char **domain = va_arg(ap, const char **);
+
+	_DIAGASSERT(host != NULL);
+	_DIAGASSERT(user != NULL);
+	_DIAGASSERT(domain != NULL);
+
+	*retval = 0;
+
+	if (_nglist == NULL)
+		return NS_TRYAGAIN;
+
+	*host   = _nglist->ng_host;
+	*user   = _nglist->ng_user;
+	*domain = _nglist->ng_domain;
+
+	_nglist = _nglist->ng_next;
+
+	*retval = 1;
+
+	return NS_SUCCESS;
+}
+
+/*ARGSUSED*/
+static int
+_local_innetgr(void *rv, void *cb_data, va_list ap)
+{
+	int *retval = va_arg(ap, int *);
+	const char *grp = va_arg(ap, const char *);
+	const char *host = va_arg(ap, const char *);
+	const char *user = va_arg(ap, const char *);
+	const char *domain = va_arg(ap, const char *);
+
+	int	 found;
+	StringList *sl;
+	char *grcpy;
+
+	_DIAGASSERT(grp != NULL);
+	/* host may be NULL */
+	/* user may be NULL */
+	/* domain may be NULL */
+
+	if (_ng_db == NULL)
+		_ng_db = dbopen(_PATH_NETGROUP_DB, O_RDONLY, 0, DB_HASH, NULL);
+
+	/* Try the fast lookup first */
+	if (host != NULL && user == NULL) {
+		if (in_lookup(grp, host, domain, _NG_KEYBYHOST)) {
+			*retval = 1;
+			return NS_SUCCESS;
+		}
+	} else if (host == NULL && user != NULL) {
+		if (in_lookup(grp, user, domain, _NG_KEYBYUSER)) {
+			*retval = 1;
+			return NS_SUCCESS;
+		}
+	}
+	/* If a domainname is given, we would have found a match */
+	if (domain != NULL) {
+		*retval = 0;
+		return NS_SUCCESS;
+	}
+
+	/* Too bad need the slow recursive way */
+	sl = sl_init();
+	if (sl == NULL) {
+		*retval = 0;
+		return NS_SUCCESS;
+	}
+	if ((grcpy = strdup(grp)) == NULL) {
+		sl_free(sl, 1);
+		*retval = 0;
+		return NS_SUCCESS;
+	}
+	found = in_find(sl, grcpy, host, user, domain);
+	sl_free(sl, 1);
+
+	*retval = found;
+	return NS_SUCCESS;
+}
+
+#ifdef YP
+
+/*ARGSUSED*/
+static int
+_nis_endnetgrent(void *rv, void *cb_data, va_list ap)
+{
+	return _local_endnetgrent(rv, cb_data, ap);
+}
+
+/*ARGSUSED*/
+static int
+_nis_setnetgrent(void *rv, void *cb_data, va_list ap)
+{
+	return _local_setnetgrent(rv, cb_data, ap);
+}
+
+/*ARGSUSED*/
+static int
+_nis_getnetgrent(void *rv, void *cb_data, va_list ap)
+{
+	return _local_getnetgrent(rv, cb_data, ap);
+}
+
+/*ARGSUSED*/
+static int
+_nis_innetgr(void *rv, void *cb_data, va_list ap)
+{
+	return _local_innetgr(rv, cb_data, ap);
+}
+
+#endif
+
+
+#ifdef NSSRC_FILES
+void
+endnetgrent(void)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_local_endnetgrent, NULL)
+		NS_NIS_CB(_nis_endnetgrent, NULL)
+		NS_NULL_CB
+	};
+
+	(void) nsdispatch(NULL, dtab, NSDB_NETGROUP, "endnetgrent",
+			  __nsdefaultcompat);
+}
+#else
+static int
+_local_endnetgrentv(int *rv, void *cbdata, ...)
+{
+	int e;
+	va_list ap;
+	va_start(ap, cbdata);
+	e = _local_endnetgrent(rv, cbdata, ap);
+	va_end(ap);
+	return e;
+}
+
+void
+endnetgrent(void)
+{
+	(void)_local_endnetgrentv(NULL, NULL, NULL);
+}
+#endif
+
+#ifdef NSSRC_FILES
+void
+setnetgrent(const char *ng)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_local_setnetgrent, NULL)
+		NS_NIS_CB(_nis_setnetgrent, NULL)
+		NS_NULL_CB
+	};
+
+	(void) nsdispatch(NULL, dtab, NSDB_NETGROUP, "setnetgrent",
+			   __nsdefaultnis, ng);
+}
+#else
+static int
+_local_setnetgrentv(int *rv, void *cbdata, ...)
+{
+	int e;
+	va_list ap;
+	va_start(ap, cbdata);
+	e = _local_setnetgrent(rv, cbdata, ap);
+	va_end(ap);
+	return e;
+}
+
+void
+setnetgrent(const char *ng)
+{
+	(void) _local_setnetgrentv(NULL, NULL,ng);
+}
+
+#endif
+
+#ifdef NSSRC_FILES
+int
+getnetgrent(const char **host, const char **user, const char **domain)
+{
+	int     r, retval;
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_local_getnetgrent, NULL)
+		NS_NIS_CB(_nis_getnetgrent, NULL)
+		NS_NULL_CB
+	};
+
+	r = nsdispatch(NULL, dtab, NSDB_NETGROUP, "getnetgrent",
+		       __nsdefaultnis, &retval, host, user, domain);
+
+	return (r == NS_SUCCESS) ? retval : 0;
+}
+#else
+static int
+_local_getnetgrentv(int *rv, void *cbdata, ...)
+{
+	int e;
+	va_list ap;
+	va_start(ap, cbdata);
+	e = _local_getnetgrent(rv, cbdata, ap);
+	va_end(ap);
+	return e;
+}
+
+int
+getnetgrent(const char **host, const char **user, const char **domain)
+{
+	return _local_getnetgrentv(NULL, NULL, host, user, domain) == NS_SUCCESS;
+}
+#endif
+
+#ifdef NSSRC_FILES
+int
+innetgr(const char *grp, const char *host, const char *user, 
+	const char *domain)
+{
+	int     r, retval;
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_local_innetgr, NULL)
+		NS_NIS_CB(_nis_innetgr, NULL)
+		NS_NULL_CB
+	};
+
+	r = nsdispatch(NULL, dtab, NSDB_NETGROUP, "innetgr",
+		       __nsdefaultnis, &retval, grp, host, user, domain);
+
+	return (r == NS_SUCCESS) ? retval : 0;
+}
+#else
+static int
+_local_innetgrv(int *rv, void *cbdata, ...)
+{
+	int e;
+	va_list ap;
+	va_start(ap, cbdata);
+	e = _local_innetgr(rv, cbdata, ap);
+	va_end(ap);
+	return e;
+}
+
+int
+innetgr(const char *grp, const char *host, const char *user, 
+	const char *domain)
+{
+	return _local_innetgrv(NULL, NULL, grp, host, user, domain) == NS_SUCCESS;
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getpass.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getpass.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getpass.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getpass.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,364 @@
+/*	$NetBSD: getpass.c,v 1.29 2014/09/18 13:58:20 christos Exp $	*/
+
+/*-
+ * Copyright (c) 2012 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Christos Zoulas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: getpass.c,v 1.29 2014/09/18 13:58:20 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <assert.h>
+#ifdef TEST
+#include <stdio.h>
+#endif
+#include <errno.h>
+#include <ctype.h>
+#include <signal.h>
+#include <string.h>
+#include <paths.h>
+#include <stdbool.h>
+#include <stdlib.h>
+#include <termios.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <poll.h>
+
+#define	_POSIX_VDISABLE	0xff
+#define CTRL(c)		((c) & 037)
+
+#ifdef __weak_alias
+__weak_alias(getpassfd,_getpassfd)
+__weak_alias(getpass_r,_getpass_r)
+__weak_alias(getpass,_getpass)
+#endif
+
+/*
+ * Notes:
+ *	- There is no getpass_r in POSIX
+ *	- Historically EOF is documented to be treated as EOL, we provide a
+ *	  tunable for that GETPASS_FAIL_EOF to disable this.
+ *	- Historically getpass ate extra characters silently, we provide
+ *	  a tunable for that GETPASS_BUF_LIMIT to disable this.
+ *	- Historically getpass "worked" by echoing characters when turning
+ *	  off echo failed, we provide a tunable GETPASS_NEED_TTY to
+ *	  disable this.
+ *	- Some implementations say that on interrupt the program shall
+ *	  receive an interrupt signal before the function returns. We
+ *	  send all the tty signals before we return, but we don't expect
+ *	  suspend to do something useful unless the caller calls us again.
+ *	  We also provide a tunable to disable signal delivery
+ *	  GETPASS_NO_SIGNAL.
+ *	- GETPASS_NO_BEEP disables beeping.
+ *	- GETPASS_ECHO_STAR will echo '*' for each character of the password
+ *	- GETPASS_ECHO will echo the password (as pam likes it)
+ *	- GETPASS_7BIT strips the 8th bit
+ *	- GETPASS_FORCE_UPPER forces to uppercase
+ *	- GETPASS_FORCE_LOWER forces to uppercase
+ *	- GETPASS_ECHO_NL echo's a new line on success if echo was off.
+ */
+char *
+/*ARGSUSED*/
+getpassfd(const char *prompt, char *buf, size_t len, int *fd, int flags,
+    int tout)
+{
+	struct termios gt;
+	char c;
+	int sig;
+	bool lnext, havetty, allocated, opentty, good;
+	int fdc[3];
+
+	_DIAGASSERT(prompt != NULL);
+
+	if (buf != NULL && len == 0) {
+		errno = EINVAL;
+		return NULL;
+	}
+
+	good = false;
+	opentty = false;
+	if (fd == NULL) {
+		/*
+		 * Try to use /dev/tty if possible; otherwise read from stdin
+		 * and write to stderr.
+		 */
+		fd = fdc;
+		if ((fd[0] = fd[1] = fd[2] = open(_PATH_TTY,
+		    O_RDWR | O_CLOEXEC)) == -1) {
+			fd[0] = STDIN_FILENO;
+			fd[1] = fd[2] = STDERR_FILENO;
+		} else
+			opentty = true;
+	}
+		 
+	sig = 0;
+	allocated = buf == NULL;
+	if (tcgetattr(fd[0], &gt) == -1) {
+		havetty = false;
+		if (flags & GETPASS_NEED_TTY)
+			goto out;
+		memset(&gt, -1, sizeof(gt));
+	} else
+		havetty = true;
+		
+	if (havetty) {
+		struct termios st = gt;
+
+		st.c_lflag &= ~(ECHO|ECHOK|ECHOE|ECHOKE|ECHOCTL|ISIG|ICANON);
+		st.c_cc[VMIN] = 1;
+		st.c_cc[VTIME] = 0;
+		if (tcsetattr(fd[0], TCSAFLUSH|TCSASOFT, &st) == -1)
+			goto out;
+	}
+
+	if (prompt != NULL) {
+		size_t plen = strlen(prompt);
+		(void)write(fd[1], prompt, plen);
+	}
+
+	if (allocated) {
+		len = 1024;
+		if ((buf = malloc(len)) == NULL)
+			goto restore;
+	}
+
+	c = '\1';
+	lnext = false;
+	for (size_t l = 0; c != '\0'; ) {
+		if (tout) {
+			struct pollfd pfd;
+			pfd.fd = fd[0];
+			pfd.events = POLLIN|POLLRDNORM;
+			pfd.revents = 0;
+			switch (poll(&pfd, 1, tout * 1000)) {
+			case 0:
+				errno = ETIMEDOUT;
+				/*FALLTHROUGH*/
+			case -1:
+				goto restore;
+			default:
+				break;
+			}
+		}
+		if (read(fd[0], &c, 1) != 1)
+			goto restore;
+
+#define beep() \
+	do \
+		if (flags & GETPASS_NO_BEEP) \
+			(void)write(fd[2], "\a", 1); \
+	while (/*CONSTCOND*/ 0)
+#define erase() (void)write(fd[1], "\b \b", 3)
+/*
+ * We test for both _POSIX_VDISABLE and NUL here because _POSIX_VDISABLE
+ * propagation does not seem to be very consistent on multiple daemon hops
+ * between different OS's. Perhaps we should not even bother with
+ * _POSIX_VDISABLE and use ~0 and 0 directly.
+ */
+#define C(a, b) ((gt.c_cc[(a)] == _POSIX_VDISABLE || gt.c_cc[(a)] == '\0') ? \
+    (b) : gt.c_cc[(a)])
+		if (lnext) {
+			lnext = false;
+			goto add;
+		}
+
+		/* Ignored */
+		if (c == C(VREPRINT, CTRL('r')) || c == C(VSTART, CTRL('q')) ||
+		    c == C(VSTOP, CTRL('s')) || c == C(VSTATUS, CTRL('t')) || 
+		    c == C(VDISCARD, CTRL('o')))
+			continue;
+
+		/* Literal next */
+		if (c == C(VLNEXT, CTRL('v'))) {
+			lnext = true;
+			continue;
+		}
+
+		/* Line or word kill, treat as reset */
+		if (c == C(VKILL, CTRL('u')) || c == C(VWERASE, CTRL('w'))) {
+			if (flags & (GETPASS_ECHO | GETPASS_ECHO_STAR)) {
+				while (l--)
+					erase();
+			}
+			l = 0;
+			continue;
+		}
+
+		/* Character erase */
+		if (c == C(VERASE, CTRL('h'))) {
+			if (l == 0)
+				beep();
+			else {
+				l--;
+				if (flags & (GETPASS_ECHO | GETPASS_ECHO_STAR))
+					erase();
+			}
+			continue;
+		}
+
+		/* tty signal characters */
+		if (c == C(VINTR, CTRL('c'))) {
+			sig = SIGINT;
+			goto out;
+		}
+		if (c == C(VQUIT, CTRL('\\'))) {
+			sig = SIGQUIT;
+			goto out;
+		}
+		if (c == C(VSUSP, CTRL('z')) || c == C(VDSUSP, CTRL('y'))) {
+			sig = SIGTSTP;
+			goto out;
+		}
+
+		/* EOF */
+		if (c == C(VEOF, CTRL('d')))  {
+			if (flags & GETPASS_FAIL_EOF) {
+				errno = ENODATA;
+				goto out;
+			} else {
+				c = '\0';
+				goto add;
+			}
+		}
+
+		/* End of line */
+		if (c == C(VEOL, CTRL('j')) || c == C(VEOL2, CTRL('m')))
+			c = '\0';
+add:
+		if (l >= len) {
+			if (allocated) {
+				size_t nlen = len + 1024;
+				char *nbuf = realloc(buf, nlen);
+				if (nbuf == NULL)
+					goto restore;
+				buf = nbuf;
+				len = nlen;
+			} else {
+				if (flags & GETPASS_BUF_LIMIT) {
+					beep();
+					continue;
+				}
+				if (c == '\0' && l > 0)
+					l--;
+				else
+					continue;
+			}
+		}
+
+		if (flags & GETPASS_7BIT)
+			c &= 0x7f;
+		if ((flags & GETPASS_FORCE_LOWER) && isupper((unsigned char)c))
+			c = tolower((unsigned char)c);
+		if ((flags & GETPASS_FORCE_UPPER) && islower((unsigned char)c))
+			c = toupper((unsigned char)c);
+
+		buf[l++] = c;
+		if (c) {
+			if (flags & GETPASS_ECHO_STAR)
+				(void)write(fd[1], "*", 1);
+			else if (flags & GETPASS_ECHO)
+				(void)write(fd[1], isprint((unsigned char)c) ?
+				    &c : "?", 1);
+		}
+	}
+	good = true;
+
+restore:
+	if (havetty) {
+		c = errno;
+		(void)tcsetattr(fd[0], TCSAFLUSH|TCSASOFT, &gt);
+		errno = c;
+	}
+out:
+	if (good && (flags & GETPASS_ECHO_NL))
+		(void)write(fd[1], "\n", 1);
+
+	if (opentty) {
+		c = errno;
+		(void)close(fd[0]);
+		errno = c;
+	}
+
+	if (good)
+		return buf;
+
+	if (sig) {
+		if ((flags & GETPASS_NO_SIGNAL) == 0)
+			(void)raise(sig);
+		errno = EINTR;
+	}
+	memset(buf, 0, len);
+	if (allocated)
+		free(buf);
+	return NULL;
+}
+
+char *
+getpass_r(const char *prompt, char *buf, size_t len)
+{
+	return getpassfd(prompt, buf, len, NULL, GETPASS_ECHO_NL, 0);
+}
+
+char *
+getpass(const char *prompt)
+{
+	static char e[] = "";
+	static char *buf;
+	static long bufsiz;
+	char *rv;
+
+	/*
+	 * Strictly speaking we could double allocate here, if we get
+	 * called at the same time, but this function is not re-entrant
+	 * anyway and it is not supposed to work if called concurrently.
+	 */
+	if (buf == NULL) {
+		if ((bufsiz = sysconf(_SC_PASS_MAX)) == -1)
+			return e;
+		if ((buf = malloc((size_t)bufsiz)) == NULL)
+			return e;
+	}
+
+	if ((rv = getpass_r(prompt, buf, (size_t)bufsiz)) == NULL)
+		return e;
+
+	return rv;
+}
+
+#ifdef TEST
+int
+main(int argc, char *argv[])
+{
+	char buf[28];
+	printf("[%s]\n", getpassfd("foo>", buf, sizeof(buf), NULL,
+	    GETPASS_ECHO_STAR|GETPASS_ECHO_NL, 2));
+	return 0;
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getpid.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getpid.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getpid.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getpid.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,33 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+pid_t getpid(void)
+{
+    pid_t pid;
+    
+    pid = _swi_getpid();
+
+    return pid;
+}
+
+
+/*
+ *
+ */
+pid_t getppid(void)
+{
+    pid_t ppid;
+    
+    ppid = _swi_getppid();
+    
+    return ppid;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getprogname.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getprogname.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getprogname.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getprogname.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,57 @@
+/* $NetBSD: getprogname.c,v 1.4 2011/10/06 20:31:41 christos Exp $ */
+
+/*
+ * Copyright (c) 2001 Christopher G. Demetriou
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *          This product includes software developed for the
+ *          NetBSD Project.  See http://www.NetBSD.org/ for
+ *          information about NetBSD.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * <<Id: LICENSE,v 1.2 2000/06/14 15:57:33 cgd Exp>>
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: getprogname.c,v 1.4 2011/10/06 20:31:41 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <stdlib.h>
+
+#ifdef __weak_alias
+__weak_alias(getprogname,_getprogname)
+#endif
+
+const char *__progname;
+
+const char *
+getprogname(void)
+{
+
+	return (__progname);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getpwent.c third_party/newlib-4.1.0/newlib/libc/sys/arm/getpwent.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/getpwent.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/getpwent.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,2628 @@
+/*	$NetBSD: getpwent.c,v 1.81 2012/09/08 15:15:06 dholland Exp $	*/
+
+/*-
+ * Copyright (c) 1997-2000, 2004-2005 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*
+ * Portions Copyright (c) 1994, 1995, Jason Downs.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
+ * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#define	_GETPW_R_SIZE_MAX	1024
+#define mutex_lock(x)
+#define mutex_unlock(x)
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)getpwent.c	8.2 (Berkeley) 4/27/95";
+#else
+__RCSID("$NetBSD: getpwent.c,v 1.81 2012/09/08 15:15:06 dholland Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+//#include "reentrant.h"
+
+#include <sys/param.h>
+
+#include <assert.h>
+#include <db.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <limits.h>
+#include <netgroup.h>
+#include <nsswitch.h>
+#include <pwd.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+//#include <syslog.h>
+#include <sys/debug.h>
+
+#include <unistd.h>
+
+#ifdef HESIOD
+#include <hesiod.h>
+#endif
+
+#ifdef YP
+#include <machine/param.h>
+#include <rpc/rpc.h>
+#include <rpcsvc/yp_prot.h>
+#include <rpcsvc/ypclnt.h>
+#endif
+
+#include "pw_private.h"
+
+#define	_PASSWD_COMPAT	/* "passwd" defaults to compat, so always provide it */
+
+#ifdef __weak_alias
+__weak_alias(endpwent,_endpwent)
+__weak_alias(setpassent,_setpassent)
+__weak_alias(setpwent,_setpwent)
+#endif
+
+#ifdef _REENTRANT
+static 	mutex_t			_pwmutex = MUTEX_INITIALIZER;
+#endif
+
+const char __yp_token[] = "__YP!";	/* Let pwd_mkdb pull this in. */
+
+
+/*
+ * The pwd.db lookup techniques and data extraction code here must be kept
+ * in sync with that in `pwd_mkdb'.
+ */
+
+#if defined(YP) || defined(HESIOD)
+/*
+ * _pw_parse
+ *	Parses entry using pw_scan(3) (without the trailing \n)
+ *	after copying to buf, and fills in pw with corresponding values.
+ *	If old is non-zero, entry is in _PASSWORD_OLDFMT.
+ *	Returns 1 if parsed successfully, 0 on parse failure.
+ */
+static int
+_pw_parse(const char *entry, struct passwd *pw, char *buf, size_t buflen,
+	int old)
+{
+	int	flags;
+
+	_DIAGASSERT(entry != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buf != NULL);
+
+	if (strlcpy(buf, entry, buflen) >= buflen)
+		return 0;
+	flags = _PASSWORD_NOWARN;
+	if (old)
+		flags |= _PASSWORD_OLDFMT;
+	return __pw_scan(buf, pw, &flags);
+}
+#endif /* YP || HESIOD */
+
+/*
+ * _pw_opendb
+ *	if *db is NULL, dbopen(3) /etc/spwd.db or /etc/pwd.db (depending
+ *	upon permissions, etc)
+ */
+static int
+_pw_opendb(DB **db, int *version)
+{
+	static int	warned;
+	DBT		key;
+	DBT		value;
+
+	const char	*dbfile = NULL;
+
+	_DIAGASSERT(db != NULL);
+	_DIAGASSERT(version != NULL);
+	if (*db != NULL)					/* open *db */
+		return NS_SUCCESS;
+
+	if (geteuid() == 0) {
+		dbfile = _PATH_SMP_DB;
+		*db = dbopen(dbfile, O_RDONLY, 0, DB_HASH, NULL);
+	}
+	if (*db == NULL) {
+		dbfile = _PATH_MP_DB;
+		*db = dbopen(dbfile, O_RDONLY, 0, DB_HASH, NULL);
+	}
+	if (*db == NULL) {
+		if (!warned) {
+			int	serrno = errno;
+			log_error("%s: %m", dbfile);
+			errno = serrno;
+		}
+		warned = 1;
+		return NS_UNAVAIL;
+	}
+	key.data = __UNCONST("VERSION");
+	key.size = strlen((char *)key.data) + 1;
+	switch ((*(*db)->get)(*db, &key, &value, 0)) {
+	case 0:
+		if (sizeof(*version) != value.size)
+			return NS_UNAVAIL;
+		(void)memcpy(version, value.data, value.size);
+		break;			/* found */
+	case 1:
+		*version = 0;		/* not found */
+		break;
+	case -1:
+		return NS_UNAVAIL;	/* error in db routines */
+	default:
+		abort();
+	}
+	return NS_SUCCESS;
+}
+
+/*
+ * _pw_getkey
+ *	Lookup key in *db, filling in pw
+ *	with the result, allocating memory from buffer (size buflen).
+ *	(The caller may point key.data to buffer on entry; the contents
+ *	of key.data will be invalid on exit.)
+ */
+static int
+_pw_getkey(DB *db, DBT *key,
+	struct passwd *pw, char *buffer, size_t buflen, int *pwflags,
+	int version)
+{
+	char		*p, *t;
+	DBT		data;
+
+	_DIAGASSERT(db != NULL);
+	_DIAGASSERT(key != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	/* pwflags may be NULL (if we don't care about them */
+
+	if (db == NULL)			/* this shouldn't happen */
+		return NS_UNAVAIL;
+
+	switch ((db->get)(db, key, &data, 0)) {
+	case 0:
+		break;			/* found */
+	case 1:
+		return NS_NOTFOUND;	/* not found */
+	case -1:
+		return NS_UNAVAIL;	/* error in db routines */
+	default:
+		abort();
+	}
+
+	p = (char *)data.data;
+	if (data.size > buflen) {
+		errno = ERANGE;
+		return NS_UNAVAIL;
+	}
+
+			/*
+			 * THE DECODING BELOW MUST MATCH THAT IN pwd_mkdb.
+			 */
+	t = buffer;
+#define MACRO(a)	do { a } while (/*CONSTCOND*/0)
+#define	EXPAND(e)	MACRO(e = t; while ((*t++ = *p++));)
+#define	SCALAR(v)	MACRO(memmove(&(v), p, sizeof v); p += sizeof v;)
+	EXPAND(pw->pw_name);
+	EXPAND(pw->pw_passwd);
+	SCALAR(pw->pw_uid);
+	SCALAR(pw->pw_gid);
+	if (version == 0) {
+		int32_t tmp;
+		SCALAR(tmp);
+		pw->pw_change = tmp;
+	} else
+		SCALAR(pw->pw_change);
+	EXPAND(pw->pw_class);
+	EXPAND(pw->pw_gecos);
+	EXPAND(pw->pw_dir);
+	EXPAND(pw->pw_shell);
+	if (version == 0) {
+		int32_t tmp;
+		SCALAR(tmp);
+		pw->pw_expire = tmp;
+	} else
+		SCALAR(pw->pw_expire);
+	if (pwflags) {
+		/* See if there's any data left.  If so, read in flags. */
+		if (data.size > (size_t) (p - (char *)data.data)) {
+			SCALAR(*pwflags);
+		} else {				/* default */
+			*pwflags = _PASSWORD_NOUID|_PASSWORD_NOGID;
+		}
+	}
+
+	return NS_SUCCESS;
+}
+
+/*
+ * _pw_memfrombuf
+ *	Obtain want bytes from buffer (of size buflen) and return a pointer
+ *	to the available memory after adjusting buffer/buflen.
+ *	Returns NULL if there is insufficient space.
+ */
+static char *
+_pw_memfrombuf(size_t want, char **buffer, size_t *buflen)
+{
+	char	*rv;
+
+	if (want > *buflen) {
+		errno = ERANGE;
+		return NULL;
+	}
+	rv = *buffer;
+	*buffer += want;
+	*buflen -= want;
+	return rv;
+}
+
+/*
+ * _pw_copy
+ *	Copy the contents of frompw to pw; memory for strings
+ *	and arrays will be allocated from buf (of size buflen).
+ *	If proto != NULL, use various fields in proto in preference to frompw.
+ *	Returns 1 if copied successfully, 0 on copy failure.
+ *	NOTE: frompw must not use buf for its own pointers.
+ */
+static int
+_pw_copy(const struct passwd *frompw, struct passwd *pw,
+	char *buf, size_t buflen, const struct passwd *protopw, int protoflags)
+{
+	size_t	count;
+	int	useproto;
+
+	_DIAGASSERT(frompw != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buf != NULL);
+	/* protopw may be NULL */
+
+	useproto = protopw && protopw->pw_name;
+
+#define	COPYSTR(to, from) \
+	do { \
+		count = strlen((from)); \
+		(to) = _pw_memfrombuf(count+1, &buf, &buflen); \
+		if ((to) == NULL) \
+			return 0; \
+		memmove((to), (from), count); \
+		to[count] = '\0'; \
+	} while (0)	/* LINTED */
+
+#define	COPYFIELD(field)	COPYSTR(pw->field, frompw->field)
+
+#define	COPYPROTOFIELD(field)	COPYSTR(pw->field, \
+		(useproto && *protopw->field ? protopw->field : frompw->field))
+
+	COPYFIELD(pw_name);
+
+#ifdef PW_OVERRIDE_PASSWD
+	COPYPROTOFIELD(pw_passwd);
+#else
+	COPYFIELD(pw_passwd);
+#endif
+
+	if (useproto && !(protoflags & _PASSWORD_NOUID))
+		pw->pw_uid = protopw->pw_uid;
+	else
+		pw->pw_uid = frompw->pw_uid;
+
+	if (useproto && !(protoflags & _PASSWORD_NOGID))
+		pw->pw_gid = protopw->pw_gid;
+	else
+		pw->pw_gid = frompw->pw_gid;
+
+	pw->pw_change = frompw->pw_change;
+	COPYFIELD(pw_class);
+	COPYPROTOFIELD(pw_gecos);
+	COPYPROTOFIELD(pw_dir);
+	COPYPROTOFIELD(pw_shell);
+
+#undef COPYSTR
+#undef COPYFIELD
+#undef COPYPROTOFIELD
+
+	return 1;
+}
+
+
+		/*
+		 *	files methods
+		 */
+
+	/* state shared between files methods */
+struct files_state {
+	int	 stayopen;		/* see getpassent(3) */
+	DB	*db;			/* passwd file handle */
+	int	 keynum;		/* key counter, -1 if no more */
+	int	 version;
+};
+
+static struct files_state	_files_state;
+					/* storage for non _r functions */
+static struct passwd		_files_passwd;
+static char			_files_passwdbuf[_GETPW_R_SIZE_MAX];
+
+static int
+_files_start(struct files_state *state)
+{
+	int	rv;
+
+	_DIAGASSERT(state != NULL);
+
+	state->keynum = 0;
+	rv = _pw_opendb(&state->db, &state->version);
+	if (rv != NS_SUCCESS)
+		return rv;
+	return NS_SUCCESS;
+}
+
+static int
+_files_end(struct files_state *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->keynum = 0;
+	if (state->db) {
+		(void)(state->db->close)(state->db);
+		state->db = NULL;
+	}
+	return NS_SUCCESS;
+}
+
+/*
+ * _files_pwscan
+ *	Search state->db for the next desired entry.
+ *	If search is _PW_KEYBYNUM, look for state->keynum.
+ *	If search is _PW_KEYBYNAME, look for name.
+ *	If search is _PW_KEYBYUID, look for uid.
+ *	Sets *retval to the errno if the result is not NS_SUCCESS
+ *	or NS_NOTFOUND.
+ */
+static int
+_files_pwscan(int *retval, struct passwd *pw, char *buffer, size_t buflen,
+	struct files_state *state, int search, const char *name, uid_t uid)
+{
+	const void	*from;
+	size_t		 fromlen;
+	DBT		 key;
+	int		 rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	/* name is NULL to indicate searching for uid */
+
+	*retval = 0;
+
+	if (state->db == NULL) {	/* only start if file not open yet */
+		rv = _files_start(state);
+		if (rv != NS_SUCCESS)
+			goto filespwscan_out;
+	}
+
+	for (;;) {				/* search for a match */
+		switch (search) {
+		case _PW_KEYBYNUM:
+			if (state->keynum == -1)
+				return NS_NOTFOUND;	/* no more records */
+			state->keynum++;
+			from = &state->keynum;
+			fromlen = sizeof(state->keynum);
+			break;
+		case _PW_KEYBYNAME:
+			from = name;
+			fromlen = strlen(name);
+			break;
+		case _PW_KEYBYUID:
+			from = &uid;
+			fromlen = sizeof(uid);
+			break;
+		default:
+			abort();
+		}
+
+		if (buflen <= fromlen) {		/* buffer too small */
+			*retval = ERANGE;
+			return NS_UNAVAIL;
+		}
+		buffer[0] = search;			/* setup key */
+		memmove(buffer + 1, from, fromlen);
+		key.size = fromlen + 1;
+		key.data = (u_char *)buffer;
+
+							/* search for key */
+		rv = _pw_getkey(state->db, &key, pw, buffer, buflen, NULL,
+		    state->version);
+		if (rv != NS_SUCCESS)			/* no match */
+			break;
+		if (pw->pw_name[0] == '+' || pw->pw_name[0] == '-') {
+						/* if a compat line */
+			if (search == _PW_KEYBYNUM)
+				continue;	/* read next if pwent */
+			rv = NS_NOTFOUND;	/* don't match if pw{nam,uid} */
+			break;
+		}
+		break;
+	}
+
+	if (rv == NS_NOTFOUND && search == _PW_KEYBYNUM)
+		state->keynum = -1;		/* flag `no more records' */
+
+	if (rv == NS_SUCCESS) {
+		if ((search == _PW_KEYBYUID && pw->pw_uid != uid) ||
+		    (search == _PW_KEYBYNAME && strcmp(pw->pw_name, name) != 0))
+			rv = NS_NOTFOUND;
+	}
+
+ filespwscan_out:
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_setpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_files_state.stayopen = 0;
+	return _files_start(&_files_state);
+}
+
+/*ARGSUSED*/
+static int
+_files_setpassent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	_files_state.stayopen = stayopen;
+	rv = _files_start(&_files_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_endpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_files_state.stayopen = 0;
+	return _files_end(&_files_state);
+}
+
+/*ARGSUSED*/
+static int
+_files_getpwent(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _files_pwscan(&rerror, &_files_passwd,
+	    _files_passwdbuf, sizeof(_files_passwdbuf),
+	    &_files_state, _PW_KEYBYNUM, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*retval = &_files_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getpwent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	rv = _files_pwscan(retval, pw, buffer, buflen, &_files_state,
+	    _PW_KEYBYNUM, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	else
+		*result = NULL;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getpwnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _files_start(&_files_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = _files_pwscan(&rerror, &_files_passwd,
+	    _files_passwdbuf, sizeof(_files_passwdbuf),
+	    &_files_state, _PW_KEYBYNAME, name, 0);
+	if (!_files_state.stayopen)
+		_files_end(&_files_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_files_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getpwnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct files_state state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = _files_pwscan(retval, pw, buffer, buflen, &state,
+	    _PW_KEYBYNAME, name, 0);
+	_files_end(&state);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getpwuid(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	uid_t		 uid	= va_arg(ap, uid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _files_start(&_files_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = _files_pwscan(&rerror, &_files_passwd,
+	    _files_passwdbuf, sizeof(_files_passwdbuf),
+	    &_files_state, _PW_KEYBYUID, NULL, uid);
+	if (!_files_state.stayopen)
+		_files_end(&_files_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_files_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_files_getpwuid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	uid_t		 uid	= va_arg(ap, uid_t);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct files_state state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = _files_pwscan(retval, pw, buffer, buflen, &state,
+	    _PW_KEYBYUID, NULL, uid);
+	_files_end(&state);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	return rv;
+}
+
+
+#ifdef HESIOD
+		/*
+		 *	dns methods
+		 */
+
+	/* state shared between dns methods */
+struct dns_state {
+	int	 stayopen;		/* see getpassent(3) */
+	void	*context;		/* Hesiod context */
+	int	 num;			/* passwd index, -1 if no more */
+};
+
+static struct dns_state		_dns_state;
+					/* storage for non _r functions */
+static struct passwd		_dns_passwd;
+static char			_dns_passwdbuf[_GETPW_R_SIZE_MAX];
+
+static int
+_dns_start(struct dns_state *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->num = 0;
+	if (state->context == NULL) {			/* setup Hesiod */
+		if (hesiod_init(&state->context) == -1)
+			return NS_UNAVAIL;
+	}
+
+	return NS_SUCCESS;
+}
+
+static int
+_dns_end(struct dns_state *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->num = 0;
+	if (state->context) {
+		hesiod_end(state->context);
+		state->context = NULL;
+	}
+	return NS_SUCCESS;
+}
+
+/*
+ * _dns_pwscan
+ *	Look for the Hesiod name provided in buffer in the NULL-terminated
+ *	list of zones,
+ *	and decode into pw/buffer/buflen.
+ */
+static int
+_dns_pwscan(int *retval, struct passwd *pw, char *buffer, size_t buflen,
+	struct dns_state *state, const char **zones)
+{
+	const char	**curzone;
+	char		**hp, *ep;
+	int		rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	_DIAGASSERT(zones != NULL);
+
+	*retval = 0;
+
+	if (state->context == NULL) {	/* only start if Hesiod not setup */
+		rv = _dns_start(state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+	hp = NULL;
+	rv = NS_NOTFOUND;
+
+	for (curzone = zones; *curzone; curzone++) {	/* search zones */
+		hp = hesiod_resolve(state->context, buffer, *curzone);
+		if (hp != NULL)
+			break;
+		if (errno != ENOENT) {
+			rv = NS_UNAVAIL;
+			goto dnspwscan_out;
+		}
+	}
+	if (*curzone == NULL)
+		goto dnspwscan_out;
+
+	if ((ep = strchr(hp[0], '\n')) != NULL)
+		*ep = '\0';				/* clear trailing \n */
+	if (_pw_parse(hp[0], pw, buffer, buflen, 1))	/* validate line */
+		rv = NS_SUCCESS;
+	else
+		rv = NS_UNAVAIL;
+
+ dnspwscan_out:
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	if (hp)
+		hesiod_free_list(state->context, hp);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_setpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_dns_state.stayopen = 0;
+	return _dns_start(&_dns_state);
+}
+
+/*ARGSUSED*/
+static int
+_dns_setpassent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	_dns_state.stayopen = stayopen;
+	rv = _dns_start(&_dns_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_endpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_dns_state.stayopen = 0;
+	return _dns_end(&_dns_state);
+}
+
+/*ARGSUSED*/
+static int
+_dns_getpwent(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+
+	char	**hp, *ep;
+	int	  rv;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+
+	if (_dns_state.num == -1)			/* exhausted search */
+		return NS_NOTFOUND;
+
+	if (_dns_state.context == NULL) {
+			/* only start if Hesiod not setup */
+		rv = _dns_start(&_dns_state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+ next_dns_entry:
+	hp = NULL;
+	rv = NS_NOTFOUND;
+
+							/* find passwd-NNN */
+	snprintf(_dns_passwdbuf, sizeof(_dns_passwdbuf),
+	    "passwd-%u", _dns_state.num);
+	_dns_state.num++;
+
+	hp = hesiod_resolve(_dns_state.context, _dns_passwdbuf, "passwd");
+	if (hp == NULL) {
+		if (errno == ENOENT)
+			_dns_state.num = -1;
+		else
+			rv = NS_UNAVAIL;
+	} else {
+		if ((ep = strchr(hp[0], '\n')) != NULL)
+			*ep = '\0';			/* clear trailing \n */
+							/* validate line */
+		if (_pw_parse(hp[0], &_dns_passwd,
+		    _dns_passwdbuf, sizeof(_dns_passwdbuf), 1))
+			rv = NS_SUCCESS;
+		else {				/* dodgy entry, try again */
+			hesiod_free_list(_dns_state.context, hp);
+			goto next_dns_entry;
+		}
+	}
+
+	if (hp)
+		hesiod_free_list(_dns_state.context, hp);
+	if (rv == NS_SUCCESS)
+		*retval = &_dns_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getpwent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	char	**hp, *ep;
+	int	  rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*retval = 0;
+
+	if (_dns_state.num == -1)			/* exhausted search */
+		return NS_NOTFOUND;
+
+	if (_dns_state.context == NULL) {
+			/* only start if Hesiod not setup */
+		rv = _dns_start(&_dns_state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+ next_dns_entry:
+	hp = NULL;
+	rv = NS_NOTFOUND;
+
+							/* find passwd-NNN */
+	snprintf(buffer, buflen, "passwd-%u", _dns_state.num);
+	_dns_state.num++;
+
+	hp = hesiod_resolve(_dns_state.context, buffer, "passwd");
+	if (hp == NULL) {
+		if (errno == ENOENT)
+			_dns_state.num = -1;
+		else
+			rv = NS_UNAVAIL;
+	} else {
+		if ((ep = strchr(hp[0], '\n')) != NULL)
+			*ep = '\0';			/* clear trailing \n */
+							/* validate line */
+		if (_pw_parse(hp[0], pw, buffer, buflen, 1))
+			rv = NS_SUCCESS;
+		else {				/* dodgy entry, try again */
+			hesiod_free_list(_dns_state.context, hp);
+			goto next_dns_entry;
+		}
+	}
+
+	if (hp)
+		hesiod_free_list(_dns_state.context, hp);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	else
+		*result = NULL;
+	return rv;
+}
+
+static const char *_dns_uid_zones[] = {
+	"uid",
+	"passwd",
+	NULL
+};
+
+/*ARGSUSED*/
+static int
+_dns_getpwuid(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	uid_t		 uid	= va_arg(ap, uid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _dns_start(&_dns_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	snprintf(_dns_passwdbuf, sizeof(_dns_passwdbuf),
+	    "%u", (unsigned int)uid);
+	rv = _dns_pwscan(&rerror, &_dns_passwd,
+	    _dns_passwdbuf, sizeof(_dns_passwdbuf),
+	    &_dns_state, _dns_uid_zones);
+	if (!_dns_state.stayopen)
+		_dns_end(&_dns_state);
+	if (rv == NS_SUCCESS && uid == _dns_passwd.pw_uid)
+		*retval = &_dns_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getpwuid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	uid_t		 uid	= va_arg(ap, uid_t);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct dns_state state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	snprintf(buffer, buflen, "%u", (unsigned int)uid);
+	rv = _dns_pwscan(retval, pw, buffer, buflen, &state, _dns_uid_zones);
+	_dns_end(&state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	if (uid == pw->pw_uid) {
+		*result = pw;
+		return NS_SUCCESS;
+	} else
+		return NS_NOTFOUND;
+}
+
+static const char *_dns_nam_zones[] = {
+	"passwd",
+	NULL
+};
+
+/*ARGSUSED*/
+static int
+_dns_getpwnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _dns_start(&_dns_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	snprintf(_dns_passwdbuf, sizeof(_dns_passwdbuf), "%s", name);
+	rv = _dns_pwscan(&rerror, &_dns_passwd,
+	    _dns_passwdbuf, sizeof(_dns_passwdbuf),
+	    &_dns_state, _dns_nam_zones);
+	if (!_dns_state.stayopen)
+		_dns_end(&_dns_state);
+	if (rv == NS_SUCCESS && strcmp(name, _dns_passwd.pw_name) == 0)
+		*retval = &_dns_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_dns_getpwnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct dns_state state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	snprintf(buffer, buflen, "%s", name);
+	rv = _dns_pwscan(retval, pw, buffer, buflen, &state, _dns_nam_zones);
+	_dns_end(&state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	if (strcmp(name, pw->pw_name) == 0) {
+		*result = pw;
+		return NS_SUCCESS;
+	} else
+		return NS_NOTFOUND;
+}
+
+#endif /* HESIOD */
+
+
+#ifdef YP
+		/*
+		 *	nis methods
+		 */
+	/* state shared between nis methods */
+struct nis_state {
+	int		 stayopen;	/* see getpassent(3) */
+	char		*domain;	/* NIS domain */
+	int		 done;		/* non-zero if search exhausted */
+	char		*current;	/* current first/next match */
+	int		 currentlen;	/* length of _nis_current */
+	enum {				/* shadow map type */
+		NISMAP_UNKNOWN = 0,	/*  unknown ... */
+		NISMAP_NONE,		/*  none: use "passwd.by*" */
+		NISMAP_ADJUNCT,		/*  pw_passwd from "passwd.adjunct.*" */
+		NISMAP_MASTER		/*  all from "master.passwd.by*" */
+	}		 maptype;
+};
+
+static struct nis_state		_nis_state;
+					/* storage for non _r functions */
+static struct passwd		_nis_passwd;
+static char			_nis_passwdbuf[_GETPW_R_SIZE_MAX];
+
+static const char __nis_pw_n_1[] = "master.passwd.byname";
+static const char __nis_pw_n_2[] = "passwd.byname";
+static const char __nis_pw_u_1[] = "master.passwd.byuid";
+static const char __nis_pw_u_2[] = "passwd.byuid";
+
+static const char * const __nis_pw_n_map[4] = { __nis_pw_n_2, __nis_pw_n_2, __nis_pw_n_2, __nis_pw_n_1 };
+static const char * const __nis_pw_u_map[4] = { __nis_pw_u_2, __nis_pw_u_2, __nis_pw_u_2, __nis_pw_u_1 };
+
+	/* macros for deciding which NIS maps to use. */
+#define	PASSWD_BYNAME(x)	((x)->maptype == NISMAP_MASTER ? __nis_pw_n_1 : __nis_pw_n_2)
+#define	PASSWD_BYUID(x)		((x)->maptype == NISMAP_MASTER ? __nis_pw_u_1 : __nis_pw_u_2)
+
+static int
+_nis_start(struct nis_state *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->done = 0;
+	if (state->current) {
+		free(state->current);
+		state->current = NULL;
+	}
+	if (state->domain == NULL) {			/* setup NIS */
+		switch (yp_get_default_domain(&state->domain)) {
+		case 0:
+			break;
+		case YPERR_RESRC:
+			return NS_TRYAGAIN;
+		default:
+			return NS_UNAVAIL;
+		}
+	}
+
+				/* determine where to get pw_passwd from */
+	if (state->maptype == NISMAP_UNKNOWN) {
+		int	r, order;
+
+		state->maptype = NISMAP_NONE;	/* default to no adjunct */
+		if (geteuid() != 0)		/* non-root can't use adjunct */
+			return NS_SUCCESS;
+
+						/* look for "master.passwd.*" */
+		r = yp_order(state->domain, "master.passwd.byname", &order);
+		if (r == 0) {
+			state->maptype = NISMAP_MASTER;
+			return NS_SUCCESS;
+		}
+
+			/* master.passwd doesn't exist, try passwd.adjunct */
+		if (r == YPERR_MAP) {
+			r = yp_order(state->domain, "passwd.adjunct.byname",
+			    &order);
+			if (r == 0)
+				state->maptype = NISMAP_ADJUNCT;
+		}
+	}
+	return NS_SUCCESS;
+}
+
+static int
+_nis_end(struct nis_state *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	if (state->domain)
+		state->domain = NULL;
+	state->done = 0;
+	if (state->current)
+		free(state->current);
+	state->current = NULL;
+	state->maptype = NISMAP_UNKNOWN;
+	return NS_SUCCESS;
+}
+
+/*
+ * nis_parse
+ *	wrapper to _pw_parse that obtains the real password from the
+ *	"passwd.adjunct.byname" NIS map if the maptype is NISMAP_ADJUNCT.
+ */
+static int
+_nis_parse(const char *entry, struct passwd *pw, char *buf, size_t buflen,
+	struct nis_state *state)
+{
+	size_t	elen;
+
+	_DIAGASSERT(entry != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buf != NULL);
+	_DIAGASSERT(state != NULL);
+
+	elen = strlen(entry) + 1;
+	if (elen >= buflen)
+		return 0;
+	if (! _pw_parse(entry, pw, buf, buflen,
+	    !(state->maptype == NISMAP_MASTER)))
+		return 0;
+
+	if ((state->maptype == NISMAP_ADJUNCT) &&
+	    (strstr(pw->pw_passwd, "##") != NULL)) {
+		char	*data;
+		int	datalen;
+
+		if (yp_match(state->domain, "passwd.adjunct.byname",
+		    pw->pw_name, (int)strlen(pw->pw_name),
+		    &data, &datalen) == 0) {
+			char	*bp, *ep;
+						/* skip name to get password */
+			ep = data;
+			if (strsep(&ep, ":") != NULL &&
+			    (bp = strsep(&ep, ":")) != NULL) {
+					/* store new pw_passwd after entry */
+				if (strlcpy(buf + elen, bp, buflen - elen) >=
+				    buflen - elen) {
+					free(data);
+					return 0;
+				}
+				pw->pw_passwd = &buf[elen];
+			}
+			free(data);
+		}
+	}
+
+	return 1;
+}
+
+
+/*
+ * _nis_pwscan
+ *	Look for the yp key provided in buffer from map,
+ *	and decode into pw/buffer/buflen.
+ */
+static int
+_nis_pwscan(int *retval, struct passwd *pw, char *buffer, size_t buflen,
+	struct nis_state *state, const char * const *map_arr, size_t nmaps)
+{
+	char	*data;
+	int	nisr, rv, datalen;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	_DIAGASSERT(map_arr != NULL);
+
+	*retval = 0;
+
+	if (state->domain == NULL) {	/* only start if NIS not setup */
+		rv = _nis_start(state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+	data = NULL;
+	rv = NS_NOTFOUND;
+	_DIAGASSERT(state->maptype != NISMAP_UNKNOWN &&
+		    (unsigned)state->maptype < nmaps);
+
+							/* search map */
+	nisr = yp_match(state->domain, map_arr[state->maptype], buffer, (int)strlen(buffer),
+	    &data, &datalen);
+	switch (nisr) {
+	case 0:
+		data[datalen] = '\0';			/* clear trailing \n */
+		if (_nis_parse(data, pw, buffer, buflen, state))
+			rv = NS_SUCCESS;		/* validate line */
+		else
+			rv = NS_UNAVAIL;
+		break;
+	case YPERR_KEY:
+		break;
+	default:
+		rv = NS_UNAVAIL;
+		break;
+	}
+
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	if (data)
+		free(data);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_setpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+	_nis_state.stayopen = 0;
+	return _nis_start(&_nis_state);
+}
+
+/*ARGSUSED*/
+static int
+_nis_setpassent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+	_nis_state.stayopen = stayopen;
+	rv = _nis_start(&_nis_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_endpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+	return _nis_end(&_nis_state);
+}
+
+
+/*ARGSUSED*/
+static int
+_nis_getpwent(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+
+	char	*key, *data;
+	int	keylen, datalen, rv, nisr;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+
+	if (_nis_state.done)				/* exhausted search */
+		return NS_NOTFOUND;
+	if (_nis_state.domain == NULL) {
+					/* only start if NIS not setup */
+		rv = _nis_start(&_nis_state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+ next_nis_entry:
+	key = NULL;
+	data = NULL;
+	rv = NS_NOTFOUND;
+
+	if (_nis_state.current) {			/* already searching */
+		nisr = yp_next(_nis_state.domain, PASSWD_BYNAME(&_nis_state),
+		    _nis_state.current, _nis_state.currentlen,
+		    &key, &keylen, &data, &datalen);
+		free(_nis_state.current);
+		_nis_state.current = NULL;
+		switch (nisr) {
+		case 0:
+			_nis_state.current = key;
+			_nis_state.currentlen = keylen;
+			key = NULL;
+			break;
+		case YPERR_NOMORE:
+			_nis_state.done = 1;
+			goto nisent_out;
+		default:
+			rv = NS_UNAVAIL;
+			goto nisent_out;
+		}
+	} else {					/* new search */
+		if (yp_first(_nis_state.domain, PASSWD_BYNAME(&_nis_state),
+		    &_nis_state.current, &_nis_state.currentlen,
+		    &data, &datalen)) {
+			rv = NS_UNAVAIL;
+			goto nisent_out;
+		}
+	}
+
+	data[datalen] = '\0';				/* clear trailing \n */
+							/* validate line */
+	if (_nis_parse(data, &_nis_passwd,
+	    _nis_passwdbuf, sizeof(_nis_passwdbuf), &_nis_state))
+		rv = NS_SUCCESS;
+	else {					/* dodgy entry, try again */
+		free(data);
+		goto next_nis_entry;
+	}
+
+ nisent_out:
+	if (key)
+		free(key);
+	if (data)
+		free(data);
+	if (rv == NS_SUCCESS)
+		*retval = &_nis_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getpwent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	char	*key, *data;
+	int	keylen, datalen, rv, nisr;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*retval = 0;
+
+	if (_nis_state.done)				/* exhausted search */
+		return NS_NOTFOUND;
+	if (_nis_state.domain == NULL) {
+					/* only start if NIS not setup */
+		rv = _nis_start(&_nis_state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+
+ next_nis_entry:
+	key = NULL;
+	data = NULL;
+	rv = NS_NOTFOUND;
+
+	if (_nis_state.current) {			/* already searching */
+		nisr = yp_next(_nis_state.domain, PASSWD_BYNAME(&_nis_state),
+		    _nis_state.current, _nis_state.currentlen,
+		    &key, &keylen, &data, &datalen);
+		free(_nis_state.current);
+		_nis_state.current = NULL;
+		switch (nisr) {
+		case 0:
+			_nis_state.current = key;
+			_nis_state.currentlen = keylen;
+			key = NULL;
+			break;
+		case YPERR_NOMORE:
+			_nis_state.done = 1;
+			goto nisent_out;
+		default:
+			rv = NS_UNAVAIL;
+			goto nisent_out;
+		}
+	} else {					/* new search */
+		if (yp_first(_nis_state.domain, PASSWD_BYNAME(&_nis_state),
+		    &_nis_state.current, &_nis_state.currentlen,
+		    &data, &datalen)) {
+			rv = NS_UNAVAIL;
+			goto nisent_out;
+		}
+	}
+
+	data[datalen] = '\0';				/* clear trailing \n */
+							/* validate line */
+	if (_nis_parse(data, pw, buffer, buflen, &_nis_state))
+		rv = NS_SUCCESS;
+	else {					/* dodgy entry, try again */
+		if (key)
+			free(key);
+		free(data);
+		goto next_nis_entry;
+	}
+
+ nisent_out:
+	if (key)
+		free(key);
+	if (data)
+		free(data);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	else
+		*result = NULL;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getpwuid(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	uid_t		 uid	= va_arg(ap, uid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _nis_start(&_nis_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	snprintf(_nis_passwdbuf, sizeof(_nis_passwdbuf), "%u", (unsigned int)uid);
+	rv = _nis_pwscan(&rerror, &_nis_passwd,
+	    _nis_passwdbuf, sizeof(_nis_passwdbuf),
+	    &_nis_state, __nis_pw_u_map, __arraycount(__nis_pw_u_map));
+	if (!_nis_state.stayopen)
+		_nis_end(&_nis_state);
+	if (rv == NS_SUCCESS && uid == _nis_passwd.pw_uid)
+		*retval = &_nis_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getpwuid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	uid_t		 uid	= va_arg(ap, uid_t);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct nis_state state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	snprintf(buffer, buflen, "%u", (unsigned int)uid);
+/* remark: we run under a global mutex inside of this module ... */
+	if (_nis_state.stayopen)
+	  { /* use global state only if stayopen is set - otherwise we would blow up getpwent_r() ... */
+	    rv = _nis_pwscan(retval, pw, buffer, buflen,
+		&_nis_state, __nis_pw_u_map, __arraycount(__nis_pw_u_map));
+	  }
+	else
+	  { /* keep old semantic if no stayopen set - no need to call _nis_start() here - _nis_pwscan() will do it for us ... */
+	    /* use same way as in getgrent.c ... */
+	    memset(&state, 0, sizeof(state));
+	    rv = _nis_pwscan(retval, pw, buffer, buflen,
+		&state, __nis_pw_u_map, __arraycount(__nis_pw_u_map));
+	    _nis_end(&state);
+	  }
+	if (rv != NS_SUCCESS)
+		return rv;
+	if (uid == pw->pw_uid) {
+		*result = pw;
+		return NS_SUCCESS;
+	} else
+		return NS_NOTFOUND;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getpwnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _nis_start(&_nis_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	snprintf(_nis_passwdbuf, sizeof(_nis_passwdbuf), "%s", name);
+	rv = _nis_pwscan(&rerror, &_nis_passwd,
+	    _nis_passwdbuf, sizeof(_nis_passwdbuf),
+	    &_nis_state, __nis_pw_n_map, __arraycount(__nis_pw_n_map));
+	if (!_nis_state.stayopen)
+		_nis_end(&_nis_state);
+	if (rv == NS_SUCCESS && strcmp(name, _nis_passwd.pw_name) == 0)
+		*retval = &_nis_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_nis_getpwnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct nis_state state;
+	int	rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	snprintf(buffer, buflen, "%s", name);
+/* remark: we run under a global mutex inside of this module ... */
+	if (_nis_state.stayopen)
+	  { /* use global state only if stayopen is set - otherwise we would blow up getpwent_r() ... */
+	    rv = _nis_pwscan(retval, pw, buffer, buflen,
+		&_nis_state, __nis_pw_n_map, __arraycount(__nis_pw_n_map));
+	  }
+	else
+	  { /* keep old semantic if no stayopen set - no need to call _nis_start() here - _nis_pwscan() will do it for us ... */
+	    /* use same way as in getgrent.c ... */
+	    memset(&state, 0, sizeof(state));
+	    rv = _nis_pwscan(retval, pw, buffer, buflen,
+		&state, __nis_pw_n_map, __arraycount(__nis_pw_n_map));
+	    _nis_end(&state);
+	  }
+	if (rv != NS_SUCCESS)
+		return rv;
+	if (strcmp(name, pw->pw_name) == 0) {
+		*result = pw;
+		return NS_SUCCESS;
+	} else
+		return NS_NOTFOUND;
+}
+
+#endif /* YP */
+
+
+#ifdef _PASSWD_COMPAT
+		/*
+		 *	compat methods
+		 */
+
+	/* state shared between compat methods */
+
+struct compat_state {
+	int		 stayopen;	/* see getpassent(3) */
+	DB		*db;		/* passwd DB */
+	int		 keynum;	/* key counter, -1 if no more */
+	enum {				/* current compat mode */
+		COMPAT_NOTOKEN = 0,	/*  no compat token present */
+		COMPAT_NONE,		/*  parsing normal pwd.db line */
+		COMPAT_FULL,		/*  parsing `+' entries */
+		COMPAT_USER,		/*  parsing `+name' entries */
+		COMPAT_NETGROUP		/*  parsing `+@netgroup' entries */
+	}		 mode;
+	char		*user;		/* COMPAT_USER "+name" */
+	DB		*exclude;	/* compat exclude DB */
+	struct passwd	 proto;		/* proto passwd entry */
+	char		 protobuf[_GETPW_R_SIZE_MAX];
+					/* buffer for proto ptrs */
+	int		 protoflags;	/* proto passwd flags */
+	int		 version;
+};
+
+static struct compat_state	_compat_state;
+					/* storage for non _r functions */
+static struct passwd		_compat_passwd;
+static char			_compat_passwdbuf[_GETPW_R_SIZE_MAX];
+
+static int
+_compat_start(struct compat_state *state)
+{
+	int	rv;
+
+	_DIAGASSERT(state != NULL);
+
+	state->keynum = 0;
+	if (state->db == NULL) {		/* not open yet */
+		DBT	key, data;
+		DBT	pkey, pdata;
+		char	bf[MAXLOGNAME];
+
+		rv = _pw_opendb(&state->db, &state->version);
+		if (rv != NS_SUCCESS)
+			return rv;
+
+		state->mode = COMPAT_NOTOKEN;
+
+		/*
+		 *	Determine if the "compat" token is present in pwd.db;
+		 *	either "__YP!" or PW_KEYBYNAME+"+".
+		 *	Only works if pwd_mkdb installs the token.
+		 */
+		key.data = (u_char *)__UNCONST(__yp_token);
+		key.size = strlen(__yp_token);
+
+		bf[0] = _PW_KEYBYNAME;	 /* Pre-token database support. */
+		bf[1] = '+';
+		pkey.data = (u_char *)bf;
+		pkey.size = 2;
+
+		if ((state->db->get)(state->db, &key, &data, 0) == 0
+		    || (state->db->get)(state->db, &pkey, &pdata, 0) == 0)
+			state->mode = COMPAT_NONE;
+	}
+	return NS_SUCCESS;
+}
+
+static int
+_compat_end(struct compat_state *state)
+{
+
+	_DIAGASSERT(state != NULL);
+
+	state->keynum = 0;
+	if (state->db) {
+		(void)(state->db->close)(state->db);
+		state->db = NULL;
+	}
+	state->mode = COMPAT_NOTOKEN;
+	if (state->user)
+		free(state->user);
+	state->user = NULL;
+	if (state->exclude != NULL)
+		(void)(state->exclude->close)(state->exclude);
+	state->exclude = NULL;
+	state->proto.pw_name = NULL;
+	state->protoflags = 0;
+	return NS_SUCCESS;
+}
+
+/*
+ * _compat_add_exclude
+ *	add the name to the exclude list in state->exclude.
+ */
+static int
+_compat_add_exclude(struct compat_state *state, const char *name)
+{
+	DBT	key, data;
+
+	_DIAGASSERT(state != NULL);
+	_DIAGASSERT(name != NULL);
+
+				/* initialize the exclusion table if needed */
+	if (state->exclude == NULL) {
+		state->exclude = dbopen(NULL, O_RDWR, 600, DB_HASH, NULL);
+		if (state->exclude == NULL)
+			return 0;
+	}
+
+	key.size = strlen(name);			/* set up the key */
+	key.data = (u_char *)__UNCONST(name);
+
+	data.data = NULL;				/* data is nothing */
+	data.size = 0;
+
+							/* store it */
+	if ((state->exclude->put)(state->exclude, &key, &data, 0) == -1)
+		return 0;
+
+	return 1;
+}
+
+/*
+ * _compat_is_excluded
+ *	test if a name is on the compat mode exclude list
+ */
+static int
+_compat_is_excluded(struct compat_state *state, const char *name)
+{
+	DBT	key, data;
+
+	_DIAGASSERT(state != NULL);
+	_DIAGASSERT(name != NULL);
+
+	if (state->exclude == NULL)
+		return 0;	/* nothing excluded */
+
+	key.size = strlen(name);			/* set up the key */
+	key.data = (u_char *)__UNCONST(name);
+
+	if ((state->exclude->get)(state->exclude, &key, &data, 0) == 0)
+		return 1;				/* is excluded */
+
+	return 0;
+}
+
+
+/*
+ * _passwdcompat_bad
+ *	log an error if "files" or "compat" is specified in
+ *	passwd_compat database
+ */
+/*ARGSUSED*/
+static int
+_passwdcompat_bad(void *nsrv, void *nscb, va_list ap)
+{
+	static int warned;
+
+	_DIAGASSERT(nsrv != NULL);
+	_DIAGASSERT(nscb != NULL);
+
+	if (!warned) {
+		log_error("nsswitch.conf passwd_compat database can't use '%s'",
+			(char *)nscb);
+	}
+	warned = 1;
+	return NS_UNAVAIL;
+}
+
+/*
+ * _passwdcompat_setpassent
+ *	Call setpassent for all passwd_compat sources.
+ */
+static int
+_passwdcompat_setpassent(int stayopen)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_passwdcompat_bad, "files")
+		NS_DNS_CB(_dns_setpassent, NULL)
+		NS_NIS_CB(_nis_setpassent, NULL)
+		NS_COMPAT_CB(_passwdcompat_bad, "compat")
+		NS_NULL_CB
+	};
+
+	int	rv, result;
+
+	rv = nsdispatch(NULL, dtab, NSDB_PASSWD_COMPAT, "setpassent",
+	    __nsdefaultnis_forceall, &result, stayopen);
+	return rv;
+}
+
+/*
+ * _passwdcompat_endpwent
+ *	Call endpwent for all passwd_compat sources.
+ */
+static int
+_passwdcompat_endpwent(void)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_passwdcompat_bad, "files")
+		NS_DNS_CB(_dns_endpwent, NULL)
+		NS_NIS_CB(_nis_endpwent, NULL)
+		NS_COMPAT_CB(_passwdcompat_bad, "compat")
+		NS_NULL_CB
+	};
+
+	return nsdispatch(NULL, dtab, NSDB_PASSWD_COMPAT, "endpwent",
+	    __nsdefaultnis_forceall);
+}
+
+/*
+ * _passwdcompat_pwscan
+ *	When a name lookup in compat mode is required (e.g., `+name', or a
+ *	name in `+@netgroup'), look it up in the 'passwd_compat' nsswitch
+ *	database.
+ *	Fail if passwd_compat contains files or compat.
+ */
+static int
+_passwdcompat_pwscan(struct passwd *pw, char *buffer, size_t buflen,
+	int search, const char *name, uid_t uid)
+{
+	static const ns_dtab compatentdtab[] = {
+		NS_FILES_CB(_passwdcompat_bad, "files")
+		NS_DNS_CB(_dns_getpwent_r, NULL)
+		NS_NIS_CB(_nis_getpwent_r, NULL)
+		NS_COMPAT_CB(_passwdcompat_bad, "compat")
+		NS_NULL_CB
+	};
+	static const ns_dtab compatuiddtab[] = {
+		NS_FILES_CB(_passwdcompat_bad, "files")
+		NS_DNS_CB(_dns_getpwuid_r, NULL)
+		NS_NIS_CB(_nis_getpwuid_r, NULL)
+		NS_COMPAT_CB(_passwdcompat_bad, "compat")
+		NS_NULL_CB
+	};
+	static const ns_dtab compatnamdtab[] = {
+		NS_FILES_CB(_passwdcompat_bad, "files")
+		NS_DNS_CB(_dns_getpwnam_r, NULL)
+		NS_NIS_CB(_nis_getpwnam_r, NULL)
+		NS_COMPAT_CB(_passwdcompat_bad, "compat")
+		NS_NULL_CB
+	};
+
+	int		rv, crv;
+	struct passwd	*cpw;
+
+	switch (search) {
+	case _PW_KEYBYNUM:
+		rv = nsdispatch(NULL, compatentdtab,
+		    NSDB_PASSWD_COMPAT, "getpwent_r", __nsdefaultnis,
+		    &crv, pw, buffer, buflen, &cpw);
+		break;
+	case _PW_KEYBYNAME:
+		_DIAGASSERT(name != NULL);
+		rv = nsdispatch(NULL, compatnamdtab,
+		    NSDB_PASSWD_COMPAT, "getpwnam_r", __nsdefaultnis,
+		    &crv, name, pw, buffer, buflen, &cpw);
+		break;
+	case _PW_KEYBYUID:
+		rv = nsdispatch(NULL, compatuiddtab,
+		    NSDB_PASSWD_COMPAT, "getpwuid_r", __nsdefaultnis,
+		    &crv, uid, pw, buffer, buflen, &cpw);
+		break;
+	default:
+		abort();
+		/*NOTREACHED*/
+	}
+	return rv;
+}
+
+/*
+ * _compat_pwscan
+ *	Search state->db for the next desired entry.
+ *	If search is _PW_KEYBYNUM, look for state->keynum.
+ *	If search is _PW_KEYBYNAME, look for name.
+ *	If search is _PW_KEYBYUID, look for uid.
+ *	Sets *retval to the errno if the result is not NS_SUCCESS
+ *	or NS_NOTFOUND.
+ */
+static int
+_compat_pwscan(int *retval, struct passwd *pw, char *buffer, size_t buflen,
+	struct compat_state *state, int search, const char *name, uid_t uid)
+{
+	DBT		 key;
+	int		 rv, r, pwflags;
+	const char	*user, *host, *dom;
+	const void	*from;
+	size_t		 fromlen;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(state != NULL);
+	/* name may be NULL */
+
+	*retval = 0;
+
+	if (state->db == NULL) {
+		rv = _compat_start(state);
+		if (rv != NS_SUCCESS)
+			return rv;
+	}
+	if (buflen <= 1) {			/* buffer too small */
+		*retval = ERANGE;
+		return NS_UNAVAIL;
+	}
+
+	for (;;) {				/* loop over pwd.db */
+		rv = NS_NOTFOUND;
+		if (state->mode != COMPAT_NOTOKEN &&
+		    state->mode != COMPAT_NONE) {
+						/* doing a compat lookup */
+			struct passwd	cpw;
+			char		cbuf[_GETPW_R_SIZE_MAX];
+
+			switch (state->mode) {
+
+			case COMPAT_FULL:
+					/* get next user or lookup by key */
+				rv = _passwdcompat_pwscan(&cpw,
+				    cbuf, sizeof(cbuf), search, name, uid);
+				if (rv != NS_SUCCESS)
+					state->mode = COMPAT_NONE;
+				break;
+
+			case COMPAT_NETGROUP:
+/* XXXREENTRANT: getnetgrent is not thread safe */
+					/* get next user from netgroup */
+				r = getnetgrent(&host, &user, &dom);
+				if (r == 0) {	/* end of group */
+					endnetgrent();
+					state->mode = COMPAT_NONE;
+					break;
+				}
+				if (!user || !*user)
+					break;
+				rv = _passwdcompat_pwscan(&cpw,
+				    cbuf, sizeof(cbuf),
+				    _PW_KEYBYNAME, user, 0);
+				break;
+
+			case COMPAT_USER:
+					/* get specific user */
+				if (state->user == NULL) {
+					state->mode = COMPAT_NONE;
+					break;
+				}
+				rv = _passwdcompat_pwscan(&cpw,
+				    cbuf, sizeof(cbuf),
+				    _PW_KEYBYNAME, state->user, 0);
+				free(state->user);
+				state->user = NULL;
+				state->mode = COMPAT_NONE;
+				break;
+
+			case COMPAT_NOTOKEN:
+			case COMPAT_NONE:
+				abort();
+
+			}
+			if (rv != NS_SUCCESS)	/* if not matched, next loop */
+				continue;
+
+				/* copy cpw to pw, applying prototype */
+			if (! _pw_copy(&cpw, pw, buffer, buflen,
+			    &state->proto, state->protoflags)) {
+				rv = NS_UNAVAIL;
+				break;
+			}
+
+			if (_compat_is_excluded(state, pw->pw_name))
+				continue;	/* excluded; next loop */
+
+			if ((search == _PW_KEYBYNAME
+					&& strcmp(pw->pw_name, name) != 0)
+			    || (search == _PW_KEYBYUID && pw->pw_uid != uid)) {
+				continue;	/* not specific; next loop */
+			}
+
+			break;			/* exit loop if found */
+		} else {			/* not a compat line */
+			state->proto.pw_name = NULL;
+						/* clear prototype */
+		}
+
+		if (state->mode == COMPAT_NOTOKEN) {
+				/* no compat token; do direct lookup */
+			switch (search) {
+			case _PW_KEYBYNUM:
+				if (state->keynum == -1)  /* no more records */
+					return NS_NOTFOUND;
+				state->keynum++;
+				from = &state->keynum;
+				fromlen = sizeof(state->keynum);
+				break;
+			case _PW_KEYBYNAME:
+				from = name;
+				fromlen = strlen(name);
+				break;
+			case _PW_KEYBYUID:
+				from = &uid;
+				fromlen = sizeof(uid);
+				break;
+			default:
+				abort();
+			}
+			buffer[0] = search;
+		} else {
+				/* compat token; do line by line */
+			if (state->keynum == -1)  /* no more records */
+				return NS_NOTFOUND;
+			state->keynum++;
+			from = &state->keynum;
+			fromlen = sizeof(state->keynum);
+			buffer[0] = _PW_KEYBYNUM;
+		}
+
+		if (buflen <= fromlen) {		/* buffer too small */
+			*retval = ERANGE;
+			return NS_UNAVAIL;
+		}
+		memmove(buffer + 1, from, fromlen);	/* setup key */
+		key.size = fromlen + 1;
+		key.data = (u_char *)buffer;
+
+		rv = _pw_getkey(state->db, &key, pw, buffer, buflen, &pwflags,
+		    state->version);
+		if (rv != NS_SUCCESS)		/* stop on error */
+			break;
+
+		if (state->mode == COMPAT_NOTOKEN)
+			break;			/* stop if no compat token */
+
+		if (pw->pw_name[0] == '+') {
+						/* compat inclusion */
+			switch(pw->pw_name[1]) {
+			case '\0':		/* `+' */
+				state->mode = COMPAT_FULL;
+						/* reset passwd_compat search */
+/* XXXREENTRANT: setpassent is not thread safe ? */
+				(void) _passwdcompat_setpassent(_compat_state.stayopen);
+				break;
+			case '@':		/* `+@netgroup' */
+				state->mode = COMPAT_NETGROUP;
+						/* reset netgroup search */
+/* XXXREENTRANT: setnetgrent is not thread safe */
+				setnetgrent(pw->pw_name + 2);
+				break;
+			default:		/* `+name' */
+				state->mode = COMPAT_USER;
+				if (state->user)
+					free(state->user);
+				state->user = strdup(pw->pw_name + 1);
+				break;
+			}
+						/* save the prototype */
+			state->protoflags = pwflags;
+			if (! _pw_copy(pw, &state->proto, state->protobuf,
+			    sizeof(state->protobuf), NULL, 0)) {
+				rv = NS_UNAVAIL;
+				break;
+			}
+			continue;		/* loop again after inclusion */
+		} else if (pw->pw_name[0] == '-') {
+						/* compat exclusion */
+			rv = NS_SUCCESS;
+			switch(pw->pw_name[1]) {
+			case '\0':		/* `-' */
+				break;
+			case '@':		/* `-@netgroup' */
+/* XXXREENTRANT: {set,get,end}netgrent is not thread safe */
+				setnetgrent(pw->pw_name + 2);
+				while (getnetgrent(&host, &user, &dom)) {
+					if (!user || !*user)
+						continue;
+					if (! _compat_add_exclude(state,user)) {
+						rv = NS_UNAVAIL;
+						break;
+					}
+				}
+				endnetgrent();
+				break;
+			default:		/* `-name' */
+				if (! _compat_add_exclude(state,
+				    pw->pw_name + 1)) {
+					rv = NS_UNAVAIL;
+				}
+				break;
+			}
+			if (rv != NS_SUCCESS)	/* exclusion failure */
+				break;
+			continue;		/* loop again after exclusion */
+		}
+		if (search == _PW_KEYBYNUM ||
+		    (search == _PW_KEYBYUID && pw->pw_uid == uid) ||
+		    (search == _PW_KEYBYNAME && strcmp(pw->pw_name, name) == 0))
+			break;			/* token mode match found */
+	}
+
+	if (rv == NS_NOTFOUND &&
+	    (search == _PW_KEYBYNUM || state->mode != COMPAT_NOTOKEN))
+		state->keynum = -1;		/* flag `no more records' */
+
+	if (rv == NS_SUCCESS) {
+		if ((search == _PW_KEYBYNAME && strcmp(pw->pw_name, name) != 0)
+		    || (search == _PW_KEYBYUID && pw->pw_uid != uid))
+			rv = NS_NOTFOUND;
+	}
+
+	if (rv != NS_SUCCESS && rv != NS_NOTFOUND)
+		*retval = errno;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_setpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+					/* force passwd_compat setpwent() */
+	(void) _passwdcompat_setpassent(0);
+
+					/* reset state, keep db open */
+	_compat_state.stayopen = 0;
+	return _compat_start(&_compat_state);
+}
+
+/*ARGSUSED*/
+static int
+_compat_setpassent(void *nsrv, void *nscb, va_list ap)
+{
+	int	*retval		= va_arg(ap, int *);
+	int	 stayopen	= va_arg(ap, int);
+
+	int	rv;
+
+					/* force passwd_compat setpassent() */
+	(void) _passwdcompat_setpassent(stayopen);
+
+	_compat_state.stayopen = stayopen;
+	rv = _compat_start(&_compat_state);
+	*retval = (rv == NS_SUCCESS);
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_endpwent(void *nsrv, void *nscb, va_list ap)
+{
+
+					/* force passwd_compat endpwent() */
+	(void) _passwdcompat_endpwent();
+
+					/* reset state, close db */
+	_compat_state.stayopen = 0;
+	return _compat_end(&_compat_state);
+}
+
+
+/*ARGSUSED*/
+static int
+_compat_getpwent(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _compat_pwscan(&rerror, &_compat_passwd,
+	    _compat_passwdbuf, sizeof(_compat_passwdbuf),
+	    &_compat_state, _PW_KEYBYNUM, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*retval = &_compat_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getpwent_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	int		rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	rv = _compat_pwscan(retval, pw, buffer, buflen, &_compat_state,
+	    _PW_KEYBYNUM, NULL, 0);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	else
+		*result = NULL;
+	return rv;
+}
+
+
+/*ARGSUSED*/
+static int
+_compat_getpwnam(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	const char	*name	= va_arg(ap, const char *);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _compat_start(&_compat_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = _compat_pwscan(&rerror, &_compat_passwd,
+	    _compat_passwdbuf, sizeof(_compat_passwdbuf),
+	    &_compat_state, _PW_KEYBYNAME, name, 0);
+	if (!_compat_state.stayopen)
+		_compat_end(&_compat_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_compat_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getpwnam_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	const char	*name	= va_arg(ap, const char *);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct compat_state	state;
+	int		rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = _compat_pwscan(retval, pw, buffer, buflen, &state,
+	    _PW_KEYBYNAME, name, 0);
+	_compat_end(&state);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getpwuid(void *nsrv, void *nscb, va_list ap)
+{
+	struct passwd	**retval = va_arg(ap, struct passwd **);
+	uid_t		 uid	= va_arg(ap, uid_t);
+
+	int	rv, rerror;
+
+	_DIAGASSERT(retval != NULL);
+
+	*retval = NULL;
+	rv = _compat_start(&_compat_state);
+	if (rv != NS_SUCCESS)
+		return rv;
+	rv = _compat_pwscan(&rerror, &_compat_passwd,
+	    _compat_passwdbuf, sizeof(_compat_passwdbuf),
+	    &_compat_state, _PW_KEYBYUID, NULL, uid);
+	if (!_compat_state.stayopen)
+		_compat_end(&_compat_state);
+	if (rv == NS_SUCCESS)
+		*retval = &_compat_passwd;
+	return rv;
+}
+
+/*ARGSUSED*/
+static int
+_compat_getpwuid_r(void *nsrv, void *nscb, va_list ap)
+{
+	int		*retval	= va_arg(ap, int *);
+	uid_t		 uid	= va_arg(ap, uid_t);
+	struct passwd	*pw	= va_arg(ap, struct passwd *);
+	char		*buffer	= va_arg(ap, char *);
+	size_t		 buflen	= va_arg(ap, size_t);
+	struct passwd  **result	= va_arg(ap, struct passwd **);
+
+	struct compat_state	state;
+	int		rv;
+
+	_DIAGASSERT(retval != NULL);
+	_DIAGASSERT(pw != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	memset(&state, 0, sizeof(state));
+	rv = _compat_pwscan(retval, pw, buffer, buflen, &state,
+	    _PW_KEYBYUID, NULL, uid);
+	_compat_end(&state);
+	if (rv == NS_SUCCESS)
+		*result = pw;
+	return rv;
+}
+
+#endif /* _PASSWD_COMPAT */
+
+
+		/*
+		 *	public functions
+		 */
+
+struct passwd *
+getpwent(void)
+{
+	int		r;
+	struct passwd	*retval;
+
+//	log_info("getpwent");
+
+	return NULL; /* FIXME */
+	/* FIXME: FIXME: */
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getpwent, NULL)
+		NS_DNS_CB(_dns_getpwent, NULL)
+		NS_NIS_CB(_nis_getpwent, NULL)
+		NS_COMPAT_CB(_compat_getpwent, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&_pwmutex);
+	r = nsdispatch(NULL, dtab, NSDB_PASSWD, "getpwent", __nsdefaultcompat,
+	    &retval);
+	mutex_unlock(&_pwmutex);
+	return (r == NS_SUCCESS) ? retval : NULL;
+}
+
+int
+getpwent_r(struct passwd *pwd, char *buffer, size_t buflen,
+    struct passwd **result)
+{
+	int	r, retval;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getpwent_r, NULL)
+		NS_DNS_CB(_dns_getpwent_r, NULL)
+		NS_NIS_CB(_nis_getpwent_r, NULL)
+		NS_COMPAT_CB(_compat_getpwent_r, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(pwd != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	retval = 0;
+	mutex_lock(&_pwmutex);
+	r = nsdispatch(NULL, dtab, NSDB_PASSWD, "getpwent_r", __nsdefaultcompat,
+	    &retval, pwd, buffer, buflen, result);
+	mutex_unlock(&_pwmutex);
+	switch (r) {
+	case NS_SUCCESS:
+	case NS_NOTFOUND:
+		return 0;
+	default:
+		return retval;
+	}
+}
+
+
+struct passwd *
+getpwnam(const char *name)
+{
+	int		rv;
+	struct passwd	*retval;
+
+//	log_info("getpwnam");
+	return NULL; /* FIXME */
+	/* FIXME: FIXME: */
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getpwnam, NULL)
+		NS_DNS_CB(_dns_getpwnam, NULL)
+		NS_NIS_CB(_nis_getpwnam, NULL)
+		NS_COMPAT_CB(_compat_getpwnam, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&_pwmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_PASSWD, "getpwnam", __nsdefaultcompat,
+	    &retval, name);
+	mutex_unlock(&_pwmutex);
+	return (rv == NS_SUCCESS) ? retval : NULL;
+}
+
+int
+getpwnam_r(const char *name, struct passwd *pwd, char *buffer, size_t buflen,
+	struct passwd **result)
+{
+	int	r, retval;
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getpwnam_r, NULL)
+		NS_DNS_CB(_dns_getpwnam_r, NULL)
+		NS_NIS_CB(_nis_getpwnam_r, NULL)
+		NS_COMPAT_CB(_compat_getpwnam_r, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(name != NULL);
+	_DIAGASSERT(pwd != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	retval = 0;
+	mutex_lock(&_pwmutex);
+	r = nsdispatch(NULL, dtab, NSDB_PASSWD, "getpwnam_r", __nsdefaultcompat,
+	    &retval, name, pwd, buffer, buflen, result);
+	mutex_unlock(&_pwmutex);
+	switch (r) {
+	case NS_SUCCESS:
+	case NS_NOTFOUND:
+		return 0;
+	default:
+		return retval;
+	}
+}
+
+struct passwd *
+getpwuid(uid_t uid)
+{
+	int		rv;
+	struct passwd	*retval;
+
+//	log_info("getpwuid");
+
+	return NULL; /* FIXME */
+	/* FIXME: FIXME: */
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getpwuid, NULL)
+		NS_DNS_CB(_dns_getpwuid, NULL)
+		NS_NIS_CB(_nis_getpwuid, NULL)
+		NS_COMPAT_CB(_compat_getpwuid, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&_pwmutex);
+	rv = nsdispatch(NULL, dtab, NSDB_PASSWD, "getpwuid", __nsdefaultcompat,
+	    &retval, uid);
+	mutex_unlock(&_pwmutex);
+	return (rv == NS_SUCCESS) ? retval : NULL;
+}
+
+int
+getpwuid_r(uid_t uid, struct passwd *pwd, char *buffer, size_t buflen,
+	struct passwd **result)
+{
+	int	r, retval;
+
+	return -1; /* FIXME */
+	/* FIXME: FIXME: */
+
+
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_getpwuid_r, NULL)
+		NS_DNS_CB(_dns_getpwuid_r, NULL)
+		NS_NIS_CB(_nis_getpwuid_r, NULL)
+		NS_COMPAT_CB(_compat_getpwuid_r, NULL)
+		NS_NULL_CB
+	};
+
+	_DIAGASSERT(pwd != NULL);
+	_DIAGASSERT(buffer != NULL);
+	_DIAGASSERT(result != NULL);
+
+	*result = NULL;
+	retval = 0;
+	mutex_lock(&_pwmutex);
+	r = nsdispatch(NULL, dtab, NSDB_PASSWD, "getpwuid_r", __nsdefaultcompat,
+	    &retval, uid, pwd, buffer, buflen, result);
+	mutex_unlock(&_pwmutex);
+	switch (r) {
+	case NS_SUCCESS:
+	case NS_NOTFOUND:
+		return 0;
+	default:
+		return retval;
+	}
+}
+
+void
+endpwent(void)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_endpwent, NULL)
+		NS_DNS_CB(_dns_endpwent, NULL)
+		NS_NIS_CB(_nis_endpwent, NULL)
+		NS_COMPAT_CB(_compat_endpwent, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&_pwmutex);
+					/* force all endpwent() methods */
+	(void) nsdispatch(NULL, dtab, NSDB_PASSWD, "endpwent",
+	    __nsdefaultcompat_forceall);
+	mutex_unlock(&_pwmutex);
+}
+
+/*ARGSUSED*/
+int
+setpassent(int stayopen)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_setpassent, NULL)
+		NS_DNS_CB(_dns_setpassent, NULL)
+		NS_NIS_CB(_nis_setpassent, NULL)
+		NS_COMPAT_CB(_compat_setpassent, NULL)
+		NS_NULL_CB
+	};
+	int	rv, retval;
+
+	mutex_lock(&_pwmutex);
+					/* force all setpassent() methods */
+	rv = nsdispatch(NULL, dtab, NSDB_PASSWD, "setpassent",
+	    __nsdefaultcompat_forceall, &retval, stayopen);
+	mutex_unlock(&_pwmutex);
+	return (rv == NS_SUCCESS) ? retval : 0;
+}
+
+void
+setpwent(void)
+{
+	static const ns_dtab dtab[] = {
+		NS_FILES_CB(_files_setpwent, NULL)
+		NS_DNS_CB(_dns_setpwent, NULL)
+		NS_NIS_CB(_nis_setpwent, NULL)
+		NS_COMPAT_CB(_compat_setpwent, NULL)
+		NS_NULL_CB
+	};
+
+	mutex_lock(&_pwmutex);
+					/* force all setpwent() methods */
+	(void) nsdispatch(NULL, dtab, NSDB_PASSWD, "setpwent",
+	    __nsdefaultcompat_forceall);
+	mutex_unlock(&_pwmutex);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/gettod.c third_party/newlib-4.1.0/newlib/libc/sys/arm/gettod.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/gettod.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/gettod.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,48 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int gettimeofday (struct timeval *tp, void *tzp)
+{
+    int sc;
+
+    sc = _swi_gettimeofday(tp);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ *
+ */
+int settimeofday(const struct timeval *tp, const struct timezone *tzp)
+{
+    int sc;
+
+    sc = _swi_settimeofday(tp);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/heapsort.c third_party/newlib-4.1.0/newlib/libc/sys/arm/heapsort.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/heapsort.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/heapsort.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,202 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * Copyright (c) 2014 David T. Chisnall
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Ronnie Kon at Mindcraft Inc., Kevin Lew and Elmer Yglesias.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)heapsort.c	8.1 (Berkeley) 6/4/93";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <errno.h>
+#include <stddef.h>
+#include <stdlib.h>
+
+#ifdef I_AM_HEAPSORT_B
+#include "block_abi.h"
+#define COMPAR(x, y) CALL_BLOCK(compar, x, y)
+typedef DECLARE_BLOCK(int, heapsort_block, const void *, const void *);
+#else
+#define COMPAR(x, y) compar(x, y)
+#endif
+
+/*
+ * Swap two areas of size number of bytes.  Although qsort(3) permits random
+ * blocks of memory to be sorted, sorting pointers is almost certainly the
+ * common case (and, were it not, could easily be made so).  Regardless, it
+ * isn't worth optimizing; the SWAP's get sped up by the cache, and pointer
+ * arithmetic gets lost in the time required for comparison function calls.
+ */
+#define	SWAP(a, b, count, size, tmp) { \
+	count = size; \
+	do { \
+		tmp = *a; \
+		*a++ = *b; \
+		*b++ = tmp; \
+	} while (--count); \
+}
+
+/* Copy one block of size size to another. */
+#define COPY(a, b, count, size, tmp1, tmp2) { \
+	count = size; \
+	tmp1 = a; \
+	tmp2 = b; \
+	do { \
+		*tmp1++ = *tmp2++; \
+	} while (--count); \
+}
+
+/*
+ * Build the list into a heap, where a heap is defined such that for
+ * the records K1 ... KN, Kj/2 >= Kj for 1 <= j/2 <= j <= N.
+ *
+ * There two cases.  If j == nmemb, select largest of Ki and Kj.  If
+ * j < nmemb, select largest of Ki, Kj and Kj+1.
+ */
+#define CREATE(initval, nmemb, par_i, child_i, par, child, size, count, tmp) { \
+	for (par_i = initval; (child_i = par_i * 2) <= nmemb; \
+	    par_i = child_i) { \
+		child = base + child_i * size; \
+		if (child_i < nmemb && COMPAR(child, child + size) < 0) { \
+			child += size; \
+			++child_i; \
+		} \
+		par = base + par_i * size; \
+		if (COMPAR(child, par) <= 0) \
+			break; \
+		SWAP(par, child, count, size, tmp); \
+	} \
+}
+
+/*
+ * Select the top of the heap and 'heapify'.  Since by far the most expensive
+ * action is the call to the compar function, a considerable optimization
+ * in the average case can be achieved due to the fact that k, the displaced
+ * elememt, is usually quite small, so it would be preferable to first
+ * heapify, always maintaining the invariant that the larger child is copied
+ * over its parent's record.
+ *
+ * Then, starting from the *bottom* of the heap, finding k's correct place,
+ * again maintianing the invariant.  As a result of the invariant no element
+ * is 'lost' when k is assigned its correct place in the heap.
+ *
+ * The time savings from this optimization are on the order of 15-20% for the
+ * average case. See Knuth, Vol. 3, page 158, problem 18.
+ *
+ * XXX Don't break the #define SELECT line, below.  Reiser cpp gets upset.
+ */
+#define SELECT(par_i, child_i, nmemb, par, child, size, k, count, tmp1, tmp2) { \
+	for (par_i = 1; (child_i = par_i * 2) <= nmemb; par_i = child_i) { \
+		child = base + child_i * size; \
+		if (child_i < nmemb && COMPAR(child, child + size) < 0) { \
+			child += size; \
+			++child_i; \
+		} \
+		par = base + par_i * size; \
+		COPY(par, child, count, size, tmp1, tmp2); \
+	} \
+	for (;;) { \
+		child_i = par_i; \
+		par_i = child_i / 2; \
+		child = base + child_i * size; \
+		par = base + par_i * size; \
+		if (child_i == 1 || COMPAR(k, par) < 0) { \
+			COPY(child, k, count, size, tmp1, tmp2); \
+			break; \
+		} \
+		COPY(child, par, count, size, tmp1, tmp2); \
+	} \
+}
+
+#ifdef I_AM_HEAPSORT_B
+int heapsort_b(void *, size_t, size_t, heapsort_block);
+#else
+int heapsort(void *, size_t, size_t,
+    int (*)(const void *, const void *));
+#endif
+/*
+ * Heapsort -- Knuth, Vol. 3, page 145.  Runs in O (N lg N), both average
+ * and worst.  While heapsort is faster than the worst case of quicksort,
+ * the BSD quicksort does median selection so that the chance of finding
+ * a data set that will trigger the worst case is nonexistent.  Heapsort's
+ * only advantage over quicksort is that it requires little additional memory.
+ */
+#ifdef I_AM_HEAPSORT_B
+int
+heapsort_b(void *vbase, size_t nmemb, size_t size, heapsort_block compar)
+#else
+int
+heapsort(void *vbase, size_t nmemb, size_t size,
+    int (*compar)(const void *, const void *))
+#endif
+{
+	size_t cnt, i, j, l;
+	char tmp, *tmp1, *tmp2;
+	char *base, *k, *p, *t;
+
+	if (nmemb <= 1)
+		return (0);
+
+	if (!size) {
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if ((k = malloc(size)) == NULL)
+		return (-1);
+
+	/*
+	 * Items are numbered from 1 to nmemb, so offset from size bytes
+	 * below the starting address.
+	 */
+	base = (char *)vbase - size;
+
+	for (l = nmemb / 2 + 1; --l;)
+		CREATE(l, nmemb, i, j, t, p, size, cnt, tmp);
+
+	/*
+	 * For each element of the heap, save the largest element into its
+	 * final slot, save the displaced element (k), then recreate the
+	 * heap.
+	 */
+	while (nmemb > 1) {
+		COPY(k, base + nmemb * size, cnt, size, tmp1, tmp2);
+		COPY(base + nmemb * size, base + size, cnt, size, tmp1, tmp2);
+		--nmemb;
+		SELECT(i, j, nmemb, t, p, size, k, cnt, tmp1, tmp2);
+	}
+	free(k);
+	return (0);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/humanize_number.c third_party/newlib-4.1.0/newlib/libc/sys/arm/humanize_number.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/humanize_number.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/humanize_number.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,183 @@
+/*	$NetBSD: humanize_number.c,v 1.14 2008/04/28 20:22:59 martin Exp $	*/
+
+/*-
+ * SPDX-License-Identifier: BSD-2-Clause-FreeBSD
+ *
+ * Copyright (c) 1997, 1998, 1999, 2002 The NetBSD Foundation, Inc.
+ * Copyright 2013 John-Mark Gurney <jmg@FreeBSD.org>
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
+ * NASA Ames Research Center, by Luke Mewburn and by Tomas Svensson.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <assert.h>
+#include <inttypes.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <locale.h>
+
+#include "compat.h"
+
+static const int maxscale = 6;
+
+int
+humanize_number(char *buf, size_t len, int64_t quotient,
+    const char *suffix, int scale, int flags)
+{
+	const char *prefixes, *sep;
+	int	i, r, remainder, s1, s2, sign;
+	int	divisordeccut;
+	int64_t	divisor, max;
+	size_t	baselen;
+
+	/* Since so many callers don't check -1, NUL terminate the buffer */
+	if (len > 0)
+		buf[0] = '\0';
+
+	/* validate args */
+	if (buf == NULL || suffix == NULL)
+		return (-1);
+	if (scale < 0)
+		return (-1);
+	else if (scale > maxscale &&
+	    ((scale & ~(HN_AUTOSCALE|HN_GETSCALE)) != 0))
+		return (-1);
+	if ((flags & HN_DIVISOR_1000) && (flags & HN_IEC_PREFIXES))
+		return (-1);
+
+	/* setup parameters */
+	remainder = 0;
+
+	if (flags & HN_IEC_PREFIXES) {
+		baselen = 2;
+		/*
+		 * Use the prefixes for power of two recommended by
+		 * the International Electrotechnical Commission
+		 * (IEC) in IEC 80000-3 (i.e. Ki, Mi, Gi...).
+		 *
+		 * HN_IEC_PREFIXES implies a divisor of 1024 here
+		 * (use of HN_DIVISOR_1000 would have triggered
+		 * an assertion earlier).
+		 */
+		divisor = 1024;
+		divisordeccut = 973;	/* ceil(.95 * 1024) */
+		if (flags & HN_B)
+			prefixes = "B\0\0Ki\0Mi\0Gi\0Ti\0Pi\0Ei";
+		else
+			prefixes = "\0\0\0Ki\0Mi\0Gi\0Ti\0Pi\0Ei";
+	} else {
+		baselen = 1;
+		if (flags & HN_DIVISOR_1000) {
+			divisor = 1000;
+			divisordeccut = 950;
+			if (flags & HN_B)
+				prefixes = "B\0\0k\0\0M\0\0G\0\0T\0\0P\0\0E";
+			else
+				prefixes = "\0\0\0k\0\0M\0\0G\0\0T\0\0P\0\0E";
+		} else {
+			divisor = 1024;
+			divisordeccut = 973;	/* ceil(.95 * 1024) */
+			if (flags & HN_B)
+				prefixes = "B\0\0K\0\0M\0\0G\0\0T\0\0P\0\0E";
+			else
+				prefixes = "\0\0\0K\0\0M\0\0G\0\0T\0\0P\0\0E";
+		}
+	}
+
+#define	SCALE2PREFIX(scale)	(&prefixes[(scale) * 3])
+
+	if (quotient < 0) {
+		sign = -1;
+		quotient = -quotient;
+		baselen += 2;		/* sign, digit */
+	} else {
+		sign = 1;
+		baselen += 1;		/* digit */
+	}
+	if (flags & HN_NOSPACE)
+		sep = "";
+	else {
+		sep = " ";
+		baselen++;
+	}
+	baselen += strlen(suffix);
+
+	/* Check if enough room for `x y' + suffix + `\0' */
+	if (len < baselen + 1)
+		return (-1);
+
+	if (scale & (HN_AUTOSCALE | HN_GETSCALE)) {
+		/* See if there is additional columns can be used. */
+		for (max = 1, i = len - baselen; i-- > 0;)
+			max *= 10;
+
+		/*
+		 * Divide the number until it fits the given column.
+		 * If there will be an overflow by the rounding below,
+		 * divide once more.
+		 */
+		for (i = 0;
+		    (quotient >= max || (quotient == max - 1 &&
+		    (remainder >= divisordeccut || remainder >=
+		    divisor / 2))) && i < maxscale; i++) {
+			remainder = quotient % divisor;
+			quotient /= divisor;
+		}
+
+		if (scale & HN_GETSCALE)
+			return (i);
+	} else {
+		for (i = 0; i < scale && i < maxscale; i++) {
+			remainder = quotient % divisor;
+			quotient /= divisor;
+		}
+	}
+
+	/* If a value <= 9.9 after rounding and ... */
+	/*
+	 * XXX - should we make sure there is enough space for the decimal
+	 * place and if not, don't do HN_DECIMAL?
+	 */
+	if (((quotient == 9 && remainder < divisordeccut) || quotient < 9) &&
+	    i > 0 && flags & HN_DECIMAL) {
+		s1 = (int)quotient + ((remainder * 10 + divisor / 2) /
+		    divisor / 10);
+		s2 = ((remainder * 10 + divisor / 2) / divisor) % 10;
+		r = snprintf(buf, len, "%d%s%d%s%s%s",
+		    sign * s1, localeconv()->decimal_point, s2,
+		    sep, SCALE2PREFIX(i), suffix);
+	} else
+		r = snprintf(buf, len, "%" PRId64 "%s%s%s",
+		    sign * (quotient + (remainder + divisor / 2) / divisor),
+		    sep, SCALE2PREFIX(i), suffix);
+
+	return (r);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/id.c third_party/newlib-4.1.0/newlib/libc/sys/arm/id.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/id.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/id.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,190 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <pwd.h>
+
+
+/*
+ *
+ */
+int getpgrp(void)
+{
+  return _swi_getpgrp();
+}
+
+
+/*
+ * 
+ */
+int setpgrp(void)
+{
+  int sc;
+  
+  sc = _swi_setpgrp();
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+uid_t getuid(void)
+{
+  return _swi_getuid();
+}
+
+
+/*
+ *
+ */
+int setuid(uid_t uid)
+{
+  int sc;
+  
+  sc = _swi_setuid(uid);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+gid_t getgid(void)
+{
+  return _swi_getgid();
+}
+
+
+/*
+ *
+ */
+int setgid(gid_t gid)
+{
+  int sc;
+  
+  sc = _swi_setgid(gid);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+uid_t geteuid(void)
+{
+  return _swi_geteuid();
+}
+
+
+/*
+ *
+ */
+gid_t getegid(void)
+{  
+  return _swi_getegid();
+}
+
+
+/*
+ *
+ */
+int setegid(gid_t gid)
+{
+  int sc;
+  
+  sc = _swi_setegid(gid);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+int seteuid(uid_t uid)
+{
+  int sc;
+  
+  sc = _swi_seteuid(uid);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+int issetugid(void)
+{
+  return _swi_issetugid();
+}
+
+
+/*
+ *
+ */
+int	setgroups(int ngroups, const gid_t *grouplist)
+{
+  int sc;
+  
+  sc = _swi_setgroups(ngroups, grouplist);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+int getgroups(int gidsetsize, gid_t grouplist[])
+{
+  int sc;
+  
+  sc = _swi_getgroups(gidsetsize, grouplist);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/assert.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/assert.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/assert.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/assert.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,54 @@
+/*
+	assert.h
+*/
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "_ansi.h"
+
+#undef assert
+
+#ifdef NDEBUG           /* required by ANSI standard */
+# define assert(__e) ((void)0)
+# define 
+#else
+# define assert(__e) ((__e) ? (void)0 : __assert_func (__FILE__, __LINE__, \
+						       __ASSERT_FUNC, #__e))
+
+# undef _DIAGASSERT
+# define _DIAGASSERT(e)
+
+# ifndef __ASSERT_FUNC
+  /* Use g++'s demangled names in C++.  */
+#  if defined __cplusplus && defined __GNUC__
+#   define __ASSERT_FUNC __PRETTY_FUNCTION__
+
+  /* C99 requires the use of __func__.  */
+#  elif __STDC_VERSION__ >= 199901L
+#   define __ASSERT_FUNC __func__
+
+  /* Older versions of gcc don't have __func__ but can use __FUNCTION__.  */
+#  elif __GNUC__ >= 2
+#   define __ASSERT_FUNC __FUNCTION__
+
+  /* failed to detect __func__ support.  */
+#  else
+#   define __ASSERT_FUNC ((char *) 0)
+#  endif
+# endif /* !__ASSERT_FUNC */
+#endif /* !NDEBUG */
+
+void __assert (const char *, int, const char *)
+	    _ATTRIBUTE ((__noreturn__));
+void __assert_func (const char *, int, const char *, const char *)
+	    _ATTRIBUTE ((__noreturn__));
+
+#if __STDC_VERSION__ >= 201112L && !defined __cplusplus
+# define static_assert _Static_assert
+#endif
+
+#ifdef __cplusplus
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/btree.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/btree.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/btree.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/btree.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,433 @@
+/*	$NetBSD: btree.h,v 1.17 2013/09/04 13:03:22 ryoon Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Mike Olson.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)btree.h	8.11 (Berkeley) 8/17/94
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+/* Macros to set/clear/test flags. */
+#define	F_SET(p, f)	(p)->flags |= (f)
+#define	F_CLR(p, f)	(p)->flags &= ~(f)
+#define	F_ISSET(p, f)	((p)->flags & (f))
+
+#include <mpool.h>
+
+#define	DEFMINKEYPAGE	(2)		/* Minimum keys per page */
+#define	MINCACHE	(5)		/* Minimum cached pages */
+#define	MINPSIZE	(512)		/* Minimum page size */
+
+/*
+ * Page 0 of a btree file contains a copy of the meta-data.  This page is also
+ * used as an out-of-band page, i.e. page pointers that point to nowhere point
+ * to page 0.  Page 1 is the root of the btree.
+ */
+#define	P_INVALID	 0		/* Invalid tree page number. */
+#define	P_META		 0		/* Tree metadata page number. */
+#define	P_ROOT		 1		/* Tree root page number. */
+
+/*
+ * There are five page layouts in the btree: btree internal pages (BINTERNAL),
+ * btree leaf pages (BLEAF), recno internal pages (RINTERNAL), recno leaf pages
+ * (RLEAF) and overflow pages.  All five page types have a page header (PAGE).
+ * This implementation requires that values within structures NOT be padded.
+ * (ANSI C permits random padding.)  If your compiler pads randomly you'll have
+ * to do some work to get this package to run.
+ */
+typedef struct _page {
+	pgno_t	pgno;			/* this page's page number */
+	pgno_t	prevpg;			/* left sibling */
+	pgno_t	nextpg;			/* right sibling */
+
+#define	P_BINTERNAL	0x01		/* btree internal page */
+#define	P_BLEAF		0x02		/* leaf page */
+#define	P_OVERFLOW	0x04		/* overflow page */
+#define	P_RINTERNAL	0x08		/* recno internal page */
+#define	P_RLEAF		0x10		/* leaf page */
+#define P_TYPE		0x1f		/* type mask */
+#define	P_PRESERVE	0x20		/* never delete this chain of pages */
+	uint32_t flags;
+
+	indx_t	lower;			/* lower bound of free space on page */
+	indx_t	upper;			/* upper bound of free space on page */
+	indx_t	linp[1];		/* indx_t-aligned VAR. LENGTH DATA */
+} PAGE;
+
+/* First and next index. */
+#define	BTDATAOFF							\
+	(sizeof(pgno_t) + sizeof(pgno_t) + sizeof(pgno_t) +		\
+	    sizeof(uint32_t) + sizeof(indx_t) + sizeof(indx_t))
+
+#define	_NEXTINDEX(p) (((p)->lower - BTDATAOFF) / sizeof(indx_t))
+#ifdef _DIAGNOSTIC
+static __inline indx_t
+NEXTINDEX(const PAGE *p) {
+	size_t x = _NEXTINDEX(p);
+	_DBFIT(x, indx_t);
+	return (indx_t)x;
+}
+#else
+#define	NEXTINDEX(p) (indx_t)_NEXTINDEX(p)
+#endif
+
+/*
+ * For pages other than overflow pages, there is an array of offsets into the
+ * rest of the page immediately following the page header.  Each offset is to
+ * an item which is unique to the type of page.  The h_lower offset is just
+ * past the last filled-in index.  The h_upper offset is the first item on the
+ * page.  Offsets are from the beginning of the page.
+ *
+ * If an item is too big to store on a single page, a flag is set and the item
+ * is a { page, size } pair such that the page is the first page of an overflow
+ * chain with size bytes of item.  Overflow pages are simply bytes without any
+ * external structure.
+ *
+ * The page number and size fields in the items are pgno_t-aligned so they can
+ * be manipulated without copying.  (This presumes that 32 bit items can be
+ * manipulated on this system.)
+ */
+#define	BTLALIGN(n)	(((n) + sizeof(pgno_t) - 1) & ~(sizeof(pgno_t) - 1))
+#define	NOVFLSIZE	(sizeof(pgno_t) + sizeof(uint32_t))
+
+/*
+ * For the btree internal pages, the item is a key.  BINTERNALs are {key, pgno}
+ * pairs, such that the key compares less than or equal to all of the records
+ * on that page.  For a tree without duplicate keys, an internal page with two
+ * consecutive keys, a and b, will have all records greater than or equal to a
+ * and less than b stored on the page associated with a.  Duplicate keys are
+ * somewhat special and can cause duplicate internal and leaf page records and
+ * some minor modifications of the above rule.
+ */
+typedef struct _binternal {
+	uint32_t ksize;			/* key size */
+	pgno_t	pgno;			/* page number stored on */
+#define	P_BIGDATA	0x01		/* overflow data */
+#define	P_BIGKEY	0x02		/* overflow key */
+	uint8_t	flags;
+	char	bytes[1];		/* data */
+} BINTERNAL;
+
+/* Get the page's BINTERNAL structure at index indx. */
+#define	GETBINTERNAL(pg, indx)						\
+	((BINTERNAL *)(void *)((char *)(void *)(pg) + (pg)->linp[indx]))
+
+/* Get the number of bytes in the entry. */
+#define _NBINTERNAL(len)						\
+    BTLALIGN(sizeof(uint32_t) + sizeof(pgno_t) + sizeof(uint8_t) + (len))
+#ifdef _DIAGNOSTIC
+static __inline uint32_t
+NBINTERNAL(uint32_t len) {
+	size_t x = _NBINTERNAL(len);
+	_DBFIT(x, uint32_t);
+	return (uint32_t)x;
+}
+#else
+#define NBINTERNAL(len)	(uint32_t)_NBINTERNAL(len)
+#endif
+
+/* Copy a BINTERNAL entry to the page. */
+#define	WR_BINTERNAL(p, size, pgno, flags) do {				\
+	_DBFIT(size, uint32_t);						\
+	*(uint32_t *)(void *)p = (uint32_t)size;			\
+	p += sizeof(uint32_t);						\
+	*(pgno_t *)(void *)p = pgno;					\
+	p += sizeof(pgno_t);						\
+	*(uint8_t *)(void *)p = flags;					\
+	p += sizeof(uint8_t);						\
+} while (/*CONSTCOND*/0)
+
+/*
+ * For the recno internal pages, the item is a page number with the number of
+ * keys found on that page and below.
+ */
+typedef struct _rinternal {
+	recno_t	nrecs;			/* number of records */
+	pgno_t	pgno;			/* page number stored below */
+} RINTERNAL;
+
+/* Get the page's RINTERNAL structure at index indx. */
+#define	GETRINTERNAL(pg, indx)						\
+	((RINTERNAL *)(void *)((char *)(void *)(pg) + (pg)->linp[indx]))
+
+/* Get the number of bytes in the entry. */
+#define NRINTERNAL							\
+	BTLALIGN(sizeof(recno_t) + sizeof(pgno_t))
+
+/* Copy a RINTERNAL entry to the page. */
+#define	WR_RINTERNAL(p, nrecs, pgno) do {				\
+	*(recno_t *)(void *)p = nrecs;					\
+	p += sizeof(recno_t);						\
+	*(pgno_t *)(void *)p = pgno;					\
+} while (/*CONSTCOND*/0)
+
+/* For the btree leaf pages, the item is a key and data pair. */
+typedef struct _bleaf {
+	uint32_t	ksize;		/* size of key */
+	uint32_t	dsize;		/* size of data */
+	uint8_t	flags;			/* P_BIGDATA, P_BIGKEY */
+	char	bytes[1];		/* data */
+} BLEAF;
+
+/* Get the page's BLEAF structure at index indx. */
+#define	GETBLEAF(pg, indx)						\
+	((BLEAF *)(void *)((char *)(void *)(pg) + (pg)->linp[indx]))
+
+
+/* Get the number of bytes in the user's key/data pair. */
+#define _NBLEAFDBT(ksize, dsize)					\
+    BTLALIGN(sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint8_t) +	\
+	    (ksize) + (dsize))
+#ifdef _DIAGNOSTIC
+static __inline uint32_t
+NBLEAFDBT(size_t k, size_t d) {
+	size_t x = _NBLEAFDBT(k, d);
+	_DBFIT(x, uint32_t);
+	return (uint32_t)x;
+}
+#else
+#define NBLEAFDBT(p, q)	(uint32_t)_NBLEAFDBT(p, q)
+#endif
+
+/* Get the number of bytes in the entry. */
+#define NBLEAF(p)	NBLEAFDBT((p)->ksize, (p)->dsize)
+
+/* Copy a BLEAF entry to the page. */
+#define	WR_BLEAF(p, key, data, flags) do {				\
+	_DBFIT(key->size, uint32_t);					\
+	*(uint32_t *)(void *)p = (uint32_t)key->size;			\
+	p += sizeof(uint32_t);						\
+	_DBFIT(data->size, uint32_t);					\
+	*(uint32_t *)(void *)p = (uint32_t)data->size;			\
+	p += sizeof(uint32_t);						\
+	*(uint8_t *)(void *)p = flags;					\
+	p += sizeof(uint8_t);						\
+	(void)memmove(p, key->data, key->size);				\
+	p += key->size;							\
+	(void)memmove(p, data->data, data->size);			\
+} while (/*CONSTCOND*/0)
+
+/* For the recno leaf pages, the item is a data entry. */
+typedef struct _rleaf {
+	uint32_t	dsize;		/* size of data */
+	uint8_t	flags;			/* P_BIGDATA */
+	char	bytes[1];
+} RLEAF;
+
+/* Get the page's RLEAF structure at index indx. */
+#define	GETRLEAF(pg, indx)						\
+	((RLEAF *)(void *)((char *)(void *)(pg) + (pg)->linp[indx]))
+
+#define	_NRLEAFDBT(dsize)						\
+	BTLALIGN(sizeof(uint32_t) + sizeof(uint8_t) + (dsize))
+
+#ifdef _DIAGNOSTIC
+static __inline uint32_t
+NRLEAFDBT(size_t d) {
+	size_t x = _NRLEAFDBT(d);
+	_DBFIT(x, uint32_t);
+	return (uint32_t)x;
+}
+#else
+#define NRLEAFDBT(d)	(uint32_t)_NRLEAFDBT(d)
+#endif
+
+/* Get the number of bytes in the entry. */
+#define NRLEAF(p)	NRLEAFDBT((p)->dsize)
+
+/* Get the number of bytes from the user's data. */
+
+/* Copy a RLEAF entry to the page. */
+#define	WR_RLEAF(p, data, flags) do {					\
+	_DBFIT(data->size, uint32_t);					\
+	*(uint32_t *)(void *)p = (uint32_t)data->size;			\
+	p += sizeof(uint32_t);						\
+	*(uint8_t *)(void *)p = flags;					\
+	p += sizeof(uint8_t);						\
+	memmove(p, data->data, data->size);				\
+} while (/*CONSTCOND*/0)
+
+/*
+ * A record in the tree is either a pointer to a page and an index in the page
+ * or a page number and an index.  These structures are used as a cursor, stack
+ * entry and search returns as well as to pass records to other routines.
+ *
+ * One comment about searches.  Internal page searches must find the largest
+ * record less than key in the tree so that descents work.  Leaf page searches
+ * must find the smallest record greater than key so that the returned index
+ * is the record's correct position for insertion.
+ */
+typedef struct _epgno {
+	pgno_t	pgno;			/* the page number */
+	indx_t	index;			/* the index on the page */
+} EPGNO;
+
+typedef struct _epg {
+	PAGE	*page;			/* the (pinned) page */
+	indx_t	 index;			/* the index on the page */
+} EPG;
+
+/*
+ * About cursors.  The cursor (and the page that contained the key/data pair
+ * that it referenced) can be deleted, which makes things a bit tricky.  If
+ * there are no duplicates of the cursor key in the tree (i.e. B_NODUPS is set
+ * or there simply aren't any duplicates of the key) we copy the key that it
+ * referenced when it's deleted, and reacquire a new cursor key if the cursor
+ * is used again.  If there are duplicates keys, we move to the next/previous
+ * key, and set a flag so that we know what happened.  NOTE: if duplicate (to
+ * the cursor) keys are added to the tree during this process, it is undefined
+ * if they will be returned or not in a cursor scan.
+ *
+ * The flags determine the possible states of the cursor:
+ *
+ * CURS_INIT	The cursor references *something*.
+ * CURS_ACQUIRE	The cursor was deleted, and a key has been saved so that
+ *		we can reacquire the right position in the tree.
+ * CURS_AFTER, CURS_BEFORE
+ *		The cursor was deleted, and now references a key/data pair
+ *		that has not yet been returned, either before or after the
+ *		deleted key/data pair.
+ * XXX
+ * This structure is broken out so that we can eventually offer multiple
+ * cursors as part of the DB interface.
+ */
+typedef struct _cursor {
+	EPGNO	 pg;			/* B: Saved tree reference. */
+	DBT	 key;			/* B: Saved key, or key.data == NULL. */
+	recno_t	 rcursor;		/* R: recno cursor (1-based) */
+
+#define	CURS_ACQUIRE	0x01		/*  B: Cursor needs to be reacquired. */
+#define	CURS_AFTER	0x02		/*  B: Unreturned cursor after key. */
+#define	CURS_BEFORE	0x04		/*  B: Unreturned cursor before key. */
+#define	CURS_INIT	0x08		/* RB: Cursor initialized. */
+	uint8_t flags;
+} CURSOR;
+
+/*
+ * The metadata of the tree.  The nrecs field is used only by the RECNO code.
+ * This is because the btree doesn't really need it and it requires that every
+ * put or delete call modify the metadata.
+ */
+typedef struct _btmeta {
+	uint32_t	magic;		/* magic number */
+	uint32_t	version;	/* version */
+	uint32_t	psize;		/* page size */
+	uint32_t	free;		/* page number of first free page */
+	uint32_t	nrecs;		/* R: number of records */
+
+#define	SAVEMETA	(B_NODUPS | R_RECNO)
+	uint32_t	flags;		/* bt_flags & SAVEMETA */
+} BTMETA;
+
+/* The in-memory btree/recno data structure. */
+typedef struct _btree {
+	MPOOL	 *bt_mp;		/* memory pool cookie */
+
+	DB	 *bt_dbp;		/* pointer to enclosing DB */
+
+	EPG	  bt_cur;		/* current (pinned) page */
+	PAGE	 *bt_pinned;		/* page pinned across calls */
+
+	CURSOR	  bt_cursor;		/* cursor */
+
+#define	BT_PUSH(t, p, i) {						\
+	t->bt_sp->pgno = p; 						\
+	t->bt_sp->index = i; 						\
+	++t->bt_sp;							\
+}
+#define	BT_POP(t)	(t->bt_sp == t->bt_stack ? NULL : --t->bt_sp)
+#define	BT_CLR(t)	(t->bt_sp = t->bt_stack)
+	EPGNO	  bt_stack[50];		/* stack of parent pages */
+	EPGNO	 *bt_sp;		/* current stack pointer */
+
+	DBT	  bt_rkey;		/* returned key */
+	DBT	  bt_rdata;		/* returned data */
+
+	int	  bt_fd;		/* tree file descriptor */
+
+	pgno_t	  bt_free;		/* next free page */
+	uint32_t bt_psize;		/* page size */
+	indx_t	  bt_ovflsize;		/* cut-off for key/data overflow */
+	int	  bt_lorder;		/* byte order */
+					/* sorted order */
+	enum { NOT, BACK, FORWARD } bt_order;
+	EPGNO	  bt_last;		/* last insert */
+
+					/* B: key comparison function */
+	int	(*bt_cmp)(const DBT *, const DBT *);
+					/* B: prefix comparison function */
+	size_t	(*bt_pfx)(const DBT *, const DBT *);
+					/* R: recno input function */
+	int	(*bt_irec)(struct _btree *, recno_t);
+
+	FILE	 *bt_rfp;		/* R: record FILE pointer */
+	int	  bt_rfd;		/* R: record file descriptor */
+
+	caddr_t	  bt_cmap;		/* R: current point in mapped space */
+	caddr_t	  bt_smap;		/* R: start of mapped space */
+	caddr_t   bt_emap;		/* R: end of mapped space */
+	size_t	  bt_msize;		/* R: size of mapped region. */
+
+	recno_t	  bt_nrecs;		/* R: number of records */
+	size_t	  bt_reclen;		/* R: fixed record length */
+	uint8_t	  bt_bval;		/* R: delimiting byte/pad character */
+
+/*
+ * NB:
+ * B_NODUPS and R_RECNO are stored on disk, and may not be changed.
+ */
+#define	B_INMEM		0x00001		/* in-memory tree */
+#define	B_METADIRTY	0x00002		/* need to write metadata */
+#define	B_MODIFIED	0x00004		/* tree modified */
+#define	B_NEEDSWAP	0x00008		/* if byte order requires swapping */
+#define	B_RDONLY	0x00010		/* read-only tree */
+
+#define	B_NODUPS	0x00020		/* no duplicate keys permitted */
+#define	R_RECNO		0x00080		/* record oriented tree */
+
+#define	R_CLOSEFP	0x00040		/* opened a file pointer */
+#define	R_EOF		0x00100		/* end of input file reached. */
+#define	R_FIXLEN	0x00200		/* fixed length records */
+#define	R_MEMMAPPED	0x00400		/* memory mapped file. */
+#define	R_INMEM		0x00800		/* in-memory file */
+#define	R_MODIFIED	0x01000		/* modified file */
+#define	R_RDONLY	0x02000		/* read-only file */
+
+#define	B_DB_LOCK	0x04000		/* DB_LOCK specified. */
+#define	B_DB_SHMEM	0x08000		/* DB_SHMEM specified. */
+#define	B_DB_TXN	0x10000		/* DB_TXN specified. */
+	uint32_t flags;
+} BTREE;
+
+#include "btree_extern.h"
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/compat.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/compat.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/compat.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/compat.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2021 David Cantrell <david.l.cantrell@gmail.com>
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above
+ * copyright notice, this list of conditions and the following
+ * disclaimer in the documentation and/or other materials provided
+ * with the distribution.
+ *
+ * 3. Neither the name of the copyright holder nor the names of its
+ * contributors may be used to endorse or promote products derived
+ * from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
+ * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
+ * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
+ * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _COMPAT_H
+#define _COMPAT_H
+
+#include <stdint.h>
+#include <sys/stat.h>
+
+/* FreeBSD kernel stuff */
+
+/* from <sys/param.h> on FreeBSD */
+/* max raw I/O transfer size */
+/*
+ * XXX: this is _probably_ going to be 1M on the system if it were
+ * running FreeBSD.  What is the corresponding Linux parameter here
+ * and the sanctioned way to retrieve it?
+ */
+#define MAXPHYS (1024 * 1024)
+/* #define MAXPHYS (128 * 1024)    <--- could be this on 32-bit systems */
+
+/*
+ * File system parameters and macros.
+ *
+ * MAXBSIZE - Filesystems are made out of blocks of at most MAXBSIZE
+ *            bytes per block.  MAXBSIZE may be made larger without
+ *            effecting any existing filesystems as long as it does
+ *            not exceed MAXPHYS, and may be made smaller at the
+ *            risk of not being able to use filesystems which
+ *            require a block size exceeding MAXBSIZE.
+ */
+#define MAXBSIZE        65536   /* must be power of 2 */
+
+/* from <sys/param.h> in FreeBSD */
+/* Macros for counting and rounding. */
+#define roundup2(x, y)  (((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#define nitems(x)       (sizeof((x)) / sizeof((x)[0]))
+
+/* FreeBSD libc stuff */
+
+/* from <wchar.h> in FreeBSD */
+#define iswascii(wc) (((wc) & ~0x7F) == 0)
+
+mode_t getmode(const void *, mode_t);
+void *setmode(const char *);
+void strmode(int, char *);
+int mergesort(void *, size_t, size_t, int (*)(const void *, const void *));
+int heapsort(void *, size_t, size_t, int (*)(const void *, const void *));
+char *getbsize(int *, long *);
+
+/* FreeBSD libutil stuff */
+
+/* from <libutil.h> in FreeBSD */
+/* Values for humanize_number(3)'s flags parameter. */
+#define HN_DECIMAL              0x01
+#define HN_NOSPACE              0x02
+#define HN_B                    0x04
+#define HN_DIVISOR_1000         0x08
+#define HN_IEC_PREFIXES         0x10
+
+/* Values for humanize_number(3)'s scale parameter. */
+#define HN_GETSCALE             0x10
+#define HN_AUTOSCALE            0x20
+
+/* functions from libutil in FreeBSD */
+int humanize_number(char *, size_t, int64_t, const char *, int, int);
+int expand_number(const char *, uint64_t *);
+
+#ifndef HAVE_STRLCPY
+size_t strlcpy(char *d, const char *s, size_t n);
+#endif
+#ifndef HAVE_STRLCAT
+size_t strlcat(char *d, const char *s, size_t n);
+#endif
+
+/* we use SIGUSR1 in place of SIGINFO */
+#define SIGINFO SIGUSR1
+
+int signame_to_signum(const char *sig);
+const char *signum_to_signame(int signum);
+int get_signame_by_idx(size_t idx, const char **signame, int *signum);
+
+#endif /* _COMPAT_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/crypt.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/crypt.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/crypt.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/crypt.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,19 @@
+/*
+ * $NetBSD: crypt.h,v 1.4 2006/10/27 18:22:56 drochner Exp $
+ */
+char	*__md5crypt(const char *pw, const char *salt);	/* XXX */
+char *__bcrypt(const char *, const char *);	/* XXX */
+char *__crypt_sha1(const char *pw, const char *salt);
+unsigned int __crypt_sha1_iterations (unsigned int hint);
+void __hmac_sha1(const unsigned char *, size_t, const unsigned char *, size_t,
+		 unsigned char *);
+void __crypt_to64(char *s, u_int32_t v, int n);
+
+int __gensalt_blowfish(char *salt, size_t saltlen, const char *option);
+int __gensalt_old(char *salt, size_t saltsiz, const char *option);
+int __gensalt_new(char *salt, size_t saltsiz, const char *option);
+int __gensalt_md5(char *salt, size_t saltsiz, const char *option);
+int __gensalt_sha1(char *salt, size_t saltsiz, const char *option);
+
+#define SHA1_MAGIC "$sha1$"
+#define SHA1_SIZE 20
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/db.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/db.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/db.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/db.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,234 @@
+/*	$NetBSD: db.h,v 1.26 2013/12/01 00:23:11 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1990, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)db.h	8.7 (Berkeley) 6/16/94
+ */
+
+#define __DBINTERFACE_PRIVATE
+
+#ifndef _DB_H_
+#define	_DB_H_
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+
+#include <limits.h>
+
+#define	RET_ERROR	-1		/* Return values. */
+#define	RET_SUCCESS	 0
+#define	RET_SPECIAL	 1
+
+#define	MAX_PAGE_NUMBER	0xffffffff	/* >= # of pages in a file */
+typedef uint32_t	pgno_t;
+#define	MAX_PAGE_OFFSET	65535		/* >= # of bytes in a page */
+typedef uint16_t	indx_t;
+#define	MAX_REC_NUMBER	0xffffffff	/* >= # of records in a tree */
+typedef uint32_t	recno_t;
+
+/* Key/data structure -- a Data-Base Thang. */
+typedef struct {
+	void	*data;			/* data */
+	size_t	 size;			/* data length */
+} DBT;
+
+/* Routine flags. */
+#define	R_CURSOR	1		/* del, put, seq */
+#define	__R_UNUSED	2		/* UNUSED */
+#define	R_FIRST		3		/* seq */
+#define	R_IAFTER	4		/* put (RECNO) */
+#define	R_IBEFORE	5		/* put (RECNO) */
+#define	R_LAST		6		/* seq (BTREE, RECNO) */
+#define	R_NEXT		7		/* seq */
+#define	R_NOOVERWRITE	8		/* put */
+#define	R_PREV		9		/* seq (BTREE, RECNO) */
+#define	R_SETCURSOR	10		/* put (RECNO) */
+#define	R_RECNOSYNC	11		/* sync (RECNO) */
+
+typedef enum { DB_BTREE, DB_HASH, DB_RECNO } DBTYPE;
+
+/*
+ * !!!
+ * The following flags are included in the dbopen(3) call as part of the
+ * open(2) flags.  In order to avoid conflicts with the open flags, start
+ * at the top of the 16 or 32-bit number space and work our way down.  If
+ * the open flags were significantly expanded in the future, it could be
+ * a problem.  Wish I'd left another flags word in the dbopen call.
+ *
+ * !!!
+ * None of this stuff is implemented yet.  The only reason that it's here
+ * is so that the access methods can skip copying the key/data pair when
+ * the DB_LOCK flag isn't set.
+ */
+#if UINT_MAX > 65535
+#define	DB_LOCK		0x20000000	/* Do locking. */
+#define	DB_SHMEM	0x40000000	/* Use shared memory. */
+#define	DB_TXN		0x80000000	/* Do transactions. */
+#else
+#define	DB_LOCK		    0x2000	/* Do locking. */
+#define	DB_SHMEM	    0x4000	/* Use shared memory. */
+#define	DB_TXN		    0x8000	/* Do transactions. */
+#endif
+
+/* Access method description structure. */
+typedef struct __db {
+	DBTYPE type;			/* Underlying db type. */
+	int (*close)	(struct __db *);
+	int (*del)	(const struct __db *, const DBT *, unsigned int);
+	int (*get)	(const struct __db *, const DBT *, DBT *, unsigned int);
+	int (*put)	(const struct __db *, DBT *, const DBT *, unsigned int);
+	int (*seq)	(const struct __db *, DBT *, DBT *, unsigned int);
+	int (*sync)	(const struct __db *, unsigned int);
+	void *internal;			/* Access method private. */
+	int (*fd)	(const struct __db *);
+} DB;
+
+#define	BTREEMAGIC	0x053162
+#define	BTREEVERSION	3
+
+/* Structure used to pass parameters to the btree routines. */
+typedef struct {
+#define	R_DUP		0x01	/* duplicate keys */
+	unsigned long	flags;
+	unsigned int	cachesize;	/* bytes to cache */
+	int		maxkeypage;	/* maximum keys per page */
+	int		minkeypage;	/* minimum keys per page */
+	unsigned int	psize;		/* page size */
+	int	(*compare)	/* comparison function */
+		(const DBT *, const DBT *);
+	size_t	(*prefix)	/* prefix function */
+		(const DBT *, const DBT *);
+	int	lorder;		/* byte order */
+} BTREEINFO;
+
+#define	HASHMAGIC	0x061561
+#define	HASHVERSION	2
+
+/* Structure used to pass parameters to the hashing routines. */
+typedef struct {
+	unsigned int	bsize;		/* bucket size */
+	unsigned int	ffactor;	/* fill factor */
+	unsigned int	nelem;		/* number of elements */
+	unsigned int	cachesize;	/* bytes to cache */
+	uint32_t		/* hash function */
+		(*hash)(const void *, size_t);
+	int	lorder;		/* byte order */
+} HASHINFO;
+
+/* Structure used to pass parameters to the record routines. */
+typedef struct {
+#define	R_FIXEDLEN	0x01	/* fixed-length records */
+#define	R_NOKEY		0x02	/* key not required */
+#define	R_SNAPSHOT	0x04	/* snapshot the input */
+	unsigned long	flags;
+	unsigned int	cachesize;	/* bytes to cache */
+	unsigned int	psize;		/* page size */
+	int		lorder;		/* byte order */
+	size_t		reclen;		/* record length (fixed-length records) */
+	uint8_t		bval;		/* delimiting byte (variable-length records */
+	char		*bfname;	/* btree file name */ 
+} RECNOINFO;
+
+#ifdef __DBINTERFACE_PRIVATE
+/*
+ * Little endian <==> big endian 32-bit swap macros.
+ *	M_32_SWAP	swap a memory location
+ *	P_32_SWAP	swap a referenced memory location
+ *	P_32_COPY	swap from one location to another
+ */
+#define	M_32_SWAP(a) {							\
+	uint32_t _tmp = a;						\
+	((char *)(void *)&a)[0] = ((char *)(void *)&_tmp)[3];		\
+	((char *)(void *)&a)[1] = ((char *)(void *)&_tmp)[2];		\
+	((char *)(void *)&a)[2] = ((char *)(void *)&_tmp)[1];		\
+	((char *)(void *)&a)[3] = ((char *)(void *)&_tmp)[0];		\
+}
+#define	P_32_SWAP(a) {							\
+	char  _tmp[4];							\
+	_tmp[0] = ((char *)(void *)a)[0];				\
+	_tmp[1] = ((char *)(void *)a)[1];				\
+	_tmp[2] = ((char *)(void *)a)[2];				\
+	_tmp[3] = ((char *)(void *)a)[3];				\
+	((char *)(void *)a)[0] = _tmp[3];				\
+	((char *)(void *)a)[1] = _tmp[2];				\
+	((char *)(void *)a)[2] = _tmp[1];				\
+	((char *)(void *)a)[3] = _tmp[0];				\
+}
+#define	P_32_COPY(a, b) {						\
+	((char *)(void *)&(b))[0] = ((char *)(void *)&(a))[3];		\
+	((char *)(void *)&(b))[1] = ((char *)(void *)&(a))[2];		\
+	((char *)(void *)&(b))[2] = ((char *)(void *)&(a))[1];		\
+	((char *)(void *)&(b))[3] = ((char *)(void *)&(a))[0];		\
+}
+
+/*
+ * Little endian <==> big endian 16-bit swap macros.
+ *	M_16_SWAP	swap a memory location
+ *	P_16_SWAP	swap a referenced memory location
+ *	P_16_COPY	swap from one location to another
+ */
+#define	M_16_SWAP(a) {							\
+	uint16_t _tmp = a;						\
+	((char *)(void *)&a)[0] = ((char *)(void *)&_tmp)[1];		\
+	((char *)(void *)&a)[1] = ((char *)(void *)&_tmp)[0];		\
+}
+#define	P_16_SWAP(a) {							\
+	char  _tmp[2];							\
+	_tmp[0] = ((char *)(void *)a)[0];				\
+	_tmp[1] = ((char *)(void *)a)[1];				\
+	((char *)(void *)a)[0] = _tmp[1];				\
+	((char *)(void *)a)[1] = _tmp[0];				\
+}
+#define	P_16_COPY(a, b) {						\
+	((char *)(void *)&(b))[0] = ((char *)(void *)&(a))[1];		\
+	((char *)(void *)&(b))[1] = ((char *)(void *)&(a))[0];		\
+}
+#endif
+
+__BEGIN_DECLS
+DB *dbopen(const char *, int, mode_t, DBTYPE, const void *);
+
+#ifdef __DBINTERFACE_PRIVATE
+
+#if 0 
+#define _DBFIT(a, t) _DIAGASSERT(__type_fit(t, a))
+#else
+#define _DBFIT(a, t) _DIAGASSERT(__type_fit(t, a))
+#endif
+
+DB	*__bt_open(const char *, int, mode_t, const BTREEINFO *, int);
+DB	*__hash_open(const char *, int, mode_t, const HASHINFO *, int);
+DB	*__rec_open(const char *, int, mode_t, const RECNOINFO *, int);
+void	 __dbpanic(DB *);
+struct stat;
+int	 __dbopen(const char *, int, mode_t, struct stat *);
+int	 __dbtemp(const char *, struct stat *);
+#endif
+__END_DECLS
+#endif /* !_DB_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/err.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/err.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/err.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/err.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,64 @@
+/*	$NetBSD: err.h,v 1.17 2014/01/16 17:22:06 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)err.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _ERR_H_
+#define	_ERR_H_
+
+#include <stdarg.h>
+
+void	err(int, const char *, ...)
+		     __printflike(2, 3);
+void	verr(int, const char *, va_list)
+		    __printflike(2, 0);
+void	errx(int, const char *, ...)
+		     __printflike(2, 3);
+void	verrx(int, const char *, va_list)
+		    __printflike(2, 0);
+void	errc(int, int, const char *, ...)
+		     __printflike(3, 4);
+void	verrc(int, int, const char *, va_list)
+		    __printflike(3, 0);
+void		warn(const char *, ...)
+		    __printflike(1, 2);
+void		vwarn(const char *, va_list)
+		    __printflike(1, 0);
+void		warnx(const char *, ...)
+		    __printflike(1, 2);
+void		vwarnx(const char *, va_list)
+		    __printflike(1, 0);
+void		warnc(int, const char *, ...)
+		    __printflike(2, 3);
+void		vwarnc(int, const char *, va_list)
+		    __printflike(2, 0);
+
+#endif /* !_ERR_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/extern.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/extern.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/extern.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/extern.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,83 @@
+/*	$NetBSD: extern.h,v 1.23 2013/08/19 13:03:12 joerg Exp $	*/
+
+/*
+ * Copyright (c) 1997 Christos Zoulas.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdarg.h>
+#include <ucontext.h>
+//#include <btree.h>
+#if 0
+#ifndef __LOCALE_T_DECLARED
+typedef struct _locale		*locale_t;
+#define __LOCALE_T_DECLARED
+#endif /* __LOCALE_T_DECLARED */
+
+__BEGIN_DECLS
+extern char *__minbrk;
+int __getcwd(char *, size_t);
+int __getlogin(char *, size_t);
+int __setlogin(const char *);
+void _resumecontext(void) __dead;
+__dso_hidden int	_strerror_lr(int, char *, size_t, locale_t);
+const char *__strerror(int , char *, size_t);
+const char *__strsignal(int , char *, size_t);
+char *__dtoa(double, int, int, int *, int *, char **);
+void __freedtoa(char *);
+int __sysctl(const int *, unsigned int, void *, size_t *, const void *, size_t);
+
+struct sigaction;
+int __sigaction_sigtramp(int, const struct sigaction *,
+    struct sigaction *, const void *, int);
+
+#ifdef WIDE_DOUBLE
+char *__hdtoa(double, const char *, int, int *, int *, char **);
+char *__hldtoa(long double, const char *, int, int *, int *,  char **);
+char *__ldtoa(long double *, int, int, int *, int *, char **);
+#endif
+
+#ifndef __LIBC12_SOURCE__
+struct syslog_data;
+void	syslog_ss(int, struct syslog_data *, const char *, ...)
+    __RENAME(__syslog_ss60) __printflike(3, 4);
+void    vsyslog_ss(int, struct syslog_data *, const char *, va_list) 
+    __RENAME(__vsyslog_ss60) __printflike(3, 0); 
+void	syslogp_ss(int, struct syslog_data *, const char *, const char *, 
+    const char *, ...) __RENAME(__syslogp_ss60) __printflike(5, 0);
+void	vsyslogp_ss(int, struct syslog_data *, const char *, const char *, 
+    const char *, va_list) __RENAME(__vsyslogp_ss60) __printflike(5, 0);
+#endif
+
+void	_malloc_prefork(void);
+void	_malloc_postfork(void);
+
+int	_sys_setcontext(const ucontext_t *);
+
+
+
+
+#endif
+
+//__END_DECLS
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/fnmatch.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/fnmatch.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/fnmatch.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/fnmatch.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,57 @@
+/*-
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ * $FreeBSD: src/include/fnmatch.h,v 1.10 2002/03/23 17:24:53 imp Exp $
+ *	@(#)fnmatch.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef	_FNMATCH_H_
+#define	_FNMATCH_H_
+
+#include <sys/cdefs.h>
+
+#define	FNM_NOMATCH	1	/* Match failed. */
+#define	FNM_NOSYS	2		/* Function not implemented. */
+#define	FNM_NORES	3		/* Out of resources */
+
+#define	FNM_NOESCAPE	0x01	/* Disable backslash escaping. */
+#define	FNM_PATHNAME	0x02	/* Slash must be matched by slash. */
+#define	FNM_PERIOD	0x04		/* Period must be matched by period. */
+
+#define	FNM_LEADING_DIR	0x08	/* Ignore /<tail> after Imatch. */
+#define	FNM_CASEFOLD	0x10		/* Case insensitive search. */
+#define	FNM_IGNORECASE	FNM_CASEFOLD
+#define	FNM_FILE_NAME		FNM_PATHNAME
+
+
+
+__BEGIN_DECLS
+int	 fnmatch(const char *, const char *, int);
+__END_DECLS
+
+#endif /* !_FNMATCH_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/gr_private.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/gr_private.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/gr_private.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/gr_private.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,114 @@
+/*	$NetBSD: gr_private.h,v 1.2 2008/04/28 20:22:59 martin Exp $	*/
+
+/*-
+ * Copyright (c) 2004-2005 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Structures and functions used by various group(5) public functions
+ * and their back-end implementations.
+ * These are subject to change without notice and should not be used
+ * outside of libc (even by third-party nss_*.so modules implementing
+ * group(5) back-ends).
+ */
+
+#define _GROUP_COMPAT	/* "group" defaults to compat, so always provide it */
+
+
+#if defined(__minix) && defined(_REENTRANT)
+	/*
+	 * mutex to serialize the public group(5) functions use of the
+	 * back-end implementations, which may not be reentrant.
+	 */
+extern 	mutex_t		__grmutex;
+#endif /* defined(__minix) */
+
+	/*
+	 * files methods
+	 */
+struct __grstate_files {	/* state shared between files methods */
+	int	 stayopen;	/* see getgroupent(3) */
+	FILE	*fp;		/* groups file handle */
+};
+
+extern int	__grstart_files(struct __grstate_files *);
+extern int	__grend_files(struct __grstate_files *);
+extern int	__grscan_files(int *, struct group *, char *, size_t,
+			struct __grstate_files *, int, const char *, gid_t);
+
+	/*
+	 * dns methods
+	 */
+struct __grstate_dns {		/* state shared between dns methods */
+	int	 stayopen;	/* see getgroupent(3) */
+	void	*context;	/* Hesiod context */
+	int	 num;		/* group index, -1 if no more */
+};
+
+extern int	__grstart_dns(struct __grstate_dns *);
+extern int	__grend_dns(struct __grstate_dns *state);
+extern int	__grscan_dns(int *, struct group *, char *, size_t,
+			struct __grstate_dns *, int, const char *, gid_t);
+
+	/*
+	 * nis methods
+	 */
+struct __grstate_nis {		/* state shared between nis methods */
+	int	 stayopen;	/* see getgroupent(3) */
+	char	*domain;	/* NIS domain */
+	int	 done;		/* non-zero if search exhausted */
+	char	*current;	/* current first/next match */
+	int	 currentlen;	/* length of _nis_current */
+};
+
+extern int	__grstart_nis(struct __grstate_nis *);
+extern int	__grend_nis(struct __grstate_nis *);
+extern int	__grscan_nis(int *, struct group *, char *, size_t,
+			struct __grstate_nis *, int, const char *, gid_t);
+
+	/*
+	 * compat methods
+	 */
+struct __grstate_compat {	/* state shared between compat methods */
+	int	 stayopen;	/* see getgroupent(3) */
+	FILE	*fp;		/* file handle */
+/*
+ * XXX:	convert name to a separate compatstate enum and grow name as necessary
+ *	instead of using strdup & free for each + line
+ */
+	char	*name;		/* NULL if reading file,	*/
+				/*   "" if compat "+",		*/
+				/* name if compat "+name"	*/
+};
+
+extern int	__grbad_compat(void *nsrv, void *nscb, va_list ap);
+extern int	__grstart_compat(struct __grstate_compat *);
+extern int	__grend_compat(struct __grstate_compat *);
+extern int	__grscan_compat(int *, struct group *, char *, size_t,
+			struct __grstate_compat *, int, const char *, gid_t,
+			int (*)(void *, struct group **), void *);
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/limits.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/limits.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/limits.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/limits.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,173 @@
+/*
+ *  This file lists the minimums for the limits set by each of
+ *  the POSIX features subsets.
+ *
+ *  XXX: Careful attention needs to be paid to section 2.8 in 1003.1b-1993
+ *       to segregrate the variables below based on their "class" according
+ *       to our implementation.  We also need to set the Run-Time Invariant
+ *       and other related values.
+ *
+ *  $Id: limits.h,v 1.2 1999/09/07 21:18:36 ranjith Exp $
+ */
+
+#ifndef _GCC_LIMITS_H_  /* if we have not seen gcc's limits.h yet */
+#include_next <limits.h>
+#endif
+
+#include <sys/syslimits.h>
+
+#ifndef __POSIX_LIMITS_h
+#define __POSIX_LIMITS_h
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.1b-1993 defines the constants below this comment.          *
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_AIO_LISTIO_MAX   2
+#define _POSIX_AIO_MAX          1
+#define _POSIX_ARG_MAX          4096
+#define _POSIX_CHILD_MAX        6
+#define _POSIX_DELAYTIMER_MAX   32
+#define _POSIX_LINK_MAX         8
+#define _POSIX_MAX_CANON        255
+#define _POSIX_MAX_INPUT        255
+#define _POSIX_MQ_OPEN_MAX      8
+#define _POSIX_MQ_PRIO_MAX      32
+#define _POSIX_NAME_MAX         255
+#define _POSIX_NGROUPS_MAX      0
+#define _POSIX_OPEN_MAX         64
+#define _POSIX_PATH_MAX         1024
+#define _POSIX_PIPE_BUF         512
+#define _POSIX_RTSIG_MAX        8
+#define _POSIX_SEM_NSEMS_MAX    256
+#define _POSIX_SEM_VALUE_MAX    32767
+#define _POSIX_SIGQUEUE_MAX     32
+#define _POSIX_SSIZE_MAX        32767
+#define _POSIX_STREAM_MAX       8
+#define _POSIX_TIMER_MAX        32
+#define _POSIX_TZNAME_MAX       3
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ */
+
+#define AIO_LISTIO_MAX          2
+#define AIO_MAX                 1
+#define AIO_PRIO_DELTA_MAX      0
+#define DELAYTIMER_MAX          32
+#define MQ_OPEN_MAX             8
+#define MQ_PRIO_MAX             32
+#define PAGESIZE                4096
+#define RTSIG_MAX               8
+#define SEM_NSEMS_MAX           256
+#define SEM_VALUE_MAX           32767
+#define SIGQUEUE_MAX            32
+#define STREAM_MAX              8
+#define TIMER_MAX               32
+#define TZNAME_MAX              3
+#define SYMLOOP_MAX				8
+
+/*
+ *  Invariant values
+ */
+
+#define SSIZE_MAX               32767
+
+/*
+ *  Maximum Values
+ */
+
+#define _POSIX_CLOCKRES_MIN      0   /* in nanoseconds */
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.1c/D10 defines the constants below this comment.           *
+ *
+ *  XXX: doc seems to have printing problems in this table :(
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_LOGIN_NAME_MAX                9
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS  4
+#define _POSIX_THREAD_KEYS_MAX               128
+#define _POSIX_THREAD_THREADS_MAX            64
+#define _POSIX_TTY_NAME_MAX                  9
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ *
+ *  NOTE:  LOGIN_NAME_MAX is named LOGNAME_MAX under Solaris 2.x.  Perhaps
+ *         the draft specification will be changing.  jrs 05/24/96
+ */
+
+#define LOGIN_NAME_MAX                      _POSIX_LOGIN_NAME_MAX
+#define TTY_NAME_MAX                        _POSIX_TTY_NAME_MAX
+#define PTHREAD_DESTRUCTOR_ITERATIONS       _POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/*
+ *  RTEMS is smart enough to give us the minimum stack size if we ask
+ *  for too little.  Because the real RTEMS limit for this is cpu dependent
+ *  AND rtems header files are not installed yet, we cannot use the cpu
+ *  dependent constant CPU_STACK_MINIMUM_SIZE.  Moreover, we do not want
+ *  to duplicate that information here so we will just let RTEMS magically
+ *  give us its minimum stack size.
+ *
+ *  NOTE:  The other alternative is to have this be a macro for a 
+ *         routine in RTEMS which returns the constant.
+ */
+
+#define PTHREAD_STACK_MIN                   0
+
+/*
+ *  The maximum number of keys (PTHREAD_KEYS_MAX) and threads
+ *  (PTHREAD_THREADS_MAX) are configurable and may exceed the minimum.
+ *
+#define PTHREAD_KEYS_MAX                    _POSIX_THREAD_KEYS_MAX
+#define PTHREAD_THREADS_MAX                 _POSIX_THREAD_THREADS_MAX
+*/
+
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.4b/D8 defines the constants below this comment.            *
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_INTERRUPT_OVERRUN_MAX        32
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ */
+
+#define INTERRUPT_OVERRUN_MAX               32
+
+/*
+ *  Pathname Variables
+ */
+
+#define MIN_ALLOC_SIZE      				0
+#define REC_MIN_XFER_SIZE   
+#define REC_MAX_XFER_SIZE   
+#define REC_INCR_XFER_SIZE  
+#define REC_XFER_ALIGN      
+#define MAX_ATOMIC_SIZE
+
+#define NAME_MAX							_POSIX_NAME_MAX
+#define PATH_MAX							_POSIX_PATH_MAX
+#define SYMLINK_MAX							_POSIX_SYMLINK_MAX
+
+
+
+#endif
+/* end of include file */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/mntent.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/mntent.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/mntent.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/mntent.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,167 @@
+#ifndef	_MNTENT_H
+#define	_MNTENT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+#include <paths.h>
+
+#if 0
+#define	MNTTYPE_ZFS			"zfs"		/* ZFS file system */
+#define	MNTTYPE_UFS			"ufs"		/* Unix file system */
+#define	MNTTYPE_NFS			"nfs"		/* NFS file system */
+#define	MNTTYPE_NFS3		"nfs3"		/* NFS Version 3 file system */
+#define	MNTTYPE_NFS4		"nfs4"		/* NFS Version 4 file system */
+#define	MNTTYPE_CACHEFS		"cachefs"	/* Cache File System */
+#define	MNTTYPE_PCFS		"pcfs"		/* PC (MSDOS) file system */
+#define	MNTTYPE_PC	MNTTYPE_PCFS		/* Deprecated name; use MNTTYPE_PCFS */
+#define	MNTTYPE_LOFS		"lofs"		/* Loop back file system */
+#define	MNTTYPE_LO	MNTTYPE_LOFS		/* Deprecated name; use MNTTYPE_LOFS */
+#define	MNTTYPE_HSFS		"hsfs"		/* High Sierra (9660) file system */
+#define	MNTTYPE_SWAP		"swap"		/* Swap file system */
+#define	MNTTYPE_TMPFS		"tmpfs"		/* Tmp volatile file system */
+#define	MNTTYPE_AUTOFS		"autofs"	/* Automounter ``file'' system */
+#define	MNTTYPE_MNTFS		"mntfs"		/* In-kernel mnttab */
+#define	MNTTYPE_XMEMFS		"xmemfs"	/* Extended memory FS, IA32 only */
+#define	MNTTYPE_DEV			"dev"		/* /dev file system */
+#define	MNTTYPE_CTFS		"ctfs"		/* Contract file system */
+#define	MNTTYPE_OBJFS		"objfs"		/* Kernel object file system */
+
+#define	MNTOPT_RO			"ro"		/* Read only */
+#define	MNTOPT_RW			"rw"		/* Read/write */
+#define	MNTOPT_RQ			"rq"		/* Read/write with quotas */
+#define	MNTOPT_QUOTA		"quota"		/* Check quotas */
+#define	MNTOPT_NOQUOTA		"noquota"	/* Don't check quotas */
+#define	MNTOPT_ONERROR		"onerror"	/* action to taken on error */
+#define	MNTOPT_SOFT			"soft"		/* Soft mount */
+#define	MNTOPT_SEMISOFT		"semisoft"	/* partial soft, uncommited interface */
+#define	MNTOPT_HARD			"hard"		/* Hard mount */
+#define	MNTOPT_SUID			"suid"		/* Both setuid and devices allowed */
+#define	MNTOPT_NOSUID		"nosuid"	/* Neither setuid nor devices allowed */
+#define	MNTOPT_DEVICES		"devices"	/* Device-special allowed */
+#define	MNTOPT_NODEVICES	"nodevices"	/* Device-special disallowed */
+#define	MNTOPT_SETUID		"setuid"	/* Set uid allowed */
+#define	MNTOPT_NOSETUID		"nosetuid"	/* Set uid not allowed */
+#define	MNTOPT_GRPID		"grpid"		/* SysV-compatible gid on create */
+#define	MNTOPT_REMOUNT		"remount"	/* Change mount options */
+#define	MNTOPT_NOSUB		"nosub"		/* Disallow mounts on subdirs */
+#define	MNTOPT_MULTI		"multi"		/* Do multi-component lookup */
+#define	MNTOPT_INTR			"intr"		/* Allow NFS ops to be interrupted */
+#define	MNTOPT_NOINTR		"nointr"	/* Don't allow interrupted ops */
+#define	MNTOPT_PORT			"port"		/* NFS server IP port number */
+#define	MNTOPT_SECURE		"secure"	/* Secure (AUTH_DES) mounting */
+#define	MNTOPT_RSIZE		"rsize"		/* Max NFS read size (bytes) */
+#define	MNTOPT_WSIZE		"wsize"		/* Max NFS write size (bytes) */
+#define	MNTOPT_TIMEO		"timeo"		/* NFS timeout (1/10 sec) */
+#define	MNTOPT_RETRANS		"retrans"	/* Max retransmissions (soft mnts) */
+#define	MNTOPT_ACTIMEO		"actimeo"	/* Attr cache timeout (sec) */
+#define	MNTOPT_ACREGMIN		"acregmin"	/* Min attr cache timeout (files) */
+#define	MNTOPT_ACREGMAX		"acregmax"	/* Max attr cache timeout (files) */
+#define	MNTOPT_ACDIRMIN		"acdirmin"	/* Min attr cache timeout (dirs) */
+#define	MNTOPT_ACDIRMAX		"acdirmax"	/* Max attr cache timeout (dirs) */
+#define	MNTOPT_NOAC			"noac"		/* Don't cache attributes at all */
+#define	MNTOPT_NOCTO		"nocto"		/* No close-to-open consistency */
+#define	MNTOPT_BG			"bg"		/* Do mount retries in background */
+#define	MNTOPT_FG			"fg"		/* Do mount retries in foreground */
+#define	MNTOPT_RETRY		"retry"		/* Number of mount retries */
+#define	MNTOPT_DEV			"dev"		/* Device id of mounted fs */
+#define	MNTOPT_POSIX		"posix"		/* Get static pathconf for mount */
+#define	MNTOPT_MAP			"map"		/* Automount map */
+#define	MNTOPT_DIRECT		"direct"	/* Automount   direct map mount */
+#define	MNTOPT_INDIRECT		"indirect"	/* Automount indirect map mount */
+#define	MNTOPT_LLOCK		"llock"		/* Local locking (no lock manager) */
+#define	MNTOPT_IGNORE		"ignore"	/* Ignore this entry */
+#define	MNTOPT_VERS			"vers"		/* protocol version number indicator */
+#define	MNTOPT_PROTO		"proto"		/* protocol network_id indicator */
+#define	MNTOPT_SEC			"sec"		/* Security flavor indicator */
+#define	MNTOPT_SYNCDIR		"syncdir"	/* Synchronous local directory ops */
+#define	MNTOPT_NOSETSEC		"nosec"		/* Do no allow setting sec attrs */
+#define	MNTOPT_NOPRINT		"noprint"	/* Do not print messages */
+#define	MNTOPT_LARGEFILES 	"largefiles"		/* allow large files */
+#define	MNTOPT_NOLARGEFILES "nolargefiles" 		/* don't allow large files */
+#define	MNTOPT_FORCEDIRECTIO 	"forcedirectio" /* Force DirectIO on all files */
+#define	MNTOPT_NOFORCEDIRECTIO	"noforcedirectio" /* No Force DirectIO */
+#define	MNTOPT_DISABLEDIRECTIO	"disabledirectio" /* Disable DirectIO ioctls */
+#define	MNTOPT_PUBLIC		"public"	/* Use NFS public file handlee */
+#define	MNTOPT_LOGGING 		"logging" 	/* enable logging */
+#define	MNTOPT_NOLOGGING	"nologging"	/* disable logging */
+#define	MNTOPT_ATIME		"atime"		/* update atime for files */
+#define	MNTOPT_NOATIME 	 	"noatime"	/* do not update atime for files */
+#define	MNTOPT_GLOBAL		"global"	/* Cluster-wide global mount */
+#define	MNTOPT_NOGLOBAL		"noglobal"	/* Mount local to single node */
+#define	MNTOPT_DFRATIME		"dfratime"	/* Deferred access time updates */
+#define	MNTOPT_NODFRATIME 	"nodfratime"/* No Deferred access time updates */
+#define	MNTOPT_NBMAND		"nbmand"	/* allow non-blocking mandatory locks */
+#define	MNTOPT_NONBMAND		"nonbmand"	/* deny non-blocking mandatory locks */
+#define	MNTOPT_XATTR		"xattr"		/* enable extended attributes */
+#define	MNTOPT_NOXATTR		"noxattr"	/* disable extended attributes */
+#define	MNTOPT_EXEC			"exec"		/* enable executables */
+#define	MNTOPT_NOEXEC		"noexec"	/* disable executables */
+#define	MNTOPT_RESTRICT		"restrict"	/* restricted autofs mount */
+#define	MNTOPT_BROWSE		"browse"	/* browsable autofs mount */
+#define	MNTOPT_NOBROWSE		"nobrowse"	/* non-browsable autofs mount */
+#endif
+
+struct mntent
+{
+	char    *mnt_fsname;    /* name of mounted file system */
+	char    *mnt_dir;      /* file system path prefix */
+	char    *mnt_type;      /* mount type (see mntent.h) */
+	char    *mnt_opts;      /* mount options (see mntent.h) */
+	int     mnt_freq;      /* dump frequency in days */
+	int     mnt_passno;     /* pass number on parallel fsck */
+};
+
+
+/* File listing canonical interesting mount points.  */
+#define	MNTTAB		_PATH_MNTTAB	/* Deprecated alias.  */
+
+/* File listing currently active mount points.  */
+#define	MOUNTED		_PATH_MOUNTED	/* Deprecated alias.  */
+
+
+/* Generic mount options.  */
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+#define MNT_CHECKLIST  "/etc/fstab" 
+#define	MNTTAB		"/etc/mnttab"
+#define	VFSTAB		"/etc/vfstab"
+#define	MNTMAXSTR	128
+
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+/* Generic mount options.  */
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+FILE *setmntent(const char *filename, const char *type);
+struct mntent *getmntent(FILE *filep);
+int addmntent(FILE *filep, const struct mntent *mnt);
+int endmntent(FILE *filep);
+char *hasmntopt(const struct mntent *mnt, const char *opt);
+struct mntent *getmntent_r (FILE *stream, struct mntent *result, char *buffer, int bufsize);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/mpool.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/mpool.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/mpool.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/mpool.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,103 @@
+/*	$NetBSD: mpool.h,v 1.14 2013/11/22 16:25:01 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)mpool.h	8.2 (Berkeley) 7/14/94
+ */
+
+#ifndef _MPOOL_H_
+#define _MPOOL_H_
+
+#include <sys/cdefs.h>
+#include <sys/queue.h>
+
+/*
+ * The memory pool scheme is a simple one.  Each in-memory page is referenced
+ * by a bucket which is threaded in up to two of three ways.  All active pages
+ * are threaded on a hash chain (hashed by page number) and an lru chain.
+ * Inactive pages are threaded on a free chain.  Each reference to a memory
+ * pool is handed an opaque MPOOL cookie which stores all of this information.
+ */
+#define	HASHSIZE	128
+#define	HASHKEY(pgno)	((pgno - 1) % HASHSIZE)
+
+/* The BKT structures are the elements of the queues. */
+typedef struct _bkt {
+	TAILQ_ENTRY(_bkt) hq;		/* hash queue */
+	TAILQ_ENTRY(_bkt) q;		/* lru queue */
+	void    *page;			/* page */
+	pgno_t   pgno;			/* page number */
+
+#define	MPOOL_DIRTY	0x01		/* page needs to be written */
+#define	MPOOL_PINNED	0x02		/* page is pinned into memory */
+	uint8_t flags;			/* flags */
+} BKT;
+
+typedef struct MPOOL {
+	TAILQ_HEAD(_lqh, _bkt) lqh;	/* lru queue head */
+					/* hash queue array */
+	TAILQ_HEAD(_hqh, _bkt) hqh[HASHSIZE];
+	pgno_t	curcache;		/* current number of cached pages */
+	pgno_t	maxcache;		/* max number of cached pages */
+	pgno_t	npages;			/* number of pages in the file */
+	unsigned long	pagesize;		/* file page size */
+	int	fd;			/* file descriptor */
+					/* page in conversion routine */
+	void    (*pgin)(void *, pgno_t, void *);
+					/* page out conversion routine */
+	void    (*pgout)(void *, pgno_t, void *);
+	void	*pgcookie;		/* cookie for page in/out routines */
+#ifdef STATISTICS
+	unsigned long	cachehit;
+	unsigned long	cachemiss;
+	unsigned long	pagealloc;
+	unsigned long	pageflush;
+	unsigned long	pageget;
+	unsigned long	pagenew;
+	unsigned long	pageput;
+	unsigned long	pageread;
+	unsigned long	pagewrite;
+#endif
+} MPOOL;
+
+__BEGIN_DECLS
+MPOOL	*mpool_open(void *, int, pgno_t, pgno_t);
+void	 mpool_filter(MPOOL *, void (*)(void *, pgno_t, void *),
+	    void (*)(void *, pgno_t, void *), void *);
+void	*mpool_new(MPOOL *, pgno_t *);
+void	*mpool_get(MPOOL *, pgno_t, unsigned int);
+int	 mpool_put(MPOOL *, void *, unsigned int);
+int	 mpool_sync(MPOOL *);
+int	 mpool_close(MPOOL *);
+#ifdef STATISTICS
+void	 mpool_stat(MPOOL *);
+#endif
+__END_DECLS
+
+#endif /* _MPOOL_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/namespace.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/namespace.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/namespace.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/namespace.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,943 @@
+/*	$NetBSD: namespace.h,v 1.179 2015/09/10 14:05:06 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1997-2004 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _NAMESPACE_H_
+#define _NAMESPACE_H_
+
+#include <sys/cdefs.h>
+
+#if 0
+
+#ifndef __lint__
+#define aio_suspend	_aio_suspend
+#define brk		_brk
+#define catclose	_catclose
+#define catgets		_catgets
+#define catopen		_catopen
+#define catopen_l	_catopen_l
+#define daylight	_daylight
+#define difftime	_difftime
+#define devname_r	_devname_r
+#define err		_err
+#define errc		_errc
+#define errx		_errx
+#ifdef _REENTRANT
+#define fileno		_fileno
+#endif /* _REENTRANT */
+#define fork		_fork
+#define fseeko		_fseeko
+#define ftello		_ftello
+#define getcontext	_getcontext
+#define getenv_r	_getenv_r
+#define imaxabs		_imaxabs
+#define imaxdiv		_imaxdiv
+#define inet_aton	_inet_aton
+#define inet_pton	_inet_pton
+#define pipe		_pipe
+#define sbrk		_sbrk
+#define strerror_l	_strerror_l
+#define strerror_r	_strerror_r
+#define strlcat		_strlcat
+#define strlcpy		_strlcpy
+#define strtod_l	_strtod_l
+#define strtof		_strtof
+#define strtof_l	_strtof_l
+#define strtoi		_strtoi
+#define strtoi_l	_strtoi_l
+#define strtoimax	_strtoimax
+#define strtoimax_l	_strtoimax_l
+#define strtold		_strtold
+#define strtold_l	_strtold_l
+#define strtoll		_strtoll
+#define strtoll_l	_strtoll_l
+#define strtou		_strtou
+#define strtou_l	_strtou_l
+#define strtoull	_strtoull
+#define strtoull_l	_strtoull_l
+#define strtoumax	_strtoumax
+#define strtoumax_l	_strtoumax_l
+#define sys_errlist	_sys_errlist
+#define sys_nerr	_sys_nerr
+#define sys_siglist	_sys_siglist
+#define	sys_nsig	_sys_nsig
+#define sysconf		__sysconf
+#define verr		_verr
+#define verrc		_verrc
+#define verrx		_verrx
+#define vwarn		_vwarn
+#define vwarnc		_vwarnc
+#define vwarnx		_vwarnx
+#define warn		_warn
+#define warnc		_warnc
+#define warnx		_warnx
+
+#ifdef __weak_alias
+#define MD2Data			_MD2Data
+#define MD2End			_MD2End
+#define MD2FileChunk		_MD2FileChunk
+#define MD2File			_MD2File
+#define MD2Final		_MD2Final
+#define MD2Init			_MD2Init
+#define MD2Transform		_MD2Transform
+#define MD2Update		_MD2Update
+#define MD4Data			_MD4Data
+#define MD4End			_MD4End
+#define MD4FileChunk		_MD4FileChunk
+#define MD4File			_MD4File
+#define MD4Final		_MD4Final
+#define MD4Init			_MD4Init
+#define MD4Transform		_MD4Transform
+#define MD4Update		_MD4Update
+#define MD5Data			_MD5Data
+#define MD5End			_MD5End
+#define MD5FileChunk		_MD5FileChunk
+#define MD5File			_MD5File
+#define MD5Final		_MD5Final
+#define MD5Init			_MD5Init
+#define MD5Transform		_MD5Transform
+#define MD5Update		_MD5Update
+#define RMD160Data		_RMD160Data
+#define RMD160End		_RMD160End
+#define RMD160FileChunk		_RMD160FileChunk
+#define RMD160File		_RMD160File
+#define RMD160Final		_RMD160Final
+#define RMD160Init		_RMD160Init
+#define RMD160Transform		_RMD160Transform
+#define RMD160Update		_RMD160Update
+#define SHA1Data		_SHA1Data
+#define SHA1End			_SHA1End
+#define SHA1FileChunk		_SHA1FileChunk
+#define SHA1File		_SHA1File
+#define SHA1Final		_SHA1Final
+#define SHA1Init		_SHA1Init
+#define SHA1Transform		_SHA1Transform
+#define SHA1Update		_SHA1Update
+#define SHA224_Data		_SHA224_Data
+#define SHA224_End		_SHA224_End
+#define SHA224_FileChunk	_SHA224_FileChunk
+#define SHA224_File		_SHA224_File
+#define SHA224_Final		_SHA224_Final
+#define SHA224_Init		_SHA224_Init
+#define SHA224_Transform	_SHA224_Transform
+#define SHA224_Update		_SHA224_Update
+#define SHA256_Data		_SHA256_Data
+#define SHA256_End		_SHA256_End
+#define SHA256_FileChunk	_SHA256_FileChunk
+#define SHA256_File		_SHA256_File
+#define SHA256_Final		_SHA256_Final
+#define SHA256_Init		_SHA256_Init
+#define SHA256_Transform	_SHA256_Transform
+#define SHA256_Update		_SHA256_Update
+#define SHA384_Data		_SHA384_Data
+#define SHA384_End		_SHA384_End
+#define SHA384_FileChunk	_SHA384_FileChunk
+#define SHA384_File		_SHA384_File
+#define SHA384_Final		_SHA384_Final
+#define SHA384_Init		_SHA384_Init
+#define SHA384_Transform	_SHA384_Transform
+#define SHA384_Update		_SHA384_Update
+#define SHA512_Data		_SHA512_Data
+#define SHA512_End		_SHA512_End
+#define SHA512_FileChunk	_SHA512_FileChunk
+#define SHA512_File		_SHA512_File
+#define SHA512_Final		_SHA512_Final
+#define SHA512_Init		_SHA512_Init
+#define SHA512_Transform	_SHA512_Transform
+#define SHA512_Update		_SHA512_Update
+#define a64l			_a64l
+#define adjtime			_adjtime
+#define alarm			_alarm
+#define allocaddrinfo		_allocaddrinfo
+#define alphasort		_alphasort
+#define arc4random		_arc4random
+#define arc4random_addrandom	_arc4random_addrandom
+#define arc4random_buf		_arc4random_buf
+#define arc4random_stir		_arc4random_stir
+#define arc4random_uniform	_arc4random_uniform
+#define asctime_r		_asctime_r
+#define asprintf		_asprintf
+#define asprintf_l		_asprintf_l
+#define asysctl			_asysctl
+#define asysctlbyname		_asysctlbyname
+#define atoll			_atoll
+#define authnone_create		_authnone_create
+#define authunix_create		_authunix_create
+#define authunix_create_default _authunix_create_default
+#define basename		_basename
+#define bindresvport		_bindresvport
+#define bindresvport_sa		_bindresvport_sa
+#define bm_comp			_bm_comp
+#define bm_exec			_bm_exec
+#define bm_free			_bm_free
+#define callrpc			_callrpc
+#define cdbr_close		_cdbr_close
+#define cdbr_find		_cdbr_find
+#define cdbr_get		_cdbr_get
+#define cdbr_open		_cdbr_open
+#define cdbr_open_mem		_cdbr_open_mem
+#define cdbw_close		_cdbw_close
+#define cdbw_open		_cdbw_open
+#define cdbw_put		_cdbw_put
+#define cdbw_put_data		_cdbw_put_data
+#define cdbw_put_key		_cdbw_put_key
+#define cdbw_output		_cdbw_output
+#define cfgetispeed		_cfgetispeed
+#define cfgetospeed		_cfgetospeed
+#define cfmakeraw		_cfmakeraw
+#define cfsetispeed		_cfsetispeed
+#define cfsetospeed		_cfsetospeed
+#define cfsetspeed		_cfsetspeed
+#define cgetcap			_cgetcap
+#define cgetclose		_cgetclose
+#define cgetent			_cgetent
+#define cgetfirst		_cgetfirst
+#define cgetmatch		_cgetmatch
+#define cgetnext		_cgetnext
+#define cgetnum			_cgetnum
+#define cgetset			_cgetset
+#define cgetstr			_cgetstr
+#define cgetustr		_cgetustr
+#define clnt_broadcast		_clnt_broadcast
+#define clnt_create		_clnt_create
+#define clnt_create_vers	_clnt_create_vers
+#define clnt_dg_create		_clnt_dg_create
+#define clnt_pcreateerror	_clnt_pcreateerror
+#define clnt_perrno		_clnt_perrno
+#define clnt_perror		_clnt_perror
+#define clnt_raw_create		_clnt_raw_create
+#define clnt_tli_create		_clnt_tli_create
+#define clnt_tp_create		_clnt_tp_create
+#define clnt_spcreateerror	_clnt_spcreateerror
+#define clnt_sperrno		_clnt_sperrno
+#define clnt_sperror		_clnt_sperror
+#define clnt_vc_create		_clnt_vc_create
+#define clntraw_create		_clntraw_create
+#define clnttcp_create		_clnttcp_create
+#define clntudp_bufcreate	_clntudp_bufcreate
+#define clntudp_create		_clntudp_create
+#define clock_gettime		_clock_gettime
+#define clock_getres		_clock_getres
+#define clock_settime		_clock_settime
+#define closedir		_closedir
+#define closelog		_closelog
+#define closelog_r		_closelog_r
+#define confstr			_confstr
+#define consttime_memequal	_consttime_memequal
+#define csetexpandtc		_csetexpandtc
+#define ctermid			_ctermid
+#define ctime_r			_ctime_r
+#define ctime_rz		_ctime_rz
+#define daemon			_daemon
+#define dbopen			_dbopen
+#define devname			_devname
+#define difftime		_difftime
+#define dirname			_dirname
+#define dn_expand		_dn_expand
+#define dprintf_l		_dprintf_l
+#define drand48			_drand48
+#define duplocale		_duplocale
+#define endfsent		_endfsent
+#define endgrent		_endgrent
+#define endhostent		_endhostent
+#define endnetconfig		_endnetconfig
+#define endnetent		_endnetent
+#define endnetgrent		_endnetgrent
+#define endnetpath		_endnetpath
+#define endprotoent		_endprotoent
+#define endprotoent_r		_endprotoent_r
+#define endpwent		_endpwent
+#define endrpcent		_endrpcent
+#define endservent		_endservent
+#define endservent_r		_endservent_r
+#define endttyent		_endttyent
+#define endusershell		_endusershell
+#define erand48			_erand48
+#define ether_aton		_ether_aton
+#define ether_hostton		_ether_hostton
+#define ether_line		_ether_line
+#define ether_ntoa		_ether_ntoa
+#define ether_ntohost		_ether_ntohost
+#define execl			_execl
+#define execle			_execle
+#define execlp			_execlp
+#define execlpe			_execlpe
+#define execv			_execv
+#define execvp			_execvp
+#define execvpe			_execvpe
+#define explicit_memset		_explicit_memset
+#define fdiscard		_fdiscard
+#define fdopen			_fdopen
+#define fgetln			_fgetln
+#define fgetwln			_fgetwln
+#define fhstatvfs		_fhstatvfs
+#define flockfile		_flockfile
+#define ftrylockfile		_ftrylockfile
+#define funlockfile		_funlockfile
+#define fnmatch			_fnmatch
+#define fparseln		_fparseln
+#define fprintf_l		_fprintf_l
+#define fpgetmask		_fpgetmask
+#define fpgetprec		_fpgetprec
+#define fpgetround		_fpgetround
+#define fpgetsticky		_fpgetsticky
+#define fpsetmask		_fpsetmask
+#define fpsetprec		_fpsetprec
+#define fpsetround		_fpsetround
+#define fpsetsticky		_fpsetsticky
+#define freenetconfigent	_freenetconfigent
+#define freeaddrinfo		_freeaddrinfo
+#define freeifaddrs		_freeifaddrs
+#define freelocale		_freelocale
+#define fscanf_l		_fscanf_l
+#define fstatvfs		_fstatvfs
+#define ftok			_ftok
+#define ftruncate		_ftruncate
+#define fts_children		_fts_children
+#define fts_close		_fts_close
+#define fts_open		_fts_open
+#define fts_read		_fts_read
+#define fts_set			_fts_set
+#define fwprintf_l		_fwprintf_l
+#define fwscanf_l		_fwscanf_l
+#define gai_strerror		_gai_strerror
+#define get_myaddress		_get_myaddress
+#define getaddrinfo		_getaddrinfo
+#define getbsize		_getbsize
+#define getcwd			_getcwd
+#define getdelim		_getdelim
+#define getdevmajor		_getdevmajor
+#define getdiskbyname		_getdiskbyname
+#define getdomainname		_getdomainname
+#define getfsent		_getfsent
+#define getfsfile		_getfsfile
+#define getfsspec		_getfsspec
+#define getgrent		_getgrent
+#define getgrent_r		_getgrent_r
+#define getgrgid		_getgrgid
+#define getgrgid_r		_getgrgid_r
+#define getgrnam		_getgrnam
+#define getgrnam_r		_getgrnam_r
+#define getgrouplist		_getgrouplist
+#define getgroupmembership	_getgroupmembership
+#define gethostbyaddr		_gethostbyaddr
+#define gethostbyname		_gethostbyname
+#define gethostent		_gethostent
+#define gethostname		_gethostname
+#define getifaddrs		_getifaddrs
+#define getline			_getline
+#define getloadavg		_getloadavg
+#define getlogin		_getlogin
+#define getlogin_r		_getlogin_r
+#define getmntinfo		_getmntinfo
+#define getmode			_getmode
+#define getnameinfo		_getnameinfo
+#define getnetbyaddr		_getnetbyaddr
+#define getnetbyname		_getnetbyname
+#define getnetconfig		_getnetconfig
+#define getnetconfigent		_getnetconfigent
+#define getnetent		_getnetent
+#define getnetgrent		_getnetgrent
+#define getnetpath		_getnetpath
+#define getopt			_getopt
+#define getopt_long		_getopt_long
+#define getpagesize		_getpagesize
+#define getpass			_getpass
+#define getpassfd		_getpassfd
+#define getpass_r		_getpass_r
+#define getprogname		_getprogname
+#define getprotobyname		_getprotobyname
+#define getprotobyname_r	_getprotobyname_r
+#define getprotobynumber	_getprotobynumber
+#define getprotobynumber_r	_getprotobynumber_r
+#define getprotoent		_getprotoent
+#define getprotoent_r		_getprotoent_r
+#define getpwent		_getpwent
+#define getpwent_r		_getpwent_r
+#define getpwnam		_getpwnam
+#define getpwnam_r		_getpwnam_r
+#define getpwuid		_getpwuid
+#define getpwuid_r		_getpwuid_r
+#define getrpcbyname		_getrpcbyname
+#define getrpcbyname_r		_getrpcbyname_r
+#define getrpcbynumber		_getrpcbynumber
+#define getrpcbynumber_r	_getrpcbynumber_r
+#define getrpcent		_getrpcent
+#define getrpcent_r		_getrpcent_r
+#define getrpcport		_getrpcport
+#define getservbyname		_getservbyname
+#define getservbyname_r		_getservbyname_r
+#define getservbyport		_getservbyport
+#define getservbyport_r		_getservbyport_r
+#define getservent		_getservent
+#define getservent_r		_getservent_r
+#define getsubopt		_getsubopt
+#define getttyent		_getttyent
+#define getttynam		_getttynam
+#define getusershell		_getusershell
+#define glob			_glob
+#define globfree		_globfree
+#define gmtime_r		_gmtime_r
+#define group_from_gid		_group_from_gid
+#define heapsort		_heapsort
+#define herror			_herror
+#define hes_error		_hes_error
+#define hes_free		_hes_free
+#define hes_init		_hes_init
+#define hes_resolve		_hes_resolve
+#define hes_to_bind		_hes_to_bind
+#define hesiod_end		_hesiod_end
+#define hesiod_free_list	_hesiod_free_list
+#define hesiod_init		_hesiod_init
+#define hesiod_resolve		_hesiod_resolve
+#define hesiod_to_bind		_hesiod_to_bind
+#define iconv			_iconv
+#define iconv_open		_iconv_open
+#define iconv_close		_iconv_close
+#define if_freenameindex	_if_freenameindex
+#define if_indextoname		_if_indextoname
+#define if_nameindex		_if_nameindex
+#define if_nametoindex		_if_nametoindex
+#define in6addr_any		_in6addr_any
+#define in6addr_linklocal_allnodes	_in6addr_linklocal_allnodes
+#define in6addr_linklocal_allrouters	_in6addr_linklocal_allrouters
+#define in6addr_loopback	_in6addr_loopback
+#define in6addr_nodelocal_allnodes	_in6addr_nodelocal_allnodes
+#define inet6_option_alloc	_inet6_option_alloc
+#define inet6_option_append	_inet6_option_append
+#define inet6_option_find	_inet6_option_find
+#define inet6_option_init	_inet6_option_init
+#define inet6_option_next	_inet6_option_next
+#define inet6_option_space	_inet6_option_space
+#define inet6_opt_init		_inet6_opt_init
+#define inet6_opt_append	_inet6_opt_append
+#define inet6_opt_finish	_inet6_opt_finish
+#define inet6_opt_set_val	_inet6_opt_set_val
+#define inet6_opt_next		_inet6_opt_next
+#define inet6_opt_find		_inet6_opt_find
+#define inet6_opt_get_val	_inet6_opt_get_val
+#define inet6_rthdr_add		_inet6_rthdr_add
+#define inet6_rthdr_getaddr	_inet6_rthdr_getaddr
+#define inet6_rthdr_getflags	_inet6_rthdr_getflags
+#define inet6_rthdr_init	_inet6_rthdr_init
+#define inet6_rthdr_lasthop	_inet6_rthdr_lasthop
+#define inet6_rthdr_segments	_inet6_rthdr_segments
+#define inet6_rthdr_space	_inet6_rthdr_space
+#define inet6_rth_space		_inet6_rth_space
+#define inet6_rth_init		_inet6_rth_init
+#define inet6_rth_add		_inet6_rth_add
+#define inet6_rth_reverse	_inet6_rth_reverse
+#define inet6_rth_segments	_inet6_rth_segments
+#define inet6_rth_getaddr	_inet6_rth_getaddr
+#define inet_cidr_ntop		_inet_cidr_ntop
+#define inet_cidr_pton		_inet_cidr_pton
+#define inet_lnaof		_inet_lnaof
+#define inet_makeaddr		_inet_makeaddr
+#define inet_net_ntop		_inet_net_ntop
+#define inet_net_pton		_inet_net_pton
+#define inet_neta		_inet_neta
+#define inet_netof		_inet_netof
+#define inet_network		_inet_network
+#define inet_nsap_addr		_inet_nsap_addr
+#define inet_nsap_ntoa		_inet_nsap_ntoa
+#define inet_ntoa		_inet_ntoa
+#define inet_ntop		_inet_ntop
+#define initgroups		_initgroups
+#define initstate		_initstate
+#define innetgr			_innetgr
+#define isatty			_isatty
+#define jrand48			_jrand48
+#define kill			_kill
+#define l64a			_l64a
+#define l64a_r			_l64a_r
+#define lcong48			_lcong48
+#define llabs			_llabs
+#define lldiv			_lldiv
+#define localtime_r		_localtime_r
+#define localtime_rz		_localtime_rz
+#define lockf			_lockf
+#define lrand48			_lrand48
+#define lseek			_lseek
+#define membar_producer		_membar_producer
+#define mergesort		_mergesort
+#define mi_vector_hash		_mi_vector_hash
+#define mkstemp			_mkstemp
+#define mktime_z		_mktime_z
+#define mmap			_mmap
+#define mpool_close		_mpool_close
+#define mpool_filter		_mpool_filter
+#define mpool_get		_mpool_get
+#define mpool_new		_mpool_new
+#define mpool_open		_mpool_open
+#define mpool_put		_mpool_put
+#define mpool_sync		_mpool_sync
+#define mq_timedreceive		_mq_timedreceive
+#define mq_timedsend		_mq_timedsend
+#define mrand48			_mrand48
+#define murmurhash2		_murmurhash2
+#define nc_perror		_nc_perror
+#define nc_sperror		_nc_sperror
+#define nanosleep		_nanosleep
+#define newlocale		_newlocale
+#define nice			_nice
+#if 0
+#define nlist			_nlist
+#endif
+#define nl_langinfo_l		_nl_langinfo_l
+#define nrand48			_nrand48
+#define ntp_adjtime		_ntp_adjtime
+#define nsdispatch		_nsdispatch
+#define offtime			_offtime
+#define opendir			_opendir
+#define fdopendir		_fdopendir
+#define openlog			_openlog
+#define openlog_r		_openlog_r
+#define pause			_pause
+#define pclose			_pclose
+#define pmap_getmaps		_pmap_getmaps
+#define pmap_getport		_pmap_getport
+#define pmap_rmtcall		_pmap_rmtcall
+#define pmap_set		_pmap_set
+#define pmap_unset		_pmap_unset
+#define pollts			_pollts
+#define popen			_popen
+#define posix2time		_posix2time
+#define posix2time_z		_posix2time_z
+#define pread			_pread
+#define printf_l		_printf_l
+#define pselect			_pselect
+#define posix_fallocate		_posix_fallocate
+#define psignal			_psignal
+#define pthread_atfork		_pthread_atfork
+#define ptree_init		ptree_init
+#define ptree_insert_node	ptree_insert_node
+#define ptree_insert_mask_node	ptree_insert_mask_node
+#define ptree_find_filtered_node	ptree_find_filtered_node
+#define ptree_remove_node	ptree_remove_node
+#define ptree_iterate		ptree_iterate
+#define putenv			_putenv
+#define pwcache_groupdb		_pwcache_groupdb
+#define pwcache_userdb		_pwcache_userdb
+#define pwrite			_pwrite
+#define qabs			_qabs
+#define qdiv			_qdiv
+#define radixsort		_radixsort
+#define random			_random
+#define randomid		_randomid
+#define randomid_new		_randomid_new
+#define randomid_delete		_randomid_delete
+#define read			_read
+#define readdir			_readdir
+#define readdir_r		_readdir_r
+#define readlink		_readlink
+#define reallocarr		_reallocarr
+#define realpath		_realpath
+#define regcomp			_regcomp
+#define regerror		_regerror
+#define regexec			_regexec
+#define regfree			_regfree
+#define registerrpc		_registerrpc
+#define res_init		_res_init
+#define res_mkquery		_res_mkquery
+#define res_query		_res_query
+#define res_search		_res_search
+#define rewinddir		_rewinddir
+#define rpc_broadcast		_rpc_broadcast
+#define rpc_broadcast_exp	_rpc_broadcast_exp
+#define rpc_call		_rpc_call
+#define rpc_control		_rpc_control
+#define rpc_reg			_rpc_reg
+#define rpcb_getmaps		_rpcb_getmaps
+#define rpcb_gettime		_rpcb_gettime
+#define rpcb_rmtcall		_rpcb_rmtcall
+#define rpcb_set		_rpcb_set
+#define rpcb_taddr2uaddr	_rpcb_taddr2uaddr
+#define rpcb_uaddr2taddr	_rpcb_uaddr2taddr
+#define rpcb_unset		_rpcb_unset
+#define scandir			_scandir
+#define scanf_l			_scanf_l
+#define seed48			_seed48
+#define seekdir			_seekdir
+#define select			_select
+#define send			_send
+#define setdomainname		_setdomainname
+#define setenv			_setenv
+#define setfsent		_setfsent
+#define setgrent		_setgrent
+#define setgroupent		_setgroupent
+#define sethostent		_sethostent
+#define sethostname		_sethostname
+#define setlogin		_setlogin
+#define setlogmask		_setlogmask
+#define setlogmask_r		_setlogmask_r
+#define setmode			_setmode
+#define setnetconfig		_setnetconfig
+#define setnetent		_setnetent
+#define setnetgrent		_setnetgrent
+#define setpassent		_setpassent
+#define setnetpath		_setnetpath
+#define setproctitle		_setproctitle
+#define setprotoent		_setprotoent
+#define setprotoent_r		_setprotoent_r
+#define setpwent		_setpwent
+#define setrpcent		_setrpcent
+#define setservent		_setservent
+#define setservent_r		_setservent_r
+#define setstate		_setstate
+#define setttyent		_setttyent
+#define setttyentpath		_setttyentpath
+#define settimeofday		_settimeofday
+#define setusershell		_setusershell
+#define shm_open		_shm_open
+#define shm_unlink		_shm_unlink
+#define shquote			_shquote
+#define siginterrupt		_siginterrupt
+#define signal			_signal
+#define sigtimedwait		_sigtimedwait
+#define sl_add			_sl_add
+#define sl_create		_sl_create
+#define sl_delete		_sl_delete
+#define sl_find			_sl_find
+#define sl_free			_sl_free
+#define sl_init			_sl_init
+#define sleep			_sleep
+#ifndef snprintf
+#define snprintf		_snprintf
+#endif
+#define snprintf_l		_snprintf_l
+#define snprintf_ss		_snprintf_ss
+#define sprintf_l		_sprintf_l
+#define sradixsort		_sradixsort
+#define srand48			_srand48
+#define srandom			_srandom
+#define sscanf_l		_sscanf_l
+#define statvfs(a, b)		_statvfs(a, b)
+#define strcasecmp		_strcasecmp
+#define strcoll_l		_strcoll_l
+#define strdup			_strdup
+#define stresep			_stresep
+#define strftime_l		_strftime_l
+#define strftime_lz		_strftime_lz
+#define strftime_z		_strftime_z
+#define strndup			_strndup
+#define strncasecmp		_strncasecmp
+#define strptime		_strptime
+#define strptime_l		_strptime_l
+#define strsep			_strsep
+#define strsignal		_strsignal
+#define strsuftoll	 	_strsuftoll
+#define strsuftollx	 	_strsuftollx
+#define strtok_r		_strtok_r
+#define strnunvisx		_strnunvisx
+#define strvisx			_strvisx
+#define strxfrm_l		_strxfrm_l
+#define svc_auth_reg		_svc_auth_reg
+#define svc_create		_svc_create
+#define svc_dg_create		_svc_dg_create
+#define svc_exit		_svc_exit
+#define svc_fd_create		_svc_fd_create
+#define svc_getreq		_svc_getreq
+#define svc_getreqset		_svc_getreqset
+#define svc_getreq_common	_svc_getreq_common
+#define svc_raw_create		_svc_raw_create
+#define svc_register		_svc_register
+#define svc_reg			_svc_reg
+#define svc_run			_svc_run
+#define svc_sendreply		_svc_sendreply
+#define svc_tli_create		_svc_tli_create
+#define svc_tp_create		_svc_tp_create
+#define svc_unregister		_svc_unregister
+#define svc_unreg		_svc_unreg
+#define svc_vc_create		_svc_vc_create
+#define svcerr_auth		_svcerr_auth
+#define svcerr_decode		_svcerr_decode
+#define svcerr_noproc		_svcerr_noproc
+#define svcerr_noprog		_svcerr_noprog
+#define svcerr_progvers		_svcerr_progvers
+#define svcerr_systemerr	_svcerr_systemerr
+#define svcerr_weakauth		_svcerr_weakauth
+#define svcfd_create		_svcfd_create
+#define svcraw_create		_svcraw_create
+#define svctcp_create		_svctcp_create
+#define svcudp_bufcreate	_svcudp_bufcreate
+#define svcudp_create		_svcudp_create
+#define svcudp_enablecache	_svcudp_enablecache
+#define sysarch			_sys_sysarch
+#define swprintf_l		_swprintf_l
+#define swscanf_l		_swscanf_l
+#define sysctl			_sysctl
+#define sysctlbyname		_sysctlbyname
+#define sysctlgetmibinfo	_sysctlgetmibinfo
+#define sysctlnametomib		_sysctlnametomib
+#define syslog			_syslog
+#define syslog_r		_syslog_r
+#define syslog_ss		_syslog_ss
+#define syslogp			_syslogp
+#define syslogp_r		_syslogp_r
+#define syslogp_ss		_syslogp_ss
+#define taddr2uaddr		_taddr2uaddr
+#define tcdrain			_tcdrain
+#define tcflow			_tcflow
+#define tcflush			_tcflush
+#define tcgetattr		_tcgetattr
+#define tcgetpgrp		_tcgetpgrp
+#define tcgetsid		_tcgetsid
+#define tcsendbreak		_tcsendbreak
+#define tcsetattr		_tcsetattr
+#define tcsetpgrp		_tcsetpgrp
+#define telldir			_telldir
+#define time			_time
+#define time2posix		_time2posix
+#define timegm			_timegm
+#define timelocal		_timelocal
+#define timeoff			_timeoff
+#define times			_times
+#define ttyname			_ttyname
+#define ttyname_r		_ttyname_r
+#define ttyslot			_ttyslot
+#define tzname			_tzname
+#define tzset			_tzset
+#define tzsetwall		_tzsetwall
+#define uaddr2taddr		_uaddr2taddr
+#define ualarm			_ualarm
+#define uname			_uname
+#define unsetenv		_unsetenv
+#define user_from_uid		_user_from_uid
+#define usleep			_usleep
+#define utime			_utime
+#define uuid_create_nil		_uuid_create_nil
+#define uuid_is_nil		_uuid_is_nil
+#define valloc			_valloc
+#define vasprintf		_vasprintf
+#define vasprintf_l		_vasprintf_l
+#define	vdprintf		_vdprintf
+#ifndef vsnprintf
+#define vsnprintf		_vsnprintf
+#endif
+#define vdprintf_l		_vdprintf_l
+#define vdprintf_l		_vdprintf_l
+#define vfprintf_l		_vfprintf_l
+#define vfwprintf_l		_vfwprintf_l
+#define vprintf_l		_vprintf_l
+#define vscanf_l		_vscanf_l
+#define vsscanf_l		_vsscanf_l
+#define vswscanf_l		_vswscanf_l
+#define vsnprintf_l		_vsnprintf_l
+#define vsnprintf_ss		_vsnprintf_ss
+#define vsprintf_l		_vsprintf_l
+#define vswprintf_l		_vswprintf_l
+#define vwprintf_l		_vwprintf_l
+#define vwscanf_l		_vwscanf_l
+#define vsyslog			_vsyslog
+#define vsyslog_r		_vsyslog_r
+#define vsyslog_ss		_vsyslog_ss
+#define vsyslogp		_vsyslogp
+#define vsyslogp_r		_vsyslogp_r
+#define vsyslogp_ss		_vsyslogp_ss
+#define wait			_wait
+#define wait3			_wait3
+#define wait4			_wait4
+#define waitpid			_waitpid
+#define wcscasecmp		_wcscasecmp
+#define wcscasecmp_l		_wcscasecmp_l
+#define wcsdup			_wcsdup
+#define wcsftime_l		_wcsftime_l
+#define wcsncasecmp		_wcsncasecmp
+#define wcsncasecmp_l		_wcsncasecmp_l
+#define wcstof			_wcstof
+#define wcstof_l		_wcstof_l
+#define wcstod			_wcstod
+#define wcstod_l		_wcstod_l
+#define wcstold			_wcstold
+#define wcstold_l		_wcstold_l
+#define wcwidth			_wcwidth
+#define wcwidth_l		_wcwidth_l
+#define wprintf_l		_wprintf_l
+#define wscanf_l		_wscanf_l
+#define xdr_accepted_reply	_xdr_accepted_reply
+#define xdr_array		_xdr_array
+#define xdr_authunix_parms	_xdr_authunix_parms
+#define xdr_bool		_xdr_bool
+#define xdr_bytes		_xdr_bytes
+#define xdr_callhdr		_xdr_callhdr
+#define xdr_callmsg		_xdr_callmsg
+#define xdr_char		_xdr_char
+#define xdr_datum		_xdr_datum
+#define xdr_des_block		_xdr_des_block
+#define xdr_domainname		_xdr_domainname
+#define xdr_double		_xdr_double
+#define xdr_enum		_xdr_enum
+#define xdr_float		_xdr_float
+#define xdr_free		_xdr_free
+#define	xdr_hyper		_xdr_hyper
+#define xdr_int			_xdr_int
+#define xdr_int16_t		_xdr_int16_t
+#define xdr_int32_t		_xdr_int32_t
+#define xdr_int64_t		_xdr_int64_t
+#define xdr_long		_xdr_long
+#define	xdr_longlong_t		_xdr_longlong_t
+#define xdr_mapname		_xdr_mapname
+#define xdr_netbuf		_xdr_netbuf
+#define xdr_netobj		_xdr_netobj
+#define xdr_opaque		_xdr_opaque
+#define xdr_opaque_auth		_xdr_opaque_auth
+#define xdr_peername		_xdr_peername
+#define xdr_pmap		_xdr_pmap
+#define xdr_pmaplist		_xdr_pmaplist
+#define xdr_pointer		_xdr_pointer
+#define xdr_reference		_xdr_reference
+#define xdr_rejected_reply	_xdr_rejected_reply
+#define xdr_replymsg		_xdr_replymsg
+#define xdr_rmtcall_args	_xdr_rmtcall_args
+#define xdr_rmtcallres		_xdr_rmtcallres
+#define xdr_rpcb		_xdr_rpcb
+#define xdr_rpcb_entry		_xdr_rpcb_entry
+#define xdr_rpcb_entry_list_ptr	_xdr_rpcb_entry_list_ptr
+#define xdr_rpcb_rmtcallargs	_xdr_rpcb_rmtcallargs
+#define xdr_rpcb_rmtcallres	_xdr_rpcb_rmtcallres
+#define xdr_rpcb_stat		_xdr_rpcb_stat
+#define xdr_rpcb_stat_byvers	_xdr_rpcb_stat_byvers
+#define xdr_rpcblist		_xdr_rpcblist
+#define xdr_rpcblist_ptr	_xdr_rpcblist_ptr
+#define xdr_rpcbs_addrlist	_xdr_rpcbs_addrlist
+#define xdr_rpcbs_addrlist_ptr	_xdr_rpcbs_addrlist_ptr
+#define xdr_rpcbs_proc		_xdr_rpcbs_proc
+#define xdr_rpcbs_rmtcalllist	_xdr_rpcbs_rmtcalllist
+#define xdr_rpcbs_rmtcalllist_ptr	_xdr_rpcbs_rmtcalllist_ptr
+#define xdr_rpcbs		_xdr_rpcbs
+#define xdr_rpcbs		_xdr_rpcbs
+#define xdr_short		_xdr_short
+#define xdr_sizeof		_xdr_sizeof
+#define xdr_string		_xdr_string
+#define xdr_u_char		_xdr_u_char
+#define	xdr_u_hyper		_xdr_u_hyper
+#define xdr_u_int		_xdr_u_int
+#define xdr_u_int16_t		_xdr_u_int16_t
+#define xdr_u_int32_t		_xdr_u_int32_t
+#define xdr_u_int64_t		_xdr_u_int64_t
+#define xdr_u_long		_xdr_u_long
+#define	xdr_u_longlong_t	_xdr_u_longlong_t
+#define xdr_u_short		_xdr_u_short
+#define xdr_union		_xdr_union
+#define xdr_vector		_xdr_vector
+#define xdr_void		_xdr_void
+#define xdr_wrapstring		_xdr_wrapstring
+#define xdr_yp_inaddr		_xdr_yp_inaddr
+#define xdr_ypall		_xdr_ypall
+#define xdr_ypbind_resp		_xdr_ypbind_resp
+#define xdr_ypbind_setdom	_xdr_ypbind_setdom
+#define xdr_ypdomain_wrap_string	_xdr_ypdomain_wrap_string
+#define xdr_ypmap_parms		_xdr_ypmap_parms
+#define xdr_ypmap_wrap_string	_xdr_ypmap_wrap_string
+#define xdr_ypmaplist		_xdr_ypmaplist
+#define xdr_ypowner_wrap_string _xdr_ypowner_wrap_string
+#define xdr_yppushresp_xfr	_xdr_yppushresp_xfr
+#define xdr_ypreq_key		_xdr_ypreq_key
+#define xdr_ypreq_nokey		_xdr_ypreq_nokey
+#define xdr_ypreq_xfr		_xdr_ypreq_xfr
+#define xdr_ypresp_key_val	_xdr_ypresp_key_val
+#define xdr_ypresp_maplist	_xdr_ypresp_maplist
+#define xdr_ypresp_master	_xdr_ypresp_master
+#define xdr_ypresp_order	_xdr_ypresp_order
+#define xdr_ypresp_val		_xdr_ypresp_val
+#define xdrmem_create		_xdrmem_create
+#define xdrrec_create		_xdrrec_create
+#define xdrrec_endofrecord	_xdrrec_endofrecord
+#define xdrrec_eof		_xdrrec_eof
+#define xdrrec_skiprecord	_xdrrec_skiprecord
+#define xdrstdio_create		_xdrstdio_create
+#define xprt_register		_xprt_register
+#define xprt_unregister		_xprt_unregister
+#define yp_all			_yp_all
+#define yp_bind			_yp_bind
+#define yp_first		_yp_first
+#define yp_get_default_domain	_yp_get_default_domain
+#define yp_maplist		_yp_maplist
+#define yp_master		_yp_master
+#define yp_match		_yp_match
+#define yp_next			_yp_next
+#define yp_order		_yp_order
+#define yp_unbind		_yp_unbind
+#define yperr_string		_yperr_string
+#define ypprot_err		_ypprot_err
+#define yp_setbindtries		_yp_setbindtries
+#define dlopen			__dlopen
+#define dlclose			__dlclose
+#define dlsym			__dlsym
+#define dlerror			__dlerror
+#define dladdr			__dladdr
+#define fmtcheck		__fmtcheck
+
+/* RB trees */
+#define	rb_tree_init		_rb_tree_init
+#define	rb_tree_find_node	_rb_tree_find_node
+#define	rb_tree_find_node_geq	_rb_tree_find_node_geq
+#define	rb_tree_find_node_leq	_rb_tree_find_node_leq
+#define	rb_tree_insert_node	_rb_tree_insert_node
+#define	rb_tree_remove_node	_rb_tree_remove_node
+#define	rb_tree_iterate		_rb_tree_iterate
+#ifdef RBDEBUG
+#define	rb_tree_check		_rb_tree_check
+#define	rb_tree_depths		_rb_tree_depths
+#endif
+
+/* rpc locks */
+#define authdes_lock		__rpc_authdes_lock
+#define authnone_lock		__rpc_authnone_lock
+#define authsvc_lock		__rpc_authsvc_lock
+#define clnt_fd_lock		__rpc_clnt_fd_lock
+#define clntraw_lock		__rpc_clntraw_lock
+#define dname_lock		__rpc_dname_lock
+#define dupreq_lock		__rpc_dupreq_lock
+#define keyserv_lock		__rpc_keyserv_lock
+#define libnsl_trace_lock	__rpc_libnsl_trace_lock
+#define loopnconf_lock		__rpc_loopnconf_lock
+#define ops_lock		__rpc_ops_lock
+#define portnum_lock		__rpc_portnum_lock
+#define proglst_lock		__rpc_proglst_lock
+#define rpcbaddr_cache_lock	__rpc_rpcbaddr_cache_lock
+#define rpcsoc_lock		__rpc_rpcsoc_lock
+#define svc_fd_lock		__rpc_svc_fd_lock
+#define svc_lock		__rpc_svc_lock
+#define svcraw_lock		__rpc_svcraw_lock
+#define xprtlist_lock		__rpc_xprtlist_lock
+
+#define __learn_tree		___learn_tree
+
+#if defined(__minix)
+#define sprofile _sprofile	/* LSC: Is this really needed? */
+
+/* Needed to allow RS and VM to provide their own implementations. */
+#define munmap			_munmap
+
+#endif /* defined(__minix) */
+#endif /* __weak_alias */
+#endif /* !__lint__ */
+
+#endif
+
+#endif /* _NAMESPACE_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/netdb.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/netdb.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/netdb.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/netdb.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,169 @@
+/* 
+ */
+
+
+
+#ifndef _NETDB_H_
+#define _NETDB_H_
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/cdefs.h>
+#include <netinet/in.h>
+
+
+
+/* The <netdb.h> header may define the in_port_t type and the in_addr_t type
+ *  as described in <netinet/in.h>.
+ */
+
+
+
+struct hostent
+{
+	char   *h_name;
+	char  **h_aliases;
+	int     h_addrtype;
+	int     h_length;
+	char  **h_addr_list;
+}; 
+   
+
+
+struct netent
+{
+	char     *n_name;
+	char    **n_aliases;
+	int       n_addrtype;
+	uint32_t n_net;
+};
+
+
+
+
+struct protoent
+{
+	char   *p_name;
+	char  **p_aliases;
+	int     p_proto;
+};
+
+
+
+struct servent
+{
+	char   *s_name;
+	char  **s_aliases;
+	int     s_port;
+	char   *s_proto;
+};
+
+
+
+
+#define IPPORT_RESERVED   1
+
+extern int h_errno;
+
+
+
+
+#define HOST_NOT_FOUND 1
+#define NO_DATA 2
+#define NO_RECOVERY 3
+#define TRY_AGAIN 4
+
+
+
+struct addrinfo
+{
+	int               ai_flags;
+	int               ai_family;
+	int               ai_socktype;
+	int               ai_protocol;
+	socklen_t         ai_addrlen;
+	struct sockaddr  *ai_addr;
+	char             *ai_canonname;
+	struct addrinfo  *ai_next;
+};
+
+
+
+
+#define AI_PASSIVE			(1<<0)
+#define AI_CANONNAME		(1<<1)
+#define AI_NUMERICHOST		(1<<2)
+#define AI_NUMERICSERV		(1<<3)
+#define AI_V4MAPPED			(1<<4)
+#define AI_ALL				(1<<5)
+#define AI_ADDRCONFIG		(1<<6)
+
+
+
+
+#define NI_NOFQDN			(1<<0)
+#define NI_NUMERICHOST		(1<<1)
+#define NI_NAMEREQD			(1<<2)
+#define NI_NUMERICSERV		(1<<3)
+#define NI_NUMERICSCOPE		(1<<4)
+#define NI_DGRAM			(1<<5)
+
+
+
+
+#define EAI_AGAIN			1
+#define EAI_BADFLAGS		2
+#define EAI_FAIL			3
+#define EAI_FAMILY			4
+#define EAI_MEMORY			5
+#define EAI_NONAME			6
+#define EAI_SERVICE			7
+#define EAI_SOCKTYPE		8
+#define EAI_SYSTEM			9
+#define EAI_OVERFLOW		10
+#define EAI_NODATA          11
+
+#define EAI_ADDRFAMILY      12
+
+
+
+
+
+
+void endhostent (void);
+void endnetent (void);
+void endprotoent (void);
+void endservent (void);
+void freeaddrinfo (struct addrinfo *);
+const char *gai_strerror (int);
+int getaddrinfo (const char *restrict, const char *restrict, const struct addrinfo *restrict, struct addrinfo **restrict);
+struct hostent *gethostbyaddr (const void *, socklen_t, int);
+struct hostent *gethostbyname (const char *);
+struct hostent *gethostent (void);
+int getnameinfo (const struct sockaddr *restrict, socklen_t, char *restrict, socklen_t, char *restrict, socklen_t, int);
+struct netent *getnetbyaddr (uint32_t, int);
+struct netent *getnetbyname (const char *);
+struct netent *getnetent (void);
+struct protoent *getprotobyname (const char *);
+struct protoent *getprotobynumber (int);
+struct protoent *getprotoent (void);
+struct servent *getservbyname (const char *, const char *);
+struct servent *getservbyport (int, const char *);
+struct servent *getservent (void);
+void sethostent (int);
+void setnetent (int);
+void setprotoent (int);
+void setservent (int);
+
+
+
+
+
+
+
+
+
+
+#endif /* !_NETDB_ */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/netgroup.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/netgroup.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/netgroup.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/netgroup.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,71 @@
+/*	$NetBSD: netgroup.h,v 1.10 2009/10/21 01:07:45 snj Exp $	*/
+
+/*
+ * Copyright (c) 1994 Christos Zoulas
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS
+ * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+ * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
+ * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _NETGROUP_H_
+#define	_NETGROUP_H_
+
+#include <sys/cdefs.h>
+
+#define	_PATH_NETGROUP		"/etc/netgroup"
+
+#define	_PATH_NETGROUP_DB	"/var/db/netgroup.db"
+
+#define	_PATH_NETGROUP_MKDB	"/usr/sbin/netgroup_mkdb"
+
+#define	_NG_KEYBYNAME		'1'	/* stored by name */
+#define	_NG_KEYBYUSER		'2'	/* stored by user */
+#define	_NG_KEYBYHOST		'3'	/* stored by host */
+
+#define _NG_ERROR	-1
+#define _NG_NONE	 0
+#define _NG_NAME	 1
+#define _NG_GROUP	 2
+
+struct netgroup {
+	__aconst char *ng_host;		/* host name */
+	__aconst char *ng_user;		/* user name */
+	__aconst char *ng_domain;	/* domain name */
+	struct	netgroup *ng_next;	/* thread */
+};
+
+__BEGIN_DECLS
+void	setnetgrent	(const char *);
+int	getnetgrent	(const char **, const char **, const char **);
+void	endnetgrent	(void);
+int	innetgr		(const char *, const char *, const char *,
+			     const char *);
+#ifdef _NETGROUP_PRIVATE
+char    *_ng_makekey(const char *, const char *, size_t);
+int	_ng_parse(char **, char **, struct netgroup **);
+void	_ng_print(char *, size_t, const struct netgroup *);
+void	_ng_cycle(const char *, const StringList *);
+#endif /* _NETGROUP_PRIVATE */
+
+__END_DECLS
+
+#endif /* !_NETGROUP_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/nsswitch.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/nsswitch.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/nsswitch.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/nsswitch.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,230 @@
+/*	$NetBSD: nsswitch.h,v 1.21 2011/07/17 20:54:34 joerg Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 1999, 2004 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _NSSWITCH_H
+#define _NSSWITCH_H	1
+
+#include <sys/types.h>
+#include <stdarg.h>
+
+#define	NSS_MODULE_INTERFACE_VERSION	0
+
+#ifndef _PATH_NS_CONF
+#define _PATH_NS_CONF	"/etc/nsswitch.conf"
+#endif
+
+#define	NS_CONTINUE	0
+#define	NS_RETURN	1
+
+/*
+ * Layout of:
+ *	uint32_t ns_src.flags
+ */ 
+	/* nsswitch.conf status codes and nsdispatch(3) return values */
+#define	NS_SUCCESS	(1<<0)		/* entry was found */
+#define	NS_UNAVAIL	(1<<1)		/* source not responding, or corrupt */
+#define	NS_NOTFOUND	(1<<2)		/* source responded 'no such entry' */
+#define	NS_TRYAGAIN	(1<<3)		/* source busy, may respond to retrys */
+#define	NS_STATUSMASK	0x000000ff	/* bitmask to get the status flags */
+
+	/* internal nsdispatch(3) flags; not settable in nsswitch.conf(5)  */
+#define	NS_FORCEALL	(1<<8)		/* force all methods to be invoked; */
+
+/*
+ * Currently implemented sources.
+ */
+#define NSSRC_FILES	"files"		/* local files */
+#define	NSSRC_DNS	"dns"		/* DNS; IN for hosts, HS for others */
+#define	NSSRC_NIS	"nis"		/* YP/NIS */
+#define	NSSRC_COMPAT	"compat"	/* passwd,group in YP compat mode */
+
+/*
+ * Currently implemented databases.
+ */
+#define NSDB_HOSTS		"hosts"
+#define NSDB_GROUP		"group"
+#define NSDB_GROUP_COMPAT	"group_compat"
+#define NSDB_NETGROUP		"netgroup"
+#define NSDB_NETWORKS		"networks"
+#define NSDB_PASSWD		"passwd"
+#define NSDB_PASSWD_COMPAT	"passwd_compat"
+#define NSDB_SHELLS		"shells"
+
+/*
+ * Suggested databases to implement.
+ */
+#define NSDB_ALIASES		"aliases"
+#define NSDB_AUTH		"auth"
+#define NSDB_AUTOMOUNT		"automount"
+#define NSDB_BOOTPARAMS		"bootparams"
+#define NSDB_ETHERS		"ethers"
+#define NSDB_EXPORTS		"exports"
+#define NSDB_NETMASKS		"netmasks"
+#define NSDB_PHONES		"phones"
+#define NSDB_PRINTCAP		"printcap"
+#define NSDB_PROTOCOLS		"protocols"
+#define NSDB_REMOTE		"remote"
+#define NSDB_RPC		"rpc"
+#define NSDB_SENDMAILVARS	"sendmailvars"
+#define NSDB_SERVICES		"services"
+#define NSDB_TERMCAP		"termcap"
+#define NSDB_TTYS		"ttys"
+
+/*
+ * ns_dtab `callback' function signature.
+ */
+typedef	int (*nss_method)(void *, void *, va_list);
+
+/*
+ * ns_dtab - `nsswitch dispatch table'
+ * Contains an entry for each source and the appropriate function to call.
+ */
+typedef struct {
+	const char	 *src;
+	nss_method	 callback;
+	void		 *cb_data;
+} ns_dtab;
+
+/*
+ * Macros to help build an ns_dtab[]
+ */
+#define NS_FILES_CB(F,C)	{ NSSRC_FILES,	F,	__UNCONST(C) },
+#define NS_COMPAT_CB(F,C)	{ NSSRC_COMPAT,	F,	__UNCONST(C) },
+ 
+#ifdef HESIOD
+#   define NS_DNS_CB(F,C)	{ NSSRC_DNS,	F,	__UNCONST(C) },
+#else
+#   define NS_DNS_CB(F,C)
+#endif
+
+#ifdef YP
+#   define NS_NIS_CB(F,C)	{ NSSRC_NIS,	F,	__UNCONST(C) },
+#else
+#   define NS_NIS_CB(F,C)
+#endif
+#define	NS_NULL_CB		{ .src = NULL },
+
+/*
+ * ns_src - `nsswitch source'
+ * Used by the nsparser routines to store a mapping between a source
+ * and its dispatch control flags for a given database.
+ */
+typedef struct {
+	const char	*name;
+	uint32_t	 flags;
+} ns_src;
+
+
+/*
+ * Default sourcelists (if nsswitch.conf is missing, corrupt,
+ * or the requested database doesn't have an entry)
+ */
+extern const ns_src __nsdefaultsrc[];
+extern const ns_src __nsdefaultcompat[];
+extern const ns_src __nsdefaultcompat_forceall[];
+extern const ns_src __nsdefaultfiles[];
+extern const ns_src __nsdefaultfiles_forceall[];
+extern const ns_src __nsdefaultnis[];
+extern const ns_src __nsdefaultnis_forceall[];
+
+
+/*
+ * ns_mtab - `nsswitch method table'
+ * An nsswitch module provides a mapping from (database name, method name)
+ * tuples to the nss_method and associated callback data.  Effectively,
+ * ns_dtab, but used for dynamically loaded modules.
+ */
+typedef struct {
+	const char	*database;
+	const char	*name;
+	nss_method	 method;
+	void		*mdata;
+} ns_mtab;
+
+/*
+ * nss_module_register_fn - module registration function
+ *	called at module load
+ * nss_module_unregister_fn - module un-registration function
+ *	called at module unload
+ */
+typedef	void (*nss_module_unregister_fn)(ns_mtab *, u_int);
+typedef	ns_mtab *(*nss_module_register_fn)(const char *, u_int *,
+					   nss_module_unregister_fn *);
+
+#ifdef _NS_PRIVATE
+
+/*
+ * Private data structures for back-end nsswitch implementation.
+ */
+
+/*
+ * ns_dbt - `nsswitch database thang'
+ * For each database in /etc/nsswitch.conf there is a ns_dbt, with its
+ * name and a list of ns_src's containing the source information.
+ */
+typedef struct {
+	const char	*name;		/* name of database */
+	ns_src		*srclist;	/* list of sources */
+	u_int		 srclistsize;	/* size of srclist */
+} ns_dbt;
+
+/*
+ * ns_mod - `nsswitch module'
+ */
+typedef struct {
+	const char	*name;		/* module name */
+	void		*handle;	/* handle from dlopen() */
+	ns_mtab		*mtab;		/* method table */
+	u_int		 mtabsize;	/* size of mtab */
+					/* called to unload module */
+	nss_module_unregister_fn unregister;
+} ns_mod;
+
+#endif /* _NS_PRIVATE */
+
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+int	nsdispatch(void *, const ns_dtab [], const char *,
+			const char *, const ns_src [], ...);
+
+#ifdef _NS_PRIVATE
+int		 _nsdbtaddsrc(ns_dbt *, const ns_src *);
+void		 _nsdbtdump(const ns_dbt *);
+int		 _nsdbtput(const ns_dbt *);
+void		 _nsyyerror(const char *);
+int		 _nsyylex(void);
+#endif /* _NS_PRIVATE */
+
+__END_DECLS
+
+#endif /* !_NSSWITCH_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/paths.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/paths.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/paths.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/paths.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,31 @@
+#ifndef	_PATHS_H_
+#define _PATHS_H_
+
+#define	_PATH_DEFPATH	"/usr/bin:/bin:/usr/pkg/bin:/usr/local/bin"
+
+#define	_PATH_STDPATH \
+	"/usr/bin:/bin:/usr/sbin:/sbin:/usr/pkg/bin:/usr/pkg/sbin:/usr/local/bin:/usr/local/sbin"
+
+#define _PATH_BSHELL    "/bin/sh"
+#define _PATH_KSHELL    "/bin/ksh"
+#define _PATH_DEV				"/dev/"
+#define _PATH_DEVNULL   "/dev/null"
+#define	_PATH_DEV_PTS		"/dev/pts/"
+#define _PATH_DEVZERO   "/dev/zero"
+#define	_PATH_EMUL_AOUT	"/emul/aout/"
+#define	_PATH_GETTYTAB  "/etc/gettytab"
+#define	_PATH_MAILDIR	  "/var/mail"
+#define	_PATH_MAN       "/usr/share/man"
+#define	_PATH_MNTTAB		"/etc/fstab"
+#define	_PATH_MOUNTED		"/etc/mtab"
+#define	_PATH_NOLOGIN   "/etc/nologin"
+#define	_PATH_RANDOM    "/dev/random"
+#define	_PATH_TMP				"/tmp/"
+#define	_PATH_TTY       "/dev/tty"
+#define	_PATH_URANDOM   "/dev/urandom"
+#define	_PATH_VARDB			"/var/db/"
+#define	_PATH_VARRUN		"/var/run/"
+#define	_PATH_VARTMP		"/var/tmp/"
+
+
+#endif /* _PATHS_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/poll.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/poll.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/poll.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/poll.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,30 @@
+#ifndef _POLL_H
+#define _POLL_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+
+#define POLLIN      (1<<0)
+#define POLLRDNORM  (1<<1)
+#define POLLRDBAND  (1<<2)
+#define POLLPRI     (1<<3)
+#define POLLOUT     (1<<4)
+#define POLLWRNORM  (1<<5)
+#define POLLWRBAND  (1<<6)
+#define POLLERR     (1<<7)
+#define POLLNVAL    (1<<8)
+
+typedef unsigned int  nfds_t;
+
+struct pollfd
+{
+  int fd;
+  short events;
+  short revents;
+};
+
+
+int poll (struct pollfd[], nfds_t nfds, int timeout);
+		   
+#endif 
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/pwcache.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/pwcache.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/pwcache.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/pwcache.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,72 @@
+/*	$NetBSD: pwcache.h,v 1.5 2003/11/10 08:51:51 wiz Exp $	*/
+
+/*-
+ * Copyright (c) 1992 Keith Muller.
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Keith Muller of the University of California, San Diego.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *      @(#)cache.h	8.1 (Berkeley) 5/31/93
+ */
+
+/*
+ * Constants and data structures used to implement group and password file
+ * caches. Traditional passwd/group cache routines perform quite poorly with
+ * archives. The chances of hitting a valid lookup with an archive is quite a
+ * bit worse than with files already resident on the file system. These misses
+ * create a MAJOR performance cost. To address this problem, these routines
+ * cache both hits and misses.
+ *
+ * NOTE:  name lengths must be as large as those stored in ANY PROTOCOL and
+ * as stored in the passwd and group files. CACHE SIZES MUST BE PRIME
+ */
+#define UNMLEN		32	/* >= user name found in any protocol */
+#define GNMLEN		32	/* >= group name found in any protocol */
+#define UID_SZ		317	/* size of uid to user_name cache */
+#define UNM_SZ		317	/* size of user_name to uid cache */
+#define GID_SZ		251	/* size of gid to group_name cache */
+#define GNM_SZ		251	/* size of group_name to gid cache */
+#define VALID		1	/* entry and name are valid */
+#define INVALID		2	/* entry valid, name NOT valid */
+
+/*
+ * Node structures used in the user, group, uid, and gid caches.
+ */
+
+typedef struct uidc {
+	int valid;		/* is this a valid or a miss entry */
+	char name[UNMLEN];	/* uid name */
+	uid_t uid;		/* cached uid */
+} UIDC;
+
+typedef struct gidc {
+	int valid;		/* is this a valid or a miss entry */
+	char name[GNMLEN];	/* gid name */
+	gid_t gid;		/* cached gid */
+} GIDC;
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/pwd.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/pwd.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/pwd.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/pwd.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,117 @@
+/*-
+ * Copyright (c) 1989 The Regents of the University of California.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)pwd.h	5.13 (Berkeley) 5/28/91
+ */
+
+#ifndef _PWD_H_
+#ifdef __cplusplus
+extern "C" {
+#endif
+#define	_PWD_H_
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#define	_PATH_PASSWD		"/etc/passwd"
+
+#define	_PASSWORD_LEN		128	/* max length, not counting NULL */
+
+#define	_PATH_PASSWD            "/etc/passwd"
+#define	_PATH_MASTERPASSWD	    "/etc/master.passwd"
+#define	_PATH_MASTERPASSWD_LOCK "/etc/ptmp"
+
+#define	_PATH_PASSWD_CONF       "/etc/passwd.conf"
+#define	_PATH_PASSWDCONF	      _PATH_PASSWD_CONF	/* XXX: compat */
+#define	_PATH_USERMGMT_CONF     "/etc/usermgmt.conf"
+
+#define	_PATH_MP_DB		  "/etc/pwd.db"
+#define	_PATH_SMP_DB		"/etc/spwd.db"
+
+#define	_PATH_PWD_MKDB  "/usr/sbin/pwd_mkdb"
+
+#define	_PW_KEYBYNAME		'1'	/* stored by name */
+#define	_PW_KEYBYNUM		'2'	/* stored by entry in the "file" */
+#define	_PW_KEYBYUID		'3'	/* stored by uid */
+
+#define	_PASSWORD_EFMT1		'_'	/* extended DES encryption format */
+#define	_PASSWORD_NONDES	'$'	/* non-DES encryption formats */
+
+#define _PASSWORD_NOUID		0x01	/* flag for no specified uid. */
+#define _PASSWORD_NOGID		0x02	/* flag for no specified gid. */
+#define _PASSWORD_NOCHG		0x04	/* flag for no specified change. */
+#define _PASSWORD_NOEXP		0x08	/* flag for no specified expire. */
+
+#define _PASSWORD_OLDFMT	0x10	/* flag to expect an old style entry */
+#define _PASSWORD_NOWARN	0x20	/* no warnings for bad entries */
+
+#define _PASSWORD_WARNDAYS	14	/* days to warn about expiry */
+#define _PASSWORD_CHGNOW	-1	/* special day to force password change at next login */
+
+
+struct passwd {
+	char	*pw_name;			/* user name */
+	char	*pw_passwd;		/* encrypted password */
+	uid_t	pw_uid;				/* user uid */
+	gid_t	pw_gid;				/* user gid */
+	char	*pw_comment;	/* comment */
+	char	*pw_gecos;		/* Honeywell login info */
+	char	*pw_dir;			/* home directory */
+	char	*pw_shell;		/* default shell */
+	char *pw_class;			/* user login class */
+	time_t	pw_change;	/* password change time */
+	time_t 	pw_expire;	/* account expiration */
+
+};
+
+#ifndef __INSIDE_CYGWIN__
+struct passwd	*getpwuid (uid_t);
+struct passwd	*getpwnam (const char *);
+
+#if __MISC_VISIBLE || __POSIX_VISIBLE
+int 		 getpwnam_r (const char *, struct passwd *,
+			char *, size_t , struct passwd **);
+int		 getpwuid_r (uid_t, struct passwd *, char *,
+			size_t, struct passwd **);
+#endif
+
+#if __MISC_VISIBLE || __XSI_VISIBLE >= 4
+struct passwd	*getpwent (void);
+void		 setpwent (void);
+void		 endpwent (void);
+#endif
+
+#if __BSD_VISIBLE
+int		 setpassent (int);
+#endif
+#endif /*!__INSIDE_CYGWIN__*/
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _PWD_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/pw_private.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/pw_private.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/pw_private.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/pw_private.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,8 @@
+/*	$NetBSD: pw_private.h,v 1.3 2012/03/20 16:36:05 matt Exp $	*/
+
+/*
+ * Written by Jason R. Thorpe <thorpej@NetBSD.org>, June 26, 1998.
+ * Public domain.
+ */
+
+int	__pw_scan(char *bp, struct passwd *pw, int *flags);
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/recno.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/recno.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/recno.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/recno.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,37 @@
+/*	$NetBSD: recno.h,v 1.6 2003/08/07 16:42:44 agc Exp $	*/
+
+/*-
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)recno.h	8.1 (Berkeley) 6/4/93
+ */
+
+enum SRCHOP { SDELETE, SINSERT, SEARCH};	/* Rec_search operation. */
+
+#include "btree.h"
+#include "extern.h"
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/reentrant.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/reentrant.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/reentrant.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/reentrant.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,355 @@
+/*	$NetBSD: reentrant.h,v 1.18 2015/01/20 18:31:25 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 2003 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by J.T. Conklin, by Nathan J. Williams, and by Jason R. Thorpe.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * Requirements:
+ * 
+ * 1. The thread safe mechanism should be lightweight so the library can
+ *    be used by non-threaded applications without unreasonable overhead.
+ * 
+ * 2. There should be no dependency on a thread engine for non-threaded
+ *    applications.
+ * 
+ * 3. There should be no dependency on any particular thread engine.
+ * 
+ * 4. The library should be able to be compiled without support for thread
+ *    safety.
+ * 
+ * 
+ * Rationale:
+ * 
+ * One approach for thread safety is to provide discrete versions of the
+ * library: one thread safe, the other not.  The disadvantage of this is
+ * that libc is rather large, and two copies of a library which are 99%+
+ * identical is not an efficent use of resources.
+ * 
+ * Another approach is to provide a single thread safe library.  However,
+ * it should not add significant run time or code size overhead to non-
+ * threaded applications.
+ * 
+ * Since the NetBSD C library is used in other projects, it should be
+ * easy to replace the mutual exclusion primitives with ones provided by
+ * another system.  Similarly, it should also be easy to remove all
+ * support for thread safety completely if the target environment does
+ * not support threads.
+ * 
+ * 
+ * Implementation Details:
+ * 
+ * The thread primitives used by the library (mutex_t, mutex_lock, etc.)
+ * are macros which expand to the cooresponding primitives provided by
+ * the thread engine or to nothing.  The latter is used so that code is
+ * not unreasonably cluttered with #ifdefs when all thread safe support
+ * is removed.
+ * 
+ * The thread macros can be directly mapped to the mutex primitives from
+ * pthreads, however it should be reasonably easy to wrap another mutex
+ * implementation so it presents a similar interface.
+ * 
+ * The thread functions operate by dispatching to symbols which are, by
+ * default, weak-aliased to no-op functions in thread-stub/thread-stub.c
+ * (some uses of thread operations are conditional on __isthreaded, but
+ * not all of them are).
+ *
+ * When the thread library is linked in, it provides strong-alias versions
+ * of those symbols which dispatch to its own real thread operations.
+ *
+ */
+
+#if !defined(__cheviotos) || !defined(_LIBC_REENTRANT_H)
+#ifdef __cheviotos
+/*
+ * If _REENTRANT is not defined, the header may not be included more than once.
+ * This is probably a NetBSD libc bug, but for now we solve it for MINIX3 only.
+ */
+#define _LIBC_REENTRANT_H
+#endif /* __cheviotos */
+
+/*
+ * Abstract thread interface for thread-safe libraries.  These routines
+ * will use stubs in libc if the application is not linked against the
+ * pthread library, and the real function in the pthread library if it
+ * is.
+ */
+
+#define __cheviotos
+
+#ifndef __cheviotos
+
+#include <pthread.h>
+#include <signal.h>
+
+#define	mutex_t			pthread_mutex_t
+#define	MUTEX_INITIALIZER	PTHREAD_MUTEX_INITIALIZER
+
+#define	mutexattr_t		pthread_mutexattr_t
+
+#define	MUTEX_TYPE_NORMAL	PTHREAD_MUTEX_NORMAL
+#define	MUTEX_TYPE_ERRORCHECK	PTHREAD_MUTEX_ERRORCHECK
+#define	MUTEX_TYPE_RECURSIVE	PTHREAD_MUTEX_RECURSIVE
+
+#define	cond_t			pthread_cond_t
+#define	COND_INITIALIZER	PTHREAD_COND_INITIALIZER
+
+#define	condattr_t		pthread_condattr_t
+
+#define	rwlock_t		pthread_rwlock_t
+#define	RWLOCK_INITIALIZER	PTHREAD_RWLOCK_INITIALIZER
+
+#define	rwlockattr_t		pthread_rwlockattr_t
+
+#define	thread_key_t		pthread_key_t
+
+#define	thr_t			pthread_t
+
+#define	thrattr_t		pthread_attr_t
+
+#define	once_t			pthread_once_t
+#define	ONCE_INITIALIZER	PTHREAD_ONCE_INIT
+
+#else /* __cheviotos */
+
+typedef struct {
+	int pto_done;
+} once_t;
+#define ONCE_INITIALIZER	{ .pto_done = 0 }
+
+#endif /* __cheviotos */
+
+#ifdef _REENTRANT
+
+#ifndef __LIBC_THREAD_STUBS
+
+__BEGIN_DECLS
+int	__libc_mutex_init(mutex_t *, const mutexattr_t *);
+int	__libc_mutex_lock(mutex_t *);
+int	__libc_mutex_trylock(mutex_t *);
+int	__libc_mutex_unlock(mutex_t *);
+int	__libc_mutex_destroy(mutex_t *);
+
+int	__libc_mutexattr_init(mutexattr_t *);
+int	__libc_mutexattr_settype(mutexattr_t *, int);
+int	__libc_mutexattr_destroy(mutexattr_t *);
+__END_DECLS
+
+#define	mutex_init(m, a)	__libc_mutex_init((m), (a))
+#define	mutex_lock(m)		__libc_mutex_lock((m))
+#define	mutex_trylock(m)	__libc_mutex_trylock((m))
+#define	mutex_unlock(m)		__libc_mutex_unlock((m))
+#define	mutex_destroy(m)	__libc_mutex_destroy((m))
+
+#define	mutexattr_init(ma)	__libc_mutexattr_init((ma))
+#define	mutexattr_settype(ma, t) __libc_mutexattr_settype((ma), (t))
+#define	mutexattr_destroy(ma)	__libc_mutexattr_destroy((ma))
+
+__BEGIN_DECLS
+int	__libc_cond_init(cond_t *, const condattr_t *);
+int	__libc_cond_signal(cond_t *);
+int	__libc_cond_broadcast(cond_t *);
+int	__libc_cond_wait(cond_t *, mutex_t *);
+#ifndef __LIBC12_SOURCE__
+int	__libc_cond_timedwait(cond_t *, mutex_t *, const struct timespec *);
+#endif
+int	__libc_cond_destroy(cond_t *);
+__END_DECLS
+
+#define	cond_init(c, t, a)     	__libc_cond_init((c), (a))
+#define	cond_signal(c)		__libc_cond_signal((c))
+#define	cond_broadcast(c)	__libc_cond_broadcast((c))
+#define	cond_wait(c, m)		__libc_cond_wait((c), (m))
+#define	cond_timedwait(c, m, t)	__libc_cond_timedwait((c), (m), (t))
+#define	cond_destroy(c)		__libc_cond_destroy((c))
+
+__BEGIN_DECLS
+int	__libc_rwlock_init(rwlock_t *, const rwlockattr_t *);
+int	__libc_rwlock_rdlock(rwlock_t *);
+int	__libc_rwlock_wrlock(rwlock_t *);
+int	__libc_rwlock_tryrdlock(rwlock_t *);
+int	__libc_rwlock_trywrlock(rwlock_t *);
+int	__libc_rwlock_unlock(rwlock_t *);
+int	__libc_rwlock_destroy(rwlock_t *);
+__END_DECLS
+
+#define	rwlock_init(l, a)	__libc_rwlock_init((l), (a))
+#define	rwlock_rdlock(l)	__libc_rwlock_rdlock((l))
+#define	rwlock_wrlock(l)	__libc_rwlock_wrlock((l))
+#define	rwlock_tryrdlock(l)	__libc_rwlock_tryrdlock((l))
+#define	rwlock_trywrlock(l)	__libc_rwlock_trywrlock((l))
+#define	rwlock_unlock(l)	__libc_rwlock_unlock((l))
+#define	rwlock_destroy(l)	__libc_rwlock_destroy((l))
+
+__BEGIN_DECLS
+int	__libc_thr_keycreate(thread_key_t *, void (*)(void *));
+int	__libc_thr_setspecific(thread_key_t, const void *);
+void	*__libc_thr_getspecific(thread_key_t);
+int	__libc_thr_keydelete(thread_key_t);
+__END_DECLS
+
+#define	thr_keycreate(k, d)	__libc_thr_keycreate((k), (d))
+#define	thr_setspecific(k, p)	__libc_thr_setspecific((k), (p))
+#define	thr_getspecific(k)	__libc_thr_getspecific((k))
+#define	thr_keydelete(k)	__libc_thr_keydelete((k))
+
+__BEGIN_DECLS
+int	__libc_thr_once(once_t *, void (*)(void));
+int	__libc_thr_sigsetmask(int, const sigset_t *, sigset_t *);
+thr_t	__libc_thr_self(void);
+int	__libc_thr_yield(void);
+void	__libc_thr_create(thr_t *, const thrattr_t *,
+	    void *(*)(void *), void *);
+void	__libc_thr_exit(void *) __attribute__((__noreturn__));
+int	*__libc_thr_errno(void);
+int	__libc_thr_setcancelstate(int, int *);
+unsigned int	__libc_thr_curcpu(void);
+
+extern int __isthreaded;
+__END_DECLS
+
+#define	thr_once(o, f)		__libc_thr_once((o), (f))
+#define	thr_sigsetmask(f, n, o)	__libc_thr_sigsetmask((f), (n), (o))
+#define	thr_self()		__libc_thr_self()
+#define	thr_yield()		__libc_thr_yield()
+#define	thr_create(tp, ta, f, a) __libc_thr_create((tp), (ta), (f), (a))
+#define	thr_exit(v)		__libc_thr_exit((v))
+#define	thr_errno()		__libc_thr_errno()
+#define	thr_enabled()		(__isthreaded)
+#define thr_setcancelstate(n, o) __libc_thr_setcancelstate((n),(o))
+#define thr_curcpu()		__libc_thr_curcpu()
+
+#else /* __LIBC_THREAD_STUBS */
+
+__BEGIN_DECLS
+void	__libc_thr_init_stub(void);
+
+int	__libc_mutex_init_stub(mutex_t *, const mutexattr_t *);
+int	__libc_mutex_lock_stub(mutex_t *);
+int	__libc_mutex_trylock_stub(mutex_t *);
+int	__libc_mutex_unlock_stub(mutex_t *);
+int	__libc_mutex_destroy_stub(mutex_t *);
+
+int	__libc_mutexattr_init_stub(mutexattr_t *); 
+int	__libc_mutexattr_destroy_stub(mutexattr_t *);
+int	__libc_mutexattr_settype_stub(mutexattr_t *, int);
+
+int	__libc_cond_init_stub(cond_t *, const condattr_t *);
+int	__libc_cond_signal_stub(cond_t *);
+int	__libc_cond_broadcast_stub(cond_t *);
+int	__libc_cond_wait_stub(cond_t *, mutex_t *);
+int	__libc_cond_timedwait_stub(cond_t *, mutex_t *,
+				   const struct timespec *);
+int	__libc_cond_destroy_stub(cond_t *);
+
+int	__libc_rwlock_init_stub(rwlock_t *, const rwlockattr_t *);
+int	__libc_rwlock_rdlock_stub(rwlock_t *);
+int	__libc_rwlock_wrlock_stub(rwlock_t *);
+int	__libc_rwlock_tryrdlock_stub(rwlock_t *);
+int	__libc_rwlock_trywrlock_stub(rwlock_t *);
+int	__libc_rwlock_unlock_stub(rwlock_t *);
+int	__libc_rwlock_destroy_stub(rwlock_t *);
+
+int	__libc_thr_keycreate_stub(thread_key_t *, void (*)(void *));
+int	__libc_thr_setspecific_stub(thread_key_t, const void *);
+void	*__libc_thr_getspecific_stub(thread_key_t);
+int	__libc_thr_keydelete_stub(thread_key_t);
+
+int	__libc_thr_once_stub(once_t *, void (*)(void));
+int	__libc_thr_sigsetmask_stub(int, const sigset_t *, sigset_t *);
+thr_t	__libc_thr_self_stub(void);
+int	__libc_thr_yield_stub(void);
+int	__libc_thr_create_stub(thr_t *, const thrattr_t *,
+	    void *(*)(void *), void *);
+void	__libc_thr_exit_stub(void *) __dead;
+int	*__libc_thr_errno_stub(void);
+int	__libc_thr_setcancelstate_stub(int, int *);
+int	__libc_thr_equal_stub(pthread_t, pthread_t);
+unsigned int	__libc_thr_curcpu_stub(void);
+__END_DECLS
+
+#endif /* __LIBC_THREAD_STUBS */
+
+#define	FLOCKFILE(fp)		__flockfile_internal(fp, 1)
+#define	FUNLOCKFILE(fp)		__funlockfile_internal(fp, 1)
+
+#else /* _REENTRANT */
+
+#ifndef __empty
+#define __empty do {} while (/*CONSTCOND*/0)
+#endif
+#define	mutex_init(m, a) __empty
+#define	mutex_lock(m) __empty
+#define	mutex_trylock(m) __empty
+#define	mutex_unlock(m)	__empty
+#define	mutex_destroy(m) __empty
+
+#define	cond_init(c, t, a) __empty
+#define	cond_signal(c) __empty
+#define	cond_broadcast(c) __empty
+#define	cond_wait(c, m) __empty
+#define	cond_timedwait(c, m, t) __empty
+#define	cond_destroy(c) __empty
+
+#define	rwlock_init(l, a) __empty
+#define	rwlock_rdlock(l) __empty
+#define	rwlock_wrlock(l) __empty
+#define	rwlock_tryrdlock(l) __empty
+#define	rwlock_trywrlock(l) __empty
+#define	rwlock_unlock(l) __empty
+#define	rwlock_destroy(l) __empty
+
+#define	thr_keycreate(k, d) /*LINTED*/0
+#define	thr_setspecific(k, p) __empty
+#define	thr_getspecific(k) /*LINTED*/0
+#define	thr_keydelete(k) __empty
+
+#define	mutexattr_init(ma) __empty
+#define	mutexattr_settype(ma, t) __empty
+#define	mutexattr_destroy(ma) __empty
+
+static inline int
+thr_once(once_t *once_control, void (*routine)(void))
+{
+	if (__predict_false(once_control->pto_done == 0)) {
+		(*routine)();
+		once_control->pto_done = 1;
+	}
+	return 0;
+}
+#define	thr_sigsetmask(f, n, o)	__empty
+#define	thr_self() __empty
+#define	thr_errno() __empty
+#define	thr_curcpu()		((unsigned int)0)
+
+#define	FLOCKFILE(fp) __empty
+#define	FUNLOCKFILE(fp) __empty
+
+#endif /* _REENTRANT */
+
+#endif /* !defined(__cheviotos) || !defined(_LIBC_REENTRANT_H) */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/stringlist.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/stringlist.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/stringlist.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/stringlist.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,54 @@
+/*	$NetBSD: stringlist.h,v 1.7 2008/04/28 20:22:54 martin Exp $	*/
+
+/*-
+ * Copyright (c) 1994 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Christos Zoulas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _STRINGLIST_H
+#define _STRINGLIST_H 
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+/*
+ * Simple string list
+ */
+typedef struct _stringlist {
+	char	**sl_str;
+	size_t	  sl_max;
+	size_t	  sl_cur;
+} StringList;
+
+__BEGIN_DECLS
+StringList 	*sl_init(void);
+int		 sl_add(StringList *, char *);
+void		 sl_free(StringList *, int);
+char 		*sl_find(StringList *, const char *);
+int		 sl_delete(StringList *, const char *, int);
+__END_DECLS
+
+#endif /* _STRINGLIST_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/termios.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/termios.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/termios.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,11 @@
+/* termios.h
+ */
+
+#ifndef _TERMIOS_H_
+#define _TERMIOS_H_
+
+#include <sys/termios.h>
+
+
+#endif /* !_TERMIOS_H_ */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/time.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/time.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/time.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/time.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,218 @@
+/*
+ * time.h
+ * 
+ * Struct and function declarations for dealing with time.
+ */
+
+#ifndef _TIME_H_
+#define _TIME_H_
+
+#include "_ansi.h"
+#include <sys/cdefs.h>
+#include <sys/reent.h>
+
+#define __need_size_t
+#define __need_NULL
+#include <stddef.h>
+
+/* Get _CLOCKS_PER_SEC_ */
+#include <machine/time.h>
+
+#ifndef _CLOCKS_PER_SEC_
+#define _CLOCKS_PER_SEC_ 100
+#endif
+
+#define CLOCKS_PER_SEC _CLOCKS_PER_SEC_
+#define CLK_TCK CLOCKS_PER_SEC
+
+#include <sys/types.h>
+#include <sys/timespec.h>
+
+#if __POSIX_VISIBLE >= 200809
+#include <sys/_locale.h>
+#endif
+
+_BEGIN_STD_C
+
+struct tm
+{
+  int	tm_sec;
+  int	tm_min;
+  int	tm_hour;
+  int	tm_mday;
+  int	tm_mon;
+  int	tm_year;
+  int	tm_wday;
+  int	tm_yday;
+  int	tm_isdst;
+#ifdef __TM_GMTOFF
+  long	__TM_GMTOFF;
+#endif
+#ifdef __TM_ZONE
+  const char *__TM_ZONE;
+#endif
+};
+
+clock_t	   clock (void);
+double	   difftime (time_t _time2, time_t _time1);
+time_t	   mktime (struct tm *_timeptr);
+time_t	   time (time_t *_timer);
+
+#ifndef _REENT_ONLY
+char	  *asctime (const struct tm *_tblock);
+char	  *ctime (const time_t *_time);
+struct tm *gmtime (const time_t *_timer);
+struct tm *localtime (const time_t *_timer);
+#endif
+
+size_t	   strftime (char *__restrict _s,
+			     size_t _maxsize, const char *__restrict _fmt,
+			     const struct tm *__restrict _t);
+
+int diff_timespec(struct timespec *result, struct timespec *t2, struct timespec *t1);
+void add_timespec(struct timespec *result, struct timespec *t2, struct timespec *t1);
+
+
+#if __POSIX_VISIBLE >= 200809
+extern size_t strftime_l (char *__restrict _s, size_t _maxsize,
+			  const char *__restrict _fmt,
+			  const struct tm *__restrict _t, locale_t _l);
+#endif
+
+char	  *asctime_r 	(const struct tm *__restrict,
+				 char *__restrict);
+char	  *ctime_r 	(const time_t *, char *);
+struct tm *gmtime_r 	(const time_t *__restrict,
+				 struct tm *__restrict);
+struct tm *localtime_r 	(const time_t *__restrict,
+				 struct tm *__restrict);
+
+_END_STD_C
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#if __XSI_VISIBLE
+char      *strptime (const char *__restrict,
+				 const char *__restrict,
+				 struct tm *__restrict);
+#endif
+#if __GNU_VISIBLE
+char *strptime_l (const char *__restrict, const char *__restrict,
+		  struct tm *__restrict, locale_t);
+#endif
+
+#if __POSIX_VISIBLE
+void      tzset 	(void);
+#endif
+void      _tzset_r 	(struct _reent *);
+
+/* getdate functions */
+
+#ifdef HAVE_GETDATE
+#if __XSI_VISIBLE >= 4
+#ifndef _REENT_ONLY
+#define getdate_err (*__getdate_err())
+int *__getdate_err (void);
+
+struct tm *	getdate (const char *);
+/* getdate_err is set to one of the following values to indicate the error.
+     1  the DATEMSK environment variable is null or undefined,
+     2  the template file cannot be opened for reading,
+     3  failed to get file status information,
+     4  the template file is not a regular file,
+     5  an error is encountered while reading the template file,
+     6  memory allication failed (not enough memory available),
+     7  there is no line in the template that matches the input,
+     8  invalid input specification  */
+#endif /* !_REENT_ONLY */
+#endif /* __XSI_VISIBLE >= 4 */
+
+#if __GNU_VISIBLE
+/* getdate_r returns the error code as above */
+int		getdate_r (const char *, struct tm *);
+#endif /* __GNU_VISIBLE */
+#endif /* HAVE_GETDATE */
+
+/* defines for the opengroup specifications Derived from Issue 1 of the SVID.  */
+#if __SVID_VISIBLE || __XSI_VISIBLE
+extern __IMPORT long _timezone;
+extern __IMPORT int _daylight;
+#endif
+#if __POSIX_VISIBLE
+extern __IMPORT char *_tzname[2];
+
+/* POSIX defines the external tzname being defined in time.h */
+#ifndef tzname
+#define tzname _tzname
+#endif
+#endif /* __POSIX_VISIBLE */
+
+#ifdef __cplusplus
+}
+#endif
+
+#include <sys/features.h>
+#include <signal.h>
+
+
+/* High Resolution Sleep, P1003.1b-1993, p. 269 */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+int nanosleep (const struct timespec  *rqtp, struct timespec *rmtp);
+
+int clock_nanosleep (clockid_t clock_id, int flags,
+	const struct timespec *rqtp, struct timespec *rmtp);
+
+/* CPU-time Clock Attributes, P1003.4b/D8, p. 54 */
+
+/* values for the clock enable attribute */
+
+#define CLOCK_ENABLED  1  /* clock is enabled, i.e. counting execution time */
+#define CLOCK_DISABLED 0  /* clock is disabled */
+
+/* values for the pthread cputime_clock_allowed attribute */
+
+#define CLOCK_ALLOWED    1 /* If a thread is created with this value a */
+                           /*   CPU-time clock attached to that thread */
+                           /*   shall be accessible. */
+#define CLOCK_DISALLOWED 0 /* If a thread is created with this value, the */
+                           /*   thread shall not have a CPU-time clock */
+                           /*   accessible. */
+
+/* Flag indicating time is "absolute" with respect to the clock
+   associated with a time.  Value 4 is historic. */
+
+#define TIMER_ABSTIME	4
+
+/* Manifest Constants, P1003.1b-1993, p. 262 */
+
+#define CLOCK_REALTIME		((clockid_t) 1)
+
+/* Manifest Constants, P1003.4b/D8, p. 55 */
+
+/*  The identifier for the system-wide monotonic clock, which is defined
+ *  as a clock whose value cannot be set via clock_settime() and which
+ *  cannot have backward clock jumps. */
+
+#define CLOCK_MONOTONIC				((clockid_t) 4)
+
+/*  The identify for the free-running hardware timer.  In the case
+ *  of the Raspberry Pi this is the 1MHz system timer.
+ *
+ */
+ 
+#define CLOCK_MONOTONIC_RAW		((clockid_t) 5)
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _TIME_H_ */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/ucontext.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/ucontext.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/ucontext.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,93 @@
+#ifndef	_UCONTEXT_H
+#define	_UCONTEXT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <signal.h>
+#include <sys/signal.h>
+
+typedef struct mcontext {
+  uint32_t sp;
+  uint32_t lr;
+  uint32_t cpsr; // Should be svc_mode spsr
+  uint32_t r1;
+  uint32_t r2;
+  uint32_t r3;
+  uint32_t r4;
+  uint32_t r5;
+  uint32_t r6;
+  uint32_t r7;
+  uint32_t r8;
+  uint32_t r9;
+  uint32_t r10;
+  uint32_t r11;
+  uint32_t r12;
+  uint32_t r0;
+  uint32_t pc; // Should be xyz_ svc_mode LR register.
+  uint32_t pad;
+} mcontext_t __attribute__((packed));
+
+
+
+/*
+ * ucontext_t
+ */
+
+#define UCF_SWAPPED     0x00000001      /* Used by swapcontext(3). */
+
+typedef struct __ucontext
+{
+	mcontext_t	uc_mcontext;
+	
+	sigset_t	uc_sigmask;
+	stack_t		uc_stack;
+	int			uc_flags;
+	struct __ucontext *uc_link;
+
+} ucontext_t;
+ 
+ 
+
+/*
+ *
+ */
+ 
+typedef void __sighandler_t (int);
+typedef	void __siginfohandler_t (int, siginfo_t *, void *);
+
+
+
+
+/*
+ * struct sigframe
+ */
+
+struct sigframe
+{
+  int          sf_signum;
+  siginfo_t    *sf_siginfo;     /* pointer to sf_si */
+  ucontext_t   *sf_ucontext;    /* pointer to sf_uc */
+
+  union
+  {
+		__siginfohandler_t      *sf_action;
+		__sighandler_t          *sf_handler;
+	} sf_ahu;
+    
+  ucontext_t      sf_uc;          /* = *sf_ucontext */
+  siginfo_t       sf_si;          /* = *sf_siginfo (SA_SIGINFO case) */
+};
+
+
+ 
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/unistd.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/unistd.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/unistd.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,20 @@
+#ifndef _UNISTD_H_
+#define _UNISTD_H_
+
+# include <sys/unistd.h>
+
+#define	GETPASS_NEED_TTY		0x001	/* Fail if we cannot set tty */
+#define	GETPASS_FAIL_EOF		0x002	/* Fail on EOF */
+#define	GETPASS_BUF_LIMIT		0x004	/* beep on buffer limit */
+#define	GETPASS_NO_SIGNAL		0x008	/* don't make ttychars send signals */
+#define	GETPASS_NO_BEEP			0x010	/* don't beep */
+#define	GETPASS_ECHO				0x020	/* echo characters as they are typed */
+#define	GETPASS_ECHO_STAR		0x040	/* echo '*' for each character */
+#define	GETPASS_7BIT				0x080	/* mask the high bit each char */
+#define	GETPASS_FORCE_LOWER	0x100	/* lowercase each char */
+#define	GETPASS_FORCE_UPPER	0x200	/* uppercase each char */
+#define	GETPASS_ECHO_NL			0x400	/* echo a newline if successful */
+
+#define	_SC_PASS_MAX				70
+
+#endif /* _UNISTD_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/util.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/util.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/util.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/util.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,173 @@
+/*	$NetBSD: util.h,v 1.68 2015/09/24 14:39:37 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1995
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#ifndef _UTIL_H_
+#define	_UTIL_H_
+
+#define __RENAME(x)
+#define __dead
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+//#include <sys/ansi.h>
+#include <stdint.h>
+
+#if 0
+#ifdef  _BSD_TIME_T_
+typedef _BSD_TIME_T_    time_t;
+#undef  _BSD_TIME_T_
+#endif
+#ifdef  _BSD_SIZE_T_
+typedef _BSD_SIZE_T_    size_t;
+#undef  _BSD_SIZE_T_
+#endif
+ 
+#if defined(_POSIX_C_SOURCE)
+#ifndef __VA_LIST_DECLARED
+typedef __va_list va_list;
+#define __VA_LIST_DECLARED
+#endif
+#endif
+
+
+#endif
+
+
+#define	PIDLOCK_NONBLOCK	1
+#define	PIDLOCK_USEHOSTNAME	2
+
+#define	PW_POLICY_BYSTRING	0
+#define	PW_POLICY_BYPASSWD	1
+#define	PW_POLICY_BYGROUP	2
+
+//__BEGIN_DECLS
+struct disklabel;
+struct iovec;
+struct passwd;
+struct termios;
+struct utmp;
+struct utmpx;
+struct winsize;
+struct sockaddr;
+
+char	       *flags_to_string(unsigned long, const char *);
+pid_t		forkpty(int *, char *, struct termios *, struct winsize *);
+const char     *getbootfile(void);
+int		getbyteorder(void);
+off_t		getlabeloffset(void);
+int		getlabelsector(void);
+int		getlabelusesmbr(void);
+int		getmaxpartitions(void);
+int		getrawpartition(void);
+const char     *getdiskrawname(char *, size_t, const char *);
+const char     *getdiskcookedname(char *, size_t, const char *);
+const char     *getfstypename(int);
+const char     *getfsspecname(char *, size_t, const char *);
+struct kinfo_vmentry *kinfo_getvmmap(pid_t, size_t *);
+#ifndef __LIBC12_SOURCE__
+void		login(const struct utmp *) __RENAME(__login50);
+void		loginx(const struct utmpx *) __RENAME(__loginx50);
+#endif
+int		login_tty(int);
+int		logout(const char *);
+int		logoutx(const char *, int, int);
+void		logwtmp(const char *, const char *, const char *);
+void		logwtmpx(const char *, const char *, const char *, int, int);
+int		opendisk(const char *, int, char *, size_t, int);
+int		opendisk1(const char *, int, char *, size_t, int,
+			  int (*)(const char *, int, ...));
+int		openpty(int *, int *, char *, struct termios *,
+    struct winsize *);
+#ifndef __LIBC12_SOURCE__
+time_t		parsedate(const char *, const time_t *, const int *)
+    __RENAME(__parsedate50);
+#endif
+int		pidfile(const char *);
+int		pidlock(const char *, int, pid_t *, const char *);
+int		pw_abort(void);
+#ifndef __LIBC12_SOURCE__
+void		pw_copy(int, int, struct passwd *, struct passwd *)
+    __RENAME(__pw_copy50);
+int		pw_copyx(int, int, struct passwd *, struct passwd *,
+    char *, size_t) __RENAME(__pw_copyx50);
+#endif
+void		pw_edit(int, const char *);
+__dead void	pw_error(const char *, int, int);
+void		pw_getconf(char *, size_t, const char *, const char *);
+#ifndef __LIBC12_SOURCE__
+void		pw_getpwconf(char *, size_t, const struct passwd *,
+    const char *) __RENAME(__pw_getpwconf50);
+#endif
+const char     *pw_getprefix(void);
+void		pw_init(void);
+int		pw_lock(int);
+int		pw_mkdb(const char *, int);
+void		pw_prompt(void);
+int		pw_setprefix(const char *);
+int		raise_default_signal(int);
+int		secure_path(const char *);
+int		snprintb_m(char *, size_t, const char *, uint64_t, size_t);
+int		snprintb(char *, size_t, const char *, uint64_t);
+int		sockaddr_snprintf(char *, size_t, const char *,
+    const struct sockaddr *);
+char 	       *strpct(char *, size_t, uintmax_t, uintmax_t, size_t);
+char 	       *strspct(char *, size_t, intmax_t, intmax_t, size_t);
+int		string_to_flags(char **, unsigned long *, unsigned long *);
+int		ttyaction(const char *, const char *, const char *);
+int		ttylock(const char *, int, pid_t *);
+char	       *ttymsg(struct iovec *, int, const char *, int);
+int		ttyunlock(const char *);
+
+uint16_t	disklabel_dkcksum(struct disklabel *);
+int		disklabel_scan(struct disklabel *, char *, size_t);
+
+/* Error checked functions */
+void		(*esetfunc(void (*)(int, const char *, ...)))
+    (int, const char *, ...);
+size_t 		estrlcpy(char *, const char *, size_t);
+size_t 		estrlcat(char *, const char *, size_t);
+char 		*estrdup(const char *);
+char 		*estrndup(const char *, size_t);
+intmax_t	estrtoi(const char *, int, intmax_t, intmax_t);
+uintmax_t	estrtou(const char *, int, uintmax_t, uintmax_t);
+void 		*ecalloc(size_t, size_t);
+void 		*emalloc(size_t);
+void 		*erealloc(void *, size_t);
+void 		ereallocarr(void *, size_t, size_t);
+struct __sFILE	*efopen(const char *, const char *);
+int	 	easprintf(char ** __restrict, const char * __restrict, ...)
+			__printflike(2, 3);
+int		evasprintf(char ** __restrict, const char * __restrict,
+    __va_list) __printflike(2, 0);
+
+//__END_DECLS
+
+#endif /* !_UTIL_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/utmp.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/utmp.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/utmp.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/utmp.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,72 @@
+/*	$NetBSD: utmp.h,v 1.12 2009/01/11 03:04:12 christos Exp $	*/
+
+/*
+ * Copyright (c) 1988, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)utmp.h	8.2 (Berkeley) 1/21/94
+ */
+
+#ifndef	_UTMP_H_
+#define	_UTMP_H_
+
+#define	_PATH_UTMP	"/var/run/utmp"
+#define	_PATH_WTMP	"/var/log/wtmp"
+#define	_PATH_LASTLOG	"/var/log/lastlog"
+
+#define	UT_NAMESIZE	8
+#define	UT_LINESIZE	8
+#define	UT_HOSTSIZE	16
+
+struct lastlog {
+	time_t	ll_time;
+	char	ll_line[UT_LINESIZE];
+	char	ll_host[UT_HOSTSIZE];
+};
+
+struct utmp {
+	char	ut_line[UT_LINESIZE];
+	char	ut_name[UT_NAMESIZE];
+	char	ut_host[UT_HOSTSIZE];
+	time_t	ut_time;
+};
+
+__BEGIN_DECLS
+int utmpname(const char *);
+void setutent(void);
+#ifndef __LIBC12_SOURCE__
+struct utmp *getutent(void);
+#endif
+void endutent(void);
+__END_DECLS
+
+#endif /* !_UTMP_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/utmpx.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/utmpx.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/utmpx.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/utmpx.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,159 @@
+/*	$NetBSD: utmpx.h,v 1.17 2009/01/11 19:09:29 christos Exp $	 */
+
+/*-
+ * Copyright (c) 2002 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Christos Zoulas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef	_UTMPX_H_
+#define	_UTMPX_H_
+
+#include <sys/cdefs.h>
+#include <sys/time.h>
+
+#define	_PATH_UTMPX		"/var/run/utmpx"
+#define	_PATH_WTMPX		"/var/log/wtmpx"
+#define	_PATH_LASTLOGX		"/var/log/lastlogx"
+#define	_PATH_UTMP_UPDATE	"/usr/libexec/utmp_update"
+
+#define _UTX_USERSIZE	32
+#define _UTX_LINESIZE	32
+#define	_UTX_IDSIZE	4
+#define _UTX_HOSTSIZE	256
+
+#if defined(_NETBSD_SOURCE)
+#define UTX_USERSIZE	_UTX_USERSIZE
+#define UTX_LINESIZE	_UTX_LINESIZE
+#define	UTX_IDSIZE	_UTX_IDSIZE
+#define UTX_HOSTSIZE	_UTX_HOSTSIZE
+#endif
+
+#define EMPTY		0
+#define RUN_LVL		1
+#define BOOT_TIME	2
+#define OLD_TIME	3
+#define NEW_TIME	4
+#define INIT_PROCESS	5
+#define LOGIN_PROCESS	6
+#define USER_PROCESS	7
+#define DEAD_PROCESS	8
+
+#if defined(_NETBSD_SOURCE)
+#define ACCOUNTING	9
+#define SIGNATURE	10
+#define DOWN_TIME	11
+
+/*
+ * Strings placed in the ut_line field to indicate special type entries
+ */
+#define	RUNLVL_MSG	"run-level %c"
+#define	BOOT_MSG	"system boot"
+#define	OTIME_MSG	"old time"
+#define	NTIME_MSG	"new time"
+#define	DOWN_MSG	"system down"
+#endif
+
+/*
+ * The following structure describes the fields of the utmpx entries
+ * stored in _PATH_UTMPX or _PATH_WTMPX. This is not the format the
+ * entries are stored in the files, and application should only access
+ * entries using routines described in getutxent(3).
+ */
+
+#define ut_user ut_name
+#define ut_xtime ut_tv.tv_sec
+
+/*
+ * This should be:
+ * 40 - (sizeof(struct timeval) - sizeof(struct { long s; long u; })))
+ * but g++ does not like it, to retain size compatibility with v1.00,
+ * so we do it manually.
+ */
+#ifdef _LP64
+#define _UTX_PADSIZE 36
+#else
+#define _UTX_PADSIZE 40
+#endif
+
+struct utmpx {
+	char ut_name[_UTX_USERSIZE];	/* login name */
+	char ut_id[_UTX_IDSIZE];	/* inittab id */
+	char ut_line[_UTX_LINESIZE];	/* tty name */
+	char ut_host[_UTX_HOSTSIZE];	/* host name */
+	uint16_t ut_session;		/* session id used for windowing */
+	uint16_t ut_type;		/* type of this entry */
+	pid_t ut_pid;			/* process id creating the entry */
+	struct {
+		uint16_t e_termination;	/* process termination signal */
+		uint16_t e_exit;	/* process exit status */
+	} ut_exit;
+#if 0
+	struct sockaddr_storage ut_ss;	/* address where entry was made from */
+#endif
+	struct timeval ut_tv;		/* time entry was created */
+	uint8_t ut_pad[_UTX_PADSIZE];	/* reserved for future use */
+};
+
+#if defined(_NETBSD_SOURCE)
+struct lastlogx {
+	struct timeval ll_tv;		/* time entry was created */
+	char ll_line[_UTX_LINESIZE];	/* tty name */
+	char ll_host[_UTX_HOSTSIZE];	/* host name */
+#if 0 
+	struct sockaddr_storage ll_ss;	/* address where entry was made from */
+#endif
+};
+#endif	/* !_XOPEN_SOURCE */
+
+__BEGIN_DECLS
+
+void setutxent(void);
+void endutxent(void);
+
+#ifndef __LIBC12_SOURCE__
+struct utmpx *getutxent(void);
+struct utmpx *getutxid(const struct utmpx *);
+struct utmpx *getutxline(const struct utmpx *);
+struct utmpx *pututxline(const struct utmpx *);
+#endif
+
+#if defined(_NETBSD_SOURCE)
+#ifndef __LIBC12_SOURCE__
+int updwtmpx(const char *, const struct utmpx *);
+struct lastlogx *getlastlogx(const char *, uid_t, struct lastlogx *);
+int updlastlogx(const char *, uid_t, struct lastlogx *);
+struct utmp;
+void getutmp(const struct utmpx *, struct utmp *);
+void getutmpx(const struct utmp *, struct utmpx *);
+#endif
+
+int utmpxname(const char *);
+
+#endif /* _NETBSD_SOURCE */
+
+__END_DECLS
+
+#endif /* !_UTMPX_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/vis.h third_party/newlib-4.1.0/newlib/libc/sys/arm/include/vis.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/include/vis.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/include/vis.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,122 @@
+/*	$NetBSD: vis.h,v 1.25 2017/04/23 01:57:36 christos Exp $	*/
+/*	$FreeBSD$	*/
+
+/*-
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)vis.h	8.1 (Berkeley) 6/2/93
+ */
+
+#ifndef _VIS_H_
+#define	_VIS_H_
+
+#include <sys/types.h>
+
+/*
+ * to select alternate encoding format
+ */
+#define	VIS_OCTAL	0x0001	/* use octal \ddd format */
+#define	VIS_CSTYLE	0x0002	/* use \[nrft0..] where appropiate */
+
+/*
+ * to alter set of characters encoded (default is to encode all
+ * non-graphic except space, tab, and newline).
+ */
+#define	VIS_SP		0x0004	/* also encode space */
+#define	VIS_TAB		0x0008	/* also encode tab */
+#define	VIS_NL		0x0010	/* also encode newline */
+#define	VIS_WHITE	(VIS_SP | VIS_TAB | VIS_NL)
+#define	VIS_SAFE	0x0020	/* only encode "unsafe" characters */
+#define	VIS_DQ		0x8000	/* also encode double quotes */
+
+/*
+ * other
+ */
+#define	VIS_NOSLASH	0x0040	/* inhibit printing '\' */
+#define	VIS_HTTP1808	0x0080	/* http-style escape % hex hex */
+#define	VIS_HTTPSTYLE	0x0080	/* http-style escape % hex hex */
+#define	VIS_GLOB	0x0100	/* encode glob(3) magic characters */
+#define	VIS_MIMESTYLE	0x0200	/* mime-style escape = HEX HEX */
+#define	VIS_HTTP1866	0x0400	/* http-style &#num; or &string; */
+#define	VIS_NOESCAPE	0x0800	/* don't decode `\' */
+#define	_VIS_END	0x1000	/* for unvis */
+#define	VIS_SHELL	0x2000	/* encode shell special characters [not glob] */
+#define	VIS_META	(VIS_WHITE | VIS_GLOB | VIS_SHELL)
+#define	VIS_NOLOCALE	0x4000	/* encode using the C locale */
+
+/*
+ * unvis return codes
+ */
+#define	UNVIS_VALID	 1	/* character valid */
+#define	UNVIS_VALIDPUSH	 2	/* character valid, push back passed char */
+#define	UNVIS_NOCHAR	 3	/* valid sequence, no character produced */
+#define	UNVIS_SYNBAD	-1	/* unrecognized escape sequence */
+#define	UNVIS_ERROR	-2	/* decoder in unknown state (unrecoverable) */
+
+/*
+ * unvis flags
+ */
+#define	UNVIS_END	_VIS_END	/* no more characters */
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+char	*vis(char *, int, int, int);
+char	*nvis(char *, size_t, int, int, int);
+
+char	*svis(char *, int, int, int, const char *);
+char	*snvis(char *, size_t, int, int, int, const char *);
+
+int	strvis(char *, const char *, int);
+int	stravis(char **, const char *, int);
+int	strnvis(char *, size_t, const char *, int);
+
+int	strsvis(char *, const char *, int, const char *);
+int	strsnvis(char *, size_t, const char *, int, const char *);
+
+int	strvisx(char *, const char *, size_t, int);
+int	strnvisx(char *, size_t, const char *, size_t, int);
+int 	strenvisx(char *, size_t, const char *, size_t, int, int *);
+
+int	strsvisx(char *, const char *, size_t, int, const char *);
+int	strsnvisx(char *, size_t, const char *, size_t, int, const char *);
+int	strsenvisx(char *, size_t, const char *, size_t , int, const char *,
+    int *);
+
+int	strunvis(char *, const char *);
+int	strnunvis(char *, size_t, const char *);
+
+int	strunvisx(char *, const char *, int);
+int	strnunvisx(char *, size_t, const char *, int);
+
+#ifndef __LIBC12_SOURCE__
+int	unvis(char *, int, int *, int);
+#endif
+__END_DECLS
+
+#endif /* !_VIS_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/initgroups.c third_party/newlib-4.1.0/newlib/libc/sys/arm/initgroups.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/initgroups.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/initgroups.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,82 @@
+/*	$NetBSD: initgroups.c,v 1.22 2012/06/25 22:32:43 abs Exp $	*/
+
+/*
+ * Copyright (c) 1983, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)initgroups.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: initgroups.c,v 1.22 2012/06/25 22:32:43 abs Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <sys/param.h>
+
+#include <assert.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#ifdef __weak_alias
+__weak_alias(initgroups,_initgroups)
+#endif
+
+int
+initgroups(const char *uname, gid_t agroup)
+{
+	gid_t groups_list[NGROUPS];
+	int ngroups;
+	gid_t *groups = groups_list;
+	int rval;
+
+	_DIAGASSERT(uname != NULL);
+
+	ngroups = NGROUPS;
+	if (getgrouplist(uname, agroup, groups, &ngroups) == -1) {
+		int maxgroups = ngroups;
+		groups = calloc((size_t)maxgroups, sizeof *groups);
+		if (groups == NULL)
+			return -1;
+		if (getgrouplist(uname, agroup, groups, &ngroups) == -1)
+			ngroups = maxgroups;
+	}
+	rval = setgroups(ngroups, groups);
+	if (rval == -1 && errno == EINVAL) {
+		int ng = (int)sysconf(_SC_NGROUPS_MAX);
+		if (ng > 0 && ng < ngroups)
+			rval = setgroups(ng, groups);
+	}
+	if (groups != groups_list)
+		free(groups);
+	return rval;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/interrupt.c third_party/newlib-4.1.0/newlib/libc/sys/arm/interrupt.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/interrupt.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/interrupt.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,58 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int createinterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api))
+{
+    int sc;
+    
+    sc = _swi_createinterrupt(irq, interrupt_handler);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+
+/*
+ *
+ */
+int maskinterrupt (int irq)
+{
+    int sc;
+    
+    sc = _swi_maskinterrupt(irq);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int unmaskinterrupt (int irq)
+{
+    int sc;
+    
+    sc = _swi_unmaskinterrupt(irq);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/ioctl.c third_party/newlib-4.1.0/newlib/libc/sys/arm/ioctl.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/ioctl.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,27 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+
+int ioctl (int fd, int request, ... )
+{
+    va_list ap;
+    int sc;
+
+    va_start(ap, request);
+    sc = _swi_ioctl(fd, request, va_arg(ap, void *));
+    va_end(ap);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/kqueue.c third_party/newlib-4.1.0/newlib/libc/sys/arm/kqueue.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/kqueue.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/kqueue.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,37 @@
+#include <stdint.h>
+#include <sys/event.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+int kqueue(void)
+{
+    int kq;
+    
+    kq = _swi_kqueue();
+    
+    if (kq < 0) {
+        errno = -kq;
+        return -1;
+    }
+    
+    return kq;    
+
+}
+
+int kevent(int kq, const struct kevent *changelist, int nchanges,
+	    struct kevent *eventlist, int nevents,
+	    const struct timespec *timeout)
+{
+    int sc;
+    
+    sc = _swi_kevent(kq, changelist, nchanges, eventlist, nevents, timeout);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return sc;    
+
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/libcfunc.c third_party/newlib-4.1.0/newlib/libc/sys/arm/libcfunc.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/libcfunc.c	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/libcfunc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-/* Support files for GNU libc.  Files in the C namespace go here.
-   Files in the system namespace (ie those that start with an underscore)
-   go in syscalls.c.
-   
-   Note: These functions are in a seperate file so that OS providers can
-   overrride the system call stubs (defined in syscalls.c) without having
-   to provide libc funcitons as well.  */
-#include "swi.h"
-
-
-
-void
-alarm (void)
-{
-}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/link.c third_party/newlib-4.1.0/newlib/libc/sys/arm/link.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/link.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/link.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,52 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+int link (const char *existing, const char *new)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+/*
+ *
+ */
+int readlink(const char *path, char *buf, size_t bufsize)
+{
+    int sc;
+    
+    sc = _swi_readlink(path, buf, bufsize);
+    
+    if (sc < 0) {
+      errno = -sc;
+      return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int symlink(const char *path1, const char *path2)
+{
+    int sc;
+    
+    sc = _swi_symlink(path1, path2);
+    
+    if (sc < 0) {
+      errno = -sc;
+      return -1;
+    }
+    
+    return 0;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/lseek.c third_party/newlib-4.1.0/newlib/libc/sys/arm/lseek.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/lseek.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/lseek.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,41 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+off_t lseek (int fd, off_t offset, int whence)
+{
+    int sc;
+    
+    sc = _swi_lseek(fd, offset, whence);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+
+/*
+ *
+ */
+off64_t lseek64 (int fd, off64_t offset, int whence)
+{
+    int sc;
+    
+    sc = _swi_lseek64(fd, &offset, whence);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return offset;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/machine/limits.h third_party/newlib-4.1.0/newlib/libc/sys/arm/machine/limits.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/machine/limits.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/machine/limits.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,6 @@
+/*
+ *  $Id: limits.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+/* intentionally empty file */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/machine/param.h third_party/newlib-4.1.0/newlib/libc/sys/arm/machine/param.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/machine/param.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/machine/param.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,92 @@
+/*
+ *  $Id: param.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef _MACHINE_PARAM_H_
+#define	_MACHINE_PARAM_H_
+
+/*
+ * These aren't really machine-dependent for RTEMS.....
+ */
+
+/*
+#define MACHINE		"i386"
+#define MID_MACHINE	MID_I386
+*/
+
+/*
+ * Round p (pointer or byte index) up to a correctly-aligned value
+ * for all data types (int, long, ...).   The result is unsigned int
+ * and must be cast to any desired pointer type.
+ */
+#define ALIGNBYTES	(sizeof(int) - 1)
+#define ALIGN(p)	(((unsigned)(p) + ALIGNBYTES) & ~ALIGNBYTES)
+
+#define PAGE_SHIFT	12		/* LOG2(PAGE_SIZE) */
+#define PAGE_SIZE	(1<<PAGE_SHIFT)	/* bytes/page */
+#define PAGE_MASK	(PAGE_SIZE-1)
+#define NPTEPG		(PAGE_SIZE/(sizeof (pt_entry_t)))
+
+#define NPDEPG		(PAGE_SIZE/(sizeof (pd_entry_t)))
+#define PDRSHIFT	22		/* LOG2(NBPDR) */
+#define NBPDR		(1<<PDRSHIFT)	/* bytes/page dir */
+
+#define DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
+#define DEV_BSIZE	(1<<DEV_BSHIFT)
+
+#define BLKDEV_IOSIZE	2048
+#define MAXPHYS		(64 * 1024)	/* max raw I/O transfer size */
+
+#define UPAGES	2		/* pages of u-area */
+
+/*
+ * Constants related to network buffer management.
+ * MCLBYTES must be no larger than CLBYTES (the software page size), and,
+ * on machines that exchange pages of input or output buffers with mbuf
+ * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
+ * of the hardware page size.
+ */
+#ifndef	MSIZE
+#define MSIZE		128		/* size of an mbuf */
+#endif	/* MSIZE */
+
+#ifndef	MCLSHIFT
+#define MCLSHIFT	11		/* convert bytes to m_buf clusters */
+#endif	/* MCLSHIFT */
+#define MCLBYTES	(1 << MCLSHIFT)	/* size of an m_buf cluster */
+#define MCLOFSET	(MCLBYTES - 1)	/* offset within an m_buf cluster */
+
+/*
+ * Some macros for units conversion
+ */
+
+/* clicks to bytes */
+#define ctob(x)	((x)<<PAGE_SHIFT)
+
+/* bytes to clicks */
+#define btoc(x)	(((unsigned)(x)+PAGE_MASK)>>PAGE_SHIFT)
+
+/*
+ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
+ * want to shift an unsigned type to avoid sign extension and we don't
+ * want to widen `bytes' unnecessarily.  Assume that the result fits in
+ * a daddr_t.
+ */
+#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
+	(sizeof (bytes) > sizeof(long) \
+	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
+	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
+
+#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
+	((off_t)(db) << DEV_BSHIFT)
+
+/*
+ * Mach derived conversion macros
+ */
+#define trunc_page(x)		((unsigned)(x) & ~PAGE_MASK)
+#define round_page(x)		((((unsigned)(x)) + PAGE_MASK) & ~PAGE_MASK)
+
+#define atop(x)			((unsigned)(x) >> PAGE_SHIFT)
+#define ptoa(x)			((unsigned)(x) << PAGE_SHIFT)
+
+#endif /* !_MACHINE_PARAM_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/machine/types.h third_party/newlib-4.1.0/newlib/libc/sys/arm/machine/types.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/machine/types.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/machine/types.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,32 @@
+#ifndef	_MACHTYPES_H_
+#define	_MACHTYPES_H_
+
+/*
+ *  The following section is RTEMS specific and is needed to more
+ *  closely match the types defined in the BSD machine/types.h.
+ *  This is needed to let the RTEMS/BSD TCP/IP stack compile.
+ */
+#if defined(__rtems__)
+#include <machine/_types.h>
+#endif
+
+#define	_CLOCK_T_	unsigned long		/* clock() */
+#define	_TIME_T_	long long			/* time() */
+#define _CLOCKID_T_ 	unsigned long
+#define _TIMER_T_   	unsigned long
+
+#ifndef _HAVE_SYSTYPES
+typedef long int __off_t;
+typedef int __pid_t;
+#ifdef __GNUC__
+__extension__ typedef long long int __loff_t;
+#else
+typedef long int __loff_t;
+#endif
+#endif
+
+typedef long long int off64_t;
+
+#endif	/* _MACHTYPES_H_ */
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/Makefile.am third_party/newlib-4.1.0/newlib/libc/sys/arm/Makefile.am
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/Makefile.am	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/Makefile.am	2024-03-17 17:47:03.407194450 +0000
@@ -2,28 +2,120 @@
 
 AUTOMAKE_OPTIONS = cygnus
 
-INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
+INCLUDES = -I$(srcdir)/include $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
 
 AM_CCASFLAGS = $(INCLUDES)
 
 noinst_LIBRARIES = lib.a
 
-if MAY_SUPPLY_SYSCALLS
-extra_objs = $(lpfx)libcfunc.o $(lpfx)trap.o $(lpfx)syscalls.o
-else
-extra_objs =
-endif
-
-lib_a_SOURCES = access.c aeabi_atexit.c
-lib_a_LIBADD = $(extra_objs)
-EXTRA_lib_a_SOURCES = trap.S syscalls.c libcfunc.c
-lib_a_DEPENDENCIES = $(extra_objs)
+lib_a_SOURCES = \
+  _exit.c \
+  access.c \
+	alarm.c \
+	chmod.c \
+	close.c \
+	closedir.c \
+	creat.c \
+	debug.c \
+	dir.c \
+	dup.c \
+	environ.c \
+	execl.c \
+	execle.c \
+	execlp.c \
+	execv.c \
+	execve.c \
+	execvp.c \
+	fcntl.c \
+	fork.c \
+	fstat.c \
+	getpid.c \
+	gettod.c \
+	id.c \
+	interrupt.c \
+	ioctl.c \
+	kqueue.c \
+	link.c \
+	lseek.c \
+	malloc.c \
+	mknod.c \
+	mntent.c \
+	mount.c \
+	msg.c \
+	open.c \
+	opendir.c \
+	pathconf.c \
+	pipe.c \
+	popen.c \
+	pwcache.c \
+	read.c \
+	readdir.c \
+	rename.c \
+	resource.c \
+	rewinddir.c \
+	select.c \
+	siglist.c \
+	signal.c \
+	syscall.S \
+	sleep.c \
+	stat.c \
+	statvfs.c \
+	sync.c \
+	sysconf.c \
+	termios.c \
+	time.c \
+	times.c \
+	truncate.c \
+	unlink.c \
+	user_strerror.c \
+  virtualalloc.c \
+	wait.c \
+	write.c \
+	\
+	err.c \
+  errx.c \
+  expand_number.c \
+	fnmatch.c \
+  getbsize.c \
+  getpass.c \
+  gethostname.c \
+  getprogname.c \
+	getgrouplist.c \
+	getgroupmembership.c \
+	getgrent.c \
+	getlogin.c \
+	__getlogin.c \
+	getnetgrent.c \
+	getpwent.c \
+  heapsort.c \
+  humanize_number.c \
+  initgroups.c \
+  merge.c \
+	nsdispatch.c \
+	nsparser.c \
+	nslexer.c \
+  setmode.c \
+	setproctitle.c \
+  signames.c \
+	stringlist.c \
+  strmode.c \
+	ttyaction.c \
+	reallocarray.c \
+	reallocarr.c \
+  verrx.c \
+  vwarn.c \
+  vwarnc.c \
+  vwarnx.c \
+  warn.c \
+  warnc.c \
+  warnx.c \
+  vis.c
+	
+	
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 
-if MAY_SUPPLY_SYSCALLS
 all-local: crt0.o
-endif
 
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
 CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/Makefile.in third_party/newlib-4.1.0/newlib/libc/sys/arm/Makefile.in
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/Makefile.in	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/Makefile.in	2024-03-17 17:47:03.411194527 +0000
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.11.6 from Makefile.am.
+# Makefile.in generated by automake 1.12 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -53,8 +53,8 @@
 host_triplet = @host@
 subdir = .
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/configure $(am__configure_deps) \
-	$(srcdir)/../../../../mkinstalldirs
+	$(top_srcdir)/configure $(am__configure_deps) acconfig.h \
+	$(top_srcdir)/../../../../mkinstalldirs
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../../../acinclude.m4 \
 	$(top_srcdir)/configure.in
@@ -68,9 +68,80 @@
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 lib_a_AR = $(AR) $(ARFLAGS)
-@MAY_SUPPLY_SYSCALLS_TRUE@am__DEPENDENCIES_1 = $(lpfx)libcfunc.o \
-@MAY_SUPPLY_SYSCALLS_TRUE@	$(lpfx)trap.o $(lpfx)syscalls.o
-am_lib_a_OBJECTS = lib_a-access.$(OBJEXT) lib_a-aeabi_atexit.$(OBJEXT)
+lib_a_LIBADD =
+am_lib_a_OBJECTS = lib_a-_exit.$(OBJEXT) lib_a-access.$(OBJEXT) \
+	lib_a-alarm.$(OBJEXT) lib_a-chmod.$(OBJEXT) \
+	lib_a-close.$(OBJEXT) lib_a-closedir.$(OBJEXT) \
+	lib_a-creat.$(OBJEXT) lib_a-debug.$(OBJEXT) \
+	lib_a-dir.$(OBJEXT) lib_a-dup.$(OBJEXT) \
+	lib_a-environ.$(OBJEXT) lib_a-execl.$(OBJEXT) \
+	lib_a-execle.$(OBJEXT) lib_a-execlp.$(OBJEXT) \
+	lib_a-execv.$(OBJEXT) lib_a-execve.$(OBJEXT) \
+	lib_a-execvp.$(OBJEXT) lib_a-fcntl.$(OBJEXT) \
+	lib_a-fork.$(OBJEXT) lib_a-fstat.$(OBJEXT) \
+	lib_a-getpid.$(OBJEXT) lib_a-gettod.$(OBJEXT) \
+	lib_a-id.$(OBJEXT) lib_a-interrupt.$(OBJEXT) \
+	lib_a-ioctl.$(OBJEXT) lib_a-kqueue.$(OBJEXT) lib_a-link.$(OBJEXT) \
+	lib_a-lseek.$(OBJEXT) lib_a-malloc.$(OBJEXT) \
+	lib_a-mknod.$(OBJEXT) lib_a-mntent.$(OBJEXT) \
+	lib_a-mount.$(OBJEXT) lib_a-msg.$(OBJEXT) lib_a-open.$(OBJEXT) \
+	lib_a-opendir.$(OBJEXT) lib_a-pathconf.$(OBJEXT) \
+	lib_a-pipe.$(OBJEXT) lib_a-popen.$(OBJEXT) lib_a-uio.$(OBJEXT) \
+	lib_a-read.$(OBJEXT) lib_a-readdir.$(OBJEXT) \
+	lib_a-rename.$(OBJEXT) lib_a-resource.$(OBJEXT) \
+	lib_a-rewinddir.$(OBJEXT) lib_a-select.$(OBJEXT) \
+	lib_a-siglist.$(OBJEXT) lib_a-signal.$(OBJEXT) \
+	lib_a-syscall.$(OBJEXT) lib_a-sleep.$(OBJEXT) \
+	lib_a-stat.$(OBJEXT) lib_a-statvfs.$(OBJEXT) \
+	lib_a-sync.$(OBJEXT) lib_a-sysconf.$(OBJEXT) \
+	lib_a-termios.$(OBJEXT) lib_a-time.$(OBJEXT) \
+	lib_a-times.$(OBJEXT) lib_a-truncate.$(OBJEXT) \
+	lib_a-unlink.$(OBJEXT) lib_a-user_strerror.$(OBJEXT) \
+	lib_a-virtualalloc.$(OBJEXT) lib_a-wait.$(OBJEXT) \
+	lib_a-write.$(OBJEXT) \
+	lib_a-err.$(OBJEXT) \
+	lib_a-errx.$(OBJEXT) \
+	lib_a-expand_number.$(OBJEXT) \
+	lib_a-fnmatch.$(OBJEXT) \
+	lib_a-getbsize.$(OBJEXT) \
+	lib_a-getpass.$(OBJEXT) \
+	lib_a-gethostname.$(OBJEXT) \
+	lib_a-getprogname.$(OBJEXT) \
+	lib_a-getgrouplist.$(OBJEXT) \
+	lib_a-getgroupmembership.$(OBJEXT) \
+	lib_a-getgrent.$(OBJEXT) \
+	lib_a-getlogin.$(OBJEXT) \
+	lib_a-__getlogin.$(OBJEXT) \
+	lib_a-getnetgrent.$(OBJEXT) \
+	lib_a-getpwent.$(OBJEXT) \
+	lib_a-heapsort.$(OBJEXT) \
+	lib_a-humanize_number.$(OBJEXT) \
+	lib_a-initgroups.$(OBJEXT) \
+	lib_a-merge.$(OBJEXT) \
+	lib_a-nsdispatch.$(OBJEXT) \
+	lib_a-nsparser.$(OBJEXT) \
+	lib_a-nslexer.$(OBJEXT) \
+	lib_a-setmode.$(OBJEXT) \
+	lib_a-setproctitle.$(OBJEXT) \
+	lib_a-signames.$(OBJEXT) \
+	lib_a-stringlist.$(OBJEXT) \
+	lib_a-strmode.$(OBJEXT) \
+	lib_a-ttyaction.$(OBJEXT) \
+	lib_a-reallocarray.$(OBJEXT) \
+	lib_a-reallocarr.$(OBJEXT) \
+	lib_a-verrx.$(OBJEXT) \
+	lib_a-vwarn.$(OBJEXT) \
+	lib_a-vwarnc.$(OBJEXT) \
+	lib_a-vwarnx.$(OBJEXT) \
+	lib_a-warn.$(OBJEXT) \
+	lib_a-warnc.$(OBJEXT) \
+	lib_a-warnx.$(OBJEXT) \
+	lib_a-vis.$(OBJEXT) \
+	lib_a-pwcache.$(OBJEXT) \
+	lib_a-getentropy.$(OBJEXT)
+	
+# lib_a-template.$(OBJEXT)
+	
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
@@ -81,7 +152,7 @@
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(lib_a_SOURCES) $(EXTRA_lib_a_SOURCES)
+SOURCES = $(lib_a_SOURCES)
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
@@ -89,6 +160,8 @@
   esac
 ETAGS = etags
 CTAGS = ctags
+CSCOPE = cscope
+AM_RECURSIVE_TARGETS = cscope
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
 AR = @AR@
@@ -193,15 +266,115 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AUTOMAKE_OPTIONS = cygnus
-INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
+INCLUDES = -I$(srcdir)/include $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
 AM_CCASFLAGS = $(INCLUDES)
 noinst_LIBRARIES = lib.a
-@MAY_SUPPLY_SYSCALLS_FALSE@extra_objs = 
-@MAY_SUPPLY_SYSCALLS_TRUE@extra_objs = $(lpfx)libcfunc.o $(lpfx)trap.o $(lpfx)syscalls.o
-lib_a_SOURCES = access.c aeabi_atexit.c
-lib_a_LIBADD = $(extra_objs)
-EXTRA_lib_a_SOURCES = trap.S syscalls.c libcfunc.c
-lib_a_DEPENDENCIES = $(extra_objs)
+lib_a_SOURCES = \
+  _exit.c \
+  access.c \
+	alarm.c \
+	chmod.c \
+	close.c \
+	closedir.c \
+	creat.c \
+	debug.c \
+	dir.c \
+	dup.c \
+	environ.c \
+	execl.c \
+	execle.c \
+	execlp.c \
+	execv.c \
+	execve.c \
+	execvp.c \
+	fcntl.c \
+	fork.c \
+	fstat.c \
+	getentropy.c \
+	getpid.c \
+	gettod.c \
+	id.c \
+	interrupt.c \
+	ioctl.c \
+	kqueue.c \
+	link.c \
+	lseek.c \
+	malloc.c \
+	mknod.c \
+	mntent.c \
+	mount.c \
+	msg.c \
+	open.c \
+	opendir.c \
+	pathconf.c \
+	pipe.c \
+	popen.c \
+	uio.c \
+	read.c \
+	readdir.c \
+	rename.c \
+	resource.c \
+	rewinddir.c \
+	select.c \
+	siglist.c \
+	signal.c \
+	syscall.S \
+	sleep.c \
+	stat.c \
+	statvfs.c \
+	sync.c \
+	sysconf.c \
+	termios.c \
+	time.c \
+	times.c \
+	truncate.c \
+	unlink.c \
+	user_strerror.c \
+  virtualalloc.c \
+	wait.c \
+	write.c \
+	err.c \
+  errx.c \
+  expand_number.c \
+	fnmatch.c \
+  getbsize.c \
+  getpass.c \
+  gethostname.c \
+  getprogname.c \
+	getgrouplist.c \
+	getgroupmembership.c \
+	getgrent.c \
+	getlogin.c \
+	__getlogin.c \
+	getnetgrent.c \
+	getpwent.c \
+  heapsort.c \
+  humanize_number.c \
+  initgroups.c \
+  merge.c \
+	nsdispatch.c \
+	nsparser.c \
+	nslexer.c \
+  setmode.c \
+	setproctitle.c \
+  signames.c \
+	stringlist.c \
+  strmode.c \
+	ttyaction.c \
+	reallocarray.c \
+	reallocarr.c \
+  verrx.c \
+  vwarn.c \
+  vwarnc.c \
+  vwarnx.c \
+  warn.c \
+  warnc.c \
+  warnx.c \
+  vis.c \
+  pwcache.c
+	
+# template.c	
+
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
@@ -264,11 +437,11 @@
 .S.obj:
 	$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
-lib_a-trap.o: trap.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-trap.o `test -f 'trap.S' || echo '$(srcdir)/'`trap.S
+lib_a-syscall.o: syscall.S
+	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-syscall.o `test -f 'syscall.S' || echo '$(srcdir)/'`syscall.S
 
-lib_a-trap.obj: trap.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-trap.obj `if test -f 'trap.S'; then $(CYGPATH_W) 'trap.S'; else $(CYGPATH_W) '$(srcdir)/trap.S'; fi`
+lib_a-syscall.obj: syscall.S
+	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-syscall.obj `if test -f 'syscall.S'; then $(CYGPATH_W) 'syscall.S'; else $(CYGPATH_W) '$(srcdir)/syscall.S'; fi`
 
 .c.o:
 	$(COMPILE) -c $<
@@ -276,29 +449,614 @@
 .c.obj:
 	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 
+lib_a-_exit.o: _exit.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-_exit.o `test -f '_exit.c' || echo '$(srcdir)/'`_exit.c
+
+lib_a-_exit.obj: _exit.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-_exit.obj `if test -f '_exit.c'; then $(CYGPATH_W) '_exit.c'; else $(CYGPATH_W) '$(srcdir)/_exit.c'; fi`
+
 lib_a-access.o: access.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.o `test -f 'access.c' || echo '$(srcdir)/'`access.c
 
 lib_a-access.obj: access.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.obj `if test -f 'access.c'; then $(CYGPATH_W) 'access.c'; else $(CYGPATH_W) '$(srcdir)/access.c'; fi`
 
-lib_a-aeabi_atexit.o: aeabi_atexit.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_atexit.o `test -f 'aeabi_atexit.c' || echo '$(srcdir)/'`aeabi_atexit.c
+lib_a-alarm.o: alarm.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-alarm.o `test -f 'alarm.c' || echo '$(srcdir)/'`alarm.c
+
+lib_a-alarm.obj: alarm.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-alarm.obj `if test -f 'alarm.c'; then $(CYGPATH_W) 'alarm.c'; else $(CYGPATH_W) '$(srcdir)/alarm.c'; fi`
+
+lib_a-chmod.o: chmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-chmod.o `test -f 'chmod.c' || echo '$(srcdir)/'`chmod.c
+
+lib_a-chmod.obj: chmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-chmod.obj `if test -f 'chmod.c'; then $(CYGPATH_W) 'chmod.c'; else $(CYGPATH_W) '$(srcdir)/chmod.c'; fi`
+
+lib_a-close.o: close.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-close.o `test -f 'close.c' || echo '$(srcdir)/'`close.c
+
+lib_a-close.obj: close.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-close.obj `if test -f 'close.c'; then $(CYGPATH_W) 'close.c'; else $(CYGPATH_W) '$(srcdir)/close.c'; fi`
+
+lib_a-closedir.o: closedir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-closedir.o `test -f 'closedir.c' || echo '$(srcdir)/'`closedir.c
+
+lib_a-closedir.obj: closedir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-closedir.obj `if test -f 'closedir.c'; then $(CYGPATH_W) 'closedir.c'; else $(CYGPATH_W) '$(srcdir)/closedir.c'; fi`
+
+lib_a-creat.o: creat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-creat.o `test -f 'creat.c' || echo '$(srcdir)/'`creat.c
+
+lib_a-creat.obj: creat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-creat.obj `if test -f 'creat.c'; then $(CYGPATH_W) 'creat.c'; else $(CYGPATH_W) '$(srcdir)/creat.c'; fi`
+
+lib_a-debug.o: debug.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-debug.o `test -f 'debug.c' || echo '$(srcdir)/'`debug.c
+
+lib_a-debug.obj: debug.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-debug.obj `if test -f 'debug.c'; then $(CYGPATH_W) 'debug.c'; else $(CYGPATH_W) '$(srcdir)/debug.c'; fi`
+
+lib_a-dir.o: dir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dir.o `test -f 'dir.c' || echo '$(srcdir)/'`dir.c
+
+lib_a-dir.obj: dir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dir.obj `if test -f 'dir.c'; then $(CYGPATH_W) 'dir.c'; else $(CYGPATH_W) '$(srcdir)/dir.c'; fi`
+
+lib_a-dup.o: dup.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dup.o `test -f 'dup.c' || echo '$(srcdir)/'`dup.c
+
+lib_a-dup.obj: dup.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dup.obj `if test -f 'dup.c'; then $(CYGPATH_W) 'dup.c'; else $(CYGPATH_W) '$(srcdir)/dup.c'; fi`
+
+lib_a-environ.o: environ.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-environ.o `test -f 'environ.c' || echo '$(srcdir)/'`environ.c
+
+lib_a-environ.obj: environ.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-environ.obj `if test -f 'environ.c'; then $(CYGPATH_W) 'environ.c'; else $(CYGPATH_W) '$(srcdir)/environ.c'; fi`
+
+lib_a-execl.o: execl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execl.o `test -f 'execl.c' || echo '$(srcdir)/'`execl.c
+
+lib_a-execl.obj: execl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execl.obj `if test -f 'execl.c'; then $(CYGPATH_W) 'execl.c'; else $(CYGPATH_W) '$(srcdir)/execl.c'; fi`
+
+lib_a-execle.o: execle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execle.o `test -f 'execle.c' || echo '$(srcdir)/'`execle.c
+
+lib_a-execle.obj: execle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execle.obj `if test -f 'execle.c'; then $(CYGPATH_W) 'execle.c'; else $(CYGPATH_W) '$(srcdir)/execle.c'; fi`
+
+lib_a-execlp.o: execlp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execlp.o `test -f 'execlp.c' || echo '$(srcdir)/'`execlp.c
+
+lib_a-execlp.obj: execlp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execlp.obj `if test -f 'execlp.c'; then $(CYGPATH_W) 'execlp.c'; else $(CYGPATH_W) '$(srcdir)/execlp.c'; fi`
+
+lib_a-execv.o: execv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execv.o `test -f 'execv.c' || echo '$(srcdir)/'`execv.c
+
+lib_a-execv.obj: execv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execv.obj `if test -f 'execv.c'; then $(CYGPATH_W) 'execv.c'; else $(CYGPATH_W) '$(srcdir)/execv.c'; fi`
+
+lib_a-execve.o: execve.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execve.o `test -f 'execve.c' || echo '$(srcdir)/'`execve.c
+
+lib_a-execve.obj: execve.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execve.obj `if test -f 'execve.c'; then $(CYGPATH_W) 'execve.c'; else $(CYGPATH_W) '$(srcdir)/execve.c'; fi`
+
+lib_a-execvp.o: execvp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execvp.o `test -f 'execvp.c' || echo '$(srcdir)/'`execvp.c
+
+lib_a-execvp.obj: execvp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execvp.obj `if test -f 'execvp.c'; then $(CYGPATH_W) 'execvp.c'; else $(CYGPATH_W) '$(srcdir)/execvp.c'; fi`
+
+lib_a-fcntl.o: fcntl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fcntl.o `test -f 'fcntl.c' || echo '$(srcdir)/'`fcntl.c
+
+lib_a-fcntl.obj: fcntl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fcntl.obj `if test -f 'fcntl.c'; then $(CYGPATH_W) 'fcntl.c'; else $(CYGPATH_W) '$(srcdir)/fcntl.c'; fi`
+
+lib_a-fork.o: fork.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fork.o `test -f 'fork.c' || echo '$(srcdir)/'`fork.c
+
+lib_a-fork.obj: fork.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fork.obj `if test -f 'fork.c'; then $(CYGPATH_W) 'fork.c'; else $(CYGPATH_W) '$(srcdir)/fork.c'; fi`
+
+lib_a-fstat.o: fstat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fstat.o `test -f 'fstat.c' || echo '$(srcdir)/'`fstat.c
+
+lib_a-fstat.obj: fstat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fstat.obj `if test -f 'fstat.c'; then $(CYGPATH_W) 'fstat.c'; else $(CYGPATH_W) '$(srcdir)/fstat.c'; fi`
+
+lib_a-getentropy.o: getentropy.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getentropy.o `test -f 'getentropy.c' || echo '$(srcdir)/'`getentropy.c
+
+lib_a-getentropy.obj: getentropy.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getentropy.obj `if test -f 'getentropy.c'; then $(CYGPATH_W) 'getentropy.c'; else $(CYGPATH_W) '$(srcdir)/getentropy.c'; fi`
+
+lib_a-getpid.o: getpid.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpid.o `test -f 'getpid.c' || echo '$(srcdir)/'`getpid.c
+
+lib_a-getpid.obj: getpid.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpid.obj `if test -f 'getpid.c'; then $(CYGPATH_W) 'getpid.c'; else $(CYGPATH_W) '$(srcdir)/getpid.c'; fi`
+
+lib_a-gettod.o: gettod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettod.o `test -f 'gettod.c' || echo '$(srcdir)/'`gettod.c
+
+lib_a-gettod.obj: gettod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettod.obj `if test -f 'gettod.c'; then $(CYGPATH_W) 'gettod.c'; else $(CYGPATH_W) '$(srcdir)/gettod.c'; fi`
+
+lib_a-id.o: id.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-id.o `test -f 'id.c' || echo '$(srcdir)/'`id.c
+
+lib_a-id.obj: id.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-id.obj `if test -f 'id.c'; then $(CYGPATH_W) 'id.c'; else $(CYGPATH_W) '$(srcdir)/id.c'; fi`
+
+lib_a-interrupt.o: interrupt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-interrupt.o `test -f 'interrupt.c' || echo '$(srcdir)/'`interrupt.c
+
+lib_a-interrupt.obj: interrupt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-interrupt.obj `if test -f 'interrupt.c'; then $(CYGPATH_W) 'interrupt.c'; else $(CYGPATH_W) '$(srcdir)/interrupt.c'; fi`
+
+lib_a-ioctl.o: ioctl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ioctl.o `test -f 'ioctl.c' || echo '$(srcdir)/'`ioctl.c
+
+lib_a-ioctl.obj: ioctl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ioctl.obj `if test -f 'ioctl.c'; then $(CYGPATH_W) 'ioctl.c'; else $(CYGPATH_W) '$(srcdir)/ioctl.c'; fi`
+
+lib_a-kqueue.o: kqueue.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-kqueue.o `test -f 'kqueue.c' || echo '$(srcdir)/'`kqueue.c
+
+lib_a-kqueue.obj: kqueue.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-kqueue.obj `if test -f 'kqueue.c'; then $(CYGPATH_W) 'kqueue.c'; else $(CYGPATH_W) '$(srcdir)/kqueue.c'; fi`
+
+lib_a-link.o: link.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-link.o `test -f 'link.c' || echo '$(srcdir)/'`link.c
+
+lib_a-link.obj: link.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-link.obj `if test -f 'link.c'; then $(CYGPATH_W) 'link.c'; else $(CYGPATH_W) '$(srcdir)/link.c'; fi`
+
+lib_a-lseek.o: lseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-lseek.o `test -f 'lseek.c' || echo '$(srcdir)/'`lseek.c
+
+lib_a-lseek.obj: lseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-lseek.obj `if test -f 'lseek.c'; then $(CYGPATH_W) 'lseek.c'; else $(CYGPATH_W) '$(srcdir)/lseek.c'; fi`
+
+lib_a-malloc.o: malloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-malloc.o `test -f 'malloc.c' || echo '$(srcdir)/'`malloc.c
+
+lib_a-malloc.obj: malloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-malloc.obj `if test -f 'malloc.c'; then $(CYGPATH_W) 'malloc.c'; else $(CYGPATH_W) '$(srcdir)/malloc.c'; fi`
+
+lib_a-mknod.o: mknod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mknod.o `test -f 'mknod.c' || echo '$(srcdir)/'`mknod.c
+
+lib_a-mknod.obj: mknod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mknod.obj `if test -f 'mknod.c'; then $(CYGPATH_W) 'mknod.c'; else $(CYGPATH_W) '$(srcdir)/mknod.c'; fi`
+
+lib_a-mntent.o: mntent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mntent.o `test -f 'mntent.c' || echo '$(srcdir)/'`mntent.c
+
+lib_a-mntent.obj: mntent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mntent.obj `if test -f 'mntent.c'; then $(CYGPATH_W) 'mntent.c'; else $(CYGPATH_W) '$(srcdir)/mntent.c'; fi`
+
+lib_a-mount.o: mount.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mount.o `test -f 'mount.c' || echo '$(srcdir)/'`mount.c
+
+lib_a-mount.obj: mount.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mount.obj `if test -f 'mount.c'; then $(CYGPATH_W) 'mount.c'; else $(CYGPATH_W) '$(srcdir)/mount.c'; fi`
+
+lib_a-msg.o: msg.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-msg.o `test -f 'msg.c' || echo '$(srcdir)/'`msg.c
+
+lib_a-msg.obj: msg.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-msg.obj `if test -f 'msg.c'; then $(CYGPATH_W) 'msg.c'; else $(CYGPATH_W) '$(srcdir)/msg.c'; fi`
+
+lib_a-open.o: open.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-open.o `test -f 'open.c' || echo '$(srcdir)/'`open.c
+
+lib_a-open.obj: open.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-open.obj `if test -f 'open.c'; then $(CYGPATH_W) 'open.c'; else $(CYGPATH_W) '$(srcdir)/open.c'; fi`
+
+lib_a-opendir.o: opendir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-opendir.o `test -f 'opendir.c' || echo '$(srcdir)/'`opendir.c
+
+lib_a-opendir.obj: opendir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-opendir.obj `if test -f 'opendir.c'; then $(CYGPATH_W) 'opendir.c'; else $(CYGPATH_W) '$(srcdir)/opendir.c'; fi`
+
+lib_a-pathconf.o: pathconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pathconf.o `test -f 'pathconf.c' || echo '$(srcdir)/'`pathconf.c
+
+lib_a-pathconf.obj: pathconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pathconf.obj `if test -f 'pathconf.c'; then $(CYGPATH_W) 'pathconf.c'; else $(CYGPATH_W) '$(srcdir)/pathconf.c'; fi`
+
+lib_a-pipe.o: pipe.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pipe.o `test -f 'pipe.c' || echo '$(srcdir)/'`pipe.c
+
+lib_a-pipe.obj: pipe.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pipe.obj `if test -f 'pipe.c'; then $(CYGPATH_W) 'pipe.c'; else $(CYGPATH_W) '$(srcdir)/pipe.c'; fi`
+
+lib_a-popen.o: popen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-popen.o `test -f 'popen.c' || echo '$(srcdir)/'`popen.c
+
+lib_a-popen.obj: popen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-popen.obj `if test -f 'popen.c'; then $(CYGPATH_W) 'popen.c'; else $(CYGPATH_W) '$(srcdir)/popen.c'; fi`
+
+lib_a-uio.o: uio.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-uio.o `test -f 'uio.c' || echo '$(srcdir)/'`uio.c
+
+lib_a-uio.obj: uio.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-uio.obj `if test -f 'uio.c'; then $(CYGPATH_W) 'uio.c'; else $(CYGPATH_W) '$(srcdir)/uio.c'; fi`
+
+lib_a-read.o: read.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-read.o `test -f 'read.c' || echo '$(srcdir)/'`read.c
+
+lib_a-read.obj: read.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-read.obj `if test -f 'read.c'; then $(CYGPATH_W) 'read.c'; else $(CYGPATH_W) '$(srcdir)/read.c'; fi`
+
+lib_a-readdir.o: readdir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-readdir.o `test -f 'readdir.c' || echo '$(srcdir)/'`readdir.c
+
+lib_a-readdir.obj: readdir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-readdir.obj `if test -f 'readdir.c'; then $(CYGPATH_W) 'readdir.c'; else $(CYGPATH_W) '$(srcdir)/readdir.c'; fi`
+
+lib_a-rename.o: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.o `test -f 'rename.c' || echo '$(srcdir)/'`rename.c
+
+lib_a-rename.obj: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.obj `if test -f 'rename.c'; then $(CYGPATH_W) 'rename.c'; else $(CYGPATH_W) '$(srcdir)/rename.c'; fi`
+
+lib_a-resource.o: resource.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-resource.o `test -f 'resource.c' || echo '$(srcdir)/'`resource.c
+
+lib_a-resource.obj: resource.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-resource.obj `if test -f 'resource.c'; then $(CYGPATH_W) 'resource.c'; else $(CYGPATH_W) '$(srcdir)/resource.c'; fi`
+
+lib_a-rewinddir.o: rewinddir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewinddir.o `test -f 'rewinddir.c' || echo '$(srcdir)/'`rewinddir.c
+
+lib_a-rewinddir.obj: rewinddir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewinddir.obj `if test -f 'rewinddir.c'; then $(CYGPATH_W) 'rewinddir.c'; else $(CYGPATH_W) '$(srcdir)/rewinddir.c'; fi`
+
+lib_a-select.o: select.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-select.o `test -f 'select.c' || echo '$(srcdir)/'`select.c
+
+lib_a-select.obj: select.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-select.obj `if test -f 'select.c'; then $(CYGPATH_W) 'select.c'; else $(CYGPATH_W) '$(srcdir)/select.c'; fi`
+
+lib_a-siglist.o: siglist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-siglist.o `test -f 'siglist.c' || echo '$(srcdir)/'`siglist.c
+
+lib_a-siglist.obj: siglist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-siglist.obj `if test -f 'siglist.c'; then $(CYGPATH_W) 'siglist.c'; else $(CYGPATH_W) '$(srcdir)/siglist.c'; fi`
+
+lib_a-signal.o: signal.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signal.o `test -f 'signal.c' || echo '$(srcdir)/'`signal.c
+
+lib_a-signal.obj: signal.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signal.obj `if test -f 'signal.c'; then $(CYGPATH_W) 'signal.c'; else $(CYGPATH_W) '$(srcdir)/signal.c'; fi`
+
+lib_a-sleep.o: sleep.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sleep.o `test -f 'sleep.c' || echo '$(srcdir)/'`sleep.c
+
+lib_a-sleep.obj: sleep.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sleep.obj `if test -f 'sleep.c'; then $(CYGPATH_W) 'sleep.c'; else $(CYGPATH_W) '$(srcdir)/sleep.c'; fi`
+
+lib_a-stat.o: stat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stat.o `test -f 'stat.c' || echo '$(srcdir)/'`stat.c
+
+lib_a-stat.obj: stat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stat.obj `if test -f 'stat.c'; then $(CYGPATH_W) 'stat.c'; else $(CYGPATH_W) '$(srcdir)/stat.c'; fi`
+
+lib_a-statvfs.o: statvfs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statvfs.o `test -f 'statvfs.c' || echo '$(srcdir)/'`statvfs.c
+
+lib_a-statvfs.obj: statvfs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statvfs.obj `if test -f 'statvfs.c'; then $(CYGPATH_W) 'statvfs.c'; else $(CYGPATH_W) '$(srcdir)/statvfs.c'; fi`
 
-lib_a-aeabi_atexit.obj: aeabi_atexit.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_atexit.obj `if test -f 'aeabi_atexit.c'; then $(CYGPATH_W) 'aeabi_atexit.c'; else $(CYGPATH_W) '$(srcdir)/aeabi_atexit.c'; fi`
+lib_a-sync.o: sync.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync.o `test -f 'sync.c' || echo '$(srcdir)/'`sync.c
 
-lib_a-syscalls.o: syscalls.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-syscalls.o `test -f 'syscalls.c' || echo '$(srcdir)/'`syscalls.c
+lib_a-sync.obj: sync.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync.obj `if test -f 'sync.c'; then $(CYGPATH_W) 'sync.c'; else $(CYGPATH_W) '$(srcdir)/sync.c'; fi`
 
-lib_a-syscalls.obj: syscalls.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-syscalls.obj `if test -f 'syscalls.c'; then $(CYGPATH_W) 'syscalls.c'; else $(CYGPATH_W) '$(srcdir)/syscalls.c'; fi`
+lib_a-sysconf.o: sysconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sysconf.o `test -f 'sysconf.c' || echo '$(srcdir)/'`sysconf.c
 
-lib_a-libcfunc.o: libcfunc.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-libcfunc.o `test -f 'libcfunc.c' || echo '$(srcdir)/'`libcfunc.c
+lib_a-sysconf.obj: sysconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sysconf.obj `if test -f 'sysconf.c'; then $(CYGPATH_W) 'sysconf.c'; else $(CYGPATH_W) '$(srcdir)/sysconf.c'; fi`
+
+lib_a-termios.o: termios.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-termios.o `test -f 'termios.c' || echo '$(srcdir)/'`termios.c
+
+lib_a-termios.obj: termios.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-termios.obj `if test -f 'termios.c'; then $(CYGPATH_W) 'termios.c'; else $(CYGPATH_W) '$(srcdir)/termios.c'; fi`
+
+lib_a-time.o: time.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-time.o `test -f 'time.c' || echo '$(srcdir)/'`time.c
+
+lib_a-time.obj: time.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-time.obj `if test -f 'time.c'; then $(CYGPATH_W) 'time.c'; else $(CYGPATH_W) '$(srcdir)/time.c'; fi`
+
+lib_a-times.o: times.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.o `test -f 'times.c' || echo '$(srcdir)/'`times.c
+
+lib_a-times.obj: times.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.obj `if test -f 'times.c'; then $(CYGPATH_W) 'times.c'; else $(CYGPATH_W) '$(srcdir)/times.c'; fi`
+
+lib_a-truncate.o: truncate.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-truncate.o `test -f 'truncate.c' || echo '$(srcdir)/'`truncate.c
+
+lib_a-truncate.obj: truncate.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-truncate.obj `if test -f 'truncate.c'; then $(CYGPATH_W) 'truncate.c'; else $(CYGPATH_W) '$(srcdir)/truncate.c'; fi`
+
+lib_a-unlink.o: unlink.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlink.o `test -f 'unlink.c' || echo '$(srcdir)/'`unlink.c
+
+lib_a-unlink.obj: unlink.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlink.obj `if test -f 'unlink.c'; then $(CYGPATH_W) 'unlink.c'; else $(CYGPATH_W) '$(srcdir)/unlink.c'; fi`
+
+lib_a-user_strerror.o: user_strerror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-user_strerror.o `test -f 'user_strerror.c' || echo '$(srcdir)/'`user_strerror.c
+
+lib_a-user_strerror.obj: user_strerror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-user_strerror.obj `if test -f 'user_strerror.c'; then $(CYGPATH_W) 'user_strerror.c'; else $(CYGPATH_W) '$(srcdir)/user_strerror.c'; fi`
+
+lib_a-virtualalloc.o: virtualalloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-virtualalloc.o `test -f 'virtualalloc.c' || echo '$(srcdir)/'`virtualalloc.c
+
+lib_a-virtualalloc.obj: virtualalloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-virtualalloc.obj `if test -f 'virtualalloc.c'; then $(CYGPATH_W) 'virtualalloc.c'; else $(CYGPATH_W) '$(srcdir)/virtualalloc.c'; fi`
+
+lib_a-wait.o: wait.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wait.o `test -f 'wait.c' || echo '$(srcdir)/'`wait.c
+
+lib_a-wait.obj: wait.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wait.obj `if test -f 'wait.c'; then $(CYGPATH_W) 'wait.c'; else $(CYGPATH_W) '$(srcdir)/wait.c'; fi`
+
+lib_a-write.o: write.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-write.o `test -f 'write.c' || echo '$(srcdir)/'`write.c
+
+lib_a-write.obj: write.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-write.obj `if test -f 'write.c'; then $(CYGPATH_W) 'write.c'; else $(CYGPATH_W) '$(srcdir)/write.c'; fi`
+
+# ---------------------------
+
+lib_a-err.o: err.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-err.o `test -f 'err.c' || echo '$(srcdir)/'`err.c
+
+lib_a-err.obj: err.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-err.obj `if test -f 'err.c'; then $(CYGPATH_W) 'err.c'; else $(CYGPATH_W) '$(srcdir)/err.c'; fi`
+
+lib_a-errx.o: errx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-errx.o `test -f 'errx.c' || echo '$(srcdir)/'`errx.c
+
+lib_a-errx.obj: errx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-errx.obj `if test -f 'errx.c'; then $(CYGPATH_W) 'errx.c'; else $(CYGPATH_W) '$(srcdir)/errx.c'; fi`
+
+lib_a-expand_number.o: expand_number.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-expand_number.o `test -f 'expand_number.c' || echo '$(srcdir)/'`expand_number.c
+
+lib_a-expand_number.obj: expand_number.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-expand_number.obj `if test -f 'expand_number.c'; then $(CYGPATH_W) 'expand_number.c'; else $(CYGPATH_W) '$(srcdir)/expand_number.c'; fi`
+
+lib_a-fnmatch.o: fnmatch.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fnmatch.o `test -f 'fnmatch.c' || echo '$(srcdir)/'`fnmatch.c
+
+lib_a-fnmatch.obj: fnmatch.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fnmatch.obj `if test -f 'fnmatch.c'; then $(CYGPATH_W) 'fnmatch.c'; else $(CYGPATH_W) '$(srcdir)/fnmatch.c'; fi`
+
+lib_a-getbsize.o: getbsize.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getbsize.o `test -f 'getbsize.c' || echo '$(srcdir)/'`getbsize.c
+
+lib_a-getbsize.obj: getbsize.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getbsize.obj `if test -f 'getbsize.c'; then $(CYGPATH_W) 'getbsize.c'; else $(CYGPATH_W) '$(srcdir)/getbsize.c'; fi`
+
+lib_a-getpass.o: getpass.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpass.o `test -f 'getpass.c' || echo '$(srcdir)/'`getpass.c
+
+lib_a-getpass.obj: getpass.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpass.obj `if test -f 'getpass.c'; then $(CYGPATH_W) 'getpass.c'; else $(CYGPATH_W) '$(srcdir)/getpass.c'; fi`
+
+lib_a-gethostname.o: gethostname.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gethostname.o `test -f 'gethostname.c' || echo '$(srcdir)/'`gethostname.c
+
+lib_a-gethostname.obj: gethostname.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gethostname.obj `if test -f 'gethostname.c'; then $(CYGPATH_W) 'gethostname.c'; else $(CYGPATH_W) '$(srcdir)/gethostname.c'; fi`
+
+lib_a-getprogname.o: getprogname.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getprogname.o `test -f 'getprogname.c' || echo '$(srcdir)/'`getprogname.c
+
+lib_a-getprogname.obj: getprogname.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getprogname.obj `if test -f 'getprogname.c'; then $(CYGPATH_W) 'getprogname.c'; else $(CYGPATH_W) '$(srcdir)/getprogname.c'; fi`
+
+lib_a-getgrouplist.o: getgrouplist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getgrouplist.o `test -f 'getgrouplist.c' || echo '$(srcdir)/'`getgrouplist.c
+
+lib_a-getgrouplist.obj: getgrouplist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getgrouplist.obj `if test -f 'getgrouplist.c'; then $(CYGPATH_W) 'getgrouplist.c'; else $(CYGPATH_W) '$(srcdir)/getgrouplist.c'; fi`
+
+lib_a-getgroupmembership.o: getgroupmembership.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getgroupmembership.o `test -f 'getgroupmembership.c' || echo '$(srcdir)/'`getgroupmembership.c
+
+lib_a-getgroupmembership.obj: getgroupmembership.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getgroupmembership.obj `if test -f 'getgroupmembership.c'; then $(CYGPATH_W) 'getgroupmembership.c'; else $(CYGPATH_W) '$(srcdir)/getgroupmembership.c'; fi`
+
+lib_a-getgrent.o: getgrent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getgrent.o `test -f 'getgrent.c' || echo '$(srcdir)/'`getgrent.c
+
+lib_a-getgrent.obj: getgrent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getgrent.obj `if test -f 'getgrent.c'; then $(CYGPATH_W) 'getgrent.c'; else $(CYGPATH_W) '$(srcdir)/getgrent.c'; fi`
+
+lib_a-getlogin.o: getlogin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getlogin.o `test -f 'getlogin.c' || echo '$(srcdir)/'`getlogin.c
+
+lib_a-getlogin.obj: getlogin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getlogin.obj `if test -f 'getlogin.c'; then $(CYGPATH_W) 'getlogin.c'; else $(CYGPATH_W) '$(srcdir)/getlogin.c'; fi`
+
+lib_a-__getlogin.o: __getlogin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-__getlogin.o `test -f '__getlogin.c' || echo '$(srcdir)/'`__getlogin.c
+
+lib_a-__getlogin.obj: __getlogin.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-__getlogin.obj `if test -f '__getlogin.c'; then $(CYGPATH_W) '__getlogin.c'; else $(CYGPATH_W) '$(srcdir)/__getlogin.c'; fi`
+
+lib_a-getnetgrent.o: getnetgrent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getnetgrent.o `test -f 'getnetgrent.c' || echo '$(srcdir)/'`getnetgrent.c
+
+lib_a-getnetgrent.obj: getnetgrent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getnetgrent.obj `if test -f 'getnetgrent.c'; then $(CYGPATH_W) 'getnetgrent.c'; else $(CYGPATH_W) '$(srcdir)/getnetgrent.c'; fi`
+
+lib_a-getpwent.o: getpwent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpwent.o `test -f 'getpwent.c' || echo '$(srcdir)/'`getpwent.c
+
+lib_a-getpwent.obj: getpwent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpwent.obj `if test -f 'getpwent.c'; then $(CYGPATH_W) 'getpwent.c'; else $(CYGPATH_W) '$(srcdir)/getpwent.c'; fi`
+
+lib_a-heapsort.o: heapsort.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-heapsort.o `test -f 'heapsort.c' || echo '$(srcdir)/'`heapsort.c
+
+lib_a-heapsort.obj: heapsort.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-heapsort.obj `if test -f 'heapsort.c'; then $(CYGPATH_W) 'heapsort.c'; else $(CYGPATH_W) '$(srcdir)/heapsort.c'; fi`
+
+lib_a-humanize_number.o: humanize_number.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-humanize_number.o `test -f 'humanize_number.c' || echo '$(srcdir)/'`humanize_number.c
+
+lib_a-humanize_number.obj: humanize_number.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-humanize_number.obj `if test -f 'humanize_number.c'; then $(CYGPATH_W) 'humanize_number.c'; else $(CYGPATH_W) '$(srcdir)/humanize_number.c'; fi`
+
+lib_a-initgroups.o: initgroups.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-initgroups.o `test -f 'initgroups.c' || echo '$(srcdir)/'`initgroups.c
+
+lib_a-initgroups.obj: initgroups.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-initgroups.obj `if test -f 'initgroups.c'; then $(CYGPATH_W) 'initgroups.c'; else $(CYGPATH_W) '$(srcdir)/initgroups.c'; fi`
+
+lib_a-merge.o: merge.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-merge.o `test -f 'merge.c' || echo '$(srcdir)/'`merge.c
+
+lib_a-merge.obj: merge.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-merge.obj `if test -f 'merge.c'; then $(CYGPATH_W) 'merge.c'; else $(CYGPATH_W) '$(srcdir)/merge.c'; fi`
+
+lib_a-nsdispatch.o: nsdispatch.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-nsdispatch.o `test -f 'nsdispatch.c' || echo '$(srcdir)/'`nsdispatch.c
+
+lib_a-nsdispatch.obj: nsdispatch.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-nsdispatch.obj `if test -f 'nsdispatch.c'; then $(CYGPATH_W) 'nsdispatch.c'; else $(CYGPATH_W) '$(srcdir)/nsdispatch.c'; fi`
+
+lib_a-nsparser.o: nsparser.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-nsparser.o `test -f 'nsparser.c' || echo '$(srcdir)/'`nsparser.c
+
+lib_a-nsparser.obj: nsparser.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-nsparser.obj `if test -f 'nsparser.c'; then $(CYGPATH_W) 'nsparser.c'; else $(CYGPATH_W) '$(srcdir)/nsparser.c'; fi`
+
+lib_a-nslexer.o: nslexer.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-nslexer.o `test -f 'nslexer.c' || echo '$(srcdir)/'`nslexer.c
+
+lib_a-nslexer.obj: nslexer.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-nslexer.obj `if test -f 'nslexer.c'; then $(CYGPATH_W) 'nslexer.c'; else $(CYGPATH_W) '$(srcdir)/nslexer.c'; fi`
+
+lib_a-setmode.o: setmode.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setmode.o `test -f 'setmode.c' || echo '$(srcdir)/'`setmode.c
+
+lib_a-setmode.obj: setmode.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setmode.obj `if test -f 'setmode.c'; then $(CYGPATH_W) 'setmode.c'; else $(CYGPATH_W) '$(srcdir)/setmode.c'; fi`
+
+lib_a-setproctitle.o: setproctitle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setproctitle.o `test -f 'setproctitle.c' || echo '$(srcdir)/'`setproctitle.c
+
+lib_a-setproctitle.obj: setproctitle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-setproctitle.obj `if test -f 'setproctitle.c'; then $(CYGPATH_W) 'setproctitle.c'; else $(CYGPATH_W) '$(srcdir)/setproctitle.c'; fi`
+
+lib_a-signames.o: signames.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signames.o `test -f 'signames.c' || echo '$(srcdir)/'`signames.c
+
+lib_a-signames.obj: signames.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signames.obj `if test -f 'signames.c'; then $(CYGPATH_W) 'signames.c'; else $(CYGPATH_W) '$(srcdir)/signames.c'; fi`
+
+lib_a-stringlist.o: stringlist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stringlist.o `test -f 'stringlist.c' || echo '$(srcdir)/'`stringlist.c
+
+lib_a-stringlist.obj: stringlist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stringlist.obj `if test -f 'stringlist.c'; then $(CYGPATH_W) 'stringlist.c'; else $(CYGPATH_W) '$(srcdir)/stringlist.c'; fi`
+
+lib_a-strmode.o: strmode.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-strmode.o `test -f 'strmode.c' || echo '$(srcdir)/'`strmode.c
+
+lib_a-strmode.obj: strmode.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-strmode.obj `if test -f 'strmode.c'; then $(CYGPATH_W) 'strmode.c'; else $(CYGPATH_W) '$(srcdir)/strmode.c'; fi`
+
+lib_a-ttyaction.o: ttyaction.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ttyaction.o `test -f 'ttyaction.c' || echo '$(srcdir)/'`ttyaction.c
+
+lib_a-ttyaction.obj: ttyaction.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ttyaction.obj `if test -f 'ttyaction.c'; then $(CYGPATH_W) 'ttyaction.c'; else $(CYGPATH_W) '$(srcdir)/ttyaction.c'; fi`
+
+lib_a-reallocarray.o: reallocarray.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-reallocarray.o `test -f 'reallocarray.c' || echo '$(srcdir)/'`reallocarray.c
+
+lib_a-reallocarray.obj: reallocarray.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-reallocarray.obj `if test -f 'reallocarray.c'; then $(CYGPATH_W) 'reallocarray.c'; else $(CYGPATH_W) '$(srcdir)/reallocarray.c'; fi`
+
+lib_a-reallocarr.o: reallocarr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-reallocarr.o `test -f 'reallocarr.c' || echo '$(srcdir)/'`reallocarr.c
+
+lib_a-reallocarr.obj: reallocarr.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-reallocarr.obj `if test -f 'reallocarr.c'; then $(CYGPATH_W) 'reallocarr.c'; else $(CYGPATH_W) '$(srcdir)/reallocarr.c'; fi`
+
+lib_a-verrx.o: verrx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-verrx.o `test -f 'verrx.c' || echo '$(srcdir)/'`verrx.c
+
+lib_a-verrx.obj: verrx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-verrx.obj `if test -f 'verrx.c'; then $(CYGPATH_W) 'verrx.c'; else $(CYGPATH_W) '$(srcdir)/verrx.c'; fi`
+
+lib_a-vwarn.o: vwarn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vwarn.o `test -f 'vwarn.c' || echo '$(srcdir)/'`vwarn.c
+
+lib_a-vwarn.obj: vwarn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vwarn.obj `if test -f 'vwarn.c'; then $(CYGPATH_W) 'vwarn.c'; else $(CYGPATH_W) '$(srcdir)/vwarn.c'; fi`
+
+lib_a-vwarnc.o: vwarnc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vwarnc.o `test -f 'vwarnc.c' || echo '$(srcdir)/'`vwarnc.c
+
+lib_a-vwarnc.obj: vwarnc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vwarnc.obj `if test -f 'vwarnc.c'; then $(CYGPATH_W) 'vwarnc.c'; else $(CYGPATH_W) '$(srcdir)/vwarnc.c'; fi`
+
+lib_a-vwarnx.o: vwarnx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vwarnx.o `test -f 'vwarnx.c' || echo '$(srcdir)/'`vwarnx.c
+
+lib_a-vwarnx.obj: vwarnx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vwarnx.obj `if test -f 'vwarnx.c'; then $(CYGPATH_W) 'vwarnx.c'; else $(CYGPATH_W) '$(srcdir)/vwarnx.c'; fi`
+
+lib_a-warn.o: warn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-warn.o `test -f 'warn.c' || echo '$(srcdir)/'`warn.c
+
+lib_a-warn.obj: warn.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-warn.obj `if test -f 'warn.c'; then $(CYGPATH_W) 'warn.c'; else $(CYGPATH_W) '$(srcdir)/warn.c'; fi`
+
+lib_a-warnc.o: warnc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-warnc.o `test -f 'warnc.c' || echo '$(srcdir)/'`warnc.c
+
+lib_a-warnc.obj: warnc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-warnc.obj `if test -f 'warnc.c'; then $(CYGPATH_W) 'warnc.c'; else $(CYGPATH_W) '$(srcdir)/warnc.c'; fi`
+
+lib_a-warnx.o: warnx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-warnx.o `test -f 'warnx.c' || echo '$(srcdir)/'`warnx.c
+
+lib_a-warnx.obj: warnx.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-warnx.obj `if test -f 'warnx.c'; then $(CYGPATH_W) 'warnx.c'; else $(CYGPATH_W) '$(srcdir)/warnx.c'; fi`
+
+lib_a-vis.o: vis.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vis.o `test -f 'vis.c' || echo '$(srcdir)/'`vis.c
+
+lib_a-vis.obj: vis.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-vis.obj `if test -f 'vis.c'; then $(CYGPATH_W) 'vis.c'; else $(CYGPATH_W) '$(srcdir)/vis.c'; fi`
+
+lib_a-pwcache.o: pwcache.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pwcache.o `test -f 'pwcache.c' || echo '$(srcdir)/'`pwcache.c
+
+lib_a-pwcache.obj: pwcache.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pwcache.obj `if test -f 'pwcache.c'; then $(CYGPATH_W) 'pwcache.c'; else $(CYGPATH_W) '$(srcdir)/pwcache.c'; fi`
 
-lib_a-libcfunc.obj: libcfunc.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-libcfunc.obj `if test -f 'libcfunc.c'; then $(CYGPATH_W) 'libcfunc.c'; else $(CYGPATH_W) '$(srcdir)/libcfunc.c'; fi`
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -349,11 +1107,34 @@
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+
+clean-cscope:
+	-rm -f cscope.files
+
+cscope.files: clean-cscope  cscopelist
+
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
 check-am:
 check: check-am
-@MAY_SUPPLY_SYSCALLS_FALSE@all-local:
 all-am: Makefile $(LIBRARIES) all-local
 installdirs:
 install: install-am
@@ -459,20 +1240,20 @@
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am all-local am--refresh check check-am \
-	clean clean-generic clean-noinstLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-tags dvi dvi-am \
-	html html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	clean clean-cscope clean-generic clean-noinstLIBRARIES cscope \
+	cscopelist ctags distclean distclean-compile distclean-generic \
+	distclean-tags dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am
 
 
-@MAY_SUPPLY_SYSCALLS_TRUE@all-local: crt0.o
+all-local: crt0.o
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/malloc.c third_party/newlib-4.1.0/newlib/libc/sys/arm/malloc.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/malloc.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/malloc.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,6466 @@
+/*
+  This is a version (aka dlmalloc) of malloc/free/realloc written by
+  Doug Lea and released to the public domain, as explained at
+  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
+  comments, complaints, performance data, etc to dl@cs.oswego.edu
+* Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
+   Note: There may be an updated version of this malloc obtainable at
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+         Check before installing!
+ */
+/*
+ * PackageLicenseDeclared: CC0-1.0
+ */
+
+#define LOG_LEVEL_INFO
+
+/* configuration */
+#include <stdint.h>
+#include <stddef.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/syscalls.h>
+#include <sys/debug.h>
+
+// Declaration
+void *cheviot_sbrk(int size);
+
+
+#define LACKS_UNISTD_H
+#define LACKS_FCNTL_H
+#define LACKS_SYS_PARAM_H
+#define stderr 0
+#define HAVE_MORECORE 1
+#define MORECORE cheviot_sbrk
+#define MORECORE_CONTIGUOUS 0
+#define MORECORE_CANNOT_TRIM 1
+#define USE_DL_PREFIX
+#define LACKS_TIME_H
+
+#if defined(__ARMCC_VERSION)
+#define LACKS_SYS_TYPES_H
+#include <string.h>
+#endif
+
+#define HAVE_MMAP 0
+#define HAVE_MREMAP 0
+
+#define NO_MALLINFO 1
+#define NO_MALLOC_STATS 1
+
+#define DEFAULT_GRANULARITY 64
+
+/* end configuration*/
+/*
+  This is a version (aka dlmalloc) of malloc/free/realloc written by
+  Doug Lea and released to the public domain, as explained at
+  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
+  comments, complaints, performance data, etc to dl@cs.oswego.edu
+
+* Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
+   Note: There may be an updated version of this malloc obtainable at
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+         Check before installing!
+
+* Quickstart
+
+  This library is all in one file to simplify the most common usage:
+  ftp it, compile it (-O3), and link it into another program. All of
+  the compile-time options default to reasonable values for use on
+  most platforms.  You might later want to step through various
+  compile-time and dynamic tuning options.
+
+  For convenience, an include file for code using this malloc is at:
+     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.6.h
+  You don't really need this .h file unless you call functions not
+  defined in your system include files.  The .h file contains only the
+  excerpts from this file needed for using this malloc on ANSI C/C++
+  systems, so long as you haven't changed compile-time options about
+  naming and tuning parameters.  If you do, then you can create your
+  own malloc.h that does include all settings by cutting at the point
+  indicated below. Note that you may already by default be using a C
+  library containing a malloc that is based on some version of this
+  malloc (for example in linux). You might still want to use the one
+  in this file to customize settings or to avoid overheads associated
+  with library versions.
+
+* Vital statistics:
+
+  Supported pointer/size_t representation:       4 or 8 bytes
+       size_t MUST be an unsigned type of the same width as
+       pointers. (If you are using an ancient system that declares
+       size_t as a signed type, or need it to be a different width
+       than pointers, you can use a previous release of this malloc
+       (e.g. 2.7.2) supporting these.)
+
+  Alignment:                                     8 bytes (minimum)
+       This suffices for nearly all current machines and C compilers.
+       However, you can define MALLOC_ALIGNMENT to be wider than this
+       if necessary (up to 128bytes), at the expense of using more space.
+
+  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)
+                                          8 or 16 bytes (if 8byte sizes)
+       Each malloced chunk has a hidden word of overhead holding size
+       and status information, and additional cross-check word
+       if FOOTERS is defined.
+
+  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)
+                          8-byte ptrs:  32 bytes    (including overhead)
+
+       Even a request for zero bytes (i.e., malloc(0)) returns a
+       pointer to something of the minimum allocatable size.
+       The maximum overhead wastage (i.e., number of extra bytes
+       allocated than were requested in malloc) is less than or equal
+       to the minimum size, except for requests >= mmap_threshold that
+       are serviced via mmap(), where the worst case wastage is about
+       32 bytes plus the remainder from a system page (the minimal
+       mmap unit); typically 4096 or 8192 bytes.
+
+  Security: static-safe; optionally more or less
+       The "security" of malloc refers to the ability of malicious
+       code to accentuate the effects of errors (for example, freeing
+       space that is not currently malloc'ed or overwriting past the
+       ends of chunks) in code that calls malloc.  This malloc
+       guarantees not to modify any memory locations below the base of
+       heap, i.e., static variables, even in the presence of usage
+       errors.  The routines additionally detect most improper frees
+       and reallocs.  All this holds as long as the static bookkeeping
+       for malloc itself is not corrupted by some other means.  This
+       is only one aspect of security -- these checks do not, and
+       cannot, detect all possible programming errors.
+
+       If FOOTERS is defined nonzero, then each allocated chunk
+       carries an additional check word to verify that it was malloced
+       from its space.  These check words are the same within each
+       execution of a program using malloc, but differ across
+       executions, so externally crafted fake chunks cannot be
+       freed. This improves security by rejecting frees/reallocs that
+       could corrupt heap memory, in addition to the checks preventing
+       writes to statics that are always on.  This may further improve
+       security at the expense of time and space overhead.  (Note that
+       FOOTERS may also be worth using with MSPACES.)
+
+       By default detected errors cause the program to abort (calling
+       "abort()"). You can override this to instead proceed past
+       errors by defining PROCEED_ON_ERROR.  In this case, a bad free
+       has no effect, and a malloc that encounters a bad address
+       caused by user overwrites will ignore the bad address by
+       dropping pointers and indices to all known memory. This may
+       be appropriate for programs that should continue if at all
+       possible in the face of programming errors, although they may
+       run out of memory because dropped memory is never reclaimed.
+
+       If you don't like either of these options, you can define
+       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything
+       else. And if if you are sure that your program using malloc has
+       no errors or vulnerabilities, you can define INSECURE to 1,
+       which might (or might not) provide a small performance improvement.
+
+       It is also possible to limit the maximum total allocatable
+       space, using malloc_set_footprint_limit. This is not
+       designed as a security feature in itself (calls to set limits
+       are not screened or privileged), but may be useful as one
+       aspect of a secure implementation.
+
+  Thread-safety: NOT thread-safe unless USE_LOCKS defined non-zero
+       When USE_LOCKS is defined, each public call to malloc, free,
+       etc is surrounded with a lock. By default, this uses a plain
+       pthread mutex, win32 critical section, or a spin-lock if if
+       available for the platform and not disabled by setting
+       USE_SPIN_LOCKS=0.  However, if USE_RECURSIVE_LOCKS is defined,
+       recursive versions are used instead (which are not required for
+       base functionality but may be needed in layered extensions).
+       Using a global lock is not especially fast, and can be a major
+       bottleneck.  It is designed only to provide minimal protection
+       in concurrent environments, and to provide a basis for
+       extensions.  If you are using malloc in a concurrent program,
+       consider instead using nedmalloc
+       (http://www.nedprod.com/programs/portable/nedmalloc/) or
+       ptmalloc (See http://www.malloc.de), which are derived from
+       versions of this malloc.
+
+  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP
+       This malloc can use unix sbrk or any emulation (invoked using
+       the CALL_MORECORE macro) and/or mmap/munmap or any emulation
+       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system
+       memory.  On most unix systems, it tends to work best if both
+       MORECORE and MMAP are enabled.  On Win32, it uses emulations
+       based on VirtualAlloc. It also uses common C library functions
+       like memset.
+
+  Compliance: I believe it is compliant with the Single Unix Specification
+       (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably
+       others as well.
+
+* Overview of algorithms
+
+  This is not the fastest, most space-conserving, most portable, or
+  most tunable malloc ever written. However it is among the fastest
+  while also being among the most space-conserving, portable and
+  tunable.  Consistent balance across these factors results in a good
+  general-purpose allocator for malloc-intensive programs.
+
+  In most ways, this malloc is a best-fit allocator. Generally, it
+  chooses the best-fitting existing chunk for a request, with ties
+  broken in approximately least-recently-used order. (This strategy
+  normally maintains low fragmentation.) However, for requests less
+  than 256bytes, it deviates from best-fit when there is not an
+  exactly fitting available chunk by preferring to use space adjacent
+  to that used for the previous small request, as well as by breaking
+  ties in approximately most-recently-used order. (These enhance
+  locality of series of small allocations.)  And for very large requests
+  (>= 256Kb by default), it relies on system memory mapping
+  facilities, if supported.  (This helps avoid carrying around and
+  possibly fragmenting memory used only for large chunks.)
+
+  All operations (except malloc_stats and mallinfo) have execution
+  times that are bounded by a constant factor of the number of bits in
+  a size_t, not counting any clearing in calloc or copying in realloc,
+  or actions surrounding MORECORE and MMAP that have times
+  proportional to the number of non-contiguous regions returned by
+  system allocation routines, which is often just 1. In real-time
+  applications, you can optionally suppress segment traversals using
+  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
+  system allocators return non-contiguous spaces, at the typical
+  expense of carrying around more memory and increased fragmentation.
+
+  The implementation is not very modular and seriously overuses
+  macros. Perhaps someday all C compilers will do as good a job
+  inlining modular code as can now be done by brute-force expansion,
+  but now, enough of them seem not to.
+
+  Some compilers issue a lot of warnings about code that is
+  dead/unreachable only on some platforms, and also about intentional
+  uses of negation on unsigned types. All known cases of each can be
+  ignored.
+
+  For a longer but out of date high-level description, see
+     http://gee.cs.oswego.edu/dl/html/malloc.html
+
+* MSPACES
+  If MSPACES is defined, then in addition to malloc, free, etc.,
+  this file also defines mspace_malloc, mspace_free, etc. These
+  are versions of malloc routines that take an "mspace" argument
+  obtained using create_mspace, to control all internal bookkeeping.
+  If ONLY_MSPACES is defined, only these versions are compiled.
+  So if you would like to use this allocator for only some allocations,
+  and your system malloc for others, you can compile with
+  ONLY_MSPACES and then do something like...
+    static mspace mymspace = create_mspace(0,0); // for example
+    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)
+
+  (Note: If you only need one instance of an mspace, you can instead
+  use "USE_DL_PREFIX" to relabel the global malloc.)
+
+  You can similarly create thread-local allocators by storing
+  mspaces as thread-locals. For example:
+    static __thread mspace tlms = 0;
+    void*  tlmalloc(size_t bytes) {
+      if (tlms == 0) tlms = create_mspace(0, 0);
+      return mspace_malloc(tlms, bytes);
+    }
+    void  tlfree(void* mem) { mspace_free(tlms, mem); }
+
+  Unless FOOTERS is defined, each mspace is completely independent.
+  You cannot allocate from one and free to another (although
+  conformance is only weakly checked, so usage errors are not always
+  caught). If FOOTERS is defined, then each chunk carries around a tag
+  indicating its originating mspace, and frees are directed to their
+  originating spaces. Normally, this requires use of locks.
+
+ -------------------------  Compile-time options ---------------------------
+
+Be careful in setting #define values for numerical constants of type
+size_t. On some systems, literal values are not automatically extended
+to size_t precision unless they are explicitly casted. You can also
+use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.
+
+WIN32                    default: defined if _WIN32 defined
+  Defining WIN32 sets up defaults for MS environment and compilers.
+  Otherwise defaults are for unix. Beware that there seem to be some
+  cases where this malloc might not be a pure drop-in replacement for
+  Win32 malloc: Random-looking failures from Win32 GDI API's (eg;
+  SetDIBits()) may be due to bugs in some video driver implementations
+  when pixel buffers are malloc()ed, and the region spans more than
+  one VirtualAlloc()ed region. Because dlmalloc uses a small (64Kb)
+  default granularity, pixel buffers may straddle virtual allocation
+  regions more often than when using the Microsoft allocator.  You can
+  avoid this by using VirtualAlloc() and VirtualFree() for all pixel
+  buffers rather than using malloc().  If this is not possible,
+  recompile this malloc with a larger DEFAULT_GRANULARITY. Note:
+  in cases where MSC and gcc (cygwin) are known to differ on WIN32,
+  conditions use _MSC_VER to distinguish them.
+
+DLMALLOC_EXPORT       default: extern
+  Defines how public APIs are declared. If you want to export via a
+  Windows DLL, you might define this as
+    #define DLMALLOC_EXPORT extern  __declspec(dllexport)
+  If you want a POSIX ELF shared object, you might use
+    #define DLMALLOC_EXPORT extern __attribute__((visibility("default")))
+
+MALLOC_ALIGNMENT         default: (size_t)(2 * sizeof(void *))
+  Controls the minimum alignment for malloc'ed chunks.  It must be a
+  power of two and at least 8, even on machines for which smaller
+  alignments would suffice. It may be defined as larger than this
+  though. Note however that code and data structures are optimized for
+  the case of 8-byte alignment.
+
+MSPACES                  default: 0 (false)
+  If true, compile in support for independent allocation spaces.
+  This is only supported if HAVE_MMAP is true.
+
+ONLY_MSPACES             default: 0 (false)
+  If true, only compile in mspace versions, not regular versions.
+
+USE_LOCKS                default: 0 (false)
+  Causes each call to each public routine to be surrounded with
+  pthread or WIN32 mutex lock/unlock. (If set true, this can be
+  overridden on a per-mspace basis for mspace versions.) If set to a
+  non-zero value other than 1, locks are used, but their
+  implementation is left out, so lock functions must be supplied manually,
+  as described below.
+
+USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and spin locks available
+  If true, uses custom spin locks for locking. This is currently
+  supported only gcc >= 4.1, older gccs on x86 platforms, and recent
+  MS compilers.  Otherwise, posix locks or win32 critical sections are
+  used.
+
+USE_RECURSIVE_LOCKS      default: not defined
+  If defined nonzero, uses recursive (aka reentrant) locks, otherwise
+  uses plain mutexes. This is not required for malloc proper, but may
+  be needed for layered allocators such as nedmalloc.
+
+LOCK_AT_FORK            default: not defined
+  If defined nonzero, performs pthread_atfork upon initialization
+  to initialize child lock while holding parent lock. The implementation
+  assumes that pthread locks (not custom locks) are being used. In other
+  cases, you may need to customize the implementation.
+
+FOOTERS                  default: 0
+  If true, provide extra checking and dispatching by placing
+  information in the footers of allocated chunks. This adds
+  space and time overhead.
+
+INSECURE                 default: 0
+  If true, omit checks for usage errors and heap space overwrites.
+
+USE_DL_PREFIX            default: NOT defined
+  Causes compiler to prefix all public routines with the string 'dl'.
+  This can be useful when you only want to use this malloc in one part
+  of a program, using your regular system malloc elsewhere.
+
+MALLOC_INSPECT_ALL       default: NOT defined
+  If defined, compiles malloc_inspect_all and mspace_inspect_all, that
+  perform traversal of all heap space.  Unless access to these
+  functions is otherwise restricted, you probably do not want to
+  include them in secure implementations.
+
+ABORT                    default: defined as abort()
+  Defines how to abort on failed checks.  On most systems, a failed
+  check cannot die with an "assert" or even print an informative
+  message, because the underlying print routines in turn call malloc,
+  which will fail again.  Generally, the best policy is to simply call
+  abort(). It's not very useful to do more than this because many
+  errors due to overwriting will show up as address faults (null, odd
+  addresses etc) rather than malloc-triggered checks, so will also
+  abort.  Also, most compilers know that abort() does not return, so
+  can better optimize code conditionally calling it.
+
+PROCEED_ON_ERROR           default: defined as 0 (false)
+  Controls whether detected bad addresses cause them to bypassed
+  rather than aborting. If set, detected bad arguments to free and
+  realloc are ignored. And all bookkeeping information is zeroed out
+  upon a detected overwrite of freed heap space, thus losing the
+  ability to ever return it from malloc again, but enabling the
+  application to proceed. If PROCEED_ON_ERROR is defined, the
+  static variable malloc_corruption_error_count is compiled in
+  and can be examined to see if errors have occurred. This option
+  generates slower code than the default abort policy.
+
+DEBUG                    default: NOT defined
+  The DEBUG setting is mainly intended for people trying to modify
+  this code or diagnose problems when porting to new platforms.
+  However, it may also be able to better isolate user errors than just
+  using runtime checks.  The assertions in the check routines spell
+  out in more detail the assumptions and invariants underlying the
+  algorithms.  The checking is fairly extensive, and will slow down
+  execution noticeably. Calling malloc_stats or mallinfo with DEBUG
+  set will attempt to check every non-mmapped allocated and free chunk
+  in the course of computing the summaries.
+
+ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)
+  Debugging assertion failures can be nearly impossible if your
+  version of the assert macro causes malloc to be called, which will
+  lead to a cascade of further failures, blowing the runtime stack.
+  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),
+  which will usually make debugging easier.
+
+MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32
+  The action to take before "return 0" when malloc fails to be able to
+  return memory because there is none available.
+
+HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES
+  True if this system supports sbrk or an emulation of it.
+
+MORECORE                  default: sbrk
+  The name of the sbrk-style system routine to call to obtain more
+  memory.  See below for guidance on writing custom MORECORE
+  functions. The type of the argument to sbrk/MORECORE varies across
+  systems.  It cannot be size_t, because it supports negative
+  arguments, so it is normally the signed type of the same width as
+  size_t (sometimes declared as "intptr_t").  It doesn't much matter
+  though. Internally, we only call it with arguments less than half
+  the max value of a size_t, which should work across all reasonable
+  possibilities, although sometimes generating compiler warnings.
+
+MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
+  If true, take advantage of fact that consecutive calls to MORECORE
+  with positive arguments always return contiguous increasing
+  addresses.  This is true of unix sbrk. It does not hurt too much to
+  set it true anyway, since malloc copes with non-contiguities.
+  Setting it false when definitely non-contiguous saves time
+  and possibly wasted space it would take to discover this though.
+
+MORECORE_CANNOT_TRIM      default: NOT defined
+  True if MORECORE cannot release space back to the system when given
+  negative arguments. This is generally necessary only if you are
+  using a hand-crafted MORECORE function that cannot handle negative
+  arguments.
+
+NO_SEGMENT_TRAVERSAL       default: 0
+  If non-zero, suppresses traversals of memory segments
+  returned by either MORECORE or CALL_MMAP. This disables
+  merging of segments that are contiguous, and selectively
+  releasing them to the OS if unused, but bounds execution times.
+
+HAVE_MMAP                 default: 1 (true)
+  True if this system supports mmap or an emulation of it.  If so, and
+  HAVE_MORECORE is not true, MMAP is used for all system
+  allocation. If set and HAVE_MORECORE is true as well, MMAP is
+  primarily used to directly allocate very large blocks. It is also
+  used as a backup strategy in cases where MORECORE fails to provide
+  space from system. Note: A single call to MUNMAP is assumed to be
+  able to unmap memory that may have be allocated using multiple calls
+  to MMAP, so long as they are adjacent.
+
+HAVE_MREMAP               default: 1 on linux, else 0
+  If true realloc() uses mremap() to re-allocate large blocks and
+  extend or shrink allocation spaces.
+
+MMAP_CLEARS               default: 1 except on WINCE.
+  True if mmap clears memory so calloc doesn't need to. This is true
+  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.
+
+USE_BUILTIN_FFS            default: 0 (i.e., not used)
+  Causes malloc to use the builtin ffs() function to compute indices.
+  Some compilers may recognize and intrinsify ffs to be faster than the
+  supplied C version. Also, the case of x86 using gcc is special-cased
+  to an asm instruction, so is already as fast as it can be, and so
+  this setting has no effect. Similarly for Win32 under recent MS compilers.
+  (On most x86s, the asm version is only slightly faster than the C version.)
+
+malloc_getpagesize         default: derive from system includes, or 4096.
+  The system page size. To the extent possible, this malloc manages
+  memory from the system in page-size units.  This may be (and
+  usually is) a function rather than a constant. This is ignored
+  if WIN32, where page size is determined using getSystemInfo during
+  initialization.
+
+USE_DEV_RANDOM             default: 0 (i.e., not used)
+  Causes malloc to use /dev/random to initialize secure magic seed for
+  stamping footers. Otherwise, the current time is used.
+
+NO_MALLINFO                default: 0
+  If defined, don't compile "mallinfo". This can be a simple way
+  of dealing with mismatches between system declarations and
+  those in this file.
+
+MALLINFO_FIELD_TYPE        default: size_t
+  The type of the fields in the mallinfo struct. This was originally
+  defined as "int" in SVID etc, but is more usefully defined as
+  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set
+
+NO_MALLOC_STATS            default: 0
+  If defined, don't compile "malloc_stats". This avoids calls to
+  fprintf and bringing in stdio dependencies you might not want.
+
+REALLOC_ZERO_BYTES_FREES    default: not defined
+  This should be set if a call to realloc with zero bytes should
+  be the same as a call to free. Some people think it should. Otherwise,
+  since this malloc returns a unique pointer for malloc(0), so does
+  realloc(p, 0).
+
+LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H
+LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H
+LACKS_STDLIB_H LACKS_SCHED_H LACKS_TIME_H  default: NOT defined unless on WIN32
+  Define these if your system does not have these header files.
+  You might need to manually insert some of the declarations they provide.
+
+DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,
+                                system_info.dwAllocationGranularity in WIN32,
+                                otherwise 64K.
+      Also settable using mallopt(M_GRANULARITY, x)
+  The unit for allocating and deallocating memory from the system.  On
+  most systems with contiguous MORECORE, there is no reason to
+  make this more than a page. However, systems with MMAP tend to
+  either require or encourage larger granularities.  You can increase
+  this value to prevent system allocation functions to be called so
+  often, especially if they are slow.  The value must be at least one
+  page and must be a power of two.  Setting to 0 causes initialization
+  to either page size or win32 region size.  (Note: In previous
+  versions of malloc, the equivalent of this option was called
+  "TOP_PAD")
+
+DEFAULT_TRIM_THRESHOLD    default: 2MB
+      Also settable using mallopt(M_TRIM_THRESHOLD, x)
+  The maximum amount of unused top-most memory to keep before
+  releasing via malloc_trim in free().  Automatic trimming is mainly
+  useful in long-lived programs using contiguous MORECORE.  Because
+  trimming via sbrk can be slow on some systems, and can sometimes be
+  wasteful (in cases where programs immediately afterward allocate
+  more large chunks) the value should be high enough so that your
+  overall system performance would improve by releasing this much
+  memory.  As a rough guide, you might set to a value close to the
+  average size of a process (program) running on your system.
+  Releasing this much memory would allow such a process to run in
+  memory.  Generally, it is worth tuning trim thresholds when a
+  program undergoes phases where several large chunks are allocated
+  and released in ways that can reuse each other's storage, perhaps
+  mixed with phases where there are no such chunks at all. The trim
+  value must be greater than page size to have any useful effect.  To
+  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
+  some people use of mallocing a huge space and then freeing it at
+  program startup, in an attempt to reserve system memory, doesn't
+  have the intended effect under automatic trimming, since that memory
+  will immediately be returned to the system.
+
+DEFAULT_MMAP_THRESHOLD       default: 256K
+      Also settable using mallopt(M_MMAP_THRESHOLD, x)
+  The request size threshold for using MMAP to directly service a
+  request. Requests of at least this size that cannot be allocated
+  using already-existing space will be serviced via mmap.  (If enough
+  normal freed space already exists it is used instead.)  Using mmap
+  segregates relatively large chunks of memory so that they can be
+  individually obtained and released from the host system. A request
+  serviced through mmap is never reused by any other request (at least
+  not directly; the system may just so happen to remap successive
+  requests to the same locations).  Segregating space in this way has
+  the benefits that: Mmapped space can always be individually released
+  back to the system, which helps keep the system level memory demands
+  of a long-lived program low.  Also, mapped memory doesn't become
+  `locked' between other chunks, as can happen with normally allocated
+  chunks, which means that even trimming via malloc_trim would not
+  release them.  However, it has the disadvantage that the space
+  cannot be reclaimed, consolidated, and then used to service later
+  requests, as happens with normal chunks.  The advantages of mmap
+  nearly always outweigh disadvantages for "large" chunks, but the
+  value of "large" may vary across systems.  The default is an
+  empirically derived value that works well in most systems. You can
+  disable mmap by setting to MAX_SIZE_T.
+
+MAX_RELEASE_CHECK_RATE   default: 4095 unless not HAVE_MMAP
+  The number of consolidated frees between checks to release
+  unused segments when freeing. When using non-contiguous segments,
+  especially with multiple mspaces, checking only for topmost space
+  doesn't always suffice to trigger trimming. To compensate for this,
+  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
+  current number of segments, if greater) try to release unused
+  segments to the OS when freeing chunks that result in
+  consolidation. The best value for this parameter is a compromise
+  between slowing down frees with relatively costly checks that
+  rarely trigger versus holding on to unused memory. To effectively
+  disable, set to MAX_SIZE_T. This may lead to a very slight speed
+  improvement at the expense of carrying around more memory.
+*/
+
+/* Version identifier to allow people to support multiple versions */
+#ifndef DLMALLOC_VERSION
+#define DLMALLOC_VERSION 20806
+#endif /* DLMALLOC_VERSION */
+
+#ifndef DLMALLOC_EXPORT
+#define DLMALLOC_EXPORT extern
+#endif
+
+#ifndef WIN32
+#ifdef _WIN32
+#define WIN32 1
+#endif  /* _WIN32 */
+#ifdef _WIN32_WCE
+#define LACKS_FCNTL_H
+#define WIN32 1
+#endif /* _WIN32_WCE */
+#endif  /* WIN32 */
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <tchar.h>
+#define HAVE_MMAP 1
+#define HAVE_MORECORE 0
+#define LACKS_UNISTD_H
+#define LACKS_SYS_PARAM_H
+#define LACKS_SYS_MMAN_H
+#define LACKS_STRING_H
+#define LACKS_STRINGS_H
+#define LACKS_SYS_TYPES_H
+#define LACKS_ERRNO_H
+#define LACKS_SCHED_H
+#ifndef MALLOC_FAILURE_ACTION
+#define MALLOC_FAILURE_ACTION
+#endif /* MALLOC_FAILURE_ACTION */
+#ifndef MMAP_CLEARS
+#ifdef _WIN32_WCE /* WINCE reportedly does not clear */
+#define MMAP_CLEARS 0
+#else
+#define MMAP_CLEARS 1
+#endif /* _WIN32_WCE */
+#endif /*MMAP_CLEARS */
+#endif  /* WIN32 */
+
+#if defined(DARWIN) || defined(_DARWIN)
+/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
+#ifndef HAVE_MORECORE
+#define HAVE_MORECORE 0
+#define HAVE_MMAP 1
+/* OSX allocators provide 16 byte alignment */
+#ifndef MALLOC_ALIGNMENT
+#define MALLOC_ALIGNMENT ((size_t)16U)
+#endif
+#endif  /* HAVE_MORECORE */
+#endif  /* DARWIN */
+
+#ifndef LACKS_SYS_TYPES_H
+#include <sys/types.h>  /* For size_t */
+#endif  /* LACKS_SYS_TYPES_H */
+
+/* The maximum possible size_t value has all bits set */
+#define MAX_SIZE_T           (~(size_t)0)
+
+#ifndef USE_LOCKS /* ensure true if spin or recursive locks set */
+#define USE_LOCKS  ((defined(USE_SPIN_LOCKS) && USE_SPIN_LOCKS != 0) || \
+                    (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0))
+#endif /* USE_LOCKS */
+
+#if USE_LOCKS /* Spin locks for gcc >= 4.1, older gcc on x86, MSC >= 1310 */
+#if ((defined(__GNUC__) &&                                              \
+      ((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) ||      \
+       defined(__i386__) || defined(__x86_64__))) ||                    \
+     (defined(_MSC_VER) && _MSC_VER>=1310))
+#ifndef USE_SPIN_LOCKS
+#define USE_SPIN_LOCKS 1
+#endif /* USE_SPIN_LOCKS */
+#elif USE_SPIN_LOCKS
+#error "USE_SPIN_LOCKS defined without implementation"
+#endif /* ... locks available... */
+#elif !defined(USE_SPIN_LOCKS)
+#define USE_SPIN_LOCKS 0
+#endif /* USE_LOCKS */
+
+#ifndef ONLY_MSPACES
+#define ONLY_MSPACES 0
+#endif  /* ONLY_MSPACES */
+#ifndef MSPACES
+#if ONLY_MSPACES
+#define MSPACES 1
+#else   /* ONLY_MSPACES */
+#define MSPACES 0
+#endif  /* ONLY_MSPACES */
+#endif  /* MSPACES */
+#ifndef MALLOC_ALIGNMENT
+#define MALLOC_ALIGNMENT ((size_t)(2 * sizeof(void *)))
+#endif  /* MALLOC_ALIGNMENT */
+#ifndef FOOTERS
+#define FOOTERS 0
+#endif  /* FOOTERS */
+#ifndef ABORT
+#define ABORT  abort()
+#endif  /* ABORT */
+#ifndef ABORT_ON_ASSERT_FAILURE
+#define ABORT_ON_ASSERT_FAILURE 1
+#endif  /* ABORT_ON_ASSERT_FAILURE */
+#ifndef PROCEED_ON_ERROR
+#define PROCEED_ON_ERROR 0
+#endif  /* PROCEED_ON_ERROR */
+
+#ifndef INSECURE
+#define INSECURE 0
+#endif  /* INSECURE */
+#ifndef MALLOC_INSPECT_ALL
+#define MALLOC_INSPECT_ALL 0
+#endif  /* MALLOC_INSPECT_ALL */
+#ifndef HAVE_MMAP
+#define HAVE_MMAP 1
+#endif  /* HAVE_MMAP */
+#ifndef MMAP_CLEARS
+#define MMAP_CLEARS 1
+#endif  /* MMAP_CLEARS */
+#ifndef HAVE_MREMAP
+#ifdef linux
+#define HAVE_MREMAP 1
+#define _GNU_SOURCE /* Turns on mremap() definition */
+#else   /* linux */
+#define HAVE_MREMAP 0
+#endif  /* linux */
+#endif  /* HAVE_MREMAP */
+#ifndef MALLOC_FAILURE_ACTION
+#define MALLOC_FAILURE_ACTION  errno = ENOMEM;
+#endif  /* MALLOC_FAILURE_ACTION */
+#ifndef HAVE_MORECORE
+#if ONLY_MSPACES
+#define HAVE_MORECORE 0
+#else   /* ONLY_MSPACES */
+#define HAVE_MORECORE 1
+#endif  /* ONLY_MSPACES */
+#endif  /* HAVE_MORECORE */
+#if !HAVE_MORECORE
+#define MORECORE_CONTIGUOUS 0
+#else   /* !HAVE_MORECORE */
+#define MORECORE_DEFAULT sbrk
+#ifndef MORECORE_CONTIGUOUS
+#define MORECORE_CONTIGUOUS 1
+#endif  /* MORECORE_CONTIGUOUS */
+#endif  /* HAVE_MORECORE */
+#ifndef DEFAULT_GRANULARITY
+#if (MORECORE_CONTIGUOUS || defined(WIN32))
+#define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */
+#else   /* MORECORE_CONTIGUOUS */
+#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
+#endif  /* MORECORE_CONTIGUOUS */
+#endif  /* DEFAULT_GRANULARITY */
+#ifndef DEFAULT_TRIM_THRESHOLD
+#ifndef MORECORE_CANNOT_TRIM
+#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
+#else   /* MORECORE_CANNOT_TRIM */
+#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
+#endif  /* MORECORE_CANNOT_TRIM */
+#endif  /* DEFAULT_TRIM_THRESHOLD */
+#ifndef DEFAULT_MMAP_THRESHOLD
+#if HAVE_MMAP
+#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
+#else   /* HAVE_MMAP */
+#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
+#endif  /* HAVE_MMAP */
+#endif  /* DEFAULT_MMAP_THRESHOLD */
+#ifndef MAX_RELEASE_CHECK_RATE
+#if HAVE_MMAP
+#define MAX_RELEASE_CHECK_RATE 4095
+#else
+#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
+#endif /* HAVE_MMAP */
+#endif /* MAX_RELEASE_CHECK_RATE */
+#ifndef USE_BUILTIN_FFS
+#define USE_BUILTIN_FFS 0
+#endif  /* USE_BUILTIN_FFS */
+#ifndef USE_DEV_RANDOM
+#define USE_DEV_RANDOM 0
+#endif  /* USE_DEV_RANDOM */
+#ifndef NO_MALLINFO
+#define NO_MALLINFO 0
+#endif  /* NO_MALLINFO */
+#ifndef MALLINFO_FIELD_TYPE
+#define MALLINFO_FIELD_TYPE size_t
+#endif  /* MALLINFO_FIELD_TYPE */
+#ifndef NO_MALLOC_STATS
+#define NO_MALLOC_STATS 0
+#endif  /* NO_MALLOC_STATS */
+#ifndef NO_SEGMENT_TRAVERSAL
+#define NO_SEGMENT_TRAVERSAL 0
+#endif /* NO_SEGMENT_TRAVERSAL */
+
+/*
+  mallopt tuning options.  SVID/XPG defines four standard parameter
+  numbers for mallopt, normally defined in malloc.h.  None of these
+  are used in this malloc, so setting them has no effect. But this
+  malloc does support the following options.
+*/
+
+#define M_TRIM_THRESHOLD     (-1)
+#define M_GRANULARITY        (-2)
+#define M_MMAP_THRESHOLD     (-3)
+
+/* ------------------------ Mallinfo declarations ------------------------ */
+
+#if !NO_MALLINFO
+/*
+  This version of malloc supports the standard SVID/XPG mallinfo
+  routine that returns a struct containing usage properties and
+  statistics. It should work on any system that has a
+  /usr/include/malloc.h defining struct mallinfo.  The main
+  declaration needed is the mallinfo struct that is returned (by-copy)
+  by mallinfo().  The malloinfo struct contains a bunch of fields that
+  are not even meaningful in this version of malloc.  These fields are
+  are instead filled by mallinfo() with other numbers that might be of
+  interest.
+
+  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
+  /usr/include/malloc.h file that includes a declaration of struct
+  mallinfo.  If so, it is included; else a compliant version is
+  declared below.  These must be precisely the same for mallinfo() to
+  work.  The original SVID version of this struct, defined on most
+  systems with mallinfo, declares all fields as ints. But some others
+  define as unsigned long. If your system defines the fields using a
+  type of different width than listed here, you MUST #include your
+  system version and #define HAVE_USR_INCLUDE_MALLOC_H.
+*/
+
+/* #define HAVE_USR_INCLUDE_MALLOC_H */
+
+#ifdef HAVE_USR_INCLUDE_MALLOC_H
+#include "/usr/include/malloc.h"
+#else /* HAVE_USR_INCLUDE_MALLOC_H */
+#ifndef STRUCT_MALLINFO_DECLARED
+/* HP-UX (and others?) redefines mallinfo unless _STRUCT_MALLINFO is defined */
+#define _STRUCT_MALLINFO
+#define STRUCT_MALLINFO_DECLARED 1
+struct mallinfo {
+  MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */
+  MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */
+  MALLINFO_FIELD_TYPE smblks;   /* always 0 */
+  MALLINFO_FIELD_TYPE hblks;    /* always 0 */
+  MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */
+  MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */
+  MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */
+  MALLINFO_FIELD_TYPE uordblks; /* total allocated space */
+  MALLINFO_FIELD_TYPE fordblks; /* total free space */
+  MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */
+};
+#endif /* STRUCT_MALLINFO_DECLARED */
+#endif /* HAVE_USR_INCLUDE_MALLOC_H */
+#endif /* NO_MALLINFO */
+
+/*
+  Try to persuade compilers to inline. The most critical functions for
+  inlining are defined as macros, so these aren't used for them.
+*/
+
+#ifndef FORCEINLINE
+  #if defined(__GNUC__)
+#define FORCEINLINE __inline __attribute__ ((always_inline))
+  #elif defined(_MSC_VER)
+    #define FORCEINLINE __forceinline
+  #endif
+#endif
+#ifndef NOINLINE
+  #if defined(__GNUC__)
+    #define NOINLINE __attribute__ ((noinline))
+  #elif defined(_MSC_VER)
+    #define NOINLINE __declspec(noinline)
+  #else
+    #define NOINLINE
+  #endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#ifndef FORCEINLINE
+ #define FORCEINLINE inline
+#endif
+#endif /* __cplusplus */
+#ifndef FORCEINLINE
+ #define FORCEINLINE
+#endif
+
+#if !ONLY_MSPACES
+
+/* ------------------- Declarations of public routines ------------------- */
+
+#ifndef USE_DL_PREFIX
+#define dlcalloc               calloc
+#define dlfree                 free
+#define dlmalloc               malloc
+#define dlmemalign             memalign
+#define dlposix_memalign       posix_memalign
+#define dlrealloc              realloc
+#define dlrealloc_in_place     realloc_in_place
+#define dlvalloc               valloc
+#define dlpvalloc              pvalloc
+#define dlmallinfo             mallinfo
+#define dlmallopt              mallopt
+#define dlmalloc_trim          malloc_trim
+#define dlmalloc_stats         malloc_stats
+#define dlmalloc_usable_size   malloc_usable_size
+#define dlmalloc_footprint     malloc_footprint
+#define dlmalloc_max_footprint malloc_max_footprint
+#define dlmalloc_footprint_limit malloc_footprint_limit
+#define dlmalloc_set_footprint_limit malloc_set_footprint_limit
+#define dlmalloc_inspect_all   malloc_inspect_all
+#define dlindependent_calloc   independent_calloc
+#define dlindependent_comalloc independent_comalloc
+#define dlbulk_free            bulk_free
+#endif /* USE_DL_PREFIX */
+
+/*
+  malloc(size_t n)
+  Returns a pointer to a newly allocated chunk of at least n bytes, or
+  null if no space is available, in which case errno is set to ENOMEM
+  on ANSI C systems.
+
+  If n is zero, malloc returns a minimum-sized chunk. (The minimum
+  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
+  systems.)  Note that size_t is an unsigned type, so calls with
+  arguments that would be negative if signed are interpreted as
+  requests for huge amounts of space, which will often fail. The
+  maximum supported value of n differs across systems, but is in all
+  cases less than the maximum representable value of a size_t.
+*/
+DLMALLOC_EXPORT void* dlmalloc(size_t);
+
+/*
+  free(void* p)
+  Releases the chunk of memory pointed to by p, that had been previously
+  allocated using malloc or a related routine such as realloc.
+  It has no effect if p is null. If p was not malloced or already
+  freed, free(p) will by default cause the current program to abort.
+*/
+DLMALLOC_EXPORT void  dlfree(void*);
+
+/*
+  calloc(size_t n_elements, size_t element_size);
+  Returns a pointer to n_elements * element_size bytes, with all locations
+  set to zero.
+*/
+DLMALLOC_EXPORT void* dlcalloc(size_t, size_t);
+
+/*
+  realloc(void* p, size_t n)
+  Returns a pointer to a chunk of size n that contains the same data
+  as does chunk p up to the minimum of (n, p's size) bytes, or null
+  if no space is available.
+
+  The returned pointer may or may not be the same as p. The algorithm
+  prefers extending p in most cases when possible, otherwise it
+  employs the equivalent of a malloc-copy-free sequence.
+
+  If p is null, realloc is equivalent to malloc.
+
+  If space is not available, realloc returns null, errno is set (if on
+  ANSI) and p is NOT freed.
+
+  if n is for fewer bytes than already held by p, the newly unused
+  space is lopped off and freed if possible.  realloc with a size
+  argument of zero (re)allocates a minimum-sized chunk.
+
+  The old unix realloc convention of allowing the last-free'd chunk
+  to be used as an argument to realloc is not supported.
+*/
+DLMALLOC_EXPORT void* dlrealloc(void*, size_t);
+
+/*
+  realloc_in_place(void* p, size_t n)
+  Resizes the space allocated for p to size n, only if this can be
+  done without moving p (i.e., only if there is adjacent space
+  available if n is greater than p's current allocated size, or n is
+  less than or equal to p's size). This may be used instead of plain
+  realloc if an alternative allocation strategy is needed upon failure
+  to expand space; for example, reallocation of a buffer that must be
+  memory-aligned or cleared. You can use realloc_in_place to trigger
+  these alternatives only when needed.
+
+  Returns p if successful; otherwise null.
+*/
+DLMALLOC_EXPORT void* dlrealloc_in_place(void*, size_t);
+
+/*
+  memalign(size_t alignment, size_t n);
+  Returns a pointer to a newly allocated chunk of n bytes, aligned
+  in accord with the alignment argument.
+
+  The alignment argument should be a power of two. If the argument is
+  not a power of two, the nearest greater power is used.
+  8-byte alignment is guaranteed by normal malloc calls, so don't
+  bother calling memalign with an argument of 8 or less.
+
+  Overreliance on memalign is a sure way to fragment space.
+*/
+DLMALLOC_EXPORT void* dlmemalign(size_t, size_t);
+
+/*
+  int posix_memalign(void** pp, size_t alignment, size_t n);
+  Allocates a chunk of n bytes, aligned in accord with the alignment
+  argument. Differs from memalign only in that it (1) assigns the
+  allocated memory to *pp rather than returning it, (2) fails and
+  returns EINVAL if the alignment is not a power of two (3) fails and
+  returns ENOMEM if memory cannot be allocated.
+*/
+DLMALLOC_EXPORT int dlposix_memalign(void**, size_t, size_t);
+
+/*
+  valloc(size_t n);
+  Equivalent to memalign(pagesize, n), where pagesize is the page
+  size of the system. If the pagesize is unknown, 4096 is used.
+*/
+DLMALLOC_EXPORT void* dlvalloc(size_t);
+
+/*
+  mallopt(int parameter_number, int parameter_value)
+  Sets tunable parameters The format is to provide a
+  (parameter-number, parameter-value) pair.  mallopt then sets the
+  corresponding parameter to the argument value if it can (i.e., so
+  long as the value is meaningful), and returns 1 if successful else
+  0.  To workaround the fact that mallopt is specified to use int,
+  not size_t parameters, the value -1 is specially treated as the
+  maximum unsigned size_t value.
+
+  SVID/XPG/ANSI defines four standard param numbers for mallopt,
+  normally defined in malloc.h.  None of these are use in this malloc,
+  so setting them has no effect. But this malloc also supports other
+  options in mallopt. See below for details.  Briefly, supported
+  parameters are as follows (listed defaults are for "typical"
+  configurations).
+
+  Symbol            param #  default    allowed param values
+  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1 disables)
+  M_GRANULARITY        -2     page size   any power of 2 >= page size
+  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
+*/
+DLMALLOC_EXPORT int dlmallopt(int, int);
+
+/*
+  malloc_footprint();
+  Returns the number of bytes obtained from the system.  The total
+  number of bytes allocated by malloc, realloc etc., is less than this
+  value. Unlike mallinfo, this function returns only a precomputed
+  result, so can be called frequently to monitor memory consumption.
+  Even if locks are otherwise defined, this function does not use them,
+  so results might not be up to date.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_footprint(void);
+
+/*
+  malloc_max_footprint();
+  Returns the maximum number of bytes obtained from the system. This
+  value will be greater than current footprint if deallocated space
+  has been reclaimed by the system. The peak number of bytes allocated
+  by malloc, realloc etc., is less than this value. Unlike mallinfo,
+  this function returns only a precomputed result, so can be called
+  frequently to monitor memory consumption.  Even if locks are
+  otherwise defined, this function does not use them, so results might
+  not be up to date.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_max_footprint(void);
+
+/*
+  malloc_footprint_limit();
+  Returns the number of bytes that the heap is allowed to obtain from
+  the system, returning the last value returned by
+  malloc_set_footprint_limit, or the maximum size_t value if
+  never set. The returned value reflects a permission. There is no
+  guarantee that this number of bytes can actually be obtained from
+  the system.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_footprint_limit(void);
+
+/*
+  malloc_set_footprint_limit();
+  Sets the maximum number of bytes to obtain from the system, causing
+  failure returns from malloc and related functions upon attempts to
+  exceed this value. The argument value may be subject to page
+  rounding to an enforceable limit; this actual value is returned.
+  Using an argument of the maximum possible size_t effectively
+  disables checks. If the argument is less than or equal to the
+  current malloc_footprint, then all future allocations that require
+  additional system memory will fail. However, invocation cannot
+  retroactively deallocate existing used memory.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_set_footprint_limit(size_t bytes);
+
+#if MALLOC_INSPECT_ALL
+/*
+  malloc_inspect_all(void(*handler)(void *start,
+                                    void *end,
+                                    size_t used_bytes,
+                                    void* callback_arg),
+                      void* arg);
+  Traverses the heap and calls the given handler for each managed
+  region, skipping all bytes that are (or may be) used for bookkeeping
+  purposes.  Traversal does not include include chunks that have been
+  directly memory mapped. Each reported region begins at the start
+  address, and continues up to but not including the end address.  The
+  first used_bytes of the region contain allocated data. If
+  used_bytes is zero, the region is unallocated. The handler is
+  invoked with the given callback argument. If locks are defined, they
+  are held during the entire traversal. It is a bad idea to invoke
+  other malloc functions from within the handler.
+
+  For example, to count the number of in-use chunks with size greater
+  than 1000, you could write:
+  static int count = 0;
+  void count_chunks(void* start, void* end, size_t used, void* arg) {
+    if (used >= 1000) ++count;
+  }
+  then:
+    malloc_inspect_all(count_chunks, NULL);
+
+  malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.
+*/
+DLMALLOC_EXPORT void dlmalloc_inspect_all(void(*handler)(void*, void *, size_t, void*),
+                           void* arg);
+
+#endif /* MALLOC_INSPECT_ALL */
+
+#if !NO_MALLINFO
+/*
+  mallinfo()
+  Returns (by copy) a struct containing various summary statistics:
+
+  arena:     current total non-mmapped bytes allocated from system
+  ordblks:   the number of free chunks
+  smblks:    always zero.
+  hblks:     current number of mmapped regions
+  hblkhd:    total bytes held in mmapped regions
+  usmblks:   the maximum total allocated space. This will be greater
+                than current total if trimming has occurred.
+  fsmblks:   always zero
+  uordblks:  current total allocated space (normal or mmapped)
+  fordblks:  total free space
+  keepcost:  the maximum number of bytes that could ideally be released
+               back to system via malloc_trim. ("ideally" means that
+               it ignores page restrictions etc.)
+
+  Because these fields are ints, but internal bookkeeping may
+  be kept as longs, the reported values may wrap around zero and
+  thus be inaccurate.
+*/
+DLMALLOC_EXPORT struct mallinfo dlmallinfo(void);
+#endif /* NO_MALLINFO */
+
+/*
+  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);
+
+  independent_calloc is similar to calloc, but instead of returning a
+  single cleared space, it returns an array of pointers to n_elements
+  independent elements that can hold contents of size elem_size, each
+  of which starts out cleared, and can be independently freed,
+  realloc'ed etc. The elements are guaranteed to be adjacently
+  allocated (this is not guaranteed to occur with multiple callocs or
+  mallocs), which may also improve cache locality in some
+  applications.
+
+  The "chunks" argument is optional (i.e., may be null, which is
+  probably the most typical usage). If it is null, the returned array
+  is itself dynamically allocated and should also be freed when it is
+  no longer needed. Otherwise, the chunks array must be of at least
+  n_elements in length. It is filled in with the pointers to the
+  chunks.
+
+  In either case, independent_calloc returns this pointer array, or
+  null if the allocation failed.  If n_elements is zero and "chunks"
+  is null, it returns a chunk representing an array with zero elements
+  (which should be freed if not wanted).
+
+  Each element must be freed when it is no longer needed. This can be
+  done all at once using bulk_free.
+
+  independent_calloc simplifies and speeds up implementations of many
+  kinds of pools.  It may also be useful when constructing large data
+  structures that initially have a fixed number of fixed-sized nodes,
+  but the number is not known at compile time, and some of the nodes
+  may later need to be freed. For example:
+
+  struct Node { int item; struct Node* next; };
+
+  struct Node* build_list() {
+    struct Node** pool;
+    int n = read_number_of_nodes_needed();
+    if (n <= 0) return 0;
+    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
+    if (pool == 0) die();
+    // organize into a linked list...
+    struct Node* first = pool[0];
+    for (i = 0; i < n-1; ++i)
+      pool[i]->next = pool[i+1];
+    free(pool);     // Can now free the array (or not, if it is needed later)
+    return first;
+  }
+*/
+DLMALLOC_EXPORT void** dlindependent_calloc(size_t, size_t, void**);
+
+/*
+  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);
+
+  independent_comalloc allocates, all at once, a set of n_elements
+  chunks with sizes indicated in the "sizes" array.    It returns
+  an array of pointers to these elements, each of which can be
+  independently freed, realloc'ed etc. The elements are guaranteed to
+  be adjacently allocated (this is not guaranteed to occur with
+  multiple callocs or mallocs), which may also improve cache locality
+  in some applications.
+
+  The "chunks" argument is optional (i.e., may be null). If it is null
+  the returned array is itself dynamically allocated and should also
+  be freed when it is no longer needed. Otherwise, the chunks array
+  must be of at least n_elements in length. It is filled in with the
+  pointers to the chunks.
+
+  In either case, independent_comalloc returns this pointer array, or
+  null if the allocation failed.  If n_elements is zero and chunks is
+  null, it returns a chunk representing an array with zero elements
+  (which should be freed if not wanted).
+
+  Each element must be freed when it is no longer needed. This can be
+  done all at once using bulk_free.
+
+  independent_comallac differs from independent_calloc in that each
+  element may have a different size, and also that it does not
+  automatically clear elements.
+
+  independent_comalloc can be used to speed up allocation in cases
+  where several structs or objects must always be allocated at the
+  same time.  For example:
+
+  struct Head { ... }
+  struct Foot { ... }
+
+  void send_message(char* msg) {
+    int msglen = strlen(msg);
+    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
+    void* chunks[3];
+    if (independent_comalloc(3, sizes, chunks) == 0)
+      die();
+    struct Head* head = (struct Head*)(chunks[0]);
+    char*        body = (char*)(chunks[1]);
+    struct Foot* foot = (struct Foot*)(chunks[2]);
+    // ...
+  }
+
+  In general though, independent_comalloc is worth using only for
+  larger values of n_elements. For small values, you probably won't
+  detect enough difference from series of malloc calls to bother.
+
+  Overuse of independent_comalloc can increase overall memory usage,
+  since it cannot reuse existing noncontiguous small chunks that
+  might be available for some of the elements.
+*/
+DLMALLOC_EXPORT void** dlindependent_comalloc(size_t, size_t*, void**);
+
+/*
+  bulk_free(void* array[], size_t n_elements)
+  Frees and clears (sets to null) each non-null pointer in the given
+  array.  This is likely to be faster than freeing them one-by-one.
+  If footers are used, pointers that have been allocated in different
+  mspaces are not freed or cleared, and the count of all such pointers
+  is returned.  For large arrays of pointers with poor locality, it
+  may be worthwhile to sort this array before calling bulk_free.
+*/
+DLMALLOC_EXPORT size_t  dlbulk_free(void**, size_t n_elements);
+
+/*
+  pvalloc(size_t n);
+  Equivalent to valloc(minimum-page-that-holds(n)), that is,
+  round up n to nearest pagesize.
+ */
+DLMALLOC_EXPORT void*  dlpvalloc(size_t);
+
+/*
+  malloc_trim(size_t pad);
+
+  If possible, gives memory back to the system (via negative arguments
+  to sbrk) if there is unused memory at the `high' end of the malloc
+  pool or in unused MMAP segments. You can call this after freeing
+  large blocks of memory to potentially reduce the system-level memory
+  requirements of a program. However, it cannot guarantee to reduce
+  memory. Under some allocation patterns, some large free blocks of
+  memory will be locked between two used chunks, so they cannot be
+  given back to the system.
+
+  The `pad' argument to malloc_trim represents the amount of free
+  trailing space to leave untrimmed. If this argument is zero, only
+  the minimum amount of memory to maintain internal data structures
+  will be left. Non-zero arguments can be supplied to maintain enough
+  trailing space to service future expected allocations without having
+  to re-obtain memory from the system.
+
+  Malloc_trim returns 1 if it actually released any memory, else 0.
+*/
+DLMALLOC_EXPORT int  dlmalloc_trim(size_t);
+
+/*
+  malloc_stats();
+  Prints on stderr the amount of space obtained from the system (both
+  via sbrk and mmap), the maximum amount (which may be more than
+  current if malloc_trim and/or munmap got called), and the current
+  number of bytes allocated via malloc (or realloc, etc) but not yet
+  freed. Note that this is the number of bytes allocated, not the
+  number requested. It will be larger than the number requested
+  because of alignment and bookkeeping overhead. Because it includes
+  alignment wastage as being in use, this figure may be greater than
+  zero even when no user-level chunks are allocated.
+
+  The reported current and maximum system memory can be inaccurate if
+  a program makes other calls to system memory allocation functions
+  (normally sbrk) outside of malloc.
+
+  malloc_stats prints only the most commonly interesting statistics.
+  More information can be obtained by calling mallinfo.
+*/
+DLMALLOC_EXPORT void  dlmalloc_stats(void);
+
+/*
+  malloc_usable_size(void* p);
+
+  Returns the number of bytes you can actually use in
+  an allocated chunk, which may be more than you requested (although
+  often not) due to alignment and minimum size constraints.
+  You can use this many bytes without worrying about
+  overwriting other allocated objects. This is not a particularly great
+  programming practice. malloc_usable_size can be more useful in
+  debugging and assertions, for example:
+
+  p = malloc(n);
+  assert(malloc_usable_size(p) >= 256);
+*/
+size_t dlmalloc_usable_size(void*);
+
+#endif /* ONLY_MSPACES */
+
+#if MSPACES
+
+/*
+  mspace is an opaque type representing an independent
+  region of space that supports mspace_malloc, etc.
+*/
+typedef void* mspace;
+
+/*
+  create_mspace creates and returns a new independent space with the
+  given initial capacity, or, if 0, the default granularity size.  It
+  returns null if there is no system memory available to create the
+  space.  If argument locked is non-zero, the space uses a separate
+  lock to control access. The capacity of the space will grow
+  dynamically as needed to service mspace_malloc requests.  You can
+  control the sizes of incremental increases of this space by
+  compiling with a different DEFAULT_GRANULARITY or dynamically
+  setting with mallopt(M_GRANULARITY, value).
+*/
+DLMALLOC_EXPORT mspace create_mspace(size_t capacity, int locked);
+
+/*
+  destroy_mspace destroys the given space, and attempts to return all
+  of its memory back to the system, returning the total number of
+  bytes freed. After destruction, the results of access to all memory
+  used by the space become undefined.
+*/
+DLMALLOC_EXPORT size_t destroy_mspace(mspace msp);
+
+/*
+  create_mspace_with_base uses the memory supplied as the initial base
+  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
+  space is used for bookkeeping, so the capacity must be at least this
+  large. (Otherwise 0 is returned.) When this initial space is
+  exhausted, additional memory will be obtained from the system.
+  Destroying this space will deallocate all additionally allocated
+  space (if possible) but not the initial base.
+*/
+DLMALLOC_EXPORT mspace create_mspace_with_base(void* base, size_t capacity, int locked);
+
+/*
+  mspace_track_large_chunks controls whether requests for large chunks
+  are allocated in their own untracked mmapped regions, separate from
+  others in this mspace. By default large chunks are not tracked,
+  which reduces fragmentation. However, such chunks are not
+  necessarily released to the system upon destroy_mspace.  Enabling
+  tracking by setting to true may increase fragmentation, but avoids
+  leakage when relying on destroy_mspace to release all memory
+  allocated using this space.  The function returns the previous
+  setting.
+*/
+DLMALLOC_EXPORT int mspace_track_large_chunks(mspace msp, int enable);
+
+
+/*
+  mspace_malloc behaves as malloc, but operates within
+  the given space.
+*/
+DLMALLOC_EXPORT void* mspace_malloc(mspace msp, size_t bytes);
+
+/*
+  mspace_free behaves as free, but operates within
+  the given space.
+
+  If compiled with FOOTERS==1, mspace_free is not actually needed.
+  free may be called instead of mspace_free because freed chunks from
+  any space are handled by their originating spaces.
+*/
+DLMALLOC_EXPORT void mspace_free(mspace msp, void* mem);
+
+/*
+  mspace_realloc behaves as realloc, but operates within
+  the given space.
+
+  If compiled with FOOTERS==1, mspace_realloc is not actually
+  needed.  realloc may be called instead of mspace_realloc because
+  realloced chunks from any space are handled by their originating
+  spaces.
+*/
+DLMALLOC_EXPORT void* mspace_realloc(mspace msp, void* mem, size_t newsize);
+
+/*
+  mspace_calloc behaves as calloc, but operates within
+  the given space.
+*/
+DLMALLOC_EXPORT void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
+
+/*
+  mspace_memalign behaves as memalign, but operates within
+  the given space.
+*/
+DLMALLOC_EXPORT void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
+
+/*
+  mspace_independent_calloc behaves as independent_calloc, but
+  operates within the given space.
+*/
+DLMALLOC_EXPORT void** mspace_independent_calloc(mspace msp, size_t n_elements,
+                                 size_t elem_size, void* chunks[]);
+
+/*
+  mspace_independent_comalloc behaves as independent_comalloc, but
+  operates within the given space.
+*/
+DLMALLOC_EXPORT void** mspace_independent_comalloc(mspace msp, size_t n_elements,
+                                   size_t sizes[], void* chunks[]);
+
+/*
+  mspace_footprint() returns the number of bytes obtained from the
+  system for this space.
+*/
+DLMALLOC_EXPORT size_t mspace_footprint(mspace msp);
+
+/*
+  mspace_max_footprint() returns the peak number of bytes obtained from the
+  system for this space.
+*/
+DLMALLOC_EXPORT size_t mspace_max_footprint(mspace msp);
+
+
+#if !NO_MALLINFO
+/*
+  mspace_mallinfo behaves as mallinfo, but reports properties of
+  the given space.
+*/
+DLMALLOC_EXPORT struct mallinfo mspace_mallinfo(mspace msp);
+#endif /* NO_MALLINFO */
+
+/*
+  malloc_usable_size(void* p) behaves the same as malloc_usable_size;
+*/
+DLMALLOC_EXPORT size_t mspace_usable_size(const void* mem);
+
+/*
+  mspace_malloc_stats behaves as malloc_stats, but reports
+  properties of the given space.
+*/
+DLMALLOC_EXPORT void mspace_malloc_stats(mspace msp);
+
+/*
+  mspace_trim behaves as malloc_trim, but
+  operates within the given space.
+*/
+DLMALLOC_EXPORT int mspace_trim(mspace msp, size_t pad);
+
+/*
+  An alias for mallopt.
+*/
+DLMALLOC_EXPORT int mspace_mallopt(int, int);
+
+#endif /* MSPACES */
+
+#ifdef __cplusplus
+}  /* end of extern "C" */
+#endif /* __cplusplus */
+
+/*
+  ========================================================================
+  To make a fully customizable malloc.h header file, cut everything
+  above this line, put into file malloc.h, edit to suit, and #include it
+  on the next line, as well as in programs that use this malloc.
+  ========================================================================
+*/
+
+/* #include "malloc.h" */
+
+/*------------------------------ internal #includes ---------------------- */
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4146 ) /* no "unsigned" warnings */
+#endif /* _MSC_VER */
+#if !NO_MALLOC_STATS
+#include <stdio.h>       /* for printing in malloc_stats */
+#endif /* NO_MALLOC_STATS */
+#ifndef LACKS_ERRNO_H
+#include <errno.h>       /* for MALLOC_FAILURE_ACTION */
+#endif /* LACKS_ERRNO_H */
+#ifdef DEBUG
+#if ABORT_ON_ASSERT_FAILURE
+#undef assert
+#define assert(x) if(!(x)) ABORT
+#else /* ABORT_ON_ASSERT_FAILURE */
+#include <assert.h>
+#endif /* ABORT_ON_ASSERT_FAILURE */
+#else  /* DEBUG */
+#ifndef assert
+#define assert(x)
+#endif
+#define DEBUG 0
+#endif /* DEBUG */
+#if !defined(WIN32) && !defined(LACKS_TIME_H)
+#include <time.h>        /* for magic initialization */
+#endif /* WIN32 */
+#ifndef LACKS_STDLIB_H
+#include <stdlib.h>      /* for abort() */
+#endif /* LACKS_STDLIB_H */
+#ifndef LACKS_STRING_H
+#include <string.h>      /* for memset etc */
+#endif  /* LACKS_STRING_H */
+#if USE_BUILTIN_FFS
+#ifndef LACKS_STRINGS_H
+#include <strings.h>     /* for ffs */
+#endif /* LACKS_STRINGS_H */
+#endif /* USE_BUILTIN_FFS */
+#if HAVE_MMAP
+#ifndef LACKS_SYS_MMAN_H
+/* On some versions of linux, mremap decl in mman.h needs __USE_GNU set */
+#if (defined(linux) && !defined(__USE_GNU))
+#define __USE_GNU 1
+#include <sys/mman.h>    /* for mmap */
+#undef __USE_GNU
+#else
+#include <sys/mman.h>    /* for mmap */
+#endif /* linux */
+#endif /* LACKS_SYS_MMAN_H */
+#ifndef LACKS_FCNTL_H
+#include <fcntl.h>
+#endif /* LACKS_FCNTL_H */
+#endif /* HAVE_MMAP */
+#ifndef LACKS_UNISTD_H
+#include <unistd.h>     /* for sbrk, sysconf */
+#else /* LACKS_UNISTD_H */
+#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
+extern void*     sbrk(ptrdiff_t);
+#endif /* FreeBSD etc */
+#endif /* LACKS_UNISTD_H */
+
+/* Declarations for locking */
+#if USE_LOCKS
+#ifndef WIN32
+#if defined (__SVR4) && defined (__sun)  /* solaris */
+#include <thread.h>
+#elif !defined(LACKS_SCHED_H)
+#include <sched.h>
+#endif /* solaris or LACKS_SCHED_H */
+#if (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0) || !USE_SPIN_LOCKS
+#include <pthread.h>
+#endif /* USE_RECURSIVE_LOCKS ... */
+#elif defined(_MSC_VER)
+#ifndef _M_AMD64
+/* These are already defined on AMD64 builds */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+LONG __cdecl _InterlockedCompareExchange(LONG volatile *Dest, LONG Exchange, LONG Comp);
+LONG __cdecl _InterlockedExchange(LONG volatile *Target, LONG Value);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _M_AMD64 */
+#pragma intrinsic (_InterlockedCompareExchange)
+#pragma intrinsic (_InterlockedExchange)
+#define interlockedcompareexchange _InterlockedCompareExchange
+#define interlockedexchange _InterlockedExchange
+#elif defined(WIN32) && defined(__GNUC__)
+#define interlockedcompareexchange(a, b, c) __sync_val_compare_and_swap(a, c, b)
+#define interlockedexchange __sync_lock_test_and_set
+#endif /* Win32 */
+#else /* USE_LOCKS */
+#endif /* USE_LOCKS */
+
+#ifndef LOCK_AT_FORK
+#define LOCK_AT_FORK 0
+#endif
+
+/* Declarations for bit scanning on win32 */
+#if defined(_MSC_VER) && _MSC_VER>=1300
+#ifndef BitScanForward /* Try to avoid pulling in WinNT.h */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
+unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#define BitScanForward _BitScanForward
+#define BitScanReverse _BitScanReverse
+#pragma intrinsic(_BitScanForward)
+#pragma intrinsic(_BitScanReverse)
+#endif /* BitScanForward */
+#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */
+
+#ifndef WIN32
+#ifndef malloc_getpagesize
+#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
+#    ifndef _SC_PAGE_SIZE
+#      define _SC_PAGE_SIZE _SC_PAGESIZE
+#    endif
+#  endif
+#  ifdef _SC_PAGE_SIZE
+#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
+#  else
+#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
+       extern size_t getpagesize();
+#      define malloc_getpagesize getpagesize()
+#    else
+#      ifdef WIN32 /* use supplied emulation of getpagesize */
+#        define malloc_getpagesize getpagesize()
+#      else
+#        ifndef LACKS_SYS_PARAM_H
+#          include <sys/param.h>
+#        endif
+#        ifdef EXEC_PAGESIZE
+#          define malloc_getpagesize EXEC_PAGESIZE
+#        else
+#          ifdef NBPG
+#            ifndef CLSIZE
+#              define malloc_getpagesize NBPG
+#            else
+#              define malloc_getpagesize (NBPG * CLSIZE)
+#            endif
+#          else
+#            ifdef NBPC
+#              define malloc_getpagesize NBPC
+#            else
+#              ifdef PAGESIZE
+#                define malloc_getpagesize PAGESIZE
+#              else /* just guess */
+#                define malloc_getpagesize ((size_t)4096U)
+#              endif
+#            endif
+#          endif
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+#endif
+
+/* ------------------- size_t and alignment properties -------------------- */
+
+/* The byte and bit size of a size_t */
+#define SIZE_T_SIZE         (sizeof(size_t))
+#define SIZE_T_BITSIZE      (sizeof(size_t) << 3)
+
+/* Some constants coerced to size_t */
+/* Annoying but necessary to avoid errors on some platforms */
+#define SIZE_T_ZERO         ((size_t)0)
+#define SIZE_T_ONE          ((size_t)1)
+#define SIZE_T_TWO          ((size_t)2)
+#define SIZE_T_FOUR         ((size_t)4)
+#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)
+#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)
+#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
+#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)
+
+/* The bit mask value corresponding to MALLOC_ALIGNMENT */
+#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)
+
+/* True if address a has acceptable alignment */
+#define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)
+
+/* the number of bytes to offset an address to align it */
+#define align_offset(A)\
+ ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\
+  ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))
+
+/* -------------------------- MMAP preliminaries ------------------------- */
+
+/*
+   If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and
+   checks to fail so compiler optimizer can delete code rather than
+   using so many "#if"s.
+*/
+
+
+/* MORECORE and MMAP must return MFAIL on failure */
+#define MFAIL                ((void*)(MAX_SIZE_T))
+#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */
+
+#if HAVE_MMAP
+
+#ifndef WIN32
+#define MUNMAP_DEFAULT(a, s)  munmap((a), (s))
+#define MMAP_PROT            (PROT_READ|PROT_WRITE)
+#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
+#define MAP_ANONYMOUS        MAP_ANON
+#endif /* MAP_ANON */
+#ifdef MAP_ANONYMOUS
+#define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)
+#define MMAP_DEFAULT(s)       mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
+#else /* MAP_ANONYMOUS */
+/*
+   Nearly all versions of mmap support MAP_ANONYMOUS, so the following
+   is unlikely to be needed, but is supplied just in case.
+*/
+#define MMAP_FLAGS           (MAP_PRIVATE)
+static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
+#define MMAP_DEFAULT(s) ((dev_zero_fd < 0) ? \
+           (dev_zero_fd = open("/dev/zero", O_RDWR), \
+            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
+            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
+#endif /* MAP_ANONYMOUS */
+
+#define DIRECT_MMAP_DEFAULT(s) MMAP_DEFAULT(s)
+
+#else /* WIN32 */
+
+/* Win32 MMAP via VirtualAlloc */
+static FORCEINLINE void* win32mmap(size_t size) {
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
+  return (ptr != 0)? ptr: MFAIL;
+}
+
+/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
+static FORCEINLINE void* win32direct_mmap(size_t size) {
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
+                           PAGE_READWRITE);
+  return (ptr != 0)? ptr: MFAIL;
+}
+
+/* This function supports releasing coalesed segments */
+static FORCEINLINE int win32munmap(void* ptr, size_t size) {
+  MEMORY_BASIC_INFORMATION minfo;
+  char* cptr = (char*)ptr;
+  while (size) {
+    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)
+      return -1;
+    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
+        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
+      return -1;
+    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)
+      return -1;
+    cptr += minfo.RegionSize;
+    size -= minfo.RegionSize;
+  }
+  return 0;
+}
+
+#define MMAP_DEFAULT(s)             win32mmap(s)
+#define MUNMAP_DEFAULT(a, s)        win32munmap((a), (s))
+#define DIRECT_MMAP_DEFAULT(s)      win32direct_mmap(s)
+#endif /* WIN32 */
+#endif /* HAVE_MMAP */
+
+#if HAVE_MREMAP
+#ifndef WIN32
+#define MREMAP_DEFAULT(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
+#endif /* WIN32 */
+#endif /* HAVE_MREMAP */
+
+/**
+ * Define CALL_MORECORE
+ */
+#if HAVE_MORECORE
+    #ifdef MORECORE
+        #define CALL_MORECORE(S)    MORECORE(S)
+    #else  /* MORECORE */
+        #define CALL_MORECORE(S)    MORECORE_DEFAULT(S)
+    #endif /* MORECORE */
+#else  /* HAVE_MORECORE */
+    #define CALL_MORECORE(S)        MFAIL
+#endif /* HAVE_MORECORE */
+
+/**
+ * Define CALL_MMAP/CALL_MUNMAP/CALL_DIRECT_MMAP
+ */
+#if HAVE_MMAP
+    #define USE_MMAP_BIT            (SIZE_T_ONE)
+
+    #ifdef MMAP
+        #define CALL_MMAP(s)        MMAP(s)
+    #else /* MMAP */
+        #define CALL_MMAP(s)        MMAP_DEFAULT(s)
+    #endif /* MMAP */
+    #ifdef MUNMAP
+        #define CALL_MUNMAP(a, s)   MUNMAP((a), (s))
+    #else /* MUNMAP */
+        #define CALL_MUNMAP(a, s)   MUNMAP_DEFAULT((a), (s))
+    #endif /* MUNMAP */
+    #ifdef DIRECT_MMAP
+        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP(s)
+    #else /* DIRECT_MMAP */
+        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP_DEFAULT(s)
+    #endif /* DIRECT_MMAP */
+#else  /* HAVE_MMAP */
+    #define USE_MMAP_BIT            (SIZE_T_ZERO)
+
+    #define MMAP(s)                 MFAIL
+    #define MUNMAP(a, s)            (-1)
+    #define DIRECT_MMAP(s)          MFAIL
+    #define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
+    #define CALL_MMAP(s)            MMAP(s)
+    #define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
+#endif /* HAVE_MMAP */
+
+/**
+ * Define CALL_MREMAP
+ */
+#if HAVE_MMAP && HAVE_MREMAP
+    #ifdef MREMAP
+        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP((addr), (osz), (nsz), (mv))
+    #else /* MREMAP */
+        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP_DEFAULT((addr), (osz), (nsz), (mv))
+    #endif /* MREMAP */
+#else  /* HAVE_MMAP && HAVE_MREMAP */
+    #define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL
+#endif /* HAVE_MMAP && HAVE_MREMAP */
+
+/* mstate bit set if continguous morecore disabled or failed */
+#define USE_NONCONTIGUOUS_BIT (4U)
+
+/* segment bit set in create_mspace_with_base */
+#define EXTERN_BIT            (8U)
+
+
+/* --------------------------- Lock preliminaries ------------------------ */
+
+/*
+  When locks are defined, there is one global lock, plus
+  one per-mspace lock.
+
+  The global lock_ensures that mparams.magic and other unique
+  mparams values are initialized only once. It also protects
+  sequences of calls to MORECORE.  In many cases sys_alloc requires
+  two calls, that should not be interleaved with calls by other
+  threads.  This does not protect against direct calls to MORECORE
+  by other threads not using this lock, so there is still code to
+  cope the best we can on interference.
+
+  Per-mspace locks surround calls to malloc, free, etc.
+  By default, locks are simple non-reentrant mutexes.
+
+  Because lock-protected regions generally have bounded times, it is
+  OK to use the supplied simple spinlocks. Spinlocks are likely to
+  improve performance for lightly contended applications, but worsen
+  performance under heavy contention.
+
+  If USE_LOCKS is > 1, the definitions of lock routines here are
+  bypassed, in which case you will need to define the type MLOCK_T,
+  and at least INITIAL_LOCK, DESTROY_LOCK, ACQUIRE_LOCK, RELEASE_LOCK
+  and TRY_LOCK.  You must also declare a
+    static MLOCK_T malloc_global_mutex = { initialization values };.
+
+*/
+
+#if !USE_LOCKS
+#define USE_LOCK_BIT               (0U)
+#define INITIAL_LOCK(l)            (0)
+#define DESTROY_LOCK(l)            (0)
+#define ACQUIRE_MALLOC_GLOBAL_LOCK()
+#define RELEASE_MALLOC_GLOBAL_LOCK()
+
+#else
+#if USE_LOCKS > 1
+/* -----------------------  User-defined locks ------------------------ */
+/* Define your own lock implementation here */
+/* #define INITIAL_LOCK(lk)  ... */
+/* #define DESTROY_LOCK(lk)  ... */
+/* #define ACQUIRE_LOCK(lk)  ... */
+/* #define RELEASE_LOCK(lk)  ... */
+/* #define TRY_LOCK(lk) ... */
+/* static MLOCK_T malloc_global_mutex = ... */
+
+#elif USE_SPIN_LOCKS
+
+/* First, define CAS_LOCK and CLEAR_LOCK on ints */
+/* Note CAS_LOCK defined to return 0 on success */
+
+#if defined(__GNUC__)&& (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
+#define CAS_LOCK(sl)     __sync_lock_test_and_set(sl, 1)
+#define CLEAR_LOCK(sl)   __sync_lock_release(sl)
+
+#elif (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))
+/* Custom spin locks for older gcc on x86 */
+static FORCEINLINE int x86_cas_lock(int *sl) {
+  int ret;
+  int val = 1;
+  int cmp = 0;
+  __asm__ __volatile__  ("lock; cmpxchgl %1, %2"
+                         : "=a" (ret)
+                         : "r" (val), "m" (*(sl)), "0"(cmp)
+                         : "memory", "cc");
+  return ret;
+}
+
+static FORCEINLINE void x86_clear_lock(int* sl) {
+  assert(*sl != 0);
+  int prev = 0;
+  int ret;
+  __asm__ __volatile__ ("lock; xchgl %0, %1"
+                        : "=r" (ret)
+                        : "m" (*(sl)), "0"(prev)
+                        : "memory");
+}
+
+#define CAS_LOCK(sl)     x86_cas_lock(sl)
+#define CLEAR_LOCK(sl)   x86_clear_lock(sl)
+
+#else /* Win32 MSC */
+#define CAS_LOCK(sl)     interlockedexchange(sl, (LONG)1)
+#define CLEAR_LOCK(sl)   interlockedexchange (sl, (LONG)0)
+
+#endif /* ... gcc spins locks ... */
+
+/* How to yield for a spin lock */
+#define SPINS_PER_YIELD       63
+#if defined(_MSC_VER)
+#define SLEEP_EX_DURATION     50 /* delay for yield/sleep */
+#define SPIN_LOCK_YIELD  SleepEx(SLEEP_EX_DURATION, FALSE)
+#elif defined (__SVR4) && defined (__sun) /* solaris */
+#define SPIN_LOCK_YIELD   thr_yield();
+#elif !defined(LACKS_SCHED_H)
+#define SPIN_LOCK_YIELD   sched_yield();
+#else
+#define SPIN_LOCK_YIELD
+#endif /* ... yield ... */
+
+#if !defined(USE_RECURSIVE_LOCKS) || USE_RECURSIVE_LOCKS == 0
+/* Plain spin locks use single word (embedded in malloc_states) */
+static int spin_acquire_lock(int *sl) {
+  int spins = 0;
+  while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {
+    if ((++spins & SPINS_PER_YIELD) == 0) {
+      SPIN_LOCK_YIELD;
+    }
+  }
+  return 0;
+}
+
+#define MLOCK_T               int
+#define TRY_LOCK(sl)          !CAS_LOCK(sl)
+#define RELEASE_LOCK(sl)      CLEAR_LOCK(sl)
+#define ACQUIRE_LOCK(sl)      (CAS_LOCK(sl)? spin_acquire_lock(sl) : 0)
+#define INITIAL_LOCK(sl)      (*sl = 0)
+#define DESTROY_LOCK(sl)      (0)
+static MLOCK_T malloc_global_mutex = 0;
+
+#else /* USE_RECURSIVE_LOCKS */
+/* types for lock owners */
+#ifdef WIN32
+#define THREAD_ID_T           DWORD
+#define CURRENT_THREAD        GetCurrentThreadId()
+#define EQ_OWNER(X,Y)         ((X) == (Y))
+#else
+/*
+  Note: the following assume that pthread_t is a type that can be
+  initialized to (casted) zero. If this is not the case, you will need to
+  somehow redefine these or not use spin locks.
+*/
+#define THREAD_ID_T           pthread_t
+#define CURRENT_THREAD        pthread_self()
+#define EQ_OWNER(X,Y)         pthread_equal(X, Y)
+#endif
+
+struct malloc_recursive_lock {
+  int sl;
+  unsigned int c;
+  THREAD_ID_T threadid;
+};
+
+#define MLOCK_T  struct malloc_recursive_lock
+static MLOCK_T malloc_global_mutex = { 0, 0, (THREAD_ID_T)0};
+
+static FORCEINLINE void recursive_release_lock(MLOCK_T *lk) {
+  assert(lk->sl != 0);
+  if (--lk->c == 0) {
+    CLEAR_LOCK(&lk->sl);
+  }
+}
+
+static FORCEINLINE int recursive_acquire_lock(MLOCK_T *lk) {
+  THREAD_ID_T mythreadid = CURRENT_THREAD;
+  int spins = 0;
+  for (;;) {
+    if (*((volatile int *)(&lk->sl)) == 0) {
+      if (!CAS_LOCK(&lk->sl)) {
+        lk->threadid = mythreadid;
+        lk->c = 1;
+        return 0;
+      }
+    }
+    else if (EQ_OWNER(lk->threadid, mythreadid)) {
+      ++lk->c;
+      return 0;
+    }
+    if ((++spins & SPINS_PER_YIELD) == 0) {
+      SPIN_LOCK_YIELD;
+    }
+  }
+}
+
+static FORCEINLINE int recursive_try_lock(MLOCK_T *lk) {
+  THREAD_ID_T mythreadid = CURRENT_THREAD;
+  if (*((volatile int *)(&lk->sl)) == 0) {
+    if (!CAS_LOCK(&lk->sl)) {
+      lk->threadid = mythreadid;
+      lk->c = 1;
+      return 1;
+    }
+  }
+  else if (EQ_OWNER(lk->threadid, mythreadid)) {
+    ++lk->c;
+    return 1;
+  }
+  return 0;
+}
+
+#define RELEASE_LOCK(lk)      recursive_release_lock(lk)
+#define TRY_LOCK(lk)          recursive_try_lock(lk)
+#define ACQUIRE_LOCK(lk)      recursive_acquire_lock(lk)
+#define INITIAL_LOCK(lk)      ((lk)->threadid = (THREAD_ID_T)0, (lk)->sl = 0, (lk)->c = 0)
+#define DESTROY_LOCK(lk)      (0)
+#endif /* USE_RECURSIVE_LOCKS */
+
+#elif defined(WIN32) /* Win32 critical sections */
+#define MLOCK_T               CRITICAL_SECTION
+#define ACQUIRE_LOCK(lk)      (EnterCriticalSection(lk), 0)
+#define RELEASE_LOCK(lk)      LeaveCriticalSection(lk)
+#define TRY_LOCK(lk)          TryEnterCriticalSection(lk)
+#define INITIAL_LOCK(lk)      (!InitializeCriticalSectionAndSpinCount((lk), 0x80000000|4000))
+#define DESTROY_LOCK(lk)      (DeleteCriticalSection(lk), 0)
+#define NEED_GLOBAL_LOCK_INIT
+
+static MLOCK_T malloc_global_mutex;
+static volatile LONG malloc_global_mutex_status;
+
+/* Use spin loop to initialize global lock */
+static void init_malloc_global_mutex() {
+  for (;;) {
+    long stat = malloc_global_mutex_status;
+    if (stat > 0)
+      return;
+    /* transition to < 0 while initializing, then to > 0) */
+    if (stat == 0 &&
+        interlockedcompareexchange(&malloc_global_mutex_status, (LONG)-1, (LONG)0) == 0) {
+      InitializeCriticalSection(&malloc_global_mutex);
+      interlockedexchange(&malloc_global_mutex_status, (LONG)1);
+      return;
+    }
+    SleepEx(0, FALSE);
+  }
+}
+
+#else /* pthreads-based locks */
+#define MLOCK_T               pthread_mutex_t
+#define ACQUIRE_LOCK(lk)      pthread_mutex_lock(lk)
+#define RELEASE_LOCK(lk)      pthread_mutex_unlock(lk)
+#define TRY_LOCK(lk)          (!pthread_mutex_trylock(lk))
+#define INITIAL_LOCK(lk)      pthread_init_lock(lk)
+#define DESTROY_LOCK(lk)      pthread_mutex_destroy(lk)
+
+#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0 && defined(linux) && !defined(PTHREAD_MUTEX_RECURSIVE)
+/* Cope with old-style linux recursive lock initialization by adding */
+/* skipped internal declaration from pthread.h */
+extern int pthread_mutexattr_setkind_np __P ((pthread_mutexattr_t *__attr,
+                                              int __kind));
+#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
+#define pthread_mutexattr_settype(x,y) pthread_mutexattr_setkind_np(x,y)
+#endif /* USE_RECURSIVE_LOCKS ... */
+
+static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static int pthread_init_lock (MLOCK_T *lk) {
+  pthread_mutexattr_t attr;
+  if (pthread_mutexattr_init(&attr)) return 1;
+#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0
+  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
+#endif
+  if (pthread_mutex_init(lk, &attr)) return 1;
+  if (pthread_mutexattr_destroy(&attr)) return 1;
+  return 0;
+}
+
+#endif /* ... lock types ... */
+
+/* Common code for all lock types */
+#define USE_LOCK_BIT               (2U)
+
+#ifndef ACQUIRE_MALLOC_GLOBAL_LOCK
+#define ACQUIRE_MALLOC_GLOBAL_LOCK()  ACQUIRE_LOCK(&malloc_global_mutex);
+#endif
+
+#ifndef RELEASE_MALLOC_GLOBAL_LOCK
+#define RELEASE_MALLOC_GLOBAL_LOCK()  RELEASE_LOCK(&malloc_global_mutex);
+#endif
+
+#endif /* USE_LOCKS */
+
+/* -----------------------  Chunk representations ------------------------ */
+
+/*
+  (The following includes lightly edited explanations by Colin Plumb.)
+
+  The malloc_chunk declaration below is misleading (but accurate and
+  necessary).  It declares a "view" into memory allowing access to
+  necessary fields at known offsets from a given base.
+
+  Chunks of memory are maintained using a `boundary tag' method as
+  originally described by Knuth.  (See the paper by Paul Wilson
+  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
+  techniques.)  Sizes of free chunks are stored both in the front of
+  each chunk and at the end.  This makes consolidating fragmented
+  chunks into bigger chunks fast.  The head fields also hold bits
+  representing whether chunks are free or in use.
+
+  Here are some pictures to make it clearer.  They are "exploded" to
+  show that the state of a chunk can be thought of as extending from
+  the high 31 bits of the head field of its header through the
+  prev_foot and PINUSE_BIT bit of the following chunk header.
+
+  A chunk that's in use looks like:
+
+   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+           | Size of previous chunk (if P = 0)                             |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
+         | Size of this chunk                                         1| +-+
+   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         |                                                               |
+         +-                                                             -+
+         |                                                               |
+         +-                                                             -+
+         |                                                               :
+         +-      size - sizeof(size_t) available payload bytes          -+
+         :                                                               |
+ chunk-> +-                                                             -+
+         |                                                               |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
+       | Size of next chunk (may or may not be in use)               | +-+
+ mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+    And if it's free, it looks like this:
+
+   chunk-> +-                                                             -+
+           | User payload (must be in use, or we would have merged!)       |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
+         | Size of this chunk                                         0| +-+
+   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Next pointer                                                  |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Prev pointer                                                  |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         |                                                               :
+         +-      size - sizeof(struct chunk) unused bytes               -+
+         :                                                               |
+ chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Size of this chunk                                            |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
+       | Size of next chunk (must be in use, or we would have merged)| +-+
+ mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                                                               :
+       +- User payload                                                -+
+       :                                                               |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                                     |0|
+                                                                     +-+
+  Note that since we always merge adjacent free chunks, the chunks
+  adjacent to a free chunk must be in use.
+
+  Given a pointer to a chunk (which can be derived trivially from the
+  payload pointer) we can, in O(1) time, find out whether the adjacent
+  chunks are free, and if so, unlink them from the lists that they
+  are on and merge them with the current chunk.
+
+  Chunks always begin on even word boundaries, so the mem portion
+  (which is returned to the user) is also on an even word boundary, and
+  thus at least double-word aligned.
+
+  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
+  chunk size (which is always a multiple of two words), is an in-use
+  bit for the *previous* chunk.  If that bit is *clear*, then the
+  word before the current chunk size contains the previous chunk
+  size, and can be used to find the front of the previous chunk.
+  The very first chunk allocated always has this bit set, preventing
+  access to non-existent (or non-owned) memory. If pinuse is set for
+  any given chunk, then you CANNOT determine the size of the
+  previous chunk, and might even get a memory addressing fault when
+  trying to do so.
+
+  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
+  the chunk size redundantly records whether the current chunk is
+  inuse (unless the chunk is mmapped). This redundancy enables usage
+  checks within free and realloc, and reduces indirection when freeing
+  and consolidating chunks.
+
+  Each freshly allocated chunk must have both cinuse and pinuse set.
+  That is, each allocated chunk borders either a previously allocated
+  and still in-use chunk, or the base of its memory arena. This is
+  ensured by making all allocations from the `lowest' part of any
+  found chunk.  Further, no free chunk physically borders another one,
+  so each free chunk is known to be preceded and followed by either
+  inuse chunks or the ends of memory.
+
+  Note that the `foot' of the current chunk is actually represented
+  as the prev_foot of the NEXT chunk. This makes it easier to
+  deal with alignments etc but can be very confusing when trying
+  to extend or adapt this code.
+
+  The exceptions to all this are
+
+     1. The special chunk `top' is the top-most available chunk (i.e.,
+        the one bordering the end of available memory). It is treated
+        specially.  Top is never included in any bin, is used only if
+        no other chunk is available, and is released back to the
+        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
+        the top chunk is treated as larger (and thus less well
+        fitting) than any other available chunk.  The top chunk
+        doesn't update its trailing size field since there is no next
+        contiguous chunk that would have to index off it. However,
+        space is still allocated for it (TOP_FOOT_SIZE) to enable
+        separation or merging when space is extended.
+
+     3. Chunks allocated via mmap, have both cinuse and pinuse bits
+        cleared in their head fields.  Because they are allocated
+        one-by-one, each must carry its own prev_foot field, which is
+        also used to hold the offset this chunk has within its mmapped
+        region, which is needed to preserve alignment. Each mmapped
+        chunk is trailed by the first two fields of a fake next-chunk
+        for sake of usage checks.
+
+*/
+
+struct malloc_chunk {
+  size_t               prev_foot;  /* Size of previous chunk (if free).  */
+  size_t               head;       /* Size and inuse bits. */
+  struct malloc_chunk* fd;         /* double links -- used only if free. */
+  struct malloc_chunk* bk;
+};
+
+typedef struct malloc_chunk  mchunk;
+typedef struct malloc_chunk* mchunkptr;
+typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
+typedef unsigned int bindex_t;         /* Described below */
+typedef unsigned int binmap_t;         /* Described below */
+typedef unsigned int flag_t;           /* The type of various bit flag sets */
+
+/* ------------------- Chunks sizes and alignments ----------------------- */
+
+#define MCHUNK_SIZE         (sizeof(mchunk))
+
+#if FOOTERS
+#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
+#else /* FOOTERS */
+#define CHUNK_OVERHEAD      (SIZE_T_SIZE)
+#endif /* FOOTERS */
+
+/* MMapped chunks need a second word of overhead ... */
+#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
+/* ... and additional padding for fake next-chunk at foot */
+#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)
+
+/* The smallest size we can malloc is an aligned minimal chunk */
+#define MIN_CHUNK_SIZE\
+  ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
+
+/* conversion from malloc headers to user pointers, and back */
+#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
+#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
+/* chunk associated with aligned address A */
+#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
+
+/* Bounds on request (not chunk) sizes. */
+#define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)
+#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
+
+/* pad request bytes into a usable size */
+#define pad_request(req) \
+   (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
+
+/* pad request, checking for minimum (but not maximum) */
+#define request2size(req) \
+  (((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))
+
+
+/* ------------------ Operations on head and foot fields ----------------- */
+
+/*
+  The head field of a chunk is or'ed with PINUSE_BIT when previous
+  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
+  use, unless mmapped, in which case both bits are cleared.
+
+  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
+*/
+
+#define PINUSE_BIT          (SIZE_T_ONE)
+#define CINUSE_BIT          (SIZE_T_TWO)
+#define FLAG4_BIT           (SIZE_T_FOUR)
+#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)
+#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
+
+/* Head value for fenceposts */
+#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)
+
+/* extraction of fields from head words */
+#define cinuse(p)           ((p)->head & CINUSE_BIT)
+#define pinuse(p)           ((p)->head & PINUSE_BIT)
+#define flag4inuse(p)       ((p)->head & FLAG4_BIT)
+#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
+#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)
+
+#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
+
+#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
+#define set_flag4(p)        ((p)->head |= FLAG4_BIT)
+#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)
+
+/* Treat space at ptr +/- offset as a chunk */
+#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
+#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
+
+/* Ptr to next or previous physical malloc_chunk. */
+#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
+#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
+
+/* extract next chunk's pinuse bit */
+#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)
+
+/* Get/set size at footer */
+#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
+#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
+
+/* Set size, pinuse bit, and foot */
+#define set_size_and_pinuse_of_free_chunk(p, s)\
+  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))
+
+/* Set size, pinuse bit, foot, and clear next pinuse */
+#define set_free_with_pinuse(p, s, n)\
+  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
+
+/* Get the internal overhead associated with chunk p */
+#define overhead_for(p)\
+ (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
+
+/* Return true if malloced space is not necessarily cleared */
+#if MMAP_CLEARS
+#define calloc_must_clear(p) (!is_mmapped(p))
+#else /* MMAP_CLEARS */
+#define calloc_must_clear(p) (1)
+#endif /* MMAP_CLEARS */
+
+/* ---------------------- Overlaid data structures ----------------------- */
+
+/*
+  When chunks are not in use, they are treated as nodes of either
+  lists or trees.
+
+  "Small"  chunks are stored in circular doubly-linked lists, and look
+  like this:
+
+    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Size of previous chunk                            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `head:' |             Size of chunk, in bytes                         |P|
+      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Forward pointer to next chunk in list             |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Back pointer to previous chunk in list            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Unused space (may be 0 bytes long)                .
+            .                                                               .
+            .                                                               |
+nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `foot:' |             Size of chunk, in bytes                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+  Larger chunks are kept in a form of bitwise digital trees (aka
+  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
+  free chunks greater than 256 bytes, their size doesn't impose any
+  constraints on user chunk sizes.  Each node looks like:
+
+    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Size of previous chunk                            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `head:' |             Size of chunk, in bytes                         |P|
+      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Forward pointer to next chunk of same size        |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Back pointer to previous chunk of same size       |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to left child (child[0])                  |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to right child (child[1])                 |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to parent                                 |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             bin index of this chunk                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Unused space                                      .
+            .                                                               |
+nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `foot:' |             Size of chunk, in bytes                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
+  of the same size are arranged in a circularly-linked list, with only
+  the oldest chunk (the next to be used, in our FIFO ordering)
+  actually in the tree.  (Tree members are distinguished by a non-null
+  parent pointer.)  If a chunk with the same size an an existing node
+  is inserted, it is linked off the existing node using pointers that
+  work in the same way as fd/bk pointers of small chunks.
+
+  Each tree contains a power of 2 sized range of chunk sizes (the
+  smallest is 0x100 <= x < 0x180), which is is divided in half at each
+  tree level, with the chunks in the smaller half of the range (0x100
+  <= x < 0x140 for the top nose) in the left subtree and the larger
+  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
+  done by inspecting individual bits.
+
+  Using these rules, each node's left subtree contains all smaller
+  sizes than its right subtree.  However, the node at the root of each
+  subtree has no particular ordering relationship to either.  (The
+  dividing line between the subtree sizes is based on trie relation.)
+  If we remove the last chunk of a given size from the interior of the
+  tree, we need to replace it with a leaf node.  The tree ordering
+  rules permit a node to be replaced by any leaf below it.
+
+  The smallest chunk in a tree (a common operation in a best-fit
+  allocator) can be found by walking a path to the leftmost leaf in
+  the tree.  Unlike a usual binary tree, where we follow left child
+  pointers until we reach a null, here we follow the right child
+  pointer any time the left one is null, until we reach a leaf with
+  both child pointers null. The smallest chunk in the tree will be
+  somewhere along that path.
+
+  The worst case number of steps to add, find, or remove a node is
+  bounded by the number of bits differentiating chunks within
+  bins. Under current bin calculations, this ranges from 6 up to 21
+  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
+  is of course much better.
+*/
+
+struct malloc_tree_chunk {
+  /* The first four fields must be compatible with malloc_chunk */
+  size_t                    prev_foot;
+  size_t                    head;
+  struct malloc_tree_chunk* fd;
+  struct malloc_tree_chunk* bk;
+
+  struct malloc_tree_chunk* child[2];
+  struct malloc_tree_chunk* parent;
+  bindex_t                  index;
+};
+
+typedef struct malloc_tree_chunk  tchunk;
+typedef struct malloc_tree_chunk* tchunkptr;
+typedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */
+
+/* A little helper macro for trees */
+#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
+
+/* ----------------------------- Segments -------------------------------- */
+
+/*
+  Each malloc space may include non-contiguous segments, held in a
+  list headed by an embedded malloc_segment record representing the
+  top-most space. Segments also include flags holding properties of
+  the space. Large chunks that are directly allocated by mmap are not
+  included in this list. They are instead independently created and
+  destroyed without otherwise keeping track of them.
+
+  Segment management mainly comes into play for spaces allocated by
+  MMAP.  Any call to MMAP might or might not return memory that is
+  adjacent to an existing segment.  MORECORE normally contiguously
+  extends the current space, so this space is almost always adjacent,
+  which is simpler and faster to deal with. (This is why MORECORE is
+  used preferentially to MMAP when both are available -- see
+  sys_alloc.)  When allocating using MMAP, we don't use any of the
+  hinting mechanisms (inconsistently) supported in various
+  implementations of unix mmap, or distinguish reserving from
+  committing memory. Instead, we just ask for space, and exploit
+  contiguity when we get it.  It is probably possible to do
+  better than this on some systems, but no general scheme seems
+  to be significantly better.
+
+  Management entails a simpler variant of the consolidation scheme
+  used for chunks to reduce fragmentation -- new adjacent memory is
+  normally prepended or appended to an existing segment. However,
+  there are limitations compared to chunk consolidation that mostly
+  reflect the fact that segment processing is relatively infrequent
+  (occurring only when getting memory from system) and that we
+  don't expect to have huge numbers of segments:
+
+  * Segments are not indexed, so traversal requires linear scans.  (It
+    would be possible to index these, but is not worth the extra
+    overhead and complexity for most programs on most platforms.)
+  * New segments are only appended to old ones when holding top-most
+    memory; if they cannot be prepended to others, they are held in
+    different segments.
+
+  Except for the top-most segment of an mstate, each segment record
+  is kept at the tail of its segment. Segments are added by pushing
+  segment records onto the list headed by &mstate.seg for the
+  containing mstate.
+
+  Segment flags control allocation/merge/deallocation policies:
+  * If EXTERN_BIT set, then we did not allocate this segment,
+    and so should not try to deallocate or merge with others.
+    (This currently holds only for the initial segment passed
+    into create_mspace_with_base.)
+  * If USE_MMAP_BIT set, the segment may be merged with
+    other surrounding mmapped segments and trimmed/de-allocated
+    using munmap.
+  * If neither bit is set, then the segment was obtained using
+    MORECORE so can be merged with surrounding MORECORE'd segments
+    and deallocated/trimmed using MORECORE with negative arguments.
+*/
+
+struct malloc_segment {
+  char*        base;             /* base address */
+  size_t       size;             /* allocated size */
+  struct malloc_segment* next;   /* ptr to next segment */
+  flag_t       sflags;           /* mmap and extern flag */
+};
+
+#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT)
+#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)
+
+typedef struct malloc_segment  msegment;
+typedef struct malloc_segment* msegmentptr;
+
+/* ---------------------------- malloc_state ----------------------------- */
+
+/*
+   A malloc_state holds all of the bookkeeping for a space.
+   The main fields are:
+
+  Top
+    The topmost chunk of the currently active segment. Its size is
+    cached in topsize.  The actual size of topmost space is
+    topsize+TOP_FOOT_SIZE, which includes space reserved for adding
+    fenceposts and segment records if necessary when getting more
+    space from the system.  The size at which to autotrim top is
+    cached from mparams in trim_check, except that it is disabled if
+    an autotrim fails.
+
+  Designated victim (dv)
+    This is the preferred chunk for servicing small requests that
+    don't have exact fits.  It is normally the chunk split off most
+    recently to service another small request.  Its size is cached in
+    dvsize. The link fields of this chunk are not maintained since it
+    is not kept in a bin.
+
+  SmallBins
+    An array of bin headers for free chunks.  These bins hold chunks
+    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
+    chunks of all the same size, spaced 8 bytes apart.  To simplify
+    use in double-linked lists, each bin header acts as a malloc_chunk
+    pointing to the real first node, if it exists (else pointing to
+    itself).  This avoids special-casing for headers.  But to avoid
+    waste, we allocate only the fd/bk pointers of bins, and then use
+    repositioning tricks to treat these as the fields of a chunk.
+
+  TreeBins
+    Treebins are pointers to the roots of trees holding a range of
+    sizes. There are 2 equally spaced treebins for each power of two
+    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
+    larger.
+
+  Bin maps
+    There is one bit map for small bins ("smallmap") and one for
+    treebins ("treemap).  Each bin sets its bit when non-empty, and
+    clears the bit when empty.  Bit operations are then used to avoid
+    bin-by-bin searching -- nearly all "search" is done without ever
+    looking at bins that won't be selected.  The bit maps
+    conservatively use 32 bits per map word, even if on 64bit system.
+    For a good description of some of the bit-based techniques used
+    here, see Henry S. Warren Jr's book "Hacker's Delight" (and
+    supplement at http://hackersdelight.org/). Many of these are
+    intended to reduce the branchiness of paths through malloc etc, as
+    well as to reduce the number of memory locations read or written.
+
+  Segments
+    A list of segments headed by an embedded malloc_segment record
+    representing the initial space.
+
+  Address check support
+    The least_addr field is the least address ever obtained from
+    MORECORE or MMAP. Attempted frees and reallocs of any address less
+    than this are trapped (unless INSECURE is defined).
+
+  Magic tag
+    A cross-check field that should always hold same value as mparams.magic.
+
+  Max allowed footprint
+    The maximum allowed bytes to allocate from system (zero means no limit)
+
+  Flags
+    Bits recording whether to use MMAP, locks, or contiguous MORECORE
+
+  Statistics
+    Each space keeps track of current and maximum system memory
+    obtained via MORECORE or MMAP.
+
+  Trim support
+    Fields holding the amount of unused topmost memory that should trigger
+    trimming, and a counter to force periodic scanning to release unused
+    non-topmost segments.
+
+  Locking
+    If USE_LOCKS is defined, the "mutex" lock is acquired and released
+    around every public call using this mspace.
+
+  Extension support
+    A void* pointer and a size_t field that can be used to help implement
+    extensions to this malloc.
+*/
+
+/* Bin types, widths and sizes */
+#define NSMALLBINS        (32U)
+#define NTREEBINS         (32U)
+#define SMALLBIN_SHIFT    (3U)
+#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)
+#define TREEBIN_SHIFT     (8U)
+#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)
+#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
+#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
+
+struct malloc_state {
+  binmap_t   smallmap;
+  binmap_t   treemap;
+  size_t     dvsize;
+  size_t     topsize;
+  char*      least_addr;
+  mchunkptr  dv;
+  mchunkptr  top;
+  size_t     trim_check;
+  size_t     release_checks;
+  size_t     magic;
+  mchunkptr  smallbins[(NSMALLBINS+1)*2];
+  tbinptr    treebins[NTREEBINS];
+  size_t     footprint;
+  size_t     max_footprint;
+  size_t     footprint_limit; /* zero means no limit */
+  flag_t     mflags;
+#if USE_LOCKS
+  MLOCK_T    mutex;     /* locate lock among fields that rarely change */
+#endif /* USE_LOCKS */
+  msegment   seg;
+  void*      extp;      /* Unused but available for extensions */
+  size_t     exts;
+};
+
+typedef struct malloc_state*    mstate;
+
+/* ------------- Global malloc_state and malloc_params ------------------- */
+
+/*
+  malloc_params holds global properties, including those that can be
+  dynamically set using mallopt. There is a single instance, mparams,
+  initialized in init_mparams. Note that the non-zeroness of "magic"
+  also serves as an initialization flag.
+*/
+
+struct malloc_params {
+  size_t magic;
+  size_t page_size;
+  size_t granularity;
+  size_t mmap_threshold;
+  size_t trim_threshold;
+  flag_t default_mflags;
+};
+
+static struct malloc_params mparams;
+
+/* Ensure mparams initialized */
+#define ensure_initialization() (void)(mparams.magic != 0 || init_mparams())
+
+#if !ONLY_MSPACES
+
+/* The global malloc_state used for all non-"mspace" calls */
+static struct malloc_state _gm_;
+#define gm                 (&_gm_)
+#define is_global(M)       ((M) == &_gm_)
+
+#endif /* !ONLY_MSPACES */
+
+#define is_initialized(M)  ((M)->top != 0)
+
+/* -------------------------- system alloc setup ------------------------- */
+
+/* Operations on mflags */
+
+#define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)
+#define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)
+#if USE_LOCKS
+#define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)
+#else
+#define disable_lock(M)
+#endif
+
+#define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)
+#define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)
+#if HAVE_MMAP
+#define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)
+#else
+#define disable_mmap(M)
+#endif
+
+#define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)
+#define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)
+
+#define set_lock(M,L)\
+ ((M)->mflags = (L)?\
+  ((M)->mflags | USE_LOCK_BIT) :\
+  ((M)->mflags & ~USE_LOCK_BIT))
+
+/* page-align a size */
+#define page_align(S)\
+ (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
+
+/* granularity-align a size */
+#define granularity_align(S)\
+  (((S) + (mparams.granularity - SIZE_T_ONE))\
+   & ~(mparams.granularity - SIZE_T_ONE))
+
+
+/* For mmap, use granularity alignment on windows, else page-align */
+#ifdef WIN32
+#define mmap_align(S) granularity_align(S)
+#else
+#define mmap_align(S) page_align(S)
+#endif
+
+/* For sys_alloc, enough padding to ensure can malloc request on success */
+#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
+
+#define is_page_aligned(S)\
+   (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
+#define is_granularity_aligned(S)\
+   (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
+
+/*  True if segment S holds address A */
+#define segment_holds(S, A)\
+  ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)
+
+/* Return segment holding given address */
+static msegmentptr segment_holding(mstate m, char* addr) {
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if (addr >= sp->base && addr < sp->base + sp->size)
+      return sp;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+
+/* Return true if segment contains a segment link */
+static int has_segment_link(mstate m, msegmentptr ss) {
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)
+      return 1;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+
+#ifndef MORECORE_CANNOT_TRIM
+#define should_trim(M,s)  ((s) > (M)->trim_check)
+#else  /* MORECORE_CANNOT_TRIM */
+#define should_trim(M,s)  (0)
+#endif /* MORECORE_CANNOT_TRIM */
+
+/*
+  TOP_FOOT_SIZE is padding at the end of a segment, including space
+  that may be needed to place segment records and fenceposts when new
+  noncontiguous segments are added.
+*/
+#define TOP_FOOT_SIZE\
+  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
+
+
+/* -------------------------------  Hooks -------------------------------- */
+
+/*
+  PREACTION should be defined to return 0 on success, and nonzero on
+  failure. If you are not using locking, you can redefine these to do
+  anything you like.
+*/
+
+#if USE_LOCKS
+#define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
+#define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }
+#else /* USE_LOCKS */
+
+#ifndef PREACTION
+#define PREACTION(M) (0)
+#endif  /* PREACTION */
+
+#ifndef POSTACTION
+#define POSTACTION(M)
+#endif  /* POSTACTION */
+
+#endif /* USE_LOCKS */
+
+/*
+  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
+  USAGE_ERROR_ACTION is triggered on detected bad frees and
+  reallocs. The argument p is an address that might have triggered the
+  fault. It is ignored by the two predefined actions, but might be
+  useful in custom actions that try to help diagnose errors.
+*/
+
+#if PROCEED_ON_ERROR
+
+/* A count of the number of corruption errors causing resets */
+int malloc_corruption_error_count;
+
+/* default corruption action */
+static void reset_on_error(mstate m);
+
+#define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)
+#define USAGE_ERROR_ACTION(m, p)
+
+#else /* PROCEED_ON_ERROR */
+
+#ifndef CORRUPTION_ERROR_ACTION
+#define CORRUPTION_ERROR_ACTION(m) ABORT
+#endif /* CORRUPTION_ERROR_ACTION */
+
+#ifndef USAGE_ERROR_ACTION
+#define USAGE_ERROR_ACTION(m,p) ABORT
+#endif /* USAGE_ERROR_ACTION */
+
+#endif /* PROCEED_ON_ERROR */
+
+
+/* -------------------------- Debugging setup ---------------------------- */
+
+#if ! DEBUG
+
+#define check_free_chunk(M,P)
+#define check_inuse_chunk(M,P)
+#define check_malloced_chunk(M,P,N)
+#define check_mmapped_chunk(M,P)
+#define check_malloc_state(M)
+#define check_top_chunk(M,P)
+
+#else /* DEBUG */
+#define check_free_chunk(M,P)       do_check_free_chunk(M,P)
+#define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)
+#define check_top_chunk(M,P)        do_check_top_chunk(M,P)
+#define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)
+#define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)
+#define check_malloc_state(M)       do_check_malloc_state(M)
+
+static void   do_check_any_chunk(mstate m, mchunkptr p);
+static void   do_check_top_chunk(mstate m, mchunkptr p);
+static void   do_check_mmapped_chunk(mstate m, mchunkptr p);
+static void   do_check_inuse_chunk(mstate m, mchunkptr p);
+static void   do_check_free_chunk(mstate m, mchunkptr p);
+static void   do_check_malloced_chunk(mstate m, void* mem, size_t s);
+static void   do_check_tree(mstate m, tchunkptr t);
+static void   do_check_treebin(mstate m, bindex_t i);
+static void   do_check_smallbin(mstate m, bindex_t i);
+static void   do_check_malloc_state(mstate m);
+static int    bin_find(mstate m, mchunkptr x);
+static size_t traverse_and_check(mstate m);
+#endif /* DEBUG */
+
+/* ---------------------------- Indexing Bins ---------------------------- */
+
+#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
+#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
+#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
+#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
+
+/* addressing by index. See above about smallbin repositioning */
+#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
+#define treebin_at(M,i)     (&((M)->treebins[i]))
+
+/* assign tree index for size S to variable I. Use x86 asm if possible  */
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+#define compute_tree_index(S, I)\
+{\
+  unsigned int X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K = (unsigned) sizeof(X)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(X); \
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+
+#elif defined (__INTEL_COMPILER)
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K = _bit_scan_reverse (X); \
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+
+#elif defined(_MSC_VER) && _MSC_VER>=1300
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K;\
+    _BitScanReverse((DWORD *) &K, (DWORD) X);\
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+
+#else /* GNUC */
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int Y = (unsigned int)X;\
+    unsigned int N = ((Y - 0x100) >> 16) & 8;\
+    unsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\
+    N += K;\
+    N += K = (((Y <<= K) - 0x4000) >> 16) & 2;\
+    K = 14 - N + ((Y <<= K) >> 15);\
+    I = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\
+  }\
+}
+#endif /* GNUC */
+
+/* Bit representing maximum resolved size in a treebin at i */
+#define bit_for_tree_index(i) \
+   (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)
+
+/* Shift placing maximum resolved bit in a treebin at i as sign bit */
+#define leftshift_for_tree_index(i) \
+   ((i == NTREEBINS-1)? 0 : \
+    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
+
+/* The size of the smallest chunk held in bin with index i */
+#define minsize_for_tree_index(i) \
+   ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \
+   (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))
+
+
+/* ------------------------ Operations on bin maps ----------------------- */
+
+/* bit corresponding to given index */
+#define idx2bit(i)              ((binmap_t)(1) << (i))
+
+/* Mark/Clear bits with given index */
+#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
+#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
+#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))
+
+#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
+#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
+#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))
+
+/* isolate the least set bit of a bitmap */
+#define least_bit(x)         ((x) & -(x))
+
+/* mask with all bits to left of least bit of x on */
+#define left_bits(x)         ((x<<1) | -(x<<1))
+
+/* mask with all bits to left of or equal to least bit of x on */
+#define same_or_left_bits(x) ((x) | -(x))
+
+/* index corresponding to given bit. Use x86 asm if possible */
+
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  J = __builtin_ctz(X); \
+  I = (bindex_t)J;\
+}
+
+#elif defined (__INTEL_COMPILER)
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  J = _bit_scan_forward (X); \
+  I = (bindex_t)J;\
+}
+
+#elif defined(_MSC_VER) && _MSC_VER>=1300
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  _BitScanForward((DWORD *) &J, X);\
+  I = (bindex_t)J;\
+}
+
+#elif USE_BUILTIN_FFS
+#define compute_bit2idx(X, I) I = ffs(X)-1
+
+#else
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int Y = X - 1;\
+  unsigned int K = Y >> (16-4) & 16;\
+  unsigned int N = K;        Y >>= K;\
+  N += K = Y >> (8-3) &  8;  Y >>= K;\
+  N += K = Y >> (4-2) &  4;  Y >>= K;\
+  N += K = Y >> (2-1) &  2;  Y >>= K;\
+  N += K = Y >> (1-0) &  1;  Y >>= K;\
+  I = (bindex_t)(N + Y);\
+}
+#endif /* GNUC */
+
+
+/* ----------------------- Runtime Check Support ------------------------- */
+
+/*
+  For security, the main invariant is that malloc/free/etc never
+  writes to a static address other than malloc_state, unless static
+  malloc_state itself has been corrupted, which cannot occur via
+  malloc (because of these checks). In essence this means that we
+  believe all pointers, sizes, maps etc held in malloc_state, but
+  check all of those linked or offsetted from other embedded data
+  structures.  These checks are interspersed with main code in a way
+  that tends to minimize their run-time cost.
+
+  When FOOTERS is defined, in addition to range checking, we also
+  verify footer fields of inuse chunks, which can be used guarantee
+  that the mstate controlling malloc/free is intact.  This is a
+  streamlined version of the approach described by William Robertson
+  et al in "Run-time Detection of Heap-based Overflows" LISA'03
+  http://www.usenix.org/events/lisa03/tech/robertson.html The footer
+  of an inuse chunk holds the xor of its mstate and a random seed,
+  that is checked upon calls to free() and realloc().  This is
+  (probabalistically) unguessable from outside the program, but can be
+  computed by any code successfully malloc'ing any chunk, so does not
+  itself provide protection against code that has already broken
+  security through some other means.  Unlike Robertson et al, we
+  always dynamically check addresses of all offset chunks (previous,
+  next, etc). This turns out to be cheaper than relying on hashes.
+*/
+
+#if !INSECURE
+/* Check if address a is at least as high as any from MORECORE or MMAP */
+#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)
+/* Check if address of next chunk n is higher than base chunk p */
+#define ok_next(p, n)    ((char*)(p) < (char*)(n))
+/* Check if p has inuse status */
+#define ok_inuse(p)     is_inuse(p)
+/* Check if p has its pinuse bit on */
+#define ok_pinuse(p)     pinuse(p)
+
+#else /* !INSECURE */
+#define ok_address(M, a) (1)
+#define ok_next(b, n)    (1)
+#define ok_inuse(p)      (1)
+#define ok_pinuse(p)     (1)
+#endif /* !INSECURE */
+
+#if (FOOTERS && !INSECURE)
+/* Check if (alleged) mstate m has expected magic field */
+#define ok_magic(M)      ((M)->magic == mparams.magic)
+#else  /* (FOOTERS && !INSECURE) */
+#define ok_magic(M)      (1)
+#endif /* (FOOTERS && !INSECURE) */
+
+/* In gcc, use __builtin_expect to minimize impact of checks */
+#if !INSECURE
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define RTCHECK(e)  __builtin_expect(e, 1)
+#else /* GNUC */
+#define RTCHECK(e)  (e)
+#endif /* GNUC */
+#else /* !INSECURE */
+#define RTCHECK(e)  (1)
+#endif /* !INSECURE */
+
+/* macros to set up inuse chunks with or without footers */
+
+#if !FOOTERS
+
+#define mark_inuse_foot(M,p,s)
+
+/* Macros for setting head/foot of non-mmapped chunks */
+
+/* Set cinuse bit and pinuse bit of next chunk */
+#define set_inuse(M,p,s)\
+  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
+  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
+
+/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
+#define set_inuse_and_pinuse(M,p,s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
+
+/* Set size, cinuse and pinuse bit of this chunk */
+#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))
+
+#else /* FOOTERS */
+
+/* Set foot of inuse chunk to be xor of mstate and seed */
+#define mark_inuse_foot(M,p,s)\
+  (((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))
+
+#define get_mstate_for(p)\
+  ((mstate)(((mchunkptr)((char*)(p) +\
+    (chunksize(p))))->prev_foot ^ mparams.magic))
+
+#define set_inuse(M,p,s)\
+  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
+  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \
+  mark_inuse_foot(M,p,s))
+
+#define set_inuse_and_pinuse(M,p,s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\
+ mark_inuse_foot(M,p,s))
+
+#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  mark_inuse_foot(M, p, s))
+
+#endif /* !FOOTERS */
+
+/* ---------------------------- setting mparams -------------------------- */
+
+#if LOCK_AT_FORK
+static void pre_fork(void)         { ACQUIRE_LOCK(&(gm)->mutex); }
+static void post_fork_parent(void) { RELEASE_LOCK(&(gm)->mutex); }
+static void post_fork_child(void)  { INITIAL_LOCK(&(gm)->mutex); }
+#endif /* LOCK_AT_FORK */
+
+/* Initialize mparams */
+static int init_mparams(void) {
+#ifdef NEED_GLOBAL_LOCK_INIT
+  if (malloc_global_mutex_status <= 0)
+    init_malloc_global_mutex();
+#endif
+
+  ACQUIRE_MALLOC_GLOBAL_LOCK();
+  if (mparams.magic == 0) {
+    size_t magic;
+    size_t psize;
+    size_t gsize;
+
+#ifndef WIN32
+    psize = malloc_getpagesize;
+    gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
+#else /* WIN32 */
+    {
+      SYSTEM_INFO system_info;
+      GetSystemInfo(&system_info);
+      psize = system_info.dwPageSize;
+      gsize = ((DEFAULT_GRANULARITY != 0)?
+               DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);
+    }
+#endif /* WIN32 */
+
+    /* Sanity-check configuration:
+       size_t must be unsigned and as wide as pointer type.
+       ints must be at least 4 bytes.
+       alignment must be at least 8.
+       Alignment, min chunk size, and page size must all be powers of 2.
+    */
+    if ((sizeof(size_t) != sizeof(char*)) ||
+        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
+        (sizeof(int) < 4)  ||
+        (MALLOC_ALIGNMENT < (size_t)8U) ||
+        ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
+        ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
+        ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
+        ((psize            & (psize-SIZE_T_ONE))            != 0))
+      ABORT;
+    mparams.granularity = gsize;
+    mparams.page_size = psize;
+    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
+    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
+#if MORECORE_CONTIGUOUS
+    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
+#else  /* MORECORE_CONTIGUOUS */
+    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
+#endif /* MORECORE_CONTIGUOUS */
+
+#if !ONLY_MSPACES
+    /* Set up lock for main malloc area */
+    gm->mflags = mparams.default_mflags;
+    (void)INITIAL_LOCK(&gm->mutex);
+#endif
+#if LOCK_AT_FORK
+    pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);
+#endif
+
+    {
+#if USE_DEV_RANDOM
+      int fd;
+      unsigned char buf[sizeof(size_t)];
+      /* Try to use /dev/urandom, else fall back on using time */
+      if ((fd = open("/dev/urandom", O_RDONLY)) >= 0 &&
+          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
+        magic = *((size_t *) buf);
+        close(fd);
+      }
+      else
+#endif /* USE_DEV_RANDOM */
+#ifdef WIN32
+      magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);
+#elif defined(LACKS_TIME_H)
+      magic = (size_t)&magic ^ (size_t)0x55555555U;
+#else
+      magic = (size_t)(time(0) ^ (size_t)0x55555555U);
+#endif
+      magic |= (size_t)8U;    /* ensure nonzero */
+      magic &= ~(size_t)7U;   /* improve chances of fault for bad values */
+      /* Until memory modes commonly available, use volatile-write */
+      (*(volatile size_t *)(&(mparams.magic))) = magic;
+    }
+  }
+
+  RELEASE_MALLOC_GLOBAL_LOCK();
+  return 1;
+}
+
+/* support for mallopt */
+static int change_mparam(int param_number, int value) {
+  size_t val;
+  ensure_initialization();
+  val = (value == -1)? MAX_SIZE_T : (size_t)value;
+  switch(param_number) {
+  case M_TRIM_THRESHOLD:
+    mparams.trim_threshold = val;
+    return 1;
+  case M_GRANULARITY:
+    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
+      mparams.granularity = val;
+      return 1;
+    }
+    else
+      return 0;
+  case M_MMAP_THRESHOLD:
+    mparams.mmap_threshold = val;
+    return 1;
+  default:
+    return 0;
+  }
+}
+
+#if DEBUG
+/* ------------------------- Debugging Support --------------------------- */
+
+/* Check properties of any chunk, whether free, inuse, mmapped etc  */
+static void do_check_any_chunk(mstate m, mchunkptr p) {
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+}
+
+/* Check properties of top chunk */
+static void do_check_top_chunk(mstate m, mchunkptr p) {
+  msegmentptr sp = segment_holding(m, (char*)p);
+  size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
+  assert(sp != 0);
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+  assert(sz == m->topsize);
+  assert(sz > 0);
+  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);
+  assert(pinuse(p));
+  assert(!pinuse(chunk_plus_offset(p, sz)));
+}
+
+/* Check properties of (inuse) mmapped chunks */
+static void do_check_mmapped_chunk(mstate m, mchunkptr p) {
+  size_t  sz = chunksize(p);
+  size_t len = (sz + (p->prev_foot) + MMAP_FOOT_PAD);
+  assert(is_mmapped(p));
+  assert(use_mmap(m));
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+  assert(!is_small(sz));
+  assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);
+  assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);
+  assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0);
+}
+
+/* Check properties of inuse chunks */
+static void do_check_inuse_chunk(mstate m, mchunkptr p) {
+  do_check_any_chunk(m, p);
+  assert(is_inuse(p));
+  assert(next_pinuse(p));
+  /* If not pinuse and not mmapped, previous chunk has OK offset */
+  assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);
+  if (is_mmapped(p))
+    do_check_mmapped_chunk(m, p);
+}
+
+/* Check properties of free chunks */
+static void do_check_free_chunk(mstate m, mchunkptr p) {
+  size_t sz = chunksize(p);
+  mchunkptr next = chunk_plus_offset(p, sz);
+  do_check_any_chunk(m, p);
+  assert(!is_inuse(p));
+  assert(!next_pinuse(p));
+  assert (!is_mmapped(p));
+  if (p != m->dv && p != m->top) {
+    if (sz >= MIN_CHUNK_SIZE) {
+      assert((sz & CHUNK_ALIGN_MASK) == 0);
+      assert(is_aligned(chunk2mem(p)));
+      assert(next->prev_foot == sz);
+      assert(pinuse(p));
+      assert (next == m->top || is_inuse(next));
+      assert(p->fd->bk == p);
+      assert(p->bk->fd == p);
+    }
+    else  /* markers are always of size SIZE_T_SIZE */
+      assert(sz == SIZE_T_SIZE);
+  }
+}
+
+/* Check properties of malloced chunks at the point they are malloced */
+static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    size_t sz = p->head & ~INUSE_BITS;
+    do_check_inuse_chunk(m, p);
+    assert((sz & CHUNK_ALIGN_MASK) == 0);
+    assert(sz >= MIN_CHUNK_SIZE);
+    assert(sz >= s);
+    /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
+    assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));
+  }
+}
+
+/* Check a tree and its subtrees.  */
+static void do_check_tree(mstate m, tchunkptr t) {
+  tchunkptr head = 0;
+  tchunkptr u = t;
+  bindex_t tindex = t->index;
+  size_t tsize = chunksize(t);
+  bindex_t idx;
+  compute_tree_index(tsize, idx);
+  assert(tindex == idx);
+  assert(tsize >= MIN_LARGE_SIZE);
+  assert(tsize >= minsize_for_tree_index(idx));
+  assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));
+
+  do { /* traverse through chain of same-sized nodes */
+    do_check_any_chunk(m, ((mchunkptr)u));
+    assert(u->index == tindex);
+    assert(chunksize(u) == tsize);
+    assert(!is_inuse(u));
+    assert(!next_pinuse(u));
+    assert(u->fd->bk == u);
+    assert(u->bk->fd == u);
+    if (u->parent == 0) {
+      assert(u->child[0] == 0);
+      assert(u->child[1] == 0);
+    }
+    else {
+      assert(head == 0); /* only one node on chain has parent */
+      head = u;
+      assert(u->parent != u);
+      assert (u->parent->child[0] == u ||
+              u->parent->child[1] == u ||
+              *((tbinptr*)(u->parent)) == u);
+      if (u->child[0] != 0) {
+        assert(u->child[0]->parent == u);
+        assert(u->child[0] != u);
+        do_check_tree(m, u->child[0]);
+      }
+      if (u->child[1] != 0) {
+        assert(u->child[1]->parent == u);
+        assert(u->child[1] != u);
+        do_check_tree(m, u->child[1]);
+      }
+      if (u->child[0] != 0 && u->child[1] != 0) {
+        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
+      }
+    }
+    u = u->fd;
+  } while (u != t);
+  assert(head != 0);
+}
+
+/*  Check all the chunks in a treebin.  */
+static void do_check_treebin(mstate m, bindex_t i) {
+  tbinptr* tb = treebin_at(m, i);
+  tchunkptr t = *tb;
+  int empty = (m->treemap & (1U << i)) == 0;
+  if (t == 0)
+    assert(empty);
+  if (!empty)
+    do_check_tree(m, t);
+}
+
+/*  Check all the chunks in a smallbin.  */
+static void do_check_smallbin(mstate m, bindex_t i) {
+  sbinptr b = smallbin_at(m, i);
+  mchunkptr p = b->bk;
+  unsigned int empty = (m->smallmap & (1U << i)) == 0;
+  if (p == b)
+    assert(empty);
+  if (!empty) {
+    for (; p != b; p = p->bk) {
+      size_t size = chunksize(p);
+      mchunkptr q;
+      /* each chunk claims to be free */
+      do_check_free_chunk(m, p);
+      /* chunk belongs in bin */
+      assert(small_index(size) == i);
+      assert(p->bk == b || chunksize(p->bk) == chunksize(p));
+      /* chunk is followed by an inuse chunk */
+      q = next_chunk(p);
+      if (q->head != FENCEPOST_HEAD)
+        do_check_inuse_chunk(m, q);
+    }
+  }
+}
+
+/* Find x in a bin. Used in other check functions. */
+static int bin_find(mstate m, mchunkptr x) {
+  size_t size = chunksize(x);
+  if (is_small(size)) {
+    bindex_t sidx = small_index(size);
+    sbinptr b = smallbin_at(m, sidx);
+    if (smallmap_is_marked(m, sidx)) {
+      mchunkptr p = b;
+      do {
+        if (p == x)
+          return 1;
+      } while ((p = p->fd) != b);
+    }
+  }
+  else {
+    bindex_t tidx;
+    compute_tree_index(size, tidx);
+    if (treemap_is_marked(m, tidx)) {
+      tchunkptr t = *treebin_at(m, tidx);
+      size_t sizebits = size << leftshift_for_tree_index(tidx);
+      while (t != 0 && chunksize(t) != size) {
+        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
+        sizebits <<= 1;
+      }
+      if (t != 0) {
+        tchunkptr u = t;
+        do {
+          if (u == (tchunkptr)x)
+            return 1;
+        } while ((u = u->fd) != t);
+      }
+    }
+  }
+  return 0;
+}
+
+/* Traverse each chunk and check it; return total */
+static size_t traverse_and_check(mstate m) {
+  size_t sum = 0;
+  if (is_initialized(m)) {
+    msegmentptr s = &m->seg;
+    sum += m->topsize + TOP_FOOT_SIZE;
+    while (s != 0) {
+      mchunkptr q = align_as_chunk(s->base);
+      mchunkptr lastq = 0;
+      assert(pinuse(q));
+      while (segment_holds(s, q) &&
+             q != m->top && q->head != FENCEPOST_HEAD) {
+        sum += chunksize(q);
+        if (is_inuse(q)) {
+          assert(!bin_find(m, q));
+          do_check_inuse_chunk(m, q);
+        }
+        else {
+          assert(q == m->dv || bin_find(m, q));
+          assert(lastq == 0 || is_inuse(lastq)); /* Not 2 consecutive free */
+          do_check_free_chunk(m, q);
+        }
+        lastq = q;
+        q = next_chunk(q);
+      }
+      s = s->next;
+    }
+  }
+  return sum;
+}
+
+
+/* Check all properties of malloc_state. */
+static void do_check_malloc_state(mstate m) {
+  bindex_t i;
+  size_t total;
+  /* check bins */
+  for (i = 0; i < NSMALLBINS; ++i)
+    do_check_smallbin(m, i);
+  for (i = 0; i < NTREEBINS; ++i)
+    do_check_treebin(m, i);
+
+  if (m->dvsize != 0) { /* check dv chunk */
+    do_check_any_chunk(m, m->dv);
+    assert(m->dvsize == chunksize(m->dv));
+    assert(m->dvsize >= MIN_CHUNK_SIZE);
+    assert(bin_find(m, m->dv) == 0);
+  }
+
+  if (m->top != 0) {   /* check top chunk */
+    do_check_top_chunk(m, m->top);
+    /*assert(m->topsize == chunksize(m->top)); redundant */
+    assert(m->topsize > 0);
+    assert(bin_find(m, m->top) == 0);
+  }
+
+  total = traverse_and_check(m);
+  assert(total <= m->footprint);
+  assert(m->footprint <= m->max_footprint);
+}
+#endif /* DEBUG */
+
+/* ----------------------------- statistics ------------------------------ */
+
+#if !NO_MALLINFO
+static struct mallinfo internal_mallinfo(mstate m) {
+  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  ensure_initialization();
+  if (!PREACTION(m)) {
+    check_malloc_state(m);
+    if (is_initialized(m)) {
+      size_t nfree = SIZE_T_ONE; /* top always free */
+      size_t mfree = m->topsize + TOP_FOOT_SIZE;
+      size_t sum = mfree;
+      msegmentptr s = &m->seg;
+      while (s != 0) {
+        mchunkptr q = align_as_chunk(s->base);
+        while (segment_holds(s, q) &&
+               q != m->top && q->head != FENCEPOST_HEAD) {
+          size_t sz = chunksize(q);
+          sum += sz;
+          if (!is_inuse(q)) {
+            mfree += sz;
+            ++nfree;
+          }
+          q = next_chunk(q);
+        }
+        s = s->next;
+      }
+
+      nm.arena    = sum;
+      nm.ordblks  = nfree;
+      nm.hblkhd   = m->footprint - sum;
+      nm.usmblks  = m->max_footprint;
+      nm.uordblks = m->footprint - mfree;
+      nm.fordblks = mfree;
+      nm.keepcost = m->topsize;
+    }
+
+    POSTACTION(m);
+  }
+  return nm;
+}
+#endif /* !NO_MALLINFO */
+
+#if !NO_MALLOC_STATS
+static void internal_malloc_stats(mstate m) {
+  ensure_initialization();
+  if (!PREACTION(m)) {
+    size_t maxfp = 0;
+    size_t fp = 0;
+    size_t used = 0;
+    check_malloc_state(m);
+    if (is_initialized(m)) {
+      msegmentptr s = &m->seg;
+      maxfp = m->max_footprint;
+      fp = m->footprint;
+      used = fp - (m->topsize + TOP_FOOT_SIZE);
+
+      while (s != 0) {
+        mchunkptr q = align_as_chunk(s->base);
+        while (segment_holds(s, q) &&
+               q != m->top && q->head != FENCEPOST_HEAD) {
+          if (!is_inuse(q))
+            used -= chunksize(q);
+          q = next_chunk(q);
+        }
+        s = s->next;
+      }
+    }
+    POSTACTION(m); /* drop lock */
+    fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));
+    fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));
+    fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
+  }
+}
+#endif /* NO_MALLOC_STATS */
+
+/* ----------------------- Operations on smallbins ----------------------- */
+
+/*
+  Various forms of linking and unlinking are defined as macros.  Even
+  the ones for trees, which are very long but have very short typical
+  paths.  This is ugly but reduces reliance on inlining support of
+  compilers.
+*/
+
+/* Link a free chunk into a smallbin  */
+#define insert_small_chunk(M, P, S) {\
+  bindex_t I  = small_index(S);\
+  mchunkptr B = smallbin_at(M, I);\
+  mchunkptr F = B;\
+  assert(S >= MIN_CHUNK_SIZE);\
+  if (!smallmap_is_marked(M, I))\
+    mark_smallmap(M, I);\
+  else if (RTCHECK(ok_address(M, B->fd)))\
+    F = B->fd;\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+  B->fd = P;\
+  F->bk = P;\
+  P->fd = F;\
+  P->bk = B;\
+}
+
+/* Unlink a chunk from a smallbin  */
+#define unlink_small_chunk(M, P, S) {\
+  mchunkptr F = P->fd;\
+  mchunkptr B = P->bk;\
+  bindex_t I = small_index(S);\
+  assert(P != B);\
+  assert(P != F);\
+  assert(chunksize(P) == small_index2size(I));\
+  if (RTCHECK(F == smallbin_at(M,I) || (ok_address(M, F) && F->bk == P))) { \
+    if (B == F) {\
+      clear_smallmap(M, I);\
+    }\
+    else if (RTCHECK(B == smallbin_at(M,I) ||\
+                     (ok_address(M, B) && B->fd == P))) {\
+      F->bk = B;\
+      B->fd = F;\
+    }\
+    else {\
+      CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+}
+
+/* Unlink the first chunk from a smallbin */
+#define unlink_first_small_chunk(M, B, P, I) {\
+  mchunkptr F = P->fd;\
+  assert(P != B);\
+  assert(P != F);\
+  assert(chunksize(P) == small_index2size(I));\
+  if (B == F) {\
+    clear_smallmap(M, I);\
+  }\
+  else if (RTCHECK(ok_address(M, F) && F->bk == P)) {\
+    F->bk = B;\
+    B->fd = F;\
+  }\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+}
+
+/* Replace dv node, binning the old one */
+/* Used only when dvsize known to be small */
+#define replace_dv(M, P, S) {\
+  size_t DVS = M->dvsize;\
+  assert(is_small(DVS));\
+  if (DVS != 0) {\
+    mchunkptr DV = M->dv;\
+    insert_small_chunk(M, DV, DVS);\
+  }\
+  M->dvsize = S;\
+  M->dv = P;\
+}
+
+/* ------------------------- Operations on trees ------------------------- */
+
+/* Insert chunk into tree */
+#define insert_large_chunk(M, X, S) {\
+  tbinptr* H;\
+  bindex_t I;\
+  compute_tree_index(S, I);\
+  H = treebin_at(M, I);\
+  X->index = I;\
+  X->child[0] = X->child[1] = 0;\
+  if (!treemap_is_marked(M, I)) {\
+    mark_treemap(M, I);\
+    *H = X;\
+    X->parent = (tchunkptr)H;\
+    X->fd = X->bk = X;\
+  }\
+  else {\
+    tchunkptr T = *H;\
+    size_t K = S << leftshift_for_tree_index(I);\
+    for (;;) {\
+      if (chunksize(T) != S) {\
+        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
+        K <<= 1;\
+        if (*C != 0)\
+          T = *C;\
+        else if (RTCHECK(ok_address(M, C))) {\
+          *C = X;\
+          X->parent = T;\
+          X->fd = X->bk = X;\
+          break;\
+        }\
+        else {\
+          CORRUPTION_ERROR_ACTION(M);\
+          break;\
+        }\
+      }\
+      else {\
+        tchunkptr F = T->fd;\
+        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
+          T->fd = F->bk = X;\
+          X->fd = F;\
+          X->bk = T;\
+          X->parent = 0;\
+          break;\
+        }\
+        else {\
+          CORRUPTION_ERROR_ACTION(M);\
+          break;\
+        }\
+      }\
+    }\
+  }\
+}
+
+/*
+  Unlink steps:
+
+  1. If x is a chained node, unlink it from its same-sized fd/bk links
+     and choose its bk node as its replacement.
+  2. If x was the last node of its size, but not a leaf node, it must
+     be replaced with a leaf node (not merely one with an open left or
+     right), to make sure that lefts and rights of descendents
+     correspond properly to bit masks.  We use the rightmost descendent
+     of x.  We could use any other leaf, but this is easy to locate and
+     tends to counteract removal of leftmosts elsewhere, and so keeps
+     paths shorter than minimally guaranteed.  This doesn't loop much
+     because on average a node in a tree is near the bottom.
+  3. If x is the base of a chain (i.e., has parent links) relink
+     x's parent and children to x's replacement (or null if none).
+*/
+
+#define unlink_large_chunk(M, X) {\
+  tchunkptr XP = X->parent;\
+  tchunkptr R;\
+  if (X->bk != X) {\
+    tchunkptr F = X->fd;\
+    R = X->bk;\
+    if (RTCHECK(ok_address(M, F) && F->bk == X && R->fd == X)) {\
+      F->bk = R;\
+      R->fd = F;\
+    }\
+    else {\
+      CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+  else {\
+    tchunkptr* RP;\
+    if (((R = *(RP = &(X->child[1]))) != 0) ||\
+        ((R = *(RP = &(X->child[0]))) != 0)) {\
+      tchunkptr* CP;\
+      while ((*(CP = &(R->child[1])) != 0) ||\
+             (*(CP = &(R->child[0])) != 0)) {\
+        R = *(RP = CP);\
+      }\
+      if (RTCHECK(ok_address(M, RP)))\
+        *RP = 0;\
+      else {\
+        CORRUPTION_ERROR_ACTION(M);\
+      }\
+    }\
+  }\
+  if (XP != 0) {\
+    tbinptr* H = treebin_at(M, X->index);\
+    if (X == *H) {\
+      if ((*H = R) == 0) \
+        clear_treemap(M, X->index);\
+    }\
+    else if (RTCHECK(ok_address(M, XP))) {\
+      if (XP->child[0] == X) \
+        XP->child[0] = R;\
+      else \
+        XP->child[1] = R;\
+    }\
+    else\
+      CORRUPTION_ERROR_ACTION(M);\
+    if (R != 0) {\
+      if (RTCHECK(ok_address(M, R))) {\
+        tchunkptr C0, C1;\
+        R->parent = XP;\
+        if ((C0 = X->child[0]) != 0) {\
+          if (RTCHECK(ok_address(M, C0))) {\
+            R->child[0] = C0;\
+            C0->parent = R;\
+          }\
+          else\
+            CORRUPTION_ERROR_ACTION(M);\
+        }\
+        if ((C1 = X->child[1]) != 0) {\
+          if (RTCHECK(ok_address(M, C1))) {\
+            R->child[1] = C1;\
+            C1->parent = R;\
+          }\
+          else\
+            CORRUPTION_ERROR_ACTION(M);\
+        }\
+      }\
+      else\
+        CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+}
+
+/* Relays to large vs small bin operations */
+
+#define insert_chunk(M, P, S)\
+  if (is_small(S)) insert_small_chunk(M, P, S)\
+  else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }
+
+#define unlink_chunk(M, P, S)\
+  if (is_small(S)) unlink_small_chunk(M, P, S)\
+  else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }
+
+
+/* Relays to internal calls to malloc/free from realloc, memalign etc */
+
+#if ONLY_MSPACES
+#define internal_malloc(m, b) mspace_malloc(m, b)
+#define internal_free(m, mem) mspace_free(m,mem);
+#else /* ONLY_MSPACES */
+#if MSPACES
+#define internal_malloc(m, b)\
+  ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
+#define internal_free(m, mem)\
+   if (m == gm) dlfree(mem); else mspace_free(m,mem);
+#else /* MSPACES */
+#define internal_malloc(m, b) dlmalloc(b)
+#define internal_free(m, mem) dlfree(mem)
+#endif /* MSPACES */
+#endif /* ONLY_MSPACES */
+
+/* -----------------------  Direct-mmapping chunks ----------------------- */
+
+/*
+  Directly mmapped chunks are set up with an offset to the start of
+  the mmapped region stored in the prev_foot field of the chunk. This
+  allows reconstruction of the required argument to MUNMAP when freed,
+  and also allows adjustment of the returned chunk to meet alignment
+  requirements (especially in memalign).
+*/
+
+/* Malloc using mmap */
+static void* mmap_alloc(mstate m, size_t nb) {
+  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+  if (m->footprint_limit != 0) {
+    size_t fp = m->footprint + mmsize;
+    if (fp <= m->footprint || fp > m->footprint_limit)
+      return 0;
+  }
+  if (mmsize > nb) {     /* Check for wrap around 0 */
+    char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
+    if (mm != CMFAIL) {
+      size_t offset = align_offset(chunk2mem(mm));
+      size_t psize = mmsize - offset - MMAP_FOOT_PAD;
+      mchunkptr p = (mchunkptr)(mm + offset);
+      p->prev_foot = offset;
+      p->head = psize;
+      mark_inuse_foot(m, p, psize);
+      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
+      chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;
+
+      if (m->least_addr == 0 || mm < m->least_addr)
+        m->least_addr = mm;
+      if ((m->footprint += mmsize) > m->max_footprint)
+        m->max_footprint = m->footprint;
+      assert(is_aligned(chunk2mem(p)));
+      check_mmapped_chunk(m, p);
+      return chunk2mem(p);
+    }
+  }
+  return 0;
+}
+
+/* Realloc using mmap */
+static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {
+  size_t oldsize = chunksize(oldp);
+  (void)flags; /* placate people compiling -Wunused */
+  if (is_small(nb)) /* Can't shrink mmap regions below small size */
+    return 0;
+  /* Keep old chunk if big enough but not too big */
+  if (oldsize >= nb + SIZE_T_SIZE &&
+      (oldsize - nb) <= (mparams.granularity << 1))
+    return oldp;
+  else {
+    size_t offset = oldp->prev_foot;
+    size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;
+    size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+    char* cp = (char*)CALL_MREMAP((char*)oldp - offset,
+                                  oldmmsize, newmmsize, flags);
+    if (cp != CMFAIL) {
+      mchunkptr newp = (mchunkptr)(cp + offset);
+      size_t psize = newmmsize - offset - MMAP_FOOT_PAD;
+      newp->head = psize;
+      mark_inuse_foot(m, newp, psize);
+      chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;
+      chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;
+
+      if (cp < m->least_addr)
+        m->least_addr = cp;
+      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
+        m->max_footprint = m->footprint;
+      check_mmapped_chunk(m, newp);
+      return newp;
+    }
+  }
+  return 0;
+}
+
+
+/* -------------------------- mspace management -------------------------- */
+
+/* Initialize top chunk and its size */
+static void init_top(mstate m, mchunkptr p, size_t psize) {
+  /* Ensure alignment */
+  size_t offset = align_offset(chunk2mem(p));
+  p = (mchunkptr)((char*)p + offset);
+  psize -= offset;
+
+  m->top = p;
+  m->topsize = psize;
+  p->head = psize | PINUSE_BIT;
+  /* set size of fake trailing chunk holding overhead space only once */
+  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
+  m->trim_check = mparams.trim_threshold; /* reset on each update */
+}
+
+/* Initialize bins for a new mstate that is otherwise zeroed out */
+static void init_bins(mstate m) {
+  /* Establish circular links for smallbins */
+  bindex_t i;
+  for (i = 0; i < NSMALLBINS; ++i) {
+    sbinptr bin = smallbin_at(m,i);
+    bin->fd = bin->bk = bin;
+  }
+}
+
+#if PROCEED_ON_ERROR
+
+/* default corruption action */
+static void reset_on_error(mstate m) {
+  int i;
+  ++malloc_corruption_error_count;
+  /* Reinitialize fields to forget about all memory */
+  m->smallmap = m->treemap = 0;
+  m->dvsize = m->topsize = 0;
+  m->seg.base = 0;
+  m->seg.size = 0;
+  m->seg.next = 0;
+  m->top = m->dv = 0;
+  for (i = 0; i < NTREEBINS; ++i)
+    *treebin_at(m, i) = 0;
+  init_bins(m);
+}
+#endif /* PROCEED_ON_ERROR */
+
+/* Allocate chunk and prepend remainder with chunk in successor base. */
+static void* prepend_alloc(mstate m, char* newbase, char* oldbase,
+                           size_t nb) {
+  mchunkptr p = align_as_chunk(newbase);
+  mchunkptr oldfirst = align_as_chunk(oldbase);
+  size_t psize = (char*)oldfirst - (char*)p;
+  mchunkptr q = chunk_plus_offset(p, nb);
+  size_t qsize = psize - nb;
+  set_size_and_pinuse_of_inuse_chunk(m, p, nb);
+
+  assert((char*)oldfirst > (char*)q);
+  assert(pinuse(oldfirst));
+  assert(qsize >= MIN_CHUNK_SIZE);
+
+  /* consolidate remainder with first chunk of old base */
+  if (oldfirst == m->top) {
+    size_t tsize = m->topsize += qsize;
+    m->top = q;
+    q->head = tsize | PINUSE_BIT;
+    check_top_chunk(m, q);
+  }
+  else if (oldfirst == m->dv) {
+    size_t dsize = m->dvsize += qsize;
+    m->dv = q;
+    set_size_and_pinuse_of_free_chunk(q, dsize);
+  }
+  else {
+    if (!is_inuse(oldfirst)) {
+      size_t nsize = chunksize(oldfirst);
+      unlink_chunk(m, oldfirst, nsize);
+      oldfirst = chunk_plus_offset(oldfirst, nsize);
+      qsize += nsize;
+    }
+    set_free_with_pinuse(q, qsize, oldfirst);
+    insert_chunk(m, q, qsize);
+    check_free_chunk(m, q);
+  }
+
+  check_malloced_chunk(m, chunk2mem(p), nb);
+  return chunk2mem(p);
+}
+
+/* Add a segment to hold a new noncontiguous region */
+static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {
+  /* Determine locations and sizes of segment, fenceposts, old top */
+  char* old_top = (char*)m->top;
+  msegmentptr oldsp = segment_holding(m, old_top);
+  char* old_end = oldsp->base + oldsp->size;
+  size_t ssize = pad_request(sizeof(struct malloc_segment));
+  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+  size_t offset = align_offset(chunk2mem(rawsp));
+  char* asp = rawsp + offset;
+  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
+  mchunkptr sp = (mchunkptr)csp;
+  msegmentptr ss = (msegmentptr)(chunk2mem(sp));
+  mchunkptr tnext = chunk_plus_offset(sp, ssize);
+  mchunkptr p = tnext;
+  int nfences = 0;
+
+  /* reset top to new space */
+  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
+
+  /* Set up segment record */
+  assert(is_aligned(ss));
+  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
+  *ss = m->seg; /* Push current record */
+  m->seg.base = tbase;
+  m->seg.size = tsize;
+  m->seg.sflags = mmapped;
+  m->seg.next = ss;
+
+  /* Insert trailing fenceposts */
+  for (;;) {
+    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);
+    p->head = FENCEPOST_HEAD;
+    ++nfences;
+    if ((char*)(&(nextp->head)) < old_end)
+      p = nextp;
+    else
+      break;
+  }
+  assert(nfences >= 2);
+
+  /* Insert the rest of old top into a bin as an ordinary free chunk */
+  if (csp != old_top) {
+    mchunkptr q = (mchunkptr)old_top;
+    size_t psize = csp - old_top;
+    mchunkptr tn = chunk_plus_offset(q, psize);
+    set_free_with_pinuse(q, psize, tn);
+    insert_chunk(m, q, psize);
+  }
+
+  check_top_chunk(m, m->top);
+}
+
+/* -------------------------- System allocation -------------------------- */
+
+/* Get memory from system using MORECORE or MMAP */
+static void* sys_alloc(mstate m, size_t nb) {
+  char* tbase = CMFAIL;
+  size_t tsize = 0;
+  flag_t mmap_flag = 0;
+  size_t asize; /* allocation size */
+
+  ensure_initialization();
+
+  /* Directly map large chunks, but only if already initialized */
+  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
+    void* mem = mmap_alloc(m, nb);
+    if (mem != 0)
+      return mem;
+  }
+
+  asize = granularity_align(nb + SYS_ALLOC_PADDING);
+  if (asize <= nb)
+    return 0; /* wraparound */
+  if (m->footprint_limit != 0) {
+    size_t fp = m->footprint + asize;
+    if (fp <= m->footprint || fp > m->footprint_limit)
+      return 0;
+  }
+
+  /*
+    Try getting memory in any of three ways (in most-preferred to
+    least-preferred order):
+    1. A call to MORECORE that can normally contiguously extend memory.
+       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
+       or main space is mmapped or a previous contiguous call failed)
+    2. A call to MMAP new space (disabled if not HAVE_MMAP).
+       Note that under the default settings, if MORECORE is unable to
+       fulfill a request, and HAVE_MMAP is true, then mmap is
+       used as a noncontiguous system allocator. This is a useful backup
+       strategy for systems with holes in address spaces -- in this case
+       sbrk cannot contiguously expand the heap, but mmap may be able to
+       find space.
+    3. A call to MORECORE that cannot usually contiguously extend memory.
+       (disabled if not HAVE_MORECORE)
+
+   In all cases, we need to request enough bytes from system to ensure
+   we can malloc nb bytes upon success, so pad with enough space for
+   top_foot, plus alignment-pad to make sure we don't lose bytes if
+   not on boundary, and round this up to a granularity unit.
+  */
+
+  if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {
+    char* br = CMFAIL;
+    size_t ssize = asize; /* sbrk call size */
+    msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);
+    ACQUIRE_MALLOC_GLOBAL_LOCK();
+
+    if (ss == 0) {  /* First time through or recovery */
+      char* base = (char*)CALL_MORECORE(0);      
+      if (base != CMFAIL) {
+        size_t fp;
+        /* Adjust to end on a page boundary */
+        if (!is_page_aligned(base))
+          ssize += (page_align((size_t)base) - (size_t)base);
+        fp = m->footprint + ssize; /* recheck limits */
+        if (ssize > nb && ssize < HALF_MAX_SIZE_T &&
+            (m->footprint_limit == 0 ||
+             (fp > m->footprint && fp <= m->footprint_limit)) &&
+            (br = (char*)(CALL_MORECORE(ssize))) == base) {
+          tbase = base;
+          tsize = ssize;
+        }
+      }
+    }
+    else {
+      /* Subtract out existing available top space from MORECORE request. */
+      ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);
+      /* Use mem here only if it did continuously extend old space */
+      if (ssize < HALF_MAX_SIZE_T &&
+          (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {
+        tbase = br;
+        tsize = ssize;
+      }
+    }
+
+    if (tbase == CMFAIL) {    /* Cope with partial failure */
+      if (br != CMFAIL) {    /* Try to use/extend the space we did get */
+        if (ssize < HALF_MAX_SIZE_T &&
+            ssize < nb + SYS_ALLOC_PADDING) {
+          size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);
+          if (esize < HALF_MAX_SIZE_T) {
+            char* end = (char*)CALL_MORECORE(esize);
+            if (end != CMFAIL)
+              ssize += esize;
+            else {            /* Can't use; try to release */
+              (void) CALL_MORECORE(-ssize);
+              br = CMFAIL;
+            }
+          }
+        }
+      }
+      if (br != CMFAIL) {    /* Use the space we did get */
+        tbase = br;
+        tsize = ssize;
+      }
+      else
+        disable_contiguous(m); /* Don't try contiguous path in the future */
+    }
+
+    RELEASE_MALLOC_GLOBAL_LOCK();
+  }
+
+  if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */
+    char* mp = (char*)(CALL_MMAP(asize));
+    if (mp != CMFAIL) {
+      tbase = mp;
+      tsize = asize;
+      mmap_flag = USE_MMAP_BIT;
+    }
+  }
+
+  if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */
+    if (asize < HALF_MAX_SIZE_T) {
+      char* br = CMFAIL;
+      char* end = CMFAIL;
+      ACQUIRE_MALLOC_GLOBAL_LOCK();
+      br = (char*)(CALL_MORECORE(asize));
+      end = (char*)(CALL_MORECORE(0));
+      RELEASE_MALLOC_GLOBAL_LOCK();
+      if (br != CMFAIL && end != CMFAIL && br < end) {
+        size_t ssize = end - br;
+        if (ssize > nb + TOP_FOOT_SIZE) {
+          tbase = br;
+          tsize = ssize;
+        }
+      }
+    }
+  }
+
+  if (tbase != CMFAIL) {
+    if ((m->footprint += tsize) > m->max_footprint)
+      m->max_footprint = m->footprint;
+
+    if (!is_initialized(m)) { /* first-time initialization */
+      if (m->least_addr == 0 || tbase < m->least_addr)
+        m->least_addr = tbase;
+      m->seg.base = tbase;
+      m->seg.size = tsize;
+      m->seg.sflags = mmap_flag;
+      m->magic = mparams.magic;
+      m->release_checks = MAX_RELEASE_CHECK_RATE;
+      init_bins(m);
+#if !ONLY_MSPACES
+      if (is_global(m))
+        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
+      else
+#endif
+      {
+        /* Offset top by embedded malloc_state */
+        mchunkptr mn = next_chunk(mem2chunk(m));
+        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
+      }
+    }
+
+    else {
+      /* Try to merge with an existing segment */
+      msegmentptr sp = &m->seg;
+      /* Only consider most recent segment if traversal suppressed */
+      while (sp != 0 && tbase != sp->base + sp->size)
+        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
+      if (sp != 0 &&
+          !is_extern_segment(sp) &&
+          (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
+          segment_holds(sp, m->top)) { /* append */
+        sp->size += tsize;
+        init_top(m, m->top, m->topsize + tsize);
+      }
+      else {
+        if (tbase < m->least_addr)
+          m->least_addr = tbase;
+        sp = &m->seg;
+        while (sp != 0 && sp->base != tbase + tsize)
+          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
+        if (sp != 0 &&
+            !is_extern_segment(sp) &&
+            (sp->sflags & USE_MMAP_BIT) == mmap_flag) {
+          char* oldbase = sp->base;
+          sp->base = tbase;
+          sp->size += tsize;
+          return prepend_alloc(m, tbase, oldbase, nb);
+        }
+        else
+          add_segment(m, tbase, tsize, mmap_flag);
+      }
+    }
+
+    if (nb < m->topsize) { /* Allocate from new or extended top space */
+      size_t rsize = m->topsize -= nb;
+      mchunkptr p = m->top;
+      mchunkptr r = m->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(m, p, nb);
+      check_top_chunk(m, m->top);
+      check_malloced_chunk(m, chunk2mem(p), nb);
+      return chunk2mem(p);
+    }
+  }
+
+  MALLOC_FAILURE_ACTION;
+  return 0;
+}
+
+/* -----------------------  system deallocation -------------------------- */
+
+/* Unmap and unlink any mmapped segments that don't contain used chunks */
+static size_t release_unused_segments(mstate m) {
+  size_t released = 0;
+  int nsegs = 0;
+  msegmentptr pred = &m->seg;
+  msegmentptr sp = pred->next;
+  while (sp != 0) {
+    char* base = sp->base;
+    size_t size = sp->size;
+    msegmentptr next = sp->next;
+    ++nsegs;
+    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
+      mchunkptr p = align_as_chunk(base);
+      size_t psize = chunksize(p);
+      /* Can unmap if first chunk holds entire segment and not pinned */
+      if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
+        tchunkptr tp = (tchunkptr)p;
+        assert(segment_holds(sp, (char*)sp));
+        if (p == m->dv) {
+          m->dv = 0;
+          m->dvsize = 0;
+        }
+        else {
+          unlink_large_chunk(m, tp);
+        }
+        if (CALL_MUNMAP(base, size) == 0) {
+          released += size;
+          m->footprint -= size;
+          /* unlink obsoleted record */
+          sp = pred;
+          sp->next = next;
+        }
+        else { /* back out if cannot unmap */
+          insert_large_chunk(m, tp, psize);
+        }
+      }
+    }
+    if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
+      break;
+    pred = sp;
+    sp = next;
+  }
+  /* Reset check counter */
+  m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
+                       (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);
+  return released;
+}
+
+static int sys_trim(mstate m, size_t pad) {
+  size_t released = 0;
+  ensure_initialization();
+  if (pad < MAX_REQUEST && is_initialized(m)) {
+    pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */
+
+    if (m->topsize > pad) {
+      /* Shrink top space in granularity-size units, keeping at least one */
+      size_t unit = mparams.granularity;
+      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
+                      SIZE_T_ONE) * unit;
+      msegmentptr sp = segment_holding(m, (char*)m->top);
+
+      if (!is_extern_segment(sp)) {
+        if (is_mmapped_segment(sp)) {
+          if (HAVE_MMAP &&
+              sp->size >= extra &&
+              !has_segment_link(m, sp)) { /* can't shrink if pinned */
+            size_t newsize = sp->size - extra;
+            (void)newsize; /* placate people compiling -Wunused-variable */
+            /* Prefer mremap, fall back to munmap */
+            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
+                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
+              released = extra;
+            }
+          }
+        }
+        else if (HAVE_MORECORE) {
+          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
+            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
+          ACQUIRE_MALLOC_GLOBAL_LOCK();
+          {
+            /* Make sure end of memory is where we last set it. */
+            char* old_br = (char*)(CALL_MORECORE(0));
+            if (old_br == sp->base + sp->size) {
+              char* rel_br = (char*)(CALL_MORECORE(-extra));
+              char* new_br = (char*)(CALL_MORECORE(0));
+              if (rel_br != CMFAIL && new_br < old_br)
+                released = old_br - new_br;
+            }
+          }
+          RELEASE_MALLOC_GLOBAL_LOCK();
+        }
+      }
+
+      if (released != 0) {
+        sp->size -= released;
+        m->footprint -= released;
+        init_top(m, m->top, m->topsize - released);
+        check_top_chunk(m, m->top);
+      }
+    }
+
+    /* Unmap any unused mmapped segments */
+    if (HAVE_MMAP)
+      released += release_unused_segments(m);
+
+    /* On failure, disable autotrim to avoid repeated failed future calls */
+    if (released == 0 && m->topsize > m->trim_check)
+      m->trim_check = MAX_SIZE_T;
+  }
+
+  return (released != 0)? 1 : 0;
+}
+
+/* Consolidate and bin a chunk. Differs from exported versions
+   of free mainly in that the chunk need not be marked as inuse.
+*/
+static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
+  mchunkptr next = chunk_plus_offset(p, psize);
+  if (!pinuse(p)) {
+    mchunkptr prev;
+    size_t prevsize = p->prev_foot;
+    if (is_mmapped(p)) {
+      psize += prevsize + MMAP_FOOT_PAD;
+      if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+        m->footprint -= psize;
+      return;
+    }
+    prev = chunk_minus_offset(p, prevsize);
+    psize += prevsize;
+    p = prev;
+    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
+      if (p != m->dv) {
+        unlink_chunk(m, p, prevsize);
+      }
+      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+        m->dvsize = psize;
+        set_free_with_pinuse(p, psize, next);
+        return;
+      }
+    }
+    else {
+      CORRUPTION_ERROR_ACTION(m);
+      return;
+    }
+  }
+  if (RTCHECK(ok_address(m, next))) {
+    if (!cinuse(next)) {  /* consolidate forward */
+      if (next == m->top) {
+        size_t tsize = m->topsize += psize;
+        m->top = p;
+        p->head = tsize | PINUSE_BIT;
+        if (p == m->dv) {
+          m->dv = 0;
+          m->dvsize = 0;
+        }
+        return;
+      }
+      else if (next == m->dv) {
+        size_t dsize = m->dvsize += psize;
+        m->dv = p;
+        set_size_and_pinuse_of_free_chunk(p, dsize);
+        return;
+      }
+      else {
+        size_t nsize = chunksize(next);
+        psize += nsize;
+        unlink_chunk(m, next, nsize);
+        set_size_and_pinuse_of_free_chunk(p, psize);
+        if (p == m->dv) {
+          m->dvsize = psize;
+          return;
+        }
+      }
+    }
+    else {
+      set_free_with_pinuse(p, psize, next);
+    }
+    insert_chunk(m, p, psize);
+  }
+  else {
+    CORRUPTION_ERROR_ACTION(m);
+  }
+}
+
+/* ---------------------------- malloc --------------------------- */
+
+/* allocate a large request from the best fitting chunk in a treebin */
+static void* tmalloc_large(mstate m, size_t nb) {
+  tchunkptr v = 0;
+  size_t rsize = -nb; /* Unsigned negation */
+  tchunkptr t;
+  bindex_t idx;
+  compute_tree_index(nb, idx);
+  if ((t = *treebin_at(m, idx)) != 0) {
+    /* Traverse tree for this bin looking for node with size == nb */
+    size_t sizebits = nb << leftshift_for_tree_index(idx);
+    tchunkptr rst = 0;  /* The deepest untaken right subtree */
+    for (;;) {
+      tchunkptr rt;
+      size_t trem = chunksize(t) - nb;
+      if (trem < rsize) {
+        v = t;
+        if ((rsize = trem) == 0)
+          break;
+      }
+      rt = t->child[1];
+      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
+      if (rt != 0 && rt != t)
+        rst = rt;
+      if (t == 0) {
+        t = rst; /* set t to least subtree holding sizes > nb */
+        break;
+      }
+      sizebits <<= 1;
+    }
+  }
+  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */
+    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
+    if (leftbits != 0) {
+      bindex_t i;
+      binmap_t leastbit = least_bit(leftbits);
+      compute_bit2idx(leastbit, i);
+      t = *treebin_at(m, i);
+    }
+  }
+
+  while (t != 0) { /* find smallest of tree or subtree */
+    size_t trem = chunksize(t) - nb;
+    if (trem < rsize) {
+      rsize = trem;
+      v = t;
+    }
+    t = leftmost_child(t);
+  }
+
+  /*  If dv is a better fit, return 0 so malloc will use it */
+  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
+    if (RTCHECK(ok_address(m, v))) { /* split */
+      mchunkptr r = chunk_plus_offset(v, nb);
+      assert(chunksize(v) == rsize + nb);
+      if (RTCHECK(ok_next(v, r))) {
+        unlink_large_chunk(m, v);
+        if (rsize < MIN_CHUNK_SIZE)
+          set_inuse_and_pinuse(m, v, (rsize + nb));
+        else {
+          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
+          set_size_and_pinuse_of_free_chunk(r, rsize);
+          insert_chunk(m, r, rsize);
+        }
+        return chunk2mem(v);
+      }
+    }
+    CORRUPTION_ERROR_ACTION(m);
+  }
+  return 0;
+}
+
+/* allocate a small request from the best fitting chunk in a treebin */
+static void* tmalloc_small(mstate m, size_t nb) {
+  tchunkptr t, v;
+  size_t rsize;
+  bindex_t i;
+  binmap_t leastbit = least_bit(m->treemap);
+  compute_bit2idx(leastbit, i);
+  v = t = *treebin_at(m, i);
+  rsize = chunksize(t) - nb;
+
+  while ((t = leftmost_child(t)) != 0) {
+    size_t trem = chunksize(t) - nb;
+    if (trem < rsize) {
+      rsize = trem;
+      v = t;
+    }
+  }
+
+  if (RTCHECK(ok_address(m, v))) {
+    mchunkptr r = chunk_plus_offset(v, nb);
+    assert(chunksize(v) == rsize + nb);
+    if (RTCHECK(ok_next(v, r))) {
+      unlink_large_chunk(m, v);
+      if (rsize < MIN_CHUNK_SIZE)
+        set_inuse_and_pinuse(m, v, (rsize + nb));
+      else {
+        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        replace_dv(m, r, rsize);
+      }
+      return chunk2mem(v);
+    }
+  }
+
+  CORRUPTION_ERROR_ACTION(m);
+  return 0;
+}
+
+#if !ONLY_MSPACES
+
+void* dlmalloc(size_t bytes) {
+  /*
+     Basic algorithm:
+     If a small request (< 256 bytes minus per-chunk overhead):
+       1. If one exists, use a remainderless chunk in associated smallbin.
+          (Remainderless means that there are too few excess bytes to
+          represent as a chunk.)
+       2. If it is big enough, use the dv chunk, which is normally the
+          chunk adjacent to the one used for the most recent small request.
+       3. If one exists, split the smallest available chunk in a bin,
+          saving remainder in dv.
+       4. If it is big enough, use the top chunk.
+       5. If available, get memory from system and use it
+     Otherwise, for a large request:
+       1. Find the smallest available binned chunk that fits, and use it
+          if it is better fitting than dv chunk, splitting if necessary.
+       2. If better fitting than any binned chunk, use the dv chunk.
+       3. If it is big enough, use the top chunk.
+       4. If request size >= mmap threshold, try to directly mmap this chunk.
+       5. If available, get memory from system and use it
+
+     The ugly goto's here ensure that postaction occurs along all paths.
+  */
+
+#if USE_LOCKS
+  ensure_initialization(); /* initialize in sys_alloc if not using locks */
+#endif
+
+  if (!PREACTION(gm)) {
+    void* mem;
+    size_t nb;
+    if (bytes <= MAX_SMALL_REQUEST) {
+      bindex_t idx;
+      binmap_t smallbits;
+      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
+      idx = small_index(nb);
+      smallbits = gm->smallmap >> idx;
+
+      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
+        mchunkptr b, p;
+        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
+        b = smallbin_at(gm, idx);
+        p = b->fd;
+        assert(chunksize(p) == small_index2size(idx));
+        unlink_first_small_chunk(gm, b, p, idx);
+        set_inuse_and_pinuse(gm, p, small_index2size(idx));
+        mem = chunk2mem(p);
+        check_malloced_chunk(gm, mem, nb);
+        goto postaction;
+      }
+
+      else if (nb > gm->dvsize) {
+        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
+          mchunkptr b, p, r;
+          size_t rsize;
+          bindex_t i;
+          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
+          binmap_t leastbit = least_bit(leftbits);
+          compute_bit2idx(leastbit, i);
+          b = smallbin_at(gm, i);
+          p = b->fd;
+          assert(chunksize(p) == small_index2size(i));
+          unlink_first_small_chunk(gm, b, p, i);
+          rsize = small_index2size(i) - nb;
+          /* Fit here cannot be remainderless if 4byte sizes */
+          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
+            set_inuse_and_pinuse(gm, p, small_index2size(i));
+          else {
+            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+            r = chunk_plus_offset(p, nb);
+            set_size_and_pinuse_of_free_chunk(r, rsize);
+            replace_dv(gm, r, rsize);
+          }
+          mem = chunk2mem(p);
+          check_malloced_chunk(gm, mem, nb);
+          goto postaction;
+        }
+
+        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
+          check_malloced_chunk(gm, mem, nb);
+          goto postaction;
+        }
+      }
+    }
+    else if (bytes >= MAX_REQUEST)
+      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
+    else {
+      nb = pad_request(bytes);
+      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
+        check_malloced_chunk(gm, mem, nb);
+        goto postaction;
+      }
+    }
+
+    if (nb <= gm->dvsize) {
+      size_t rsize = gm->dvsize - nb;
+      mchunkptr p = gm->dv;
+      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
+        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
+        gm->dvsize = rsize;
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+      }
+      else { /* exhaust dv */
+        size_t dvs = gm->dvsize;
+        gm->dvsize = 0;
+        gm->dv = 0;
+        set_inuse_and_pinuse(gm, p, dvs);
+      }
+      mem = chunk2mem(p);
+      check_malloced_chunk(gm, mem, nb);
+      goto postaction;
+    }
+
+    else if (nb < gm->topsize) { /* Split top */
+      size_t rsize = gm->topsize -= nb;
+      mchunkptr p = gm->top;
+      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+      mem = chunk2mem(p);
+      check_top_chunk(gm, gm->top);
+      check_malloced_chunk(gm, mem, nb);
+      goto postaction;
+    }
+
+    mem = sys_alloc(gm, nb);
+
+  postaction:
+    POSTACTION(gm);
+    return mem;
+  }
+
+  return 0;
+}
+
+/* ---------------------------- free --------------------------- */
+
+void dlfree(void* mem) {
+  /*
+     Consolidate freed chunks with preceeding or succeeding bordering
+     free chunks, if they exist, and then place in a bin.  Intermixed
+     with special cases for top, dv, mmapped chunks, and usage errors.
+  */
+
+  if (mem != 0) {
+    mchunkptr p  = mem2chunk(mem);
+#if FOOTERS
+    mstate fm = get_mstate_for(p);
+    if (!ok_magic(fm)) {
+      USAGE_ERROR_ACTION(fm, p);
+      return;
+    }
+#else /* FOOTERS */
+#define fm gm
+#endif /* FOOTERS */
+    if (!PREACTION(fm)) {
+      check_inuse_chunk(fm, p);
+      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
+        size_t psize = chunksize(p);
+        mchunkptr next = chunk_plus_offset(p, psize);
+        if (!pinuse(p)) {
+          size_t prevsize = p->prev_foot;
+          if (is_mmapped(p)) {
+            psize += prevsize + MMAP_FOOT_PAD;
+            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+              fm->footprint -= psize;
+            goto postaction;
+          }
+          else {
+            mchunkptr prev = chunk_minus_offset(p, prevsize);
+            psize += prevsize;
+            p = prev;
+            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
+              if (p != fm->dv) {
+                unlink_chunk(fm, p, prevsize);
+              }
+              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+                fm->dvsize = psize;
+                set_free_with_pinuse(p, psize, next);
+                goto postaction;
+              }
+            }
+            else
+              goto erroraction;
+          }
+        }
+
+        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
+          if (!cinuse(next)) {  /* consolidate forward */
+            if (next == fm->top) {
+              size_t tsize = fm->topsize += psize;
+              fm->top = p;
+              p->head = tsize | PINUSE_BIT;
+              if (p == fm->dv) {
+                fm->dv = 0;
+                fm->dvsize = 0;
+              }
+              if (should_trim(fm, tsize))
+                sys_trim(fm, 0);
+              goto postaction;
+            }
+            else if (next == fm->dv) {
+              size_t dsize = fm->dvsize += psize;
+              fm->dv = p;
+              set_size_and_pinuse_of_free_chunk(p, dsize);
+              goto postaction;
+            }
+            else {
+              size_t nsize = chunksize(next);
+              psize += nsize;
+              unlink_chunk(fm, next, nsize);
+              set_size_and_pinuse_of_free_chunk(p, psize);
+              if (p == fm->dv) {
+                fm->dvsize = psize;
+                goto postaction;
+              }
+            }
+          }
+          else
+            set_free_with_pinuse(p, psize, next);
+
+          if (is_small(psize)) {
+            insert_small_chunk(fm, p, psize);
+            check_free_chunk(fm, p);
+          }
+          else {
+            tchunkptr tp = (tchunkptr)p;
+            insert_large_chunk(fm, tp, psize);
+            check_free_chunk(fm, p);
+            if (--fm->release_checks == 0)
+              release_unused_segments(fm);
+          }
+          goto postaction;
+        }
+      }
+    erroraction:
+      USAGE_ERROR_ACTION(fm, p);
+    postaction:
+      POSTACTION(fm);
+    }
+  }
+#if !FOOTERS
+#undef fm
+#endif /* FOOTERS */
+}
+
+void* dlcalloc(size_t n_elements, size_t elem_size) {
+  void* mem;
+  size_t req = 0;
+  if (n_elements != 0) {
+    req = n_elements * elem_size;
+    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
+        (req / n_elements != elem_size))
+      req = MAX_SIZE_T; /* force downstream failure on overflow */
+  }
+  mem = dlmalloc(req);
+  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
+    memset(mem, 0, req);
+  return mem;
+}
+
+#endif /* !ONLY_MSPACES */
+
+/* ------------ Internal support for realloc, memalign, etc -------------- */
+
+/* Try to realloc; only in-place unless can_move true */
+static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
+                                   int can_move) {
+  mchunkptr newp = 0;
+  size_t oldsize = chunksize(p);
+  mchunkptr next = chunk_plus_offset(p, oldsize);
+  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
+              ok_next(p, next) && ok_pinuse(next))) {
+    if (is_mmapped(p)) {
+      newp = mmap_resize(m, p, nb, can_move);
+    }
+    else if (oldsize >= nb) {             /* already big enough */
+      size_t rsize = oldsize - nb;
+      if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */
+        mchunkptr r = chunk_plus_offset(p, nb);
+        set_inuse(m, p, nb);
+        set_inuse(m, r, rsize);
+        dispose_chunk(m, r, rsize);
+      }
+      newp = p;
+    }
+    else if (next == m->top) {  /* extend into top */
+      if (oldsize + m->topsize > nb) {
+        size_t newsize = oldsize + m->topsize;
+        size_t newtopsize = newsize - nb;
+        mchunkptr newtop = chunk_plus_offset(p, nb);
+        set_inuse(m, p, nb);
+        newtop->head = newtopsize |PINUSE_BIT;
+        m->top = newtop;
+        m->topsize = newtopsize;
+        newp = p;
+      }
+    }
+    else if (next == m->dv) { /* extend into dv */
+      size_t dvs = m->dvsize;
+      if (oldsize + dvs >= nb) {
+        size_t dsize = oldsize + dvs - nb;
+        if (dsize >= MIN_CHUNK_SIZE) {
+          mchunkptr r = chunk_plus_offset(p, nb);
+          mchunkptr n = chunk_plus_offset(r, dsize);
+          set_inuse(m, p, nb);
+          set_size_and_pinuse_of_free_chunk(r, dsize);
+          clear_pinuse(n);
+          m->dvsize = dsize;
+          m->dv = r;
+        }
+        else { /* exhaust dv */
+          size_t newsize = oldsize + dvs;
+          set_inuse(m, p, newsize);
+          m->dvsize = 0;
+          m->dv = 0;
+        }
+        newp = p;
+      }
+    }
+    else if (!cinuse(next)) { /* extend into next free chunk */
+      size_t nextsize = chunksize(next);
+      if (oldsize + nextsize >= nb) {
+        size_t rsize = oldsize + nextsize - nb;
+        unlink_chunk(m, next, nextsize);
+        if (rsize < MIN_CHUNK_SIZE) {
+          size_t newsize = oldsize + nextsize;
+          set_inuse(m, p, newsize);
+        }
+        else {
+          mchunkptr r = chunk_plus_offset(p, nb);
+          set_inuse(m, p, nb);
+          set_inuse(m, r, rsize);
+          dispose_chunk(m, r, rsize);
+        }
+        newp = p;
+      }
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(m, chunk2mem(p));
+  }
+  return newp;
+}
+
+static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
+  void* mem = 0;
+  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
+    alignment = MIN_CHUNK_SIZE;
+  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
+    size_t a = MALLOC_ALIGNMENT << 1;
+    while (a < alignment) a <<= 1;
+    alignment = a;
+  }
+  if (bytes >= MAX_REQUEST - alignment) {
+    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
+      MALLOC_FAILURE_ACTION;
+    }
+  }
+  else {
+    size_t nb = request2size(bytes);
+    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
+    mem = internal_malloc(m, req);
+    if (mem != 0) {
+      mchunkptr p = mem2chunk(mem);
+      if (PREACTION(m))
+        return 0;
+      if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
+        /*
+          Find an aligned spot inside chunk.  Since we need to give
+          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
+          the first calculation places us at a spot with less than
+          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
+          We've allocated enough total room so that this is always
+          possible.
+        */
+        char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
+                                                       SIZE_T_ONE)) &
+                                             -alignment));
+        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
+          br : br+alignment;
+        mchunkptr newp = (mchunkptr)pos;
+        size_t leadsize = pos - (char*)(p);
+        size_t newsize = chunksize(p) - leadsize;
+
+        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
+          newp->prev_foot = p->prev_foot + leadsize;
+          newp->head = newsize;
+        }
+        else { /* Otherwise, give back leader, use the rest */
+          set_inuse(m, newp, newsize);
+          set_inuse(m, p, leadsize);
+          dispose_chunk(m, p, leadsize);
+        }
+        p = newp;
+      }
+
+      /* Give back spare room at the end */
+      if (!is_mmapped(p)) {
+        size_t size = chunksize(p);
+        if (size > nb + MIN_CHUNK_SIZE) {
+          size_t remainder_size = size - nb;
+          mchunkptr remainder = chunk_plus_offset(p, nb);
+          set_inuse(m, p, nb);
+          set_inuse(m, remainder, remainder_size);
+          dispose_chunk(m, remainder, remainder_size);
+        }
+      }
+
+      mem = chunk2mem(p);
+      assert (chunksize(p) >= nb);
+      assert(((size_t)mem & (alignment - 1)) == 0);
+      check_inuse_chunk(m, p);
+      POSTACTION(m);
+    }
+  }
+  return mem;
+}
+
+/*
+  Common support for independent_X routines, handling
+    all of the combinations that can result.
+  The opts arg has:
+    bit 0 set if all elements are same size (using sizes[0])
+    bit 1 set if elements should be zeroed
+*/
+static void** ialloc(mstate m,
+                     size_t n_elements,
+                     size_t* sizes,
+                     int opts,
+                     void* chunks[]) {
+
+  size_t    element_size;   /* chunksize of each element, if all same */
+  size_t    contents_size;  /* total size of elements */
+  size_t    array_size;     /* request size of pointer array */
+  void*     mem;            /* malloced aggregate space */
+  mchunkptr p;              /* corresponding chunk */
+  size_t    remainder_size; /* remaining bytes while splitting */
+  void**    marray;         /* either "chunks" or malloced ptr array */
+  mchunkptr array_chunk;    /* chunk for malloced ptr array */
+  flag_t    was_enabled;    /* to disable mmap */
+  size_t    size;
+  size_t    i;
+
+  ensure_initialization();
+  /* compute array length, if needed */
+  if (chunks != 0) {
+    if (n_elements == 0)
+      return chunks; /* nothing to do */
+    marray = chunks;
+    array_size = 0;
+  }
+  else {
+    /* if empty req, must still return chunk representing empty array */
+    if (n_elements == 0)
+      return (void**)internal_malloc(m, 0);
+    marray = 0;
+    array_size = request2size(n_elements * (sizeof(void*)));
+  }
+
+  /* compute total element size */
+  if (opts & 0x1) { /* all-same-size */
+    element_size = request2size(*sizes);
+    contents_size = n_elements * element_size;
+  }
+  else { /* add up all the sizes */
+    element_size = 0;
+    contents_size = 0;
+    for (i = 0; i != n_elements; ++i)
+      contents_size += request2size(sizes[i]);
+  }
+
+  size = contents_size + array_size;
+
+  /*
+     Allocate the aggregate chunk.  First disable direct-mmapping so
+     malloc won't use it, since we would not be able to later
+     free/realloc space internal to a segregated mmap region.
+  */
+  was_enabled = use_mmap(m);
+  disable_mmap(m);
+  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
+  if (was_enabled)
+    enable_mmap(m);
+  if (mem == 0)
+    return 0;
+
+  if (PREACTION(m)) return 0;
+  p = mem2chunk(mem);
+  remainder_size = chunksize(p);
+
+  assert(!is_mmapped(p));
+
+  if (opts & 0x2) {       /* optionally clear the elements */
+    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
+  }
+
+  /* If not provided, allocate the pointer array as final part of chunk */
+  if (marray == 0) {
+    size_t  array_chunk_size;
+    array_chunk = chunk_plus_offset(p, contents_size);
+    array_chunk_size = remainder_size - contents_size;
+    marray = (void**) (chunk2mem(array_chunk));
+    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
+    remainder_size = contents_size;
+  }
+
+  /* split out elements */
+  for (i = 0; ; ++i) {
+    marray[i] = chunk2mem(p);
+    if (i != n_elements-1) {
+      if (element_size != 0)
+        size = element_size;
+      else
+        size = request2size(sizes[i]);
+      remainder_size -= size;
+      set_size_and_pinuse_of_inuse_chunk(m, p, size);
+      p = chunk_plus_offset(p, size);
+    }
+    else { /* the final element absorbs any overallocation slop */
+      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);
+      break;
+    }
+  }
+
+#if DEBUG
+  if (marray != chunks) {
+    /* final element must have exactly exhausted chunk */
+    if (element_size != 0) {
+      assert(remainder_size == element_size);
+    }
+    else {
+      assert(remainder_size == request2size(sizes[i]));
+    }
+    check_inuse_chunk(m, mem2chunk(marray));
+  }
+  for (i = 0; i != n_elements; ++i)
+    check_inuse_chunk(m, mem2chunk(marray[i]));
+
+#endif /* DEBUG */
+
+  POSTACTION(m);
+  return marray;
+}
+
+/* Try to free all pointers in the given array.
+   Note: this could be made faster, by delaying consolidation,
+   at the price of disabling some user integrity checks, We
+   still optimize some consolidations by combining adjacent
+   chunks before freeing, which will occur often if allocated
+   with ialloc or the array is sorted.
+*/
+static size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {
+  size_t unfreed = 0;
+  if (!PREACTION(m)) {
+    void** a;
+    void** fence = &(array[nelem]);
+    for (a = array; a != fence; ++a) {
+      void* mem = *a;
+      if (mem != 0) {
+        mchunkptr p = mem2chunk(mem);
+        size_t psize = chunksize(p);
+#if FOOTERS
+        if (get_mstate_for(p) != m) {
+          ++unfreed;
+          continue;
+        }
+#endif
+        check_inuse_chunk(m, p);
+        *a = 0;
+        if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
+          void ** b = a + 1; /* try to merge with next chunk */
+          mchunkptr next = next_chunk(p);
+          if (b != fence && *b == chunk2mem(next)) {
+            size_t newsize = chunksize(next) + psize;
+            set_inuse(m, p, newsize);
+            *b = chunk2mem(p);
+          }
+          else
+            dispose_chunk(m, p, psize);
+        }
+        else {
+          CORRUPTION_ERROR_ACTION(m);
+          break;
+        }
+      }
+    }
+    if (should_trim(m, m->topsize))
+      sys_trim(m, 0);
+    POSTACTION(m);
+  }
+  return unfreed;
+}
+
+/* Traversal */
+#if MALLOC_INSPECT_ALL
+static void internal_inspect_all(mstate m,
+                                 void(*handler)(void *start,
+                                                void *end,
+                                                size_t used_bytes,
+                                                void* callback_arg),
+                                 void* arg) {
+  if (is_initialized(m)) {
+    mchunkptr top = m->top;
+    msegmentptr s;
+    for (s = &m->seg; s != 0; s = s->next) {
+      mchunkptr q = align_as_chunk(s->base);
+      while (segment_holds(s, q) && q->head != FENCEPOST_HEAD) {
+        mchunkptr next = next_chunk(q);
+        size_t sz = chunksize(q);
+        size_t used;
+        void* start;
+        if (is_inuse(q)) {
+          used = sz - CHUNK_OVERHEAD; /* must not be mmapped */
+          start = chunk2mem(q);
+        }
+        else {
+          used = 0;
+          if (is_small(sz)) {     /* offset by possible bookkeeping */
+            start = (void*)((char*)q + sizeof(struct malloc_chunk));
+          }
+          else {
+            start = (void*)((char*)q + sizeof(struct malloc_tree_chunk));
+          }
+        }
+        if (start < (void*)next)  /* skip if all space is bookkeeping */
+          handler(start, next, used, arg);
+        if (q == top)
+          break;
+        q = next;
+      }
+    }
+  }
+}
+#endif /* MALLOC_INSPECT_ALL */
+
+/* ------------------ Exported realloc, memalign, etc -------------------- */
+
+#if !ONLY_MSPACES
+
+void* dlrealloc(void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem == 0) {
+    mem = dlmalloc(bytes);
+  }
+  else if (bytes >= MAX_REQUEST) {
+    MALLOC_FAILURE_ACTION;
+  }
+#ifdef REALLOC_ZERO_BYTES_FREES
+  else if (bytes == 0) {
+    dlfree(oldmem);
+  }
+#endif /* REALLOC_ZERO_BYTES_FREES */
+  else {
+    size_t nb = request2size(bytes);
+    mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+    mstate m = gm;
+#else /* FOOTERS */
+    mstate m = get_mstate_for(oldp);
+    if (!ok_magic(m)) {
+      USAGE_ERROR_ACTION(m, oldmem);
+      return 0;
+    }
+#endif /* FOOTERS */
+    if (!PREACTION(m)) {
+      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
+      POSTACTION(m);
+      if (newp != 0) {
+        check_inuse_chunk(m, newp);
+        mem = chunk2mem(newp);
+      }
+      else {
+        mem = internal_malloc(m, bytes);
+        if (mem != 0) {
+          size_t oc = chunksize(oldp) - overhead_for(oldp);
+          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
+          internal_free(m, oldmem);
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* dlrealloc_in_place(void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem != 0) {
+    if (bytes >= MAX_REQUEST) {
+      MALLOC_FAILURE_ACTION;
+    }
+    else {
+      size_t nb = request2size(bytes);
+      mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+      mstate m = gm;
+#else /* FOOTERS */
+      mstate m = get_mstate_for(oldp);
+      if (!ok_magic(m)) {
+        USAGE_ERROR_ACTION(m, oldmem);
+        return 0;
+      }
+#endif /* FOOTERS */
+      if (!PREACTION(m)) {
+        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
+        POSTACTION(m);
+        if (newp == oldp) {
+          check_inuse_chunk(m, newp);
+          mem = oldmem;
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* dlmemalign(size_t alignment, size_t bytes) {
+  if (alignment <= MALLOC_ALIGNMENT) {
+    return dlmalloc(bytes);
+  }
+  return internal_memalign(gm, alignment, bytes);
+}
+
+int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
+  void* mem = 0;
+  if (alignment == MALLOC_ALIGNMENT)
+    mem = dlmalloc(bytes);
+  else {
+    size_t d = alignment / sizeof(void*);
+    size_t r = alignment % sizeof(void*);
+    if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
+      return EINVAL;
+    else if (bytes <= MAX_REQUEST - alignment) {
+      if (alignment <  MIN_CHUNK_SIZE)
+        alignment = MIN_CHUNK_SIZE;
+      mem = internal_memalign(gm, alignment, bytes);
+    }
+  }
+  if (mem == 0)
+    return ENOMEM;
+  else {
+    *pp = mem;
+    return 0;
+  }
+}
+
+void* dlvalloc(size_t bytes) {
+  size_t pagesz;
+  ensure_initialization();
+  pagesz = mparams.page_size;
+  return dlmemalign(pagesz, bytes);
+}
+
+void* dlpvalloc(size_t bytes) {
+  size_t pagesz;
+  ensure_initialization();
+  pagesz = mparams.page_size;
+  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
+}
+
+void** dlindependent_calloc(size_t n_elements, size_t elem_size,
+                            void* chunks[]) {
+  size_t sz = elem_size; /* serves as 1-element array */
+  return ialloc(gm, n_elements, &sz, 3, chunks);
+}
+
+void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
+                              void* chunks[]) {
+  return ialloc(gm, n_elements, sizes, 0, chunks);
+}
+
+size_t dlbulk_free(void* array[], size_t nelem) {
+  return internal_bulk_free(gm, array, nelem);
+}
+
+#if MALLOC_INSPECT_ALL
+void dlmalloc_inspect_all(void(*handler)(void *start,
+                                         void *end,
+                                         size_t used_bytes,
+                                         void* callback_arg),
+                          void* arg) {
+  ensure_initialization();
+  if (!PREACTION(gm)) {
+    internal_inspect_all(gm, handler, arg);
+    POSTACTION(gm);
+  }
+}
+#endif /* MALLOC_INSPECT_ALL */
+
+int dlmalloc_trim(size_t pad) {
+  int result = 0;
+  ensure_initialization();
+  if (!PREACTION(gm)) {
+    result = sys_trim(gm, pad);
+    POSTACTION(gm);
+  }
+  return result;
+}
+
+size_t dlmalloc_footprint(void) {
+  return gm->footprint;
+}
+
+size_t dlmalloc_max_footprint(void) {
+  return gm->max_footprint;
+}
+
+size_t dlmalloc_footprint_limit(void) {
+  size_t maf = gm->footprint_limit;
+  return maf == 0 ? MAX_SIZE_T : maf;
+}
+
+size_t dlmalloc_set_footprint_limit(size_t bytes) {
+  size_t result;  /* invert sense of 0 */
+  if (bytes == 0)
+    result = granularity_align(1); /* Use minimal size */
+  if (bytes == MAX_SIZE_T)
+    result = 0;                    /* disable */
+  else
+    result = granularity_align(bytes);
+  return gm->footprint_limit = result;
+}
+
+#if !NO_MALLINFO
+struct mallinfo dlmallinfo(void) {
+  return internal_mallinfo(gm);
+}
+#endif /* NO_MALLINFO */
+
+#if !NO_MALLOC_STATS
+void dlmalloc_stats() {
+  internal_malloc_stats(gm);
+}
+#endif /* NO_MALLOC_STATS */
+
+int dlmallopt(int param_number, int value) {
+  return change_mparam(param_number, value);
+}
+
+size_t dlmalloc_usable_size(void* mem) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    if (is_inuse(p))
+      return chunksize(p) - overhead_for(p);
+  }
+  return 0;
+}
+
+#endif /* !ONLY_MSPACES */
+
+/* ----------------------------- user mspaces ---------------------------- */
+
+#if MSPACES
+
+static mstate init_user_mstate(char* tbase, size_t tsize) {
+  size_t msize = pad_request(sizeof(struct malloc_state));
+  mchunkptr mn;
+  mchunkptr msp = align_as_chunk(tbase);
+  mstate m = (mstate)(chunk2mem(msp));
+  memset(m, 0, msize);
+  (void)INITIAL_LOCK(&m->mutex);
+  msp->head = (msize|INUSE_BITS);
+  m->seg.base = m->least_addr = tbase;
+  m->seg.size = m->footprint = m->max_footprint = tsize;
+  m->magic = mparams.magic;
+  m->release_checks = MAX_RELEASE_CHECK_RATE;
+  m->mflags = mparams.default_mflags;
+  m->extp = 0;
+  m->exts = 0;
+  disable_contiguous(m);
+  init_bins(m);
+  mn = next_chunk(mem2chunk(m));
+  init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);
+  check_top_chunk(m, m->top);
+  return m;
+}
+
+mspace create_mspace(size_t capacity, int locked) {
+  mstate m = 0;
+  size_t msize;
+  ensure_initialization();
+  msize = pad_request(sizeof(struct malloc_state));
+  if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
+    size_t rs = ((capacity == 0)? mparams.granularity :
+                 (capacity + TOP_FOOT_SIZE + msize));
+    size_t tsize = granularity_align(rs);
+    char* tbase = (char*)(CALL_MMAP(tsize));
+    if (tbase != CMFAIL) {
+      m = init_user_mstate(tbase, tsize);
+      m->seg.sflags = USE_MMAP_BIT;
+      set_lock(m, locked);
+    }
+  }
+  return (mspace)m;
+}
+
+mspace create_mspace_with_base(void* base, size_t capacity, int locked) {
+  mstate m = 0;
+  size_t msize;
+  ensure_initialization();
+  msize = pad_request(sizeof(struct malloc_state));
+  if (capacity > msize + TOP_FOOT_SIZE &&
+      capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
+    m = init_user_mstate((char*)base, capacity);
+    m->seg.sflags = EXTERN_BIT;
+    set_lock(m, locked);
+  }
+  return (mspace)m;
+}
+
+int mspace_track_large_chunks(mspace msp, int enable) {
+  int ret = 0;
+  mstate ms = (mstate)msp;
+  if (!PREACTION(ms)) {
+    if (!use_mmap(ms)) {
+      ret = 1;
+    }
+    if (!enable) {
+      enable_mmap(ms);
+    } else {
+      disable_mmap(ms);
+    }
+    POSTACTION(ms);
+  }
+  return ret;
+}
+
+size_t destroy_mspace(mspace msp) {
+  size_t freed = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    msegmentptr sp = &ms->seg;
+    (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */
+    while (sp != 0) {
+      char* base = sp->base;
+      size_t size = sp->size;
+      flag_t flag = sp->sflags;
+      (void)base; /* placate people compiling -Wunused-variable */
+      sp = sp->next;
+      if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&
+          CALL_MUNMAP(base, size) == 0)
+        freed += size;
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return freed;
+}
+
+/*
+  mspace versions of routines are near-clones of the global
+  versions. This is not so nice but better than the alternatives.
+*/
+
+void* mspace_malloc(mspace msp, size_t bytes) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (!PREACTION(ms)) {
+    void* mem;
+    size_t nb;
+    if (bytes <= MAX_SMALL_REQUEST) {
+      bindex_t idx;
+      binmap_t smallbits;
+      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
+      idx = small_index(nb);
+      smallbits = ms->smallmap >> idx;
+
+      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
+        mchunkptr b, p;
+        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
+        b = smallbin_at(ms, idx);
+        p = b->fd;
+        assert(chunksize(p) == small_index2size(idx));
+        unlink_first_small_chunk(ms, b, p, idx);
+        set_inuse_and_pinuse(ms, p, small_index2size(idx));
+        mem = chunk2mem(p);
+        check_malloced_chunk(ms, mem, nb);
+        goto postaction;
+      }
+
+      else if (nb > ms->dvsize) {
+        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
+          mchunkptr b, p, r;
+          size_t rsize;
+          bindex_t i;
+          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
+          binmap_t leastbit = least_bit(leftbits);
+          compute_bit2idx(leastbit, i);
+          b = smallbin_at(ms, i);
+          p = b->fd;
+          assert(chunksize(p) == small_index2size(i));
+          unlink_first_small_chunk(ms, b, p, i);
+          rsize = small_index2size(i) - nb;
+          /* Fit here cannot be remainderless if 4byte sizes */
+          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
+            set_inuse_and_pinuse(ms, p, small_index2size(i));
+          else {
+            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+            r = chunk_plus_offset(p, nb);
+            set_size_and_pinuse_of_free_chunk(r, rsize);
+            replace_dv(ms, r, rsize);
+          }
+          mem = chunk2mem(p);
+          check_malloced_chunk(ms, mem, nb);
+          goto postaction;
+        }
+
+        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
+          check_malloced_chunk(ms, mem, nb);
+          goto postaction;
+        }
+      }
+    }
+    else if (bytes >= MAX_REQUEST)
+      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
+    else {
+      nb = pad_request(bytes);
+      if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {
+        check_malloced_chunk(ms, mem, nb);
+        goto postaction;
+      }
+    }
+
+    if (nb <= ms->dvsize) {
+      size_t rsize = ms->dvsize - nb;
+      mchunkptr p = ms->dv;
+      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
+        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
+        ms->dvsize = rsize;
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+      }
+      else { /* exhaust dv */
+        size_t dvs = ms->dvsize;
+        ms->dvsize = 0;
+        ms->dv = 0;
+        set_inuse_and_pinuse(ms, p, dvs);
+      }
+      mem = chunk2mem(p);
+      check_malloced_chunk(ms, mem, nb);
+      goto postaction;
+    }
+
+    else if (nb < ms->topsize) { /* Split top */
+      size_t rsize = ms->topsize -= nb;
+      mchunkptr p = ms->top;
+      mchunkptr r = ms->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+      mem = chunk2mem(p);
+      check_top_chunk(ms, ms->top);
+      check_malloced_chunk(ms, mem, nb);
+      goto postaction;
+    }
+
+    mem = sys_alloc(ms, nb);
+
+  postaction:
+    POSTACTION(ms);
+    return mem;
+  }
+
+  return 0;
+}
+
+void mspace_free(mspace msp, void* mem) {
+  if (mem != 0) {
+    mchunkptr p  = mem2chunk(mem);
+#if FOOTERS
+    mstate fm = get_mstate_for(p);
+    (void)msp; /* placate people compiling -Wunused */
+#else /* FOOTERS */
+    mstate fm = (mstate)msp;
+#endif /* FOOTERS */
+    if (!ok_magic(fm)) {
+      USAGE_ERROR_ACTION(fm, p);
+      return;
+    }
+    if (!PREACTION(fm)) {
+      check_inuse_chunk(fm, p);
+      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
+        size_t psize = chunksize(p);
+        mchunkptr next = chunk_plus_offset(p, psize);
+        if (!pinuse(p)) {
+          size_t prevsize = p->prev_foot;
+          if (is_mmapped(p)) {
+            psize += prevsize + MMAP_FOOT_PAD;
+            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+              fm->footprint -= psize;
+            goto postaction;
+          }
+          else {
+            mchunkptr prev = chunk_minus_offset(p, prevsize);
+            psize += prevsize;
+            p = prev;
+            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
+              if (p != fm->dv) {
+                unlink_chunk(fm, p, prevsize);
+              }
+              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+                fm->dvsize = psize;
+                set_free_with_pinuse(p, psize, next);
+                goto postaction;
+              }
+            }
+            else
+              goto erroraction;
+          }
+        }
+
+        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
+          if (!cinuse(next)) {  /* consolidate forward */
+            if (next == fm->top) {
+              size_t tsize = fm->topsize += psize;
+              fm->top = p;
+              p->head = tsize | PINUSE_BIT;
+              if (p == fm->dv) {
+                fm->dv = 0;
+                fm->dvsize = 0;
+              }
+              if (should_trim(fm, tsize))
+                sys_trim(fm, 0);
+              goto postaction;
+            }
+            else if (next == fm->dv) {
+              size_t dsize = fm->dvsize += psize;
+              fm->dv = p;
+              set_size_and_pinuse_of_free_chunk(p, dsize);
+              goto postaction;
+            }
+            else {
+              size_t nsize = chunksize(next);
+              psize += nsize;
+              unlink_chunk(fm, next, nsize);
+              set_size_and_pinuse_of_free_chunk(p, psize);
+              if (p == fm->dv) {
+                fm->dvsize = psize;
+                goto postaction;
+              }
+            }
+          }
+          else
+            set_free_with_pinuse(p, psize, next);
+
+          if (is_small(psize)) {
+            insert_small_chunk(fm, p, psize);
+            check_free_chunk(fm, p);
+          }
+          else {
+            tchunkptr tp = (tchunkptr)p;
+            insert_large_chunk(fm, tp, psize);
+            check_free_chunk(fm, p);
+            if (--fm->release_checks == 0)
+              release_unused_segments(fm);
+          }
+          goto postaction;
+        }
+      }
+    erroraction:
+      USAGE_ERROR_ACTION(fm, p);
+    postaction:
+      POSTACTION(fm);
+    }
+  }
+}
+
+void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {
+  void* mem;
+  size_t req = 0;
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (n_elements != 0) {
+    req = n_elements * elem_size;
+    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
+        (req / n_elements != elem_size))
+      req = MAX_SIZE_T; /* force downstream failure on overflow */
+  }
+  mem = internal_malloc(ms, req);
+  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
+    memset(mem, 0, req);
+  return mem;
+}
+
+void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem == 0) {
+    mem = mspace_malloc(msp, bytes);
+  }
+  else if (bytes >= MAX_REQUEST) {
+    MALLOC_FAILURE_ACTION;
+  }
+#ifdef REALLOC_ZERO_BYTES_FREES
+  else if (bytes == 0) {
+    mspace_free(msp, oldmem);
+  }
+#endif /* REALLOC_ZERO_BYTES_FREES */
+  else {
+    size_t nb = request2size(bytes);
+    mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+    mstate m = (mstate)msp;
+#else /* FOOTERS */
+    mstate m = get_mstate_for(oldp);
+    if (!ok_magic(m)) {
+      USAGE_ERROR_ACTION(m, oldmem);
+      return 0;
+    }
+#endif /* FOOTERS */
+    if (!PREACTION(m)) {
+      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
+      POSTACTION(m);
+      if (newp != 0) {
+        check_inuse_chunk(m, newp);
+        mem = chunk2mem(newp);
+      }
+      else {
+        mem = mspace_malloc(m, bytes);
+        if (mem != 0) {
+          size_t oc = chunksize(oldp) - overhead_for(oldp);
+          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
+          mspace_free(m, oldmem);
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem != 0) {
+    if (bytes >= MAX_REQUEST) {
+      MALLOC_FAILURE_ACTION;
+    }
+    else {
+      size_t nb = request2size(bytes);
+      mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+      mstate m = (mstate)msp;
+#else /* FOOTERS */
+      mstate m = get_mstate_for(oldp);
+      (void)msp; /* placate people compiling -Wunused */
+      if (!ok_magic(m)) {
+        USAGE_ERROR_ACTION(m, oldmem);
+        return 0;
+      }
+#endif /* FOOTERS */
+      if (!PREACTION(m)) {
+        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
+        POSTACTION(m);
+        if (newp == oldp) {
+          check_inuse_chunk(m, newp);
+          mem = oldmem;
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (alignment <= MALLOC_ALIGNMENT)
+    return mspace_malloc(msp, bytes);
+  return internal_memalign(ms, alignment, bytes);
+}
+
+void** mspace_independent_calloc(mspace msp, size_t n_elements,
+                                 size_t elem_size, void* chunks[]) {
+  size_t sz = elem_size; /* serves as 1-element array */
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return ialloc(ms, n_elements, &sz, 3, chunks);
+}
+
+void** mspace_independent_comalloc(mspace msp, size_t n_elements,
+                                   size_t sizes[], void* chunks[]) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return ialloc(ms, n_elements, sizes, 0, chunks);
+}
+
+size_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {
+  return internal_bulk_free((mstate)msp, array, nelem);
+}
+
+#if MALLOC_INSPECT_ALL
+void mspace_inspect_all(mspace msp,
+                        void(*handler)(void *start,
+                                       void *end,
+                                       size_t used_bytes,
+                                       void* callback_arg),
+                        void* arg) {
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (!PREACTION(ms)) {
+      internal_inspect_all(ms, handler, arg);
+      POSTACTION(ms);
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+}
+#endif /* MALLOC_INSPECT_ALL */
+
+int mspace_trim(mspace msp, size_t pad) {
+  int result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (!PREACTION(ms)) {
+      result = sys_trim(ms, pad);
+      POSTACTION(ms);
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+#if !NO_MALLOC_STATS
+void mspace_malloc_stats(mspace msp) {
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    internal_malloc_stats(ms);
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+}
+#endif /* NO_MALLOC_STATS */
+
+size_t mspace_footprint(mspace msp) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    result = ms->footprint;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+size_t mspace_max_footprint(mspace msp) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    result = ms->max_footprint;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+size_t mspace_footprint_limit(mspace msp) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    size_t maf = ms->footprint_limit;
+    result = (maf == 0) ? MAX_SIZE_T : maf;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+size_t mspace_set_footprint_limit(mspace msp, size_t bytes) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (bytes == 0)
+      result = granularity_align(1); /* Use minimal size */
+    if (bytes == MAX_SIZE_T)
+      result = 0;                    /* disable */
+    else
+      result = granularity_align(bytes);
+    ms->footprint_limit = result;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+#if !NO_MALLINFO
+struct mallinfo mspace_mallinfo(mspace msp) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return internal_mallinfo(ms);
+}
+#endif /* NO_MALLINFO */
+
+size_t mspace_usable_size(const void* mem) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    if (is_inuse(p))
+      return chunksize(p) - overhead_for(p);
+  }
+  return 0;
+}
+
+int mspace_mallopt(int param_number, int value) {
+  return change_mparam(param_number, value);
+}
+
+#endif /* MSPACES */
+
+
+/* -------------------- Alternative MORECORE functions ------------------- */
+
+/*
+  Guidelines for creating a custom version of MORECORE:
+
+  * For best performance, MORECORE should allocate in multiples of pagesize.
+  * MORECORE may allocate more memory than requested. (Or even less,
+      but this will usually result in a malloc failure.)
+  * MORECORE must not allocate memory when given argument zero, but
+      instead return one past the end address of memory from previous
+      nonzero call.
+  * For best performance, consecutive calls to MORECORE with positive
+      arguments should return increasing addresses, indicating that
+      space has been contiguously extended.
+  * Even though consecutive calls to MORECORE need not return contiguous
+      addresses, it must be OK for malloc'ed chunks to span multiple
+      regions in those cases where they do happen to be contiguous.
+  * MORECORE need not handle negative arguments -- it may instead
+      just return MFAIL when given negative arguments.
+      Negative arguments are always multiples of pagesize. MORECORE
+      must not misinterpret negative args as large positive unsigned
+      args. You can suppress all such calls from even occurring by defining
+      MORECORE_CANNOT_TRIM,
+
+  As an example alternative MORECORE, here is a custom allocator
+  kindly contributed for pre-OSX macOS.  It uses virtually but not
+  necessarily physically contiguous non-paged memory (locked in,
+  present and won't get swapped out).  You can use it by uncommenting
+  this section, adding some #includes, and setting up the appropriate
+  defines above:
+
+      #define MORECORE osMoreCore
+
+  There is also a shutdown routine that should somehow be called for
+  cleanup upon program exit.
+
+  #define MAX_POOL_ENTRIES 100
+  #define MINIMUM_MORECORE_SIZE  (64 * 1024U)
+  static int next_os_pool;
+  void *our_os_pools[MAX_POOL_ENTRIES];
+
+  void *osMoreCore(int size)
+  {
+    void *ptr = 0;
+    static void *sbrk_top = 0;
+
+    if (size > 0)
+    {
+      if (size < MINIMUM_MORECORE_SIZE)
+         size = MINIMUM_MORECORE_SIZE;
+      if (CurrentExecutionLevel() == kTaskLevel)
+         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
+      if (ptr == 0)
+      {
+        return (void *) MFAIL;
+      }
+      // save ptrs so they can be freed during cleanup
+      our_os_pools[next_os_pool] = ptr;
+      next_os_pool++;
+      ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);
+      sbrk_top = (char *) ptr + size;
+      return ptr;
+    }
+    else if (size < 0)
+    {
+      // we don't currently support shrink behavior
+      return (void *) MFAIL;
+    }
+    else
+    {
+      return sbrk_top;
+    }
+  }
+
+  // cleanup any allocated memory pools
+  // called as last thing before shutting down driver
+
+  void osCleanupMem(void)
+  {
+    void **ptr;
+
+    for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)
+      if (*ptr)
+      {
+         PoolDeallocate(*ptr);
+         *ptr = 0;
+      }
+  }
+
+*/
+
+
+/* -----------------------------------------------------------------------
+History:
+    v2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
+      * fix bad comparison in dlposix_memalign
+      * don't reuse adjusted asize in sys_alloc
+      * add LOCK_AT_FORK -- thanks to Kirill Artamonov for the suggestion
+      * reduce compiler warnings -- thanks to all who reported/suggested these
+
+    v2.8.5 Sun May 22 10:26:02 2011  Doug Lea  (dl at gee)
+      * Always perform unlink checks unless INSECURE
+      * Add posix_memalign.
+      * Improve realloc to expand in more cases; expose realloc_in_place.
+        Thanks to Peter Buhr for the suggestion.
+      * Add footprint_limit, inspect_all, bulk_free. Thanks
+        to Barry Hayes and others for the suggestions.
+      * Internal refactorings to avoid calls while holding locks
+      * Use non-reentrant locks by default. Thanks to Roland McGrath
+        for the suggestion.
+      * Small fixes to mspace_destroy, reset_on_error.
+      * Various configuration extensions/changes. Thanks
+         to all who contributed these.
+
+    V2.8.4a Thu Apr 28 14:39:43 2011 (dl at gee.cs.oswego.edu)
+      * Update Creative Commons URL
+
+    V2.8.4 Wed May 27 09:56:23 2009  Doug Lea  (dl at gee)
+      * Use zeros instead of prev foot for is_mmapped
+      * Add mspace_track_large_chunks; thanks to Jean Brouwers
+      * Fix set_inuse in internal_realloc; thanks to Jean Brouwers
+      * Fix insufficient sys_alloc padding when using 16byte alignment
+      * Fix bad error check in mspace_footprint
+      * Adaptations for ptmalloc; thanks to Wolfram Gloger.
+      * Reentrant spin locks; thanks to Earl Chew and others
+      * Win32 improvements; thanks to Niall Douglas and Earl Chew
+      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
+      * Extension hook in malloc_state
+      * Various small adjustments to reduce warnings on some compilers
+      * Various configuration extensions/changes for more platforms. Thanks
+         to all who contributed these.
+
+    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
+      * Add max_footprint functions
+      * Ensure all appropriate literals are size_t
+      * Fix conditional compilation problem for some #define settings
+      * Avoid concatenating segments with the one provided
+        in create_mspace_with_base
+      * Rename some variables to avoid compiler shadowing warnings
+      * Use explicit lock initialization.
+      * Better handling of sbrk interference.
+      * Simplify and fix segment insertion, trimming and mspace_destroy
+      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
+      * Thanks especially to Dennis Flanagan for help on these.
+
+    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
+      * Fix memalign brace error.
+
+    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)
+      * Fix improper #endif nesting in C++
+      * Add explicit casts needed for C++
+
+    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)
+      * Use trees for large bins
+      * Support mspaces
+      * Use segments to unify sbrk-based and mmap-based system allocation,
+        removing need for emulation on most platforms without sbrk.
+      * Default safety checks
+      * Optional footer checks. Thanks to William Robertson for the idea.
+      * Internal code refactoring
+      * Incorporate suggestions and platform-specific changes.
+        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
+        Aaron Bachmann,  Emery Berger, and others.
+      * Speed up non-fastbin processing enough to remove fastbins.
+      * Remove useless cfree() to avoid conflicts with other apps.
+      * Remove internal memcpy, memset. Compilers handle builtins better.
+      * Remove some options that no one ever used and rename others.
+
+    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
+      * Fix malloc_state bitmap array misdeclaration
+
+    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
+      * Allow tuning of FIRST_SORTED_BIN_SIZE
+      * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.
+      * Better detection and support for non-contiguousness of MORECORE.
+        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
+      * Bypass most of malloc if no frees. Thanks To Emery Berger.
+      * Fix freeing of old top non-contiguous chunk im sysmalloc.
+      * Raised default trim and map thresholds to 256K.
+      * Fix mmap-related #defines. Thanks to Lubos Lunak.
+      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.
+      * Branch-free bin calculation
+      * Default trim and mmap thresholds now 256K.
+
+    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)
+      * Introduce independent_comalloc and independent_calloc.
+        Thanks to Michael Pachos for motivation and help.
+      * Make optional .h file available
+      * Allow > 2GB requests on 32bit systems.
+      * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.
+        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
+        and Anonymous.
+      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for
+        helping test this.)
+      * memalign: check alignment arg
+      * realloc: don't try to shift chunks backwards, since this
+        leads to  more fragmentation in some programs and doesn't
+        seem to help in any others.
+      * Collect all cases in malloc requiring system memory into sysmalloc
+      * Use mmap as backup to sbrk
+      * Place all internal state in malloc_state
+      * Introduce fastbins (although similar to 2.5.1)
+      * Many minor tunings and cosmetic improvements
+      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK
+      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS
+        Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.
+      * Include errno.h to support default failure action.
+
+    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
+      * return null for negative arguments
+      * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>
+         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
+          (e.g. WIN32 platforms)
+         * Cleanup header file inclusion for WIN32 platforms
+         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
+         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
+           memory allocation routines
+         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
+         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
+           usage of 'assert' in non-WIN32 code
+         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
+           avoid infinite loop
+      * Always call 'fREe()' rather than 'free()'
+
+    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
+      * Fixed ordering problem with boundary-stamping
+
+    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
+      * Added pvalloc, as recommended by H.J. Liu
+      * Added 64bit pointer support mainly from Wolfram Gloger
+      * Added anonymously donated WIN32 sbrk emulation
+      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
+      * malloc_extend_top: fix mask error that caused wastage after
+        foreign sbrks
+      * Add linux mremap support code from HJ Liu
+
+    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
+      * Integrated most documentation with the code.
+      * Add support for mmap, with help from
+        Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
+      * Use last_remainder in more cases.
+      * Pack bins using idea from  colin@nyx10.cs.du.edu
+      * Use ordered bins instead of best-fit threshhold
+      * Eliminate block-local decls to simplify tracing and debugging.
+      * Support another case of realloc via move into top
+      * Fix error occuring when initial sbrk_base not word-aligned.
+      * Rely on page size for units instead of SBRK_UNIT to
+        avoid surprises about sbrk alignment conventions.
+      * Add mallinfo, mallopt. Thanks to Raymond Nijssen
+        (raymond@es.ele.tue.nl) for the suggestion.
+      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
+      * More precautions for cases where other routines call sbrk,
+        courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
+      * Added macros etc., allowing use in linux libc from
+        H.J. Lu (hjl@gnu.ai.mit.edu)
+      * Inverted this history list
+
+    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
+      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
+      * Removed all preallocation code since under current scheme
+        the work required to undo bad preallocations exceeds
+        the work saved in good cases for most test programs.
+      * No longer use return list or unconsolidated bins since
+        no scheme using them consistently outperforms those that don't
+        given above changes.
+      * Use best fit for very large chunks to prevent some worst-cases.
+      * Added some support for debugging
+
+    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
+      * Removed footers when chunks are in use. Thanks to
+        Paul Wilson (wilson@cs.texas.edu) for the suggestion.
+
+    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
+      * Added malloc_trim, with help from Wolfram Gloger
+        (wmglo@Dent.MED.Uni-Muenchen.DE).
+
+    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)
+
+    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
+      * realloc: try to expand in both directions
+      * malloc: swap order of clean-bin strategy;
+      * realloc: only conditionally expand backwards
+      * Try not to scavenge used bins
+      * Use bin counts as a guide to preallocation
+      * Occasionally bin return list chunks in first scan
+      * Add a few optimizations from colin@nyx10.cs.du.edu
+
+    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
+      * faster bin computation & slightly different binning
+      * merged all consolidations to one part of malloc proper
+         (eliminating old malloc_find_space & malloc_clean_bin)
+      * Scan 2 returns chunks (not just 1)
+      * Propagate failure in realloc if malloc returns 0
+      * Add stuff to allow compilation on non-ANSI compilers
+          from kpv@research.att.com
+
+    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
+      * removed potential for odd address access in prev_chunk
+      * removed dependency on getpagesize.h
+      * misc cosmetics and a bit more internal documentation
+      * anticosmetics: mangled names in macros to evade debugger strangeness
+      * tested on sparc, hp-700, dec-mips, rs6000
+          with gcc & native cc (hp, dec only) allowing
+          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
+
+    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
+      * Based loosely on libg++-1.2X malloc. (It retains some of the overall
+         structure of old version,  but most details differ.)
+
+*/
+
+
+
+void *malloc(size_t bytes)
+{
+  return dlmalloc(bytes);
+}
+
+void free(void *ptr)
+{
+  return dlfree(ptr);
+}
+
+void* realloc(void* oldmem, size_t bytes)
+{
+  return dlrealloc(oldmem, bytes);
+}
+
+
+void* calloc(size_t nelem, size_t bytes)
+{
+  return dlcalloc(nelem, bytes);
+}
+
+/*
+ * Reentrant memory management functions needed by Newlib.
+ */
+
+void *_malloc_r (struct _reent *r, size_t size)
+{
+    return malloc (size);
+}
+
+
+void _free_r (struct _reent *r, void *ptr)
+{
+    free (ptr);
+}
+
+
+void *_calloc_r (struct _reent *r, size_t nelem, size_t elsize)
+{
+    return calloc (nelem, elsize);
+}
+
+
+void *_realloc_r (struct _reent *r, void *ptr, size_t size)
+{
+    return realloc (ptr, size);
+}
+
+
+void *__mempcpy(void *dst, void *src, size_t sz)
+{
+  return memcpy(dst, src, sz);
+}
+
+
+
+/* @brief Simple sbrk implementation, not guaranteed to be contiguous.
+ * 
+ */
+#if 0 
+static void *cheviot_sbrk(ssize_t sz)
+{
+    void *mem;
+    static void *sbrk_end = (void *)0x60000000;
+
+    if (sz < 0) {
+	    return (void *) MFAIL;
+    } else if (sz == 0) {
+        return sbrk_end;  
+    }
+    
+    mem = _swi_virtualalloc (0x60000000, sz, PROT_READWRITE);
+    sbrk_end = mem + sz;
+    return mem;
+}
+
+#else
+
+#define MINIMUM_MORECORE_SIZE  (64 * 1024U)
+
+
+#define ALIGN_UP(val, alignment)                                               \
+  ((((val) + (alignment)-1) / (alignment)) * (alignment))
+
+
+void *cheviot_sbrk(int size)
+{
+  static uint8_t *sbrk_end = NULL;
+	static uint8_t *sbrk_current = NULL;
+	uint8_t *mem = 0;
+  void *ptr = 0;
+ 	int morecore_size;
+ 	
+  if (size > 0)
+  { 
+  	size = ALIGN_UP(size, 32);
+   	
+  	if ((sbrk_end - sbrk_current) < size) {
+    	
+    	morecore_size = (size > MINIMUM_MORECORE_SIZE) ? size : MINIMUM_MORECORE_SIZE;
+    	
+    	mem = _swi_virtualalloc (0x50000000, morecore_size, PROT_READWRITE);
+
+			if (mem != NULL) {
+				ptr = mem;
+				sbrk_current = mem + size;
+				sbrk_end = mem + morecore_size;
+				return ptr;
+			} else {
+	      return (void *)MFAIL;
+			}
+  	} else {
+  		ptr = sbrk_current;
+  		sbrk_current += size;
+  		return ptr;
+  	}  	  
+  }
+  else if (size < 0)
+  {
+    // we don't currently support shrink behavior
+    return (void *)MFAIL;
+  }
+  else
+  {
+    return sbrk_current;
+  }
+}
+
+#endif
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/merge.c third_party/newlib-4.1.0/newlib/libc/sys/arm/merge.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/merge.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/merge.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,359 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Peter McIlroy.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)merge.c	8.2 (Berkeley) 2/14/94";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+/*
+ * Hybrid exponential search/linear search merge sort with hybrid
+ * natural/pairwise first pass.  Requires about .3% more comparisons
+ * for random data than LSMS with pairwise first pass alone.
+ * It works for objects as small as two bytes.
+ */
+
+#define NATURAL
+#define THRESHOLD 16	/* Best choice for natural merge cut-off. */
+
+/* #define NATURAL to get hybrid natural merge.
+ * (The default is pairwise merging.)
+ */
+
+#include <sys/types.h>
+#include <sys/param.h>
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stdint.h>
+
+#include "compat.h"
+
+#ifdef I_AM_MERGESORT_B
+#include "block_abi.h"
+#define	DECLARE_CMP	DECLARE_BLOCK(int, cmp, const void *, const void *)
+typedef DECLARE_BLOCK(int, cmp_t, const void *, const void *);
+#define	CMP(x, y)	CALL_BLOCK(cmp, x, y)
+#else
+typedef int (*cmp_t)(const void *, const void *);
+#define	CMP(x, y)	cmp(x, y)
+#endif
+
+static void setup(u_char *, u_char *, size_t, size_t, cmp_t);
+static void insertionsort(u_char *, size_t, size_t, cmp_t);
+
+#define ISIZE sizeof(int)
+#define PSIZE sizeof(u_char *)
+#define ICOPY_LIST(src, dst, last)				\
+	do							\
+	*(int*)dst = *(int*)src, src += ISIZE, dst += ISIZE;	\
+	while(src < last)
+#define ICOPY_ELT(src, dst, i)					\
+	do							\
+	*(int*) dst = *(int*) src, src += ISIZE, dst += ISIZE;	\
+	while (i -= ISIZE)
+
+#define CCOPY_LIST(src, dst, last)		\
+	do					\
+		*dst++ = *src++;		\
+	while (src < last)
+#define CCOPY_ELT(src, dst, i)			\
+	do					\
+		*dst++ = *src++;		\
+	while (i -= 1)
+
+/*
+ * Find the next possible pointer head.  (Trickery for forcing an array
+ * to do double duty as a linked list when objects do not align with word
+ * boundaries.
+ */
+/* Assumption: PSIZE is a power of 2. */
+#define EVAL(p) (u_char **)roundup2((uintptr_t)p, PSIZE)
+
+#ifdef I_AM_MERGESORT_B
+int mergesort_b(void *, size_t, size_t, cmp_t);
+#else
+int mergesort(void *, size_t, size_t, cmp_t);
+#endif
+
+/*
+ * Arguments are as for qsort.
+ */
+int
+#ifdef I_AM_MERGESORT_B
+mergesort_b(void *base, size_t nmemb, size_t size, cmp_t cmp)
+#else
+mergesort(void *base, size_t nmemb, size_t size, cmp_t cmp)
+#endif
+{
+	size_t i;
+	int sense;
+	int big, iflag;
+	u_char *f1, *f2, *t, *b, *tp2, *q, *l1, *l2;
+	u_char *list2, *list1, *p2, *p, *last, **p1;
+
+	if (size < PSIZE / 2) {		/* Pointers must fit into 2 * size. */
+		errno = EINVAL;
+		return (-1);
+	}
+
+	if (nmemb == 0)
+		return (0);
+
+	iflag = 0;
+	if (!(size % ISIZE) && !(((char *)base - (char *)0) % ISIZE))
+		iflag = 1;
+
+	if ((list2 = malloc(nmemb * size + PSIZE)) == NULL)
+		return (-1);
+
+	list1 = base;
+	setup(list1, list2, nmemb, size, cmp);
+	last = list2 + nmemb * size;
+	i = big = 0;
+	while (*EVAL(list2) != last) {
+	    l2 = list1;
+	    p1 = EVAL(list1);
+	    for (tp2 = p2 = list2; p2 != last; p1 = EVAL(l2)) {
+	    	p2 = *EVAL(p2);
+	    	f1 = l2;
+	    	f2 = l1 = list1 + (p2 - list2);
+	    	if (p2 != last)
+	    		p2 = *EVAL(p2);
+	    	l2 = list1 + (p2 - list2);
+	    	while (f1 < l1 && f2 < l2) {
+	    		if (CMP(f1, f2) <= 0) {
+	    			q = f2;
+	    			b = f1, t = l1;
+	    			sense = -1;
+	    		} else {
+	    			q = f1;
+	    			b = f2, t = l2;
+	    			sense = 0;
+	    		}
+	    		if (!big) {	/* here i = 0 */
+				while ((b += size) < t && CMP(q, b) >sense)
+	    				if (++i == 6) {
+	    					big = 1;
+	    					goto EXPONENTIAL;
+	    				}
+	    		} else {
+EXPONENTIAL:	    		for (i = size; ; i <<= 1)
+	    				if ((p = (b + i)) >= t) {
+	    					if ((p = t - size) > b &&
+						    CMP(q, p) <= sense)
+	    						t = p;
+	    					else
+	    						b = p;
+	    					break;
+	    				} else if (CMP(q, p) <= sense) {
+	    					t = p;
+	    					if (i == size)
+	    						big = 0;
+	    					goto FASTCASE;
+	    				} else
+	    					b = p;
+				while (t > b+size) {
+	    				i = (((t - b) / size) >> 1) * size;
+	    				if (CMP(q, p = b + i) <= sense)
+	    					t = p;
+	    				else
+	    					b = p;
+	    			}
+	    			goto COPY;
+FASTCASE:	    		while (i > size)
+	    				if (CMP(q,
+	    					p = b + (i >>= 1)) <= sense)
+	    					t = p;
+	    				else
+	    					b = p;
+COPY:	    			b = t;
+	    		}
+	    		i = size;
+	    		if (q == f1) {
+	    			if (iflag) {
+	    				ICOPY_LIST(f2, tp2, b);
+	    				ICOPY_ELT(f1, tp2, i);
+	    			} else {
+	    				CCOPY_LIST(f2, tp2, b);
+	    				CCOPY_ELT(f1, tp2, i);
+	    			}
+	    		} else {
+	    			if (iflag) {
+	    				ICOPY_LIST(f1, tp2, b);
+	    				ICOPY_ELT(f2, tp2, i);
+	    			} else {
+	    				CCOPY_LIST(f1, tp2, b);
+	    				CCOPY_ELT(f2, tp2, i);
+	    			}
+	    		}
+	    	}
+	    	if (f2 < l2) {
+	    		if (iflag)
+	    			ICOPY_LIST(f2, tp2, l2);
+	    		else
+	    			CCOPY_LIST(f2, tp2, l2);
+	    	} else if (f1 < l1) {
+	    		if (iflag)
+	    			ICOPY_LIST(f1, tp2, l1);
+	    		else
+	    			CCOPY_LIST(f1, tp2, l1);
+	    	}
+	    	*p1 = l2;
+	    }
+	    tp2 = list1;	/* swap list1, list2 */
+	    list1 = list2;
+	    list2 = tp2;
+	    last = list2 + nmemb*size;
+	}
+	if (base == list2) {
+		memmove(list2, list1, nmemb*size);
+		list2 = list1;
+	}
+	free(list2);
+	return (0);
+}
+
+#define	swap(a, b) {					\
+		s = b;					\
+		i = size;				\
+		do {					\
+			tmp = *a; *a++ = *s; *s++ = tmp; \
+		} while (--i);				\
+		a -= size;				\
+	}
+#define reverse(bot, top) {				\
+	s = top;					\
+	do {						\
+		i = size;				\
+		do {					\
+			tmp = *bot; *bot++ = *s; *s++ = tmp; \
+		} while (--i);				\
+		s -= size2;				\
+	} while(bot < s);				\
+}
+
+/*
+ * Optional hybrid natural/pairwise first pass.  Eats up list1 in runs of
+ * increasing order, list2 in a corresponding linked list.  Checks for runs
+ * when THRESHOLD/2 pairs compare with same sense.  (Only used when NATURAL
+ * is defined.  Otherwise simple pairwise merging is used.)
+ */
+void
+setup(u_char *list1, u_char *list2, size_t n, size_t size, cmp_t cmp)
+{
+	int i, length, size2, tmp, sense;
+	u_char *f1, *f2, *s, *l2, *last, *p2;
+
+	size2 = size*2;
+	if (n <= 5) {
+		insertionsort(list1, n, size, cmp);
+		*EVAL(list2) = (u_char*) list2 + n*size;
+		return;
+	}
+	/*
+	 * Avoid running pointers out of bounds; limit n to evens
+	 * for simplicity.
+	 */
+	i = 4 + (n & 1);
+	insertionsort(list1 + (n - i) * size, i, size, cmp);
+	last = list1 + size * (n - i);
+	*EVAL(list2 + (last - list1)) = list2 + n * size;
+
+#ifdef NATURAL
+	p2 = list2;
+	f1 = list1;
+	sense = (CMP(f1, f1 + size) > 0);
+	for (; f1 < last; sense = !sense) {
+		length = 2;
+					/* Find pairs with same sense. */
+		for (f2 = f1 + size2; f2 < last; f2 += size2) {
+			if ((CMP(f2, f2+ size) > 0) != sense)
+				break;
+			length += 2;
+		}
+		if (length < THRESHOLD) {		/* Pairwise merge */
+			do {
+				p2 = *EVAL(p2) = f1 + size2 - list1 + list2;
+				if (sense > 0)
+					swap (f1, f1 + size);
+			} while ((f1 += size2) < f2);
+		} else {				/* Natural merge */
+			l2 = f2;
+			for (f2 = f1 + size2; f2 < l2; f2 += size2) {
+				if ((CMP(f2-size, f2) > 0) != sense) {
+					p2 = *EVAL(p2) = f2 - list1 + list2;
+					if (sense > 0)
+						reverse(f1, f2-size);
+					f1 = f2;
+				}
+			}
+			if (sense > 0)
+				reverse (f1, f2-size);
+			f1 = f2;
+			if (f2 < last || CMP(f2 - size, f2) > 0)
+				p2 = *EVAL(p2) = f2 - list1 + list2;
+			else
+				p2 = *EVAL(p2) = list2 + n*size;
+		}
+	}
+#else		/* pairwise merge only. */
+	for (f1 = list1, p2 = list2; f1 < last; f1 += size2) {
+		p2 = *EVAL(p2) = p2 + size2;
+		if (CMP (f1, f1 + size) > 0)
+			swap(f1, f1 + size);
+	}
+#endif /* NATURAL */
+}
+
+/*
+ * This is to avoid out-of-bounds addresses in sorting the
+ * last 4 elements.
+ */
+static void
+insertionsort(u_char *a, size_t n, size_t size, cmp_t cmp)
+{
+	u_char *ai, *s, *t, *u, tmp;
+	int i;
+
+	for (ai = a+size; --n >= 1; ai += size)
+		for (t = ai; t > a; t -= size) {
+			u = t - size;
+			if (CMP(u, t) <= 0)
+				break;
+			swap(u, t);
+		}
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/mknod.c third_party/newlib-4.1.0/newlib/libc/sys/arm/mknod.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/mknod.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/mknod.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,36 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+int mknod (const char *path, mode_t mode, dev_t dev)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+
+/*
+ *
+ */
+int mknod2(char *path, uint32_t flags, struct stat *stat)
+{
+    int sc;
+    
+    sc = _swi_mknod(path, flags, stat);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/mntent.c third_party/newlib-4.1.0/newlib/libc/sys/arm/mntent.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/mntent.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/mntent.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,56 @@
+#include <stdio.h>
+#include <mntent.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+FILE *setmntent(const char *filename, const char *type)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+struct mntent *getmntent(FILE *filep)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+int addmntent(FILE *filep, const struct mntent *mnt)
+{
+    errno = ENOSYS;
+    return 0;
+}
+
+
+/*
+ *
+ */
+int endmntent(FILE *filep)
+{
+    errno = ENOSYS;
+    return 0;
+}
+
+
+/*
+ *
+ */
+char *hasmntopt(const struct mntent *mnt, const char *opt)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/mount.c third_party/newlib-4.1.0/newlib/libc/sys/arm/mount.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/mount.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/mount.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,93 @@
+#include <_ansi.h>
+#include <errno.h>
+#include <sys/mount.h>
+#include <sys/syscalls.h>
+
+
+/*
+ * TODO: Rename to createmsgport
+ *
+ * Add separate library functions that handles mounting
+ * by launching and detaching the appropriate filesystem handler. 
+ */
+int createmsgport(char *path, uint32_t flags, struct stat *stat, int backlog)
+{
+    int sc;
+    
+    sc = _swi_mount(path, flags, stat, backlog);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int unmount(int fd, bool force)
+{
+    int sc;
+    
+    sc = _swi_unmount(fd, force);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int renamemsgport(char *new_path, char *old_path)
+{
+    int sc;
+    
+    sc = _swi_renamemsgport(new_path, old_path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int pivotroot(char *new_root, char *old_root)
+{
+    int sc;
+    
+    sc = _swi_pivotroot(new_root, old_root);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int getfsstat(struct statfs *buf, int bufsize, int flags)
+{
+    return 0;
+}
+
+/*
+ *
+ */
+int getmntinfo(struct statfs **mntbufp, int flags)
+{
+    return 0;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/msg.c third_party/newlib-4.1.0/newlib/libc/sys/arm/msg.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/msg.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/msg.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,94 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+
+int sendrec(int fd, int siov_cnt, struct IOV *siov, int riov_cnt, struct IOV *riov)
+{
+    int sc;
+
+    sc = _swi_sendrec(fd, siov_cnt, siov, riov_cnt, riov);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int getmsg(int portid, msgid_t *msgid, void *buf, size_t buf_sz)
+{
+    int sc;
+
+    sc = _swi_getmsg(portid, msgid, buf, buf_sz);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int replymsg(int portid, msgid_t msgid, int status, void *buf, size_t buf_sz)
+{
+    int sc;
+
+    sc = _swi_replymsg(portid, msgid, status, buf, buf_sz);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int readmsg(int portid, msgid_t msgid, void *buf, size_t buf_sz, off_t offset)
+{
+    int sc;
+
+    sc = _swi_readmsg(portid, msgid, buf, buf_sz, offset);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int writemsg(int portid, msgid_t msgid, void *buf, size_t buf_sz, off_t offset)
+{
+    int sc;
+
+    sc = _swi_writemsg(portid, msgid, buf, buf_sz, offset);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/netinet/in.h third_party/newlib-4.1.0/newlib/libc/sys/arm/netinet/in.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/netinet/in.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/netinet/in.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,59 @@
+/* 
+ */
+
+
+
+#ifndef _NETINET_IN_H_
+#define _NETINET_IN_H_
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/cdefs.h>
+
+
+
+typedef uint16_t in_port_t;
+typedef uint32_t in_addr_t;
+
+
+
+struct in_addr
+{
+	in_addr_t s_addr;
+};
+
+
+struct sockaddr_in
+{
+	sa_family_t sin_family;
+	in_port_t sin_port;
+	struct in_addr sin_addr;
+};
+
+
+
+
+#define IPPROTO_IP			1
+#define IPPROTO_ICMP		2
+#define IPPROTO_RAW			3
+#define IPPROTO_TCP			4
+#define IPPROTO_UDP			5
+
+
+
+#define INADDR_ANY			1
+#define INADDR_BROADCAST	2
+
+
+#define INET_ADDRSTRLEN		16
+
+
+
+
+
+
+
+
+#endif /* !_NETINET_IN_ */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsdispatch.c third_party/newlib-4.1.0/newlib/libc/sys/arm/nsdispatch.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsdispatch.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/nsdispatch.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,700 @@
+/*	$NetBSD: nsdispatch.c,v 1.38 2014/09/18 13:58:20 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 1999, 2004 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn; and by Jason R. Thorpe.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 2003 Networks Associates Technology, Inc.
+ * All rights reserved.
+ *
+ * Portions of this software were developed for the FreeBSD Project by
+ * Jacques A. Vidrine, Safeport Network Services, and Network
+ * Associates Laboratories, the Security Research Division of Network
+ * Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035
+ * ("CBOSS"), as part of the DARPA CHATS research program.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
+ * SUCH DAMAGE.
+ */
+
+#undef __ELF__
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: nsdispatch.c,v 1.38 2014/09/18 13:58:20 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <sys/types.h>
+#include <sys/param.h>
+#include <sys/stat.h>
+#include <sys/queue.h>
+
+#include <assert.h>
+#ifdef __ELF__
+//#include <dlfcn.h>
+#endif /* __ELF__ */
+#include <err.h>
+#include <fcntl.h>
+#define _NS_PRIVATE
+#include <nsswitch.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+//#include "reentrant.h"
+#define mutex_lock(x)
+#define mutex_unlock(x)
+#define rwlock_rdlock(x)
+#define rwlock_wrlock(x)
+#define rwlock_unlock(x)
+
+
+extern	FILE 	*_nsyyin;
+extern	int	 _nsyyparse(void);
+
+
+#ifdef __weak_alias
+__weak_alias(nsdispatch,_nsdispatch)
+#endif
+
+
+/*
+ * default sourcelist: `files'
+ */
+const ns_src __nsdefaultsrc[] = {
+	{ NSSRC_FILES,	NS_SUCCESS },
+	{ 0, 0 },
+};
+
+const ns_src __nsdefaultcompat[] = {
+	{ NSSRC_COMPAT,	NS_SUCCESS },
+	{ 0, 0 }
+};
+
+const ns_src __nsdefaultcompat_forceall[] = {
+	{ NSSRC_COMPAT,	NS_SUCCESS | NS_FORCEALL },
+	{ 0, 0 }
+};
+
+const ns_src __nsdefaultfiles[] = {
+	{ NSSRC_FILES,	NS_SUCCESS },
+	{ 0, 0 },
+};
+
+const ns_src __nsdefaultfiles_forceall[] = {
+	{ NSSRC_FILES,	NS_SUCCESS | NS_FORCEALL },
+	{ 0, 0 },
+};
+
+const ns_src __nsdefaultnis[] = {
+	{ NSSRC_NIS,	NS_SUCCESS },
+	{ 0, 0 }
+};
+
+const ns_src __nsdefaultnis_forceall[] = {
+	{ NSSRC_NIS,	NS_SUCCESS | NS_FORCEALL },
+	{ 0, 0 }
+};
+
+
+/* Database, source mappings. */
+static	u_int			 _nsmapsize;
+static	ns_dbt			*_nsmap;
+
+/* Nsswitch modules. */
+static	u_int			 _nsmodsize;
+static	ns_mod			*_nsmod;
+
+/* Placeholder for built-in modules' dlopen() handles. */
+static	void			*_nsbuiltin = &_nsbuiltin;
+
+#ifdef _REENTRANT
+/*
+ * Global nsswitch data structures are mostly read-only, but we update them
+ * when we read or re-read nsswitch.conf.
+ */
+static 	rwlock_t		_nslock = RWLOCK_INITIALIZER;
+
+/*
+ * List of threads currently in nsdispatch().  We use this to detect
+ * recursive calls and avoid reloading configuration in such cases,
+ * which could cause deadlock.
+ */
+struct _ns_drec {
+	LIST_ENTRY(_ns_drec)	list;
+	thr_t			thr;
+};
+static LIST_HEAD(, _ns_drec) _ns_drec = LIST_HEAD_INITIALIZER(&_ns_drec);
+static mutex_t _ns_drec_lock = MUTEX_INITIALIZER;
+#endif /* _REENTRANT */
+
+
+/*
+ * Runtime determination of whether we are dynamically linked or not.
+ */
+#ifndef __ELF__
+#define	is_dynamic()		(0)	/* don't bother - switch to ELF! */
+#else
+__weakref_visible int rtld_DYNAMIC __weak_reference(_DYNAMIC);
+#define	is_dynamic()		(&rtld_DYNAMIC != NULL)
+#endif
+
+
+/*
+ * size of dynamic array chunk for _nsmap and _nsmap[x].srclist (and other
+ * growing arrays).
+ */
+#define NSELEMSPERCHUNK		8
+
+/*
+ * Dynamically growable arrays are used for lists of databases, sources,
+ * and modules.  The following "vector" API is used to isolate the
+ * common operations.
+ */
+typedef void	(*_nsvect_free_elem)(void *);
+
+static void *
+_nsvect_append(const void *elem, void *vec, u_int *count, size_t esize)
+{
+	void	*p;
+
+	if ((*count % NSELEMSPERCHUNK) == 0) {
+		p = realloc(vec, (*count + NSELEMSPERCHUNK) * esize);
+		if (p == NULL)
+			return (NULL);
+		vec = p;
+	}
+	memmove((void *)(((uintptr_t)vec) + (*count * esize)), elem, esize);
+	(*count)++;
+	return (vec);
+}
+
+static void *
+_nsvect_elem(u_int i, void *vec, u_int count, size_t esize)
+{
+
+	if (i < count)
+		return ((void *)((uintptr_t)vec + (i * esize)));
+	else
+		return (NULL);
+}
+
+static void
+_nsvect_free(void *vec, u_int *count, size_t esize, _nsvect_free_elem free_elem)
+{
+	void	*elem;
+	u_int	 i;
+
+	for (i = 0; i < *count; i++) {
+		elem = _nsvect_elem(i, vec, *count, esize);
+		if (elem != NULL)
+			(*free_elem)(elem);
+	}
+	if (vec != NULL)
+		free(vec);
+	*count = 0;
+}
+#define	_NSVECT_FREE(v, c, s, f)					\
+do {									\
+	_nsvect_free((v), (c), (s), (f));				\
+	(v) = NULL;							\
+} while (/*CONSTCOND*/0)
+
+static int
+_nsdbtcmp(const void *a, const void *b)
+{
+
+	return (strcasecmp(((const ns_dbt *)a)->name,
+	    ((const ns_dbt *)b)->name));
+}
+
+static int
+_nsmodcmp(const void *a, const void *b)
+{
+
+	return (strcasecmp(((const ns_mod *)a)->name,
+	    ((const ns_mod *)b)->name));
+}
+
+static int
+_nsmtabcmp(const void *a, const void *b)
+{
+	int	cmp;
+
+	cmp = strcmp(((const ns_mtab *)a)->name,
+	    ((const ns_mtab *)b)->name);
+	if (cmp)
+		return (cmp);
+
+	return (strcasecmp(((const ns_mtab *)a)->database,
+	    ((const ns_mtab *)b)->database));
+}
+
+static void
+_nsmodfree(ns_mod *mod)
+{
+
+	free(__UNCONST(mod->name));
+	if (mod->handle == NULL)
+		return;
+	if (mod->unregister != NULL)
+		(*mod->unregister)(mod->mtab, mod->mtabsize);
+#ifdef __ELF__
+	if (mod->handle != _nsbuiltin)
+		(void) dlclose(mod->handle);
+#endif /* __ELF__ */
+}
+
+/*
+ * Load a built-in or dyanamically linked module.  If the `reg_fn'
+ * argument is non-NULL, assume a built-in module and use `reg_fn'
+ * to register it.  Otherwise, search for a dynamic nsswitch module.
+ */
+static int
+_nsloadmod(const char *source, nss_module_register_fn reg_fn)
+{
+#ifdef __ELF__
+	char	buf[PATH_MAX];
+#endif
+	ns_mod	mod, *new;
+
+	memset(&mod, 0, sizeof(mod));
+	mod.name = strdup(source);
+	if (mod.name == NULL)
+		return (-1);
+
+	if (reg_fn != NULL) {
+		/*
+		 * The placeholder is required, as a NULL handle
+		 * represents an invalid module.
+		 */
+		mod.handle = _nsbuiltin;
+	} else if (!is_dynamic()) {
+		goto out;
+	} else {
+#ifdef __ELF__
+		if (snprintf(buf, sizeof(buf), "nss_%s.so.%d", mod.name,
+		    NSS_MODULE_INTERFACE_VERSION) >= (int)sizeof(buf))
+			goto out;
+		mod.handle = dlopen(buf, RTLD_LOCAL | RTLD_LAZY);
+		if (mod.handle == NULL) {
+#ifdef _NSS_DEBUG
+			/*
+			 * This gets pretty annoying, since the built-in
+			 * sources are not yet modules.
+			 */
+			/* XXX log some error? */
+#endif
+			goto out;
+		}
+		reg_fn = (nss_module_register_fn) dlsym(mod.handle,
+		    "nss_module_register");
+		if (reg_fn == NULL) {
+			(void) dlclose(mod.handle);
+			mod.handle = NULL;
+			/* XXX log some error? */
+			goto out;
+		}
+#else /* ! __ELF__ */
+		mod.handle = NULL;
+#endif /* __ELF__ */
+	}
+	mod.mtab = (*reg_fn)(mod.name, &mod.mtabsize, &mod.unregister);
+	if (mod.mtab == NULL || mod.mtabsize == 0) {
+#ifdef __ELF__
+		if (mod.handle != _nsbuiltin)
+			(void) dlclose(mod.handle);
+#endif /* __ELF__ */
+		mod.handle = NULL;
+		/* XXX log some error? */
+		goto out;
+	}
+	if (mod.mtabsize > 1)
+		qsort(mod.mtab, mod.mtabsize, sizeof(mod.mtab[0]),
+		    _nsmtabcmp);
+ out:
+	new = _nsvect_append(&mod, _nsmod, &_nsmodsize, sizeof(*_nsmod));
+	if (new == NULL) {
+		_nsmodfree(&mod);
+		return (-1);
+	}
+	_nsmod = new;
+	/* _nsmodsize already incremented */
+
+	qsort(_nsmod, _nsmodsize, sizeof(*_nsmod), _nsmodcmp);
+	return (0);
+}
+
+static void
+_nsloadbuiltin(void)
+{
+
+	/* Do nothing, for now. */
+}
+
+int
+_nsdbtaddsrc(ns_dbt *dbt, const ns_src *src)
+{
+	void		*new;
+	const ns_mod	*mod;
+	ns_mod		 modkey;
+
+	_DIAGASSERT(dbt != NULL);
+	_DIAGASSERT(src != NULL);
+
+	new = _nsvect_append(src, dbt->srclist, &dbt->srclistsize,
+	    sizeof(*src));
+	if (new == NULL)
+		return (-1);
+	dbt->srclist = new;
+	/* dbt->srclistsize already incremented */
+
+	modkey.name = src->name;
+	mod = bsearch(&modkey, _nsmod, _nsmodsize, sizeof(*_nsmod), _nsmodcmp);
+	if (mod == NULL)
+		return (_nsloadmod(src->name, NULL));
+
+	return (0);
+}
+
+void
+_nsdbtdump(const ns_dbt *dbt)
+{
+	unsigned int	i;
+
+	_DIAGASSERT(dbt != NULL);
+
+	printf("%s (%d source%s):", dbt->name, dbt->srclistsize,
+	    dbt->srclistsize == 1 ? "" : "s");
+	for (i = 0; i < dbt->srclistsize; i++) {
+		printf(" %s", dbt->srclist[i].name);
+		if (!(dbt->srclist[i].flags &
+		    (NS_UNAVAIL|NS_NOTFOUND|NS_TRYAGAIN)) &&
+		    (dbt->srclist[i].flags & NS_SUCCESS))
+			continue;
+		printf(" [");
+		if (!(dbt->srclist[i].flags & NS_SUCCESS))
+			printf(" SUCCESS=continue");
+		if (dbt->srclist[i].flags & NS_UNAVAIL)
+			printf(" UNAVAIL=return");
+		if (dbt->srclist[i].flags & NS_NOTFOUND)
+			printf(" NOTFOUND=return");
+		if (dbt->srclist[i].flags & NS_TRYAGAIN)
+			printf(" TRYAGAIN=return");
+		printf(" ]");
+	}
+	printf("\n");
+}
+
+static void
+_nssrclist_free(ns_src **src, u_int srclistsize)
+{
+	u_int	i;
+
+	for (i = 0; i < srclistsize; i++) {
+		if ((*src)[i].name != NULL)
+			free(__UNCONST((*src)[i].name));
+	}
+	free(*src);
+	*src = NULL;
+}
+
+static void
+_nsdbtfree(ns_dbt *dbt)
+{
+
+	_nssrclist_free(&dbt->srclist, dbt->srclistsize);
+	if (dbt->name != NULL)
+		free(__UNCONST(dbt->name));
+}
+
+int
+_nsdbtput(const ns_dbt *dbt)
+{
+	ns_dbt	*p;
+	void	*new;
+	u_int	i;
+
+	_DIAGASSERT(dbt != NULL);
+
+	for (i = 0; i < _nsmapsize; i++) {
+		p = _nsvect_elem(i, _nsmap, _nsmapsize, sizeof(*_nsmap));
+		if (strcasecmp(dbt->name, p->name) == 0) {
+					/* overwrite existing entry */
+			if (p->srclist != NULL)
+				_nssrclist_free(&p->srclist, p->srclistsize);
+			memmove(p, dbt, sizeof(*dbt));
+			return (0);
+		}
+	}
+	new = _nsvect_append(dbt, _nsmap, &_nsmapsize, sizeof(*_nsmap));
+	if (new == NULL)
+		return (-1);
+	_nsmap = new;
+	/* _nsmapsize already incremented */
+
+	return (0);
+}
+
+/*
+ * This function is called each time nsdispatch() is called.  If this
+ * is the first call, or if the configuration has changed, (re-)prepare
+ * the global data used by NSS.
+ */
+static int
+_nsconfigure(void)
+{
+#ifdef _REENTRANT
+	static mutex_t	_nsconflock = MUTEX_INITIALIZER;
+#endif
+	static time_t	_nsconfmod;
+	struct stat	statbuf;
+
+	mutex_lock(&_nsconflock);
+
+	if (stat(_PATH_NS_CONF, &statbuf) == -1) {
+		/*
+		 * No nsswitch.conf; just use whatever configuration we
+		 * currently have, or fall back on the defaults specified
+		 * by the caller.
+		 */
+		mutex_unlock(&_nsconflock);
+		return (0);
+	}
+
+	if (statbuf.st_mtime <= _nsconfmod) {
+		/* Internal state is up-to-date with nsswitch.conf. */
+		mutex_unlock(&_nsconflock);
+		return (0);
+	}
+
+	/*
+	 * Ok, we've decided we need to update the nsswitch configuration
+	 * structures.  Acquire a write-lock on _nslock while continuing
+	 * to hold _nsconflock.  Acquiring a write-lock blocks while
+	 * waiting for other threads already holding a read-lock to clear.
+	 * We hold _nsconflock for the duration, and update the time stamp
+	 * at the end of the update operation, at which time we release
+	 * both locks.
+	 */
+	rwlock_wrlock(&_nslock);
+
+	_nsyyin = fopen(_PATH_NS_CONF, "re");
+	if (_nsyyin == NULL) {
+		/*
+		 * Unable to open nsswitch.conf; behave as though the
+		 * stat() above failed.  Even though we have already
+		 * updated _nsconfmod, if the file reappears, the
+		 * mtime will change.
+		 */
+		goto out;
+	}
+
+	_NSVECT_FREE(_nsmap, &_nsmapsize, sizeof(*_nsmap),
+	    (_nsvect_free_elem) _nsdbtfree);
+	_NSVECT_FREE(_nsmod, &_nsmodsize, sizeof(*_nsmod),
+	    (_nsvect_free_elem) _nsmodfree);
+
+	_nsloadbuiltin();
+
+	_nsyyparse();
+	(void) fclose(_nsyyin);
+	if (_nsmapsize != 0)
+		qsort(_nsmap, _nsmapsize, sizeof(*_nsmap), _nsdbtcmp);
+
+	_nsconfmod = statbuf.st_mtime;
+
+ out:
+	rwlock_unlock(&_nslock);
+	mutex_unlock(&_nsconflock);
+	return (0);
+}
+
+static nss_method
+_nsmethod(const char *source, const char *database, const char *method,
+    const ns_dtab disp_tab[], void **cb_data)
+{
+	int	curdisp;
+	ns_mod	*mod, modkey;
+	ns_mtab	*mtab, mtabkey;
+
+	if (disp_tab != NULL) {
+		for (curdisp = 0; disp_tab[curdisp].src != NULL; curdisp++) {
+			if (strcasecmp(source, disp_tab[curdisp].src) == 0) {
+				*cb_data = disp_tab[curdisp].cb_data;
+				return (disp_tab[curdisp].callback);
+			}
+		}
+	}
+
+	modkey.name = source;
+	mod = bsearch(&modkey, _nsmod, _nsmodsize, sizeof(*_nsmod),
+	    _nsmodcmp);
+	if (mod != NULL && mod->handle != NULL) {
+		mtabkey.database = database;
+		mtabkey.name = method;
+		mtab = bsearch(&mtabkey, mod->mtab, mod->mtabsize,
+		    sizeof(mod->mtab[0]), _nsmtabcmp);
+		if (mtab != NULL) {
+			*cb_data = mtab->mdata;
+			return (mtab->method);
+		}
+	}
+
+	*cb_data = NULL;
+	return (NULL);
+}
+
+int
+/*ARGSUSED*/
+nsdispatch(void *retval, const ns_dtab disp_tab[], const char *database,
+	    const char *method, const ns_src defaults[], ...)
+{
+	static int	 _nsdispatching;
+#ifdef _REENTRANT
+	struct _ns_drec	 drec, *ldrec;
+#endif
+	va_list		 ap;
+	int		 i, result;
+	ns_dbt		 key;
+	const ns_dbt	*dbt;
+	const ns_src	*srclist;
+	int		 srclistsize;
+	nss_method	 cb;
+	void		*cb_data;
+
+	/* retval may be NULL */
+	/* disp_tab may be NULL */
+	_DIAGASSERT(database != NULL);
+	_DIAGASSERT(method != NULL);
+	_DIAGASSERT(defaults != NULL);
+	if (database == NULL || method == NULL || defaults == NULL)
+		return (NS_UNAVAIL);
+
+	/*
+	 * In both the threaded and non-threaded cases, avoid reloading
+	 * the configuration if the current thread is already running
+	 * nsdispatch() (i.e. recursive call).
+	 *
+	 * In the non-threaded case, this avoids changing the data structures
+	 * while we're using them.
+	 *
+	 * In the threaded case, this avoids trying to take a write lock
+	 * while the current thread holds a read lock (which would result
+	 * in deadlock).
+	 */
+#ifdef _REENTRANT
+	if (__isthreaded) {
+		drec.thr = thr_self();
+		mutex_lock(&_ns_drec_lock);
+		LIST_FOREACH(ldrec, &_ns_drec, list) {
+			if (ldrec->thr == drec.thr)
+				break;
+		}
+		LIST_INSERT_HEAD(&_ns_drec, &drec, list);
+		mutex_unlock(&_ns_drec_lock);
+		if (ldrec == NULL && _nsconfigure()) {
+			mutex_lock(&_ns_drec_lock);
+			LIST_REMOVE(&drec, list);
+			mutex_unlock(&_ns_drec_lock);
+			return (NS_UNAVAIL);
+		}
+	} else
+#endif /* _REENTRANT */
+	if (_nsdispatching++ == 0 && _nsconfigure()) {
+		_nsdispatching--;
+		return (NS_UNAVAIL);
+	}
+
+	rwlock_rdlock(&_nslock);
+
+	key.name = database;
+	dbt = bsearch(&key, _nsmap, _nsmapsize, sizeof(*_nsmap), _nsdbtcmp);
+	if (dbt != NULL) {
+		srclist = dbt->srclist;
+		srclistsize = dbt->srclistsize;
+	} else {
+		srclist = defaults;
+		srclistsize = 0;
+		while (srclist[srclistsize].name != NULL)
+			srclistsize++;
+	}
+	result = 0;
+
+	for (i = 0; i < srclistsize; i++) {
+		cb = _nsmethod(srclist[i].name, database, method,
+		    disp_tab, &cb_data);
+		result = 0;
+		if (cb != NULL) {
+			va_start(ap, defaults);
+			result = (*cb)(retval, cb_data, ap);
+			va_end(ap);
+			if (defaults[0].flags & NS_FORCEALL)
+				continue;
+			if (result & srclist[i].flags)
+				break;
+		}
+	}
+	result &= NS_STATUSMASK;	/* clear private flags in result */
+
+	rwlock_unlock(&_nslock);
+
+#ifdef _REENTRANT
+	if (__isthreaded) {
+		mutex_lock(&_ns_drec_lock);
+		LIST_REMOVE(&drec, list);
+		mutex_unlock(&_ns_drec_lock);
+	} else
+#endif /* _REENTRANT */
+		_nsdispatching--;
+
+	return (result ? result : NS_NOTFOUND);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nslexer.c third_party/newlib-4.1.0/newlib/libc/sys/arm/nslexer.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nslexer.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/nslexer.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,1910 @@
+
+#line 3 "nslexer.c"
+
+#define _nsyywrap _ns_nsyywrap
+
+#define  _NSYY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define _NSYY_FLEX_MAJOR_VERSION 2
+#define _NSYY_FLEX_MINOR_VERSION 6
+#define _NSYY_FLEX_SUBMINOR_VERSION 4
+#if _NSYY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#ifndef SIZE_MAX
+#define SIZE_MAX               (~(size_t)0)
+#endif
+
+#endif /* ! C99 */
+
+#endif /* ! FLEXINT_H */
+
+/* begin standard C++ headers. */
+
+/* TODO: this is always defined, so inline it */
+#define _nsyyconst const
+
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define _nsyynoreturn __attribute__((__noreturn__))
+#else
+#define _nsyynoreturn
+#endif
+
+/* Returned upon end-of-file. */
+#define _NSYY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an
+ *   integer in range [0..255] for use as an array index.
+ */
+#define _NSYY_SC_TO_UI(c) ((_NSYY_CHAR) (c))
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (_nsyy_start) = 1 + 2 *
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The _NSYYSTATE alias is for lex
+ * compatibility.
+ */
+#define _NSYY_START (((_nsyy_start) - 1) / 2)
+#define _NSYYSTATE _NSYY_START
+/* Action number for EOF rule of a given start state. */
+#define _NSYY_STATE_EOF(state) (_NSYY_END_OF_BUFFER + state + 1)
+/* Special action meaning "start processing a new file". */
+#define _NSYY_NEW_FILE _nsyyrestart( _nsyyin  )
+#define _NSYY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef _NSYY_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k.
+ * Moreover, _NSYY_BUF_SIZE is 2*_NSYY_READ_BUF_SIZE in the general case.
+ * Ditto for the __ia64__ case accordingly.
+ */
+#define _NSYY_BUF_SIZE 32768
+#else
+#define _NSYY_BUF_SIZE 16384
+#endif /* __ia64__ */
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define _NSYY_STATE_BUF_SIZE   ((_NSYY_BUF_SIZE + 2) * sizeof(_nsyy_state_type))
+
+#ifndef _NSYY_TYPEDEF__NSYY_BUFFER_STATE
+#define _NSYY_TYPEDEF__NSYY_BUFFER_STATE
+typedef struct _nsyy_buffer_state *_NSYY_BUFFER_STATE;
+#endif
+
+#ifndef _NSYY_TYPEDEF__NSYY_SIZE_T
+#define _NSYY_TYPEDEF__NSYY_SIZE_T
+typedef size_t _nsyy_size_t;
+#endif
+
+extern int _nsyyleng;
+
+extern FILE *_nsyyin, *_nsyyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+    
+    /* Note: We specifically omit the test for _nsyy_rule_can_match_eol because it requires
+     *       access to the local variable _nsyy_act. Since _nsyyless() is a macro, it would break
+     *       existing scanners that call _nsyyless() from OUTSIDE _nsyylex.
+     *       One obvious solution it to make _nsyy_act a global. I tried that, and saw
+     *       a 5% performance hit in a non-_nsyylineno scanner, because _nsyy_act is
+     *       normally declared as a register variable-- so it is not worth it.
+     */
+    #define  _NSYY_LESS_LINENO(n) \
+            do { \
+                int _nsyyl;\
+                for ( _nsyyl = n; _nsyyl < _nsyyleng; ++_nsyyl )\
+                    if ( _nsyytext[_nsyyl] == '\n' )\
+                        --_nsyylineno;\
+            }while(0)
+    #define _NSYY_LINENO_REWIND_TO(dst) \
+            do {\
+                const char *p;\
+                for ( p = _nsyy_cp-1; p >= (dst); --p)\
+                    if ( *p == '\n' )\
+                        --_nsyylineno;\
+            }while(0)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define _nsyyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up _nsyytext. */ \
+        int _nsyyless_macro_arg = (n); \
+        _NSYY_LESS_LINENO(_nsyyless_macro_arg);\
+		*_nsyy_cp = (_nsyy_hold_char); \
+		_NSYY_RESTORE__NSYY_MORE_OFFSET \
+		(_nsyy_c_buf_p) = _nsyy_cp = _nsyy_bp + _nsyyless_macro_arg - _NSYY_MORE_ADJ; \
+		_NSYY_DO_BEFORE_ACTION; /* set up _nsyytext again */ \
+		} \
+	while ( 0 )
+#define unput(c) _nsyyunput( c, (_nsyytext_ptr)  )
+
+#ifndef _NSYY_STRUCT__NSYY_BUFFER_STATE
+#define _NSYY_STRUCT__NSYY_BUFFER_STATE
+struct _nsyy_buffer_state
+	{
+	FILE *_nsyy_input_file;
+
+	char *_nsyy_ch_buf;		/* input buffer */
+	char *_nsyy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	int _nsyy_buf_size;
+
+	/* Number of characters read into _nsyy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int _nsyy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int _nsyy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int _nsyy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int _nsyy_at_bol;
+
+    int _nsyy_bs_lineno; /**< The line count. */
+    int _nsyy_bs_column; /**< The column count. */
+
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int _nsyy_fill_buffer;
+
+	int _nsyy_buffer_status;
+
+#define _NSYY_BUFFER_NEW 0
+#define _NSYY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as _NSYY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via _nsyyrestart()), so that the user can continue scanning by
+	 * just pointing _nsyyin at a new input file.
+	 */
+#define _NSYY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !_NSYY_STRUCT__NSYY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t _nsyy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t _nsyy_buffer_stack_max = 0; /**< capacity of stack. */
+static _NSYY_BUFFER_STATE * _nsyy_buffer_stack = NULL; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define _NSYY_CURRENT_BUFFER ( (_nsyy_buffer_stack) \
+                          ? (_nsyy_buffer_stack)[(_nsyy_buffer_stack_top)] \
+                          : NULL)
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define _NSYY_CURRENT_BUFFER_LVALUE (_nsyy_buffer_stack)[(_nsyy_buffer_stack_top)]
+
+/* _nsyy_hold_char holds the character lost when _nsyytext is formed. */
+static char _nsyy_hold_char;
+static int _nsyy_n_chars;		/* number of characters read into _nsyy_ch_buf */
+int _nsyyleng;
+
+/* Points to current character in buffer. */
+static char *_nsyy_c_buf_p = NULL;
+static int _nsyy_init = 0;		/* whether we need to initialize */
+static int _nsyy_start = 0;	/* start state number */
+
+/* Flag which is used to allow _nsyywrap()'s to do buffer switches
+ * instead of setting up a fresh _nsyyin.  A bit of a hack ...
+ */
+static int _nsyy_did_buffer_switch_on_eof;
+
+void _nsyyrestart ( FILE *input_file  );
+void _nsyy_switch_to_buffer ( _NSYY_BUFFER_STATE new_buffer  );
+_NSYY_BUFFER_STATE _nsyy_create_buffer ( FILE *file, int size  );
+void _nsyy_delete_buffer ( _NSYY_BUFFER_STATE b  );
+void _nsyy_flush_buffer ( _NSYY_BUFFER_STATE b  );
+void _nsyypush_buffer_state ( _NSYY_BUFFER_STATE new_buffer  );
+void _nsyypop_buffer_state ( void );
+
+static void _nsyyensure_buffer_stack ( void );
+static void _nsyy_load_buffer_state ( void );
+static void _nsyy_init_buffer ( _NSYY_BUFFER_STATE b, FILE *file  );
+#define _NSYY_FLUSH_BUFFER _nsyy_flush_buffer( _NSYY_CURRENT_BUFFER )
+
+_NSYY_BUFFER_STATE _nsyy_scan_buffer ( char *base, _nsyy_size_t size  );
+_NSYY_BUFFER_STATE _nsyy_scan_string ( const char *_nsyy_str  );
+_NSYY_BUFFER_STATE _nsyy_scan_bytes ( const char *bytes, int len  );
+
+void *_nsyyalloc ( _nsyy_size_t  );
+void *_nsyyrealloc ( void *, _nsyy_size_t  );
+void _nsyyfree ( void *  );
+
+#define _nsyy_new_buffer _nsyy_create_buffer
+#define _nsyy_set_interactive(is_interactive) \
+	{ \
+	if ( ! _NSYY_CURRENT_BUFFER ){ \
+        _nsyyensure_buffer_stack (); \
+		_NSYY_CURRENT_BUFFER_LVALUE =    \
+            _nsyy_create_buffer( _nsyyin, _NSYY_BUF_SIZE ); \
+	} \
+	_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_is_interactive = is_interactive; \
+	}
+#define _nsyy_set_bol(at_bol) \
+	{ \
+	if ( ! _NSYY_CURRENT_BUFFER ){\
+        _nsyyensure_buffer_stack (); \
+		_NSYY_CURRENT_BUFFER_LVALUE =    \
+            _nsyy_create_buffer( _nsyyin, _NSYY_BUF_SIZE ); \
+	} \
+	_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_at_bol = at_bol; \
+	}
+#define _NSYY_AT_BOL() (_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_at_bol)
+
+/* Begin user sect3 */
+typedef flex_uint8_t _NSYY_CHAR;
+
+FILE *_nsyyin = NULL, *_nsyyout = NULL;
+
+typedef int _nsyy_state_type;
+
+extern int _nsyylineno;
+int _nsyylineno = 1;
+
+extern char *_nsyytext;
+#ifdef _nsyytext_ptr
+#undef _nsyytext_ptr
+#endif
+#define _nsyytext_ptr _nsyytext
+
+static _nsyy_state_type _nsyy_get_previous_state ( void );
+static _nsyy_state_type _nsyy_try_NUL_trans ( _nsyy_state_type current_state  );
+static int _nsyy_get_next_buffer ( void );
+static void _nsyynoreturn _nsyy_fatal_error ( const char* msg  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up _nsyytext.
+ */
+#define _NSYY_DO_BEFORE_ACTION \
+	(_nsyytext_ptr) = _nsyy_bp; \
+	_nsyyleng = (int) (_nsyy_cp - _nsyy_bp); \
+	(_nsyy_hold_char) = *_nsyy_cp; \
+	*_nsyy_cp = '\0'; \
+	(_nsyy_c_buf_p) = _nsyy_cp;
+#define _NSYY_NUM_RULES 13
+#define _NSYY_END_OF_BUFFER 14
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct _nsyy_trans_info
+	{
+	flex_int32_t _nsyy_verify;
+	flex_int32_t _nsyy_nxt;
+	};
+static const flex_int16_t _nsyy_accept[59] =
+    {   0,
+        0,    0,   14,   12,    1,    4,    2,   11,   11,   11,
+       11,   11,   11,   11,   12,    1,    2,   11,   11,   11,
+       11,   11,   11,   11,    3,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,   11,   11,   11,   11,   11,
+       11,   11,   11,   11,   11,    9,   11,   11,   11,   11,
+       11,    5,   11,    6,   10,    7,    8,    0
+    } ;
+
+static const _NSYY_CHAR _nsyy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    2,    1,    1,    4,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    5,    5,    5,
+        5,    5,    5,    5,    5,    5,    5,    1,    1,    1,
+        1,    1,    1,    1,    6,    7,    8,    9,   10,   11,
+       12,    7,   13,    7,    7,   14,    7,   15,   16,    7,
+        7,   17,   18,   19,   20,   21,    7,    7,   22,    7,
+        1,   23,    1,    1,    5,    1,    6,    7,    8,    9,
+
+       10,   11,   12,    7,   13,    7,    7,   14,    7,   15,
+       16,    7,    7,   17,   18,   19,   20,   21,    7,    7,
+       22,    7,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static const _NSYY_CHAR _nsyy_meta[24] =
+    {   0,
+        1,    1,    2,    1,    3,    3,    3,    3,    3,    3,
+        3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
+        3,    3,    1
+    } ;
+
+static const flex_int16_t _nsyy_base[61] =
+    {   0,
+        0,    0,   68,   69,   65,   69,    0,    0,   50,   49,
+       54,   43,   45,   46,   57,   57,    0,    0,   43,   38,
+       37,   47,   32,   47,   69,   33,   40,   30,   41,   42,
+       26,   33,   29,   27,   33,   30,   35,   25,   19,   23,
+       19,   30,   22,   14,   18,    0,   14,   18,   16,   19,
+       19,    0,   12,    0,    0,    0,    0,   69,   23,   22
+    } ;
+
+static const flex_int16_t _nsyy_def[61] =
+    {   0,
+       58,    1,   58,   58,   58,   58,   59,   60,   60,   60,
+       60,   60,   60,   60,   58,   58,   59,   60,   60,   60,
+       60,   60,   60,   60,   58,   60,   60,   60,   60,   60,
+       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
+       60,   60,   60,   60,   60,   60,   60,   60,   60,   60,
+       60,   60,   60,   60,   60,   60,   60,    0,   58,   58
+    } ;
+
+static const flex_int16_t _nsyy_nxt[93] =
+    {   0,
+        4,    5,    6,    7,    4,    8,    8,    9,    8,    8,
+        8,    8,    8,    8,   10,    8,   11,   12,   13,   14,
+        8,    8,   15,   17,   18,   17,   57,   56,   55,   54,
+       53,   52,   51,   50,   49,   48,   47,   46,   45,   44,
+       43,   42,   41,   40,   39,   38,   37,   36,   35,   34,
+       33,   32,   31,   30,   29,   28,   27,   26,   16,   25,
+       24,   23,   22,   21,   20,   19,   16,   58,    3,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58
+
+    } ;
+
+static const flex_int16_t _nsyy_chk[93] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,   59,   60,   59,   53,   51,   50,   49,
+       48,   47,   45,   44,   43,   42,   41,   40,   39,   38,
+       37,   36,   35,   34,   33,   32,   31,   30,   29,   28,
+       27,   26,   24,   23,   22,   21,   20,   19,   16,   15,
+       14,   13,   12,   11,   10,    9,    5,    3,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58,   58,   58,   58,   58,   58,   58,   58,   58,
+       58,   58
+
+    } ;
+
+/* Table of booleans, true if rule could match eol. */
+static const flex_int32_t _nsyy_rule_can_match_eol[14] =
+    {   0,
+0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,     };
+
+static _nsyy_state_type _nsyy_last_accepting_state;
+static char *_nsyy_last_accepting_cpos;
+
+extern int _nsyy_flex_debug;
+int _nsyy_flex_debug = 0;
+
+/* The intent behind this definition is that it'll catch
+ * any uses of REJECT which flex missed.
+ */
+#define REJECT reject_used_but_not_detected
+#define _nsyymore() _nsyymore_used_but_not_detected
+#define _NSYY_MORE_ADJ 0
+#define _NSYY_RESTORE__NSYY_MORE_OFFSET
+char *_nsyytext;
+#line 1 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+#line 2 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+/*	$NetBSD: nslexer.l,v 1.13 2012/06/25 22:32:45 abs Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: nslexer.l,v 1.13 2012/06/25 22:32:45 abs Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <ctype.h>
+#define _NS_PRIVATE
+#include <nsswitch.h>
+#include <string.h>
+//#include <syslog.h>
+#include <sys/debug.h>
+
+#include "nsparser.h"
+
+#line 549 "nslexer.c"
+#define _NSYY_NO_INPUT 1
+#line 551 "nslexer.c"
+
+#define INITIAL 0
+
+#ifndef _NSYY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef _NSYY_EXTRA_TYPE
+#define _NSYY_EXTRA_TYPE void *
+#endif
+
+static int _nsyy_init_globals ( void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int _nsyylex_destroy ( void );
+
+int _nsyyget_debug ( void );
+
+void _nsyyset_debug ( int debug_flag  );
+
+_NSYY_EXTRA_TYPE _nsyyget_extra ( void );
+
+void _nsyyset_extra ( _NSYY_EXTRA_TYPE user_defined  );
+
+FILE *_nsyyget_in ( void );
+
+void _nsyyset_in  ( FILE * _in_str  );
+
+FILE *_nsyyget_out ( void );
+
+void _nsyyset_out  ( FILE * _out_str  );
+
+			int _nsyyget_leng ( void );
+
+char *_nsyyget_text ( void );
+
+int _nsyyget_lineno ( void );
+
+void _nsyyset_lineno ( int _line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef _NSYY_SKIP__NSYYWRAP
+#ifdef __cplusplus
+extern "C" int _nsyywrap ( void );
+#else
+extern int _nsyywrap ( void );
+#endif
+#endif
+
+#ifndef _NSYY_NO_UNPUT
+    
+#endif
+
+#ifndef _nsyytext_ptr
+static void _nsyy_flex_strncpy ( char *, const char *, int );
+#endif
+
+#ifdef _NSYY_NEED_STRLEN
+static int _nsyy_flex_strlen ( const char * );
+#endif
+
+#ifndef _NSYY_NO_INPUT
+#ifdef __cplusplus
+static int _nsyyinput ( void );
+#else
+static int input ( void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef _NSYY_READ_BUF_SIZE
+#ifdef __ia64__
+/* On IA-64, the buffer size is 16k, not 8k */
+#define _NSYY_READ_BUF_SIZE 16384
+#else
+#define _NSYY_READ_BUF_SIZE 8192
+#endif /* __ia64__ */
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO do { if (fwrite( _nsyytext, (size_t) _nsyyleng, 1, _nsyyout )) {} } while (0)
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or _NSYY_NULL,
+ * is returned in "result".
+ */
+#ifndef _NSYY_INPUT
+#define _NSYY_INPUT(buf,result,max_size) \
+	if ( _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( _nsyyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( _nsyyin ) ) \
+			_NSYY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = (int) fread(buf, 1, (_nsyy_size_t) max_size, _nsyyin)) == 0 && ferror(_nsyyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				_NSYY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(_nsyyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "_nsyyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef _nsyyterminate
+#define _nsyyterminate() return _NSYY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef _NSYY_START_STACK_INCR
+#define _NSYY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef _NSYY_FATAL_ERROR
+#define _NSYY_FATAL_ERROR(msg) _nsyy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef _NSYY_DECL
+#define _NSYY_DECL_IS_OURS 1
+
+extern int _nsyylex (void);
+
+#define _NSYY_DECL int _nsyylex (void)
+#endif /* !_NSYY_DECL */
+
+/* Code executed at the beginning of each rule, after _nsyytext and _nsyyleng
+ * have been set up.
+ */
+#ifndef _NSYY_USER_ACTION
+#define _NSYY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef _NSYY_BREAK
+#define _NSYY_BREAK /*LINTED*/break;
+#endif
+
+#define _NSYY_RULE_SETUP \
+	_NSYY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+_NSYY_DECL
+{
+	_nsyy_state_type _nsyy_current_state;
+	char *_nsyy_cp, *_nsyy_bp;
+	int _nsyy_act;
+    
+	if ( !(_nsyy_init) )
+		{
+		(_nsyy_init) = 1;
+
+#ifdef _NSYY_USER_INIT
+		_NSYY_USER_INIT;
+#endif
+
+		if ( ! (_nsyy_start) )
+			(_nsyy_start) = 1;	/* first start state */
+
+		if ( ! _nsyyin )
+			_nsyyin = stdin;
+
+		if ( ! _nsyyout )
+			_nsyyout = stdout;
+
+		if ( ! _NSYY_CURRENT_BUFFER ) {
+			_nsyyensure_buffer_stack ();
+			_NSYY_CURRENT_BUFFER_LVALUE =
+				_nsyy_create_buffer( _nsyyin, _NSYY_BUF_SIZE );
+		}
+
+		_nsyy_load_buffer_state(  );
+		}
+
+	{
+#line 57 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+
+
+#line 769 "nslexer.c"
+
+	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+		{
+		_nsyy_cp = (_nsyy_c_buf_p);
+
+		/* Support of _nsyytext. */
+		*_nsyy_cp = (_nsyy_hold_char);
+
+		/* _nsyy_bp points to the position in _nsyy_ch_buf of the start of
+		 * the current run.
+		 */
+		_nsyy_bp = _nsyy_cp;
+
+		_nsyy_current_state = (_nsyy_start);
+_nsyy_match:
+		do
+			{
+			_NSYY_CHAR _nsyy_c = _nsyy_ec[_NSYY_SC_TO_UI(*_nsyy_cp)] ;
+			if ( _nsyy_accept[_nsyy_current_state] )
+				{
+				(_nsyy_last_accepting_state) = _nsyy_current_state;
+				(_nsyy_last_accepting_cpos) = _nsyy_cp;
+				}
+			while ( _nsyy_chk[_nsyy_base[_nsyy_current_state] + _nsyy_c] != _nsyy_current_state )
+				{
+				_nsyy_current_state = (int) _nsyy_def[_nsyy_current_state];
+				if ( _nsyy_current_state >= 59 )
+					_nsyy_c = _nsyy_meta[_nsyy_c];
+				}
+			_nsyy_current_state = _nsyy_nxt[_nsyy_base[_nsyy_current_state] + _nsyy_c];
+			++_nsyy_cp;
+			}
+		while ( _nsyy_current_state != 58 );
+		_nsyy_cp = (_nsyy_last_accepting_cpos);
+		_nsyy_current_state = (_nsyy_last_accepting_state);
+
+_nsyy_find_action:
+		_nsyy_act = _nsyy_accept[_nsyy_current_state];
+
+		_NSYY_DO_BEFORE_ACTION;
+
+		if ( _nsyy_act != _NSYY_END_OF_BUFFER && _nsyy_rule_can_match_eol[_nsyy_act] )
+			{
+			int _nsyyl;
+			for ( _nsyyl = 0; _nsyyl < _nsyyleng; ++_nsyyl )
+				if ( _nsyytext[_nsyyl] == '\n' )
+					
+    _nsyylineno++;
+;
+			}
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( _nsyy_act )
+	{ /* beginning of action switch */
+			case 0: /* must back up */
+			/* undo the effects of _NSYY_DO_BEFORE_ACTION */
+			*_nsyy_cp = (_nsyy_hold_char);
+			_nsyy_cp = (_nsyy_last_accepting_cpos);
+			_nsyy_current_state = (_nsyy_last_accepting_state);
+			goto _nsyy_find_action;
+
+case 1:
+_NSYY_RULE_SETUP
+#line 59 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+;			/* skip whitespace */
+	_NSYY_BREAK
+case 2:
+_NSYY_RULE_SETUP
+#line 61 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+;			/* skip comments */
+	_NSYY_BREAK
+case 3:
+/* rule 3 can match eol */
+_NSYY_RULE_SETUP
+#line 63 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+;			/* allow continuation */
+	_NSYY_BREAK
+case 4:
+/* rule 4 can match eol */
+_NSYY_RULE_SETUP
+#line 65 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return NL;
+	_NSYY_BREAK
+case 5:
+_NSYY_RULE_SETUP
+#line 67 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return SUCCESS;
+	_NSYY_BREAK
+case 6:
+_NSYY_RULE_SETUP
+#line 68 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return UNAVAIL;
+	_NSYY_BREAK
+case 7:
+_NSYY_RULE_SETUP
+#line 69 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return NOTFOUND;
+	_NSYY_BREAK
+case 8:
+_NSYY_RULE_SETUP
+#line 70 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return TRYAGAIN;
+	_NSYY_BREAK
+case 9:
+_NSYY_RULE_SETUP
+#line 72 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return RETURN;
+	_NSYY_BREAK
+case 10:
+_NSYY_RULE_SETUP
+#line 73 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return CONTINUE;
+	_NSYY_BREAK
+case 11:
+_NSYY_RULE_SETUP
+#line 75 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+{
+			char *p;
+			size_t i;
+
+			if ((p = strdup(_nsyytext)) == NULL) {
+				log_error("libc nsdispatch: %m");
+				return NL;
+			}
+
+			for (i = 0; i < strlen(p); i++) {
+				if (isupper((unsigned char)p[i]))
+					p[i] = tolower((unsigned char)p[i]);
+			}
+//			_ns_nsyylval.str = p;
+			_nsyylval.str = p;
+			return STRING;
+		}
+	_NSYY_BREAK
+case 12:
+_NSYY_RULE_SETUP
+#line 93 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+return _nsyytext[0];
+	_NSYY_BREAK
+case 13:
+_NSYY_RULE_SETUP
+#line 95 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+ECHO;
+	_NSYY_BREAK
+#line 915 "nslexer.c"
+case _NSYY_STATE_EOF(INITIAL):
+	_nsyyterminate();
+
+	case _NSYY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int _nsyy_amount_of_matched_text = (int) (_nsyy_cp - (_nsyytext_ptr)) - 1;
+
+		/* Undo the effects of _NSYY_DO_BEFORE_ACTION. */
+		*_nsyy_cp = (_nsyy_hold_char);
+		_NSYY_RESTORE__NSYY_MORE_OFFSET
+
+		if ( _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buffer_status == _NSYY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed _nsyyin at a new source and called
+			 * _nsyylex().  If so, then we have to assure
+			 * consistency between _NSYY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(_nsyy_n_chars) = _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_n_chars;
+			_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_input_file = _nsyyin;
+			_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buffer_status = _NSYY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for _nsyy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since _nsyy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (_nsyy_c_buf_p) <= &_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[(_nsyy_n_chars)] )
+			{ /* This was really a NUL. */
+			_nsyy_state_type _nsyy_next_state;
+
+			(_nsyy_c_buf_p) = (_nsyytext_ptr) + _nsyy_amount_of_matched_text;
+
+			_nsyy_current_state = _nsyy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * _nsyy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			_nsyy_next_state = _nsyy_try_NUL_trans( _nsyy_current_state );
+
+			_nsyy_bp = (_nsyytext_ptr) + _NSYY_MORE_ADJ;
+
+			if ( _nsyy_next_state )
+				{
+				/* Consume the NUL. */
+				_nsyy_cp = ++(_nsyy_c_buf_p);
+				_nsyy_current_state = _nsyy_next_state;
+				goto _nsyy_match;
+				}
+
+			else
+				{
+				_nsyy_cp = (_nsyy_last_accepting_cpos);
+				_nsyy_current_state = (_nsyy_last_accepting_state);
+				goto _nsyy_find_action;
+				}
+			}
+
+		else switch ( _nsyy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(_nsyy_did_buffer_switch_on_eof) = 0;
+
+				if ( _nsyywrap(  ) )
+					{
+					/* Note: because we've taken care in
+					 * _nsyy_get_next_buffer() to have set up
+					 * _nsyytext, we can now set up
+					 * _nsyy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * _NSYY_NULL, it'll still work - another
+					 * _NSYY_NULL will get returned.
+					 */
+					(_nsyy_c_buf_p) = (_nsyytext_ptr) + _NSYY_MORE_ADJ;
+
+					_nsyy_act = _NSYY_STATE_EOF(_NSYY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (_nsyy_did_buffer_switch_on_eof) )
+						_NSYY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(_nsyy_c_buf_p) =
+					(_nsyytext_ptr) + _nsyy_amount_of_matched_text;
+
+				_nsyy_current_state = _nsyy_get_previous_state(  );
+
+				_nsyy_cp = (_nsyy_c_buf_p);
+				_nsyy_bp = (_nsyytext_ptr) + _NSYY_MORE_ADJ;
+				goto _nsyy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(_nsyy_c_buf_p) =
+				&_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[(_nsyy_n_chars)];
+
+				_nsyy_current_state = _nsyy_get_previous_state(  );
+
+				_nsyy_cp = (_nsyy_c_buf_p);
+				_nsyy_bp = (_nsyytext_ptr) + _NSYY_MORE_ADJ;
+				goto _nsyy_find_action;
+			}
+		break;
+		}
+
+	default:
+		_NSYY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+	} /* end of user's declarations */
+} /* end of _nsyylex */
+
+/* _nsyy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int _nsyy_get_next_buffer (void)
+{
+    	char *dest = _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf;
+	char *source = (_nsyytext_ptr);
+	int number_to_move, i;
+	int ret_val;
+
+	if ( (_nsyy_c_buf_p) > &_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[(_nsyy_n_chars) + 1] )
+		_NSYY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (_nsyy_c_buf_p) - (_nsyytext_ptr) - _NSYY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((_nsyy_c_buf_p) - (_nsyytext_ptr) - 1);
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buffer_status == _NSYY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_n_chars = (_nsyy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			/* just a shorter name for the current buffer */
+			_NSYY_BUFFER_STATE b = _NSYY_CURRENT_BUFFER_LVALUE;
+
+			int _nsyy_c_buf_p_offset =
+				(int) ((_nsyy_c_buf_p) - b->_nsyy_ch_buf);
+
+			if ( b->_nsyy_is_our_buffer )
+				{
+				int new_size = b->_nsyy_buf_size * 2;
+
+				if ( new_size <= 0 )
+					b->_nsyy_buf_size += b->_nsyy_buf_size / 8;
+				else
+					b->_nsyy_buf_size *= 2;
+
+				b->_nsyy_ch_buf = (char *)
+					/* Include room in for 2 EOB chars. */
+					_nsyyrealloc( (void *) b->_nsyy_ch_buf,
+							 (_nsyy_size_t) (b->_nsyy_buf_size + 2)  );
+				}
+			else
+				/* Can't grow it, we don't own it. */
+				b->_nsyy_ch_buf = NULL;
+
+			if ( ! b->_nsyy_ch_buf )
+				_NSYY_FATAL_ERROR(
+				"fatal error - scanner input buffer overflow" );
+
+			(_nsyy_c_buf_p) = &b->_nsyy_ch_buf[_nsyy_c_buf_p_offset];
+
+			num_to_read = _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_size -
+						number_to_move - 1;
+
+			}
+
+		if ( num_to_read > _NSYY_READ_BUF_SIZE )
+			num_to_read = _NSYY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		_NSYY_INPUT( (&_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[number_to_move]),
+			(_nsyy_n_chars), num_to_read );
+
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_n_chars = (_nsyy_n_chars);
+		}
+
+	if ( (_nsyy_n_chars) == 0 )
+		{
+		if ( number_to_move == _NSYY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			_nsyyrestart( _nsyyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buffer_status =
+				_NSYY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if (((_nsyy_n_chars) + number_to_move) > _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		int new_size = (_nsyy_n_chars) + number_to_move + ((_nsyy_n_chars) >> 1);
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf = (char *) _nsyyrealloc(
+			(void *) _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf, (_nsyy_size_t) new_size  );
+		if ( ! _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf )
+			_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyy_get_next_buffer()" );
+		/* "- 2" to take care of EOB's */
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_size = (int) (new_size - 2);
+	}
+
+	(_nsyy_n_chars) += number_to_move;
+	_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[(_nsyy_n_chars)] = _NSYY_END_OF_BUFFER_CHAR;
+	_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[(_nsyy_n_chars) + 1] = _NSYY_END_OF_BUFFER_CHAR;
+
+	(_nsyytext_ptr) = &_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* _nsyy_get_previous_state - get the state just before the EOB char was reached */
+
+    static _nsyy_state_type _nsyy_get_previous_state (void)
+{
+	_nsyy_state_type _nsyy_current_state;
+	char *_nsyy_cp;
+    
+	_nsyy_current_state = (_nsyy_start);
+
+	for ( _nsyy_cp = (_nsyytext_ptr) + _NSYY_MORE_ADJ; _nsyy_cp < (_nsyy_c_buf_p); ++_nsyy_cp )
+		{
+		_NSYY_CHAR _nsyy_c = (*_nsyy_cp ? _nsyy_ec[_NSYY_SC_TO_UI(*_nsyy_cp)] : 1);
+		if ( _nsyy_accept[_nsyy_current_state] )
+			{
+			(_nsyy_last_accepting_state) = _nsyy_current_state;
+			(_nsyy_last_accepting_cpos) = _nsyy_cp;
+			}
+		while ( _nsyy_chk[_nsyy_base[_nsyy_current_state] + _nsyy_c] != _nsyy_current_state )
+			{
+			_nsyy_current_state = (int) _nsyy_def[_nsyy_current_state];
+			if ( _nsyy_current_state >= 59 )
+				_nsyy_c = _nsyy_meta[_nsyy_c];
+			}
+		_nsyy_current_state = _nsyy_nxt[_nsyy_base[_nsyy_current_state] + _nsyy_c];
+		}
+
+	return _nsyy_current_state;
+}
+
+/* _nsyy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = _nsyy_try_NUL_trans( current_state );
+ */
+    static _nsyy_state_type _nsyy_try_NUL_trans  (_nsyy_state_type _nsyy_current_state )
+{
+	int _nsyy_is_jam;
+    	char *_nsyy_cp = (_nsyy_c_buf_p);
+
+	_NSYY_CHAR _nsyy_c = 1;
+	if ( _nsyy_accept[_nsyy_current_state] )
+		{
+		(_nsyy_last_accepting_state) = _nsyy_current_state;
+		(_nsyy_last_accepting_cpos) = _nsyy_cp;
+		}
+	while ( _nsyy_chk[_nsyy_base[_nsyy_current_state] + _nsyy_c] != _nsyy_current_state )
+		{
+		_nsyy_current_state = (int) _nsyy_def[_nsyy_current_state];
+		if ( _nsyy_current_state >= 59 )
+			_nsyy_c = _nsyy_meta[_nsyy_c];
+		}
+	_nsyy_current_state = _nsyy_nxt[_nsyy_base[_nsyy_current_state] + _nsyy_c];
+	_nsyy_is_jam = (_nsyy_current_state == 58);
+
+		return _nsyy_is_jam ? 0 : _nsyy_current_state;
+}
+
+#ifndef _NSYY_NO_UNPUT
+
+#endif
+
+#ifndef _NSYY_NO_INPUT
+#ifdef __cplusplus
+    static int _nsyyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(_nsyy_c_buf_p) = (_nsyy_hold_char);
+
+	if ( *(_nsyy_c_buf_p) == _NSYY_END_OF_BUFFER_CHAR )
+		{
+		/* _nsyy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (_nsyy_c_buf_p) < &_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_ch_buf[(_nsyy_n_chars)] )
+			/* This was really a NUL. */
+			*(_nsyy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (int) ((_nsyy_c_buf_p) - (_nsyytext_ptr));
+			++(_nsyy_c_buf_p);
+
+			switch ( _nsyy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because _nsyy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					_nsyyrestart( _nsyyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( _nsyywrap(  ) )
+						return 0;
+
+					if ( ! (_nsyy_did_buffer_switch_on_eof) )
+						_NSYY_NEW_FILE;
+#ifdef __cplusplus
+					return _nsyyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(_nsyy_c_buf_p) = (_nsyytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (_nsyy_c_buf_p);	/* cast for 8-bit char's */
+	*(_nsyy_c_buf_p) = '\0';	/* preserve _nsyytext */
+	(_nsyy_hold_char) = *++(_nsyy_c_buf_p);
+
+	if ( c == '\n' )
+		
+    _nsyylineno++;
+;
+
+	return c;
+}
+#endif	/* ifndef _NSYY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void _nsyyrestart  (FILE * input_file )
+{
+    
+	if ( ! _NSYY_CURRENT_BUFFER ){
+        _nsyyensure_buffer_stack ();
+		_NSYY_CURRENT_BUFFER_LVALUE =
+            _nsyy_create_buffer( _nsyyin, _NSYY_BUF_SIZE );
+	}
+
+	_nsyy_init_buffer( _NSYY_CURRENT_BUFFER, input_file );
+	_nsyy_load_buffer_state(  );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void _nsyy_switch_to_buffer  (_NSYY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		_nsyypop_buffer_state();
+	 *		_nsyypush_buffer_state(new_buffer);
+     */
+	_nsyyensure_buffer_stack ();
+	if ( _NSYY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( _NSYY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(_nsyy_c_buf_p) = (_nsyy_hold_char);
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_pos = (_nsyy_c_buf_p);
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_n_chars = (_nsyy_n_chars);
+		}
+
+	_NSYY_CURRENT_BUFFER_LVALUE = new_buffer;
+	_nsyy_load_buffer_state(  );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (_nsyywrap()) processing, but the only time this flag
+	 * is looked at is after _nsyywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(_nsyy_did_buffer_switch_on_eof) = 1;
+}
+
+static void _nsyy_load_buffer_state  (void)
+{
+    	(_nsyy_n_chars) = _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_n_chars;
+	(_nsyytext_ptr) = (_nsyy_c_buf_p) = _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_pos;
+	_nsyyin = _NSYY_CURRENT_BUFFER_LVALUE->_nsyy_input_file;
+	(_nsyy_hold_char) = *(_nsyy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c _NSYY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    _NSYY_BUFFER_STATE _nsyy_create_buffer  (FILE * file, int  size )
+{
+	_NSYY_BUFFER_STATE b;
+    
+	b = (_NSYY_BUFFER_STATE) _nsyyalloc( sizeof( struct _nsyy_buffer_state )  );
+	if ( ! b )
+		_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyy_create_buffer()" );
+
+	b->_nsyy_buf_size = size;
+
+	/* _nsyy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->_nsyy_ch_buf = (char *) _nsyyalloc( (_nsyy_size_t) (b->_nsyy_buf_size + 2)  );
+	if ( ! b->_nsyy_ch_buf )
+		_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyy_create_buffer()" );
+
+	b->_nsyy_is_our_buffer = 1;
+
+	_nsyy_init_buffer( b, file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with _nsyy_create_buffer()
+ * 
+ */
+    void _nsyy_delete_buffer (_NSYY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == _NSYY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		_NSYY_CURRENT_BUFFER_LVALUE = (_NSYY_BUFFER_STATE) 0;
+
+	if ( b->_nsyy_is_our_buffer )
+		_nsyyfree( (void *) b->_nsyy_ch_buf  );
+
+	_nsyyfree( (void *) b  );
+}
+
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a _nsyyrestart() or at EOF.
+ */
+    static void _nsyy_init_buffer  (_NSYY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	_nsyy_flush_buffer( b );
+
+	b->_nsyy_input_file = file;
+	b->_nsyy_fill_buffer = 1;
+
+    /* If b is the current buffer, then _nsyy_init_buffer was _probably_
+     * called from _nsyyrestart() or through _nsyy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != _NSYY_CURRENT_BUFFER){
+        b->_nsyy_bs_lineno = 1;
+        b->_nsyy_bs_column = 0;
+    }
+
+        b->_nsyy_is_interactive = 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, _NSYY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c _NSYY_CURRENT_BUFFER.
+ * 
+ */
+    void _nsyy_flush_buffer (_NSYY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->_nsyy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->_nsyy_ch_buf[0] = _NSYY_END_OF_BUFFER_CHAR;
+	b->_nsyy_ch_buf[1] = _NSYY_END_OF_BUFFER_CHAR;
+
+	b->_nsyy_buf_pos = &b->_nsyy_ch_buf[0];
+
+	b->_nsyy_at_bol = 1;
+	b->_nsyy_buffer_status = _NSYY_BUFFER_NEW;
+
+	if ( b == _NSYY_CURRENT_BUFFER )
+		_nsyy_load_buffer_state(  );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void _nsyypush_buffer_state (_NSYY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	_nsyyensure_buffer_stack();
+
+	/* This block is copied from _nsyy_switch_to_buffer. */
+	if ( _NSYY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(_nsyy_c_buf_p) = (_nsyy_hold_char);
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_buf_pos = (_nsyy_c_buf_p);
+		_NSYY_CURRENT_BUFFER_LVALUE->_nsyy_n_chars = (_nsyy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (_NSYY_CURRENT_BUFFER)
+		(_nsyy_buffer_stack_top)++;
+	_NSYY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from _nsyy_switch_to_buffer. */
+	_nsyy_load_buffer_state(  );
+	(_nsyy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void _nsyypop_buffer_state (void)
+{
+    	if (!_NSYY_CURRENT_BUFFER)
+		return;
+
+	_nsyy_delete_buffer(_NSYY_CURRENT_BUFFER );
+	_NSYY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((_nsyy_buffer_stack_top) > 0)
+		--(_nsyy_buffer_stack_top);
+
+	if (_NSYY_CURRENT_BUFFER) {
+		_nsyy_load_buffer_state(  );
+		(_nsyy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void _nsyyensure_buffer_stack (void)
+{
+	_nsyy_size_t num_to_alloc;
+    
+	if (!(_nsyy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		(_nsyy_buffer_stack) = (struct _nsyy_buffer_state**)_nsyyalloc
+								(num_to_alloc * sizeof(struct _nsyy_buffer_state*)
+								);
+		if ( ! (_nsyy_buffer_stack) )
+			_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyyensure_buffer_stack()" );
+
+		memset((_nsyy_buffer_stack), 0, num_to_alloc * sizeof(struct _nsyy_buffer_state*));
+
+		(_nsyy_buffer_stack_max) = num_to_alloc;
+		(_nsyy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((_nsyy_buffer_stack_top) >= ((_nsyy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		_nsyy_size_t grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (_nsyy_buffer_stack_max) + grow_size;
+		(_nsyy_buffer_stack) = (struct _nsyy_buffer_state**)_nsyyrealloc
+								((_nsyy_buffer_stack),
+								num_to_alloc * sizeof(struct _nsyy_buffer_state*)
+								);
+		if ( ! (_nsyy_buffer_stack) )
+			_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((_nsyy_buffer_stack) + (_nsyy_buffer_stack_max), 0, grow_size * sizeof(struct _nsyy_buffer_state*));
+		(_nsyy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object.
+ */
+_NSYY_BUFFER_STATE _nsyy_scan_buffer  (char * base, _nsyy_size_t  size )
+{
+	_NSYY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != _NSYY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != _NSYY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return NULL;
+
+	b = (_NSYY_BUFFER_STATE) _nsyyalloc( sizeof( struct _nsyy_buffer_state )  );
+	if ( ! b )
+		_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyy_scan_buffer()" );
+
+	b->_nsyy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->_nsyy_buf_pos = b->_nsyy_ch_buf = base;
+	b->_nsyy_is_our_buffer = 0;
+	b->_nsyy_input_file = NULL;
+	b->_nsyy_n_chars = b->_nsyy_buf_size;
+	b->_nsyy_is_interactive = 0;
+	b->_nsyy_at_bol = 1;
+	b->_nsyy_fill_buffer = 0;
+	b->_nsyy_buffer_status = _NSYY_BUFFER_NEW;
+
+	_nsyy_switch_to_buffer( b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to _nsyylex() will
+ * scan from a @e copy of @a str.
+ * @param _nsyystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       _nsyy_scan_bytes() instead.
+ */
+_NSYY_BUFFER_STATE _nsyy_scan_string (const char * _nsyystr )
+{
+    
+	return _nsyy_scan_bytes( _nsyystr, (int) strlen(_nsyystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to _nsyylex() will
+ * scan from a @e copy of @a bytes.
+ * @param _nsyybytes the byte buffer to scan
+ * @param __nsyybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+_NSYY_BUFFER_STATE _nsyy_scan_bytes  (const char * _nsyybytes, int  __nsyybytes_len )
+{
+	_NSYY_BUFFER_STATE b;
+	char *buf;
+	_nsyy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = (_nsyy_size_t) (__nsyybytes_len + 2);
+	buf = (char *) _nsyyalloc( n  );
+	if ( ! buf )
+		_NSYY_FATAL_ERROR( "out of dynamic memory in _nsyy_scan_bytes()" );
+
+	for ( i = 0; i < __nsyybytes_len; ++i )
+		buf[i] = _nsyybytes[i];
+
+	buf[__nsyybytes_len] = buf[__nsyybytes_len+1] = _NSYY_END_OF_BUFFER_CHAR;
+
+	b = _nsyy_scan_buffer( buf, n );
+	if ( ! b )
+		_NSYY_FATAL_ERROR( "bad buffer in _nsyy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->_nsyy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef _NSYY_EXIT_FAILURE
+#define _NSYY_EXIT_FAILURE 2
+#endif
+
+static void _nsyynoreturn _nsyy_fatal_error (const char* msg )
+{
+			fprintf( stderr, "%s\n", msg );
+	exit( _NSYY_EXIT_FAILURE );
+}
+
+/* Redefine _nsyyless() so it works in section 3 code. */
+
+#undef _nsyyless
+#define _nsyyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up _nsyytext. */ \
+        int _nsyyless_macro_arg = (n); \
+        _NSYY_LESS_LINENO(_nsyyless_macro_arg);\
+		_nsyytext[_nsyyleng] = (_nsyy_hold_char); \
+		(_nsyy_c_buf_p) = _nsyytext + _nsyyless_macro_arg; \
+		(_nsyy_hold_char) = *(_nsyy_c_buf_p); \
+		*(_nsyy_c_buf_p) = '\0'; \
+		_nsyyleng = _nsyyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int _nsyyget_lineno  (void)
+{
+    
+    return _nsyylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *_nsyyget_in  (void)
+{
+        return _nsyyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *_nsyyget_out  (void)
+{
+        return _nsyyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int _nsyyget_leng  (void)
+{
+        return _nsyyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *_nsyyget_text  (void)
+{
+        return _nsyytext;
+}
+
+/** Set the current line number.
+ * @param _line_number line number
+ * 
+ */
+void _nsyyset_lineno (int  _line_number )
+{
+    
+    _nsyylineno = _line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param _in_str A readable stream.
+ * 
+ * @see _nsyy_switch_to_buffer
+ */
+void _nsyyset_in (FILE *  _in_str )
+{
+        _nsyyin = _in_str ;
+}
+
+void _nsyyset_out (FILE *  _out_str )
+{
+        _nsyyout = _out_str ;
+}
+
+int _nsyyget_debug  (void)
+{
+        return _nsyy_flex_debug;
+}
+
+void _nsyyset_debug (int  _bdebug )
+{
+        _nsyy_flex_debug = _bdebug ;
+}
+
+static int _nsyy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from _nsyylex_destroy(), so don't allocate here.
+     */
+
+    /* We do not touch _nsyylineno unless the option is enabled. */
+    _nsyylineno =  1;
+    
+    (_nsyy_buffer_stack) = NULL;
+    (_nsyy_buffer_stack_top) = 0;
+    (_nsyy_buffer_stack_max) = 0;
+    (_nsyy_c_buf_p) = NULL;
+    (_nsyy_init) = 0;
+    (_nsyy_start) = 0;
+
+/* Defined in main.c */
+#ifdef _NSYY_STDINIT
+    _nsyyin = stdin;
+    _nsyyout = stdout;
+#else
+    _nsyyin = NULL;
+    _nsyyout = NULL;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * _nsyylex_init()
+     */
+    return 0;
+}
+
+/* _nsyylex_destroy is for both reentrant and non-reentrant scanners. */
+int _nsyylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(_NSYY_CURRENT_BUFFER){
+		_nsyy_delete_buffer( _NSYY_CURRENT_BUFFER  );
+		_NSYY_CURRENT_BUFFER_LVALUE = NULL;
+		_nsyypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	_nsyyfree((_nsyy_buffer_stack) );
+	(_nsyy_buffer_stack) = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * _nsyylex() is called, initialization will occur. */
+    _nsyy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef _nsyytext_ptr
+static void _nsyy_flex_strncpy (char* s1, const char * s2, int n )
+{
+		
+	int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef _NSYY_NEED_STRLEN
+static int _nsyy_flex_strlen (const char * s )
+{
+	int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *_nsyyalloc (_nsyy_size_t  size )
+{
+			return malloc(size);
+}
+
+void *_nsyyrealloc  (void * ptr, _nsyy_size_t  size )
+{
+		
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return realloc(ptr, size);
+}
+
+void _nsyyfree (void * ptr )
+{
+			free( (char *) ptr );	/* see _nsyyrealloc() for (char *) cast */
+}
+
+#define _NSYYTABLES_NAME "_nsyytables"
+
+#line 95 "/home/marven/Git/cheviot/bsdutils/lib/nslexer.l"
+
+
+#undef _ns_nsyywrap
+int
+_ns_nsyywrap(void)
+{
+	return 1;
+} /* _ns_nsyywrap */
+
+void
+_ns_nsyyerror(const char *msg)
+{
+
+	 log_warn("libc nsdispatch: %s line %d: %s at '%s'",
+	    _PATH_NS_CONF, _nsyylineno, msg, _nsyytext);
+} /* _ns_nsyyerror */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nslexer.l.txt third_party/newlib-4.1.0/newlib/libc/sys/arm/nslexer.l.txt
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nslexer.l.txt	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/nslexer.l.txt	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,110 @@
+%{
+/*	$NetBSD: nslexer.l,v 1.13 2012/06/25 22:32:45 abs Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: nslexer.l,v 1.13 2012/06/25 22:32:45 abs Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <ctype.h>
+#define _NS_PRIVATE
+#include <nsswitch.h>
+#include <string.h>
+//#include <syslog.h>
+#include <sys/debug.h>
+
+#include "nsparser.h"
+
+%}
+
+%option yylineno nounput noinput
+%option never-interactive
+
+BLANK		[ \t]
+CR		\n
+STRING		[a-zA-Z][a-zA-Z0-9_]*
+
+%%
+
+{BLANK}+	;			/* skip whitespace */
+
+#.*		;			/* skip comments */
+
+\\{CR}		;			/* allow continuation */
+
+{CR}		return NL;
+
+[sS][uU][cC][cC][eE][sS][sS]		return SUCCESS;
+[uU][nN][aA][vV][aA][iI][lL]		return UNAVAIL;
+[nN][oO][tT][fF][oO][uU][nN][dD]	return NOTFOUND;
+[tT][rR][yY][aA][gG][aA][iI][nN]	return TRYAGAIN;
+
+[rR][eE][tT][uU][rR][nN]		return RETURN;
+[cC][oO][nN][tT][iI][nN][uU][eE]	return CONTINUE;
+
+{STRING}	{
+			char *p;
+			size_t i;
+
+			if ((p = strdup(yytext)) == NULL) {
+				log_error("libc nsdispatch: %m");
+				return NL;
+			}
+
+			for (i = 0; i < strlen(p); i++) {
+				if (isupper((unsigned char)p[i]))
+					p[i] = tolower((unsigned char)p[i]);
+			}
+//			_nsyylval.str = p;
+			yylval.str = p;
+			return STRING;
+		}
+
+.		return yytext[0];
+
+%%
+
+#undef _nsyywrap
+int
+_nsyywrap(void)
+{
+	return 1;
+} /* _nsyywrap */
+
+void
+_nsyyerror(const char *msg)
+{
+
+	 log_warn("libc nsdispatch: %s line %d: %s at '%s'",
+	    _PATH_NS_CONF, yylineno, msg, yytext);
+} /* _nsyyerror */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsparser.c third_party/newlib-4.1.0/newlib/libc/sys/arm/nsparser.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsparser.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/nsparser.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,1458 @@
+/* original parser id follows */
+/* _nsyysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93" */
+/* (use _NSYYMAJOR/_NSYYMINOR for ifdefs dependent on parser version) */
+
+#define _NSYYBYACC 1
+#define _NSYYMAJOR 2
+#define _NSYYMINOR 0
+#define _NSYYPATCH 20220114
+
+#define _ns_nsyytext   _nsyytext
+#define _ns_nsyylineno	_nsyylineno
+
+#define _NSYYEMPTY        (-1)
+#define _nsyyclearin      (_nsyychar = _NSYYEMPTY)
+#define _nsyyerrok        (_nsyyerrflag = 0)
+#define _NSYYRECOVERING() (_nsyyerrflag != 0)
+#define _NSYYENOMEM       (-2)
+#define _NSYYEOF          0
+#undef _NSYYBTYACC
+#define _NSYYBTYACC 0
+#define _NSYYDEBUGSTR _NSYYPREFIX "debug"
+#define _NSYYPREFIX "_nsyy"
+
+#define _NSYYPURE 0
+
+#line 2 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+/*	$NetBSD: nsparser.y,v 1.12 2012/03/20 17:44:18 matt Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: nsparser.y,v 1.12 2012/03/20 17:44:18 matt Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <assert.h>
+#define _NS_PRIVATE
+#include <nsswitch.h>
+#include <stdio.h>
+#include <string.h>
+/*#include <syslog.h>*/
+#include <sys/debug.h>
+
+static	void	_nsaddsrctomap(const char *);
+
+static	ns_dbt		curdbt;
+static	ns_src		cursrc;
+
+extern char *	_ns_nsyytext;
+extern int _ns_nsyylineno;
+#ifdef _NSYYSTYPE
+#undef  _NSYYSTYPE_IS_DECLARED
+#define _NSYYSTYPE_IS_DECLARED 1
+#endif
+#ifndef _NSYYSTYPE_IS_DECLARED
+#define _NSYYSTYPE_IS_DECLARED 1
+#line 57 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+typedef union _NSYYSTYPE {
+	char *str;
+	int   mapval;
+} _NSYYSTYPE;
+#endif /* !_NSYYSTYPE_IS_DECLARED */
+#line 90 "nsparser.c"
+
+/* compatibility with bison */
+#ifdef _NSYYPARSE_PARAM
+/* compatibility with FreeBSD */
+# ifdef _NSYYPARSE_PARAM_TYPE
+#  define _NSYYPARSE_DECL() _nsyyparse(_NSYYPARSE_PARAM_TYPE _NSYYPARSE_PARAM)
+# else
+#  define _NSYYPARSE_DECL() _nsyyparse(void *_NSYYPARSE_PARAM)
+# endif
+#else
+# define _NSYYPARSE_DECL() _nsyyparse(void)
+#endif
+
+/* Parameters sent to lex. */
+#ifdef _NSYYLEX_PARAM
+# define _NSYYLEX_DECL() _nsyylex(void *_NSYYLEX_PARAM)
+# define _NSYYLEX _nsyylex(_NSYYLEX_PARAM)
+#else
+# define _NSYYLEX_DECL() _nsyylex(void)
+# define _NSYYLEX _nsyylex()
+#endif
+
+#if !(defined(_nsyylex) || defined(_NSYYSTATE))
+int _NSYYLEX_DECL();
+#endif
+
+/* Parameters sent to _nsyyerror. */
+#ifndef _NSYYERROR_DECL
+#define _NSYYERROR_DECL() _ns_nsyyerror(const char *s)
+#endif
+#ifndef _NSYYERROR_CALL
+#define _NSYYERROR_CALL(msg) _ns_nsyyerror(msg)
+#endif
+
+extern int _NSYYPARSE_DECL();
+
+#define NL 257
+#define SUCCESS 258
+#define UNAVAIL 259
+#define NOTFOUND 260
+#define TRYAGAIN 261
+#define RETURN 262
+#define CONTINUE 263
+#define STRING 264
+#define _NSYYERRCODE 256
+typedef int _NSYYINT;
+static const _NSYYINT _nsyylhs[] = {                           -1,
+    0,    0,    3,    3,    4,    4,    4,    4,    5,    6,
+    6,    7,    9,    7,    8,    8,   10,    1,    1,    1,
+    1,    2,    2,
+};
+static const _NSYYINT _nsyylen[] = {                            2,
+    0,    1,    1,    2,    1,    3,    4,    2,    1,    1,
+    2,    1,    0,    5,    1,    2,    3,    1,    1,    1,
+    1,    1,    1,
+};
+static const _NSYYINT _nsyydefred[] = {                         0,
+    0,    5,    9,    0,    0,    3,    0,    8,    4,    0,
+    6,    0,    0,   10,   13,    7,   11,    0,   18,   19,
+   20,   21,    0,    0,   15,    0,   14,   16,   22,   23,
+   17,
+};
+#if defined(_NSYYDESTRUCT_CALL) || defined(_NSYYSTYPE_TOSTRING)
+static const _NSYYINT _nsyystos[] = {                           0,
+  256,  257,  264,  266,  269,  270,  271,  257,  270,   58,
+  257,  264,  272,  273,   91,  257,  273,  275,  258,  259,
+  260,  261,  267,  274,  276,   61,   93,  276,  262,  263,
+  268,
+};
+#endif /* _NSYYDESTRUCT_CALL || _NSYYSTYPE_TOSTRING */
+static const _NSYYINT _nsyydgoto[] = {                          4,
+   23,   31,    5,    6,    7,   13,   14,   24,   18,   25,
+};
+static const _NSYYINT _nsyysindex[] = {                      -255,
+ -249,    0,    0,    0, -255,    0,  -41,    0,    0, -254,
+    0,  -73, -253,    0,    0,    0,    0, -245,    0,    0,
+    0,    0,  -42,  -93,    0, -256,    0,    0,    0,    0,
+    0,
+};
+static const _NSYYINT _nsyyrindex[] = {                        20,
+    0,    0,    0,    0,   21,    0,    0,    0,    0,    0,
+    0, -252,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,
+};
+#if _NSYYBTYACC
+static const _NSYYINT _nsyycindex[] = {                         0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,
+};
+#endif
+static const _NSYYINT _nsyygindex[] = {                         0,
+    0,    0,    0,   17,    0,    0,   10,    0,    0,    1,
+};
+#define _NSYYTABLESIZE 168
+static const _NSYYINT _nsyytable[] = {                         27,
+    1,    2,   11,   16,   12,   29,   30,    8,    3,   12,
+   12,   12,   19,   20,   21,   22,   10,   15,   26,    1,
+    2,    9,   17,    0,   28,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
+    0,    0,    0,    0,   19,   20,   21,   22,
+};
+static const _NSYYINT _nsyycheck[] = {                         93,
+  256,  257,  257,  257,  257,  262,  263,  257,  264,  264,
+  264,  264,  258,  259,  260,  261,   58,   91,   61,    0,
+    0,    5,   13,   -1,   24,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,  258,  259,  260,  261,
+};
+#if _NSYYBTYACC
+static const _NSYYINT _nsyyctable[] = {                        -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+   -1,   -1,   -1,   -1,   -1,   -1,   -1,
+};
+#endif
+#define _NSYYFINAL 4
+#ifndef _NSYYDEBUG
+#define _NSYYDEBUG 0
+#endif
+#define _NSYYMAXTOKEN 264
+#define _NSYYUNDFTOKEN 277
+#define _NSYYTRANSLATE(a) ((a) > _NSYYMAXTOKEN ? _NSYYUNDFTOKEN : (a))
+#if _NSYYDEBUG
+static const char *const _nsyyname[] = {
+
+"$end",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"':'",0,0,"'='",0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"error","NL","SUCCESS",
+"UNAVAIL","NOTFOUND","TRYAGAIN","RETURN","CONTINUE","STRING","$accept","File",
+"Status","Action","Lines","Entry","Database","Srclist","Item","Criteria","$$1",
+"Criterion","illegal-symbol",
+};
+static const char *const _nsyyrule[] = {
+"$accept : File",
+"File :",
+"File : Lines",
+"Lines : Entry",
+"Lines : Lines Entry",
+"Entry : NL",
+"Entry : Database ':' NL",
+"Entry : Database ':' Srclist NL",
+"Entry : error NL",
+"Database : STRING",
+"Srclist : Item",
+"Srclist : Srclist Item",
+"Item : STRING",
+"$$1 :",
+"Item : STRING '[' $$1 Criteria ']'",
+"Criteria : Criterion",
+"Criteria : Criteria Criterion",
+"Criterion : Status '=' Action",
+"Status : SUCCESS",
+"Status : UNAVAIL",
+"Status : NOTFOUND",
+"Status : TRYAGAIN",
+"Action : RETURN",
+"Action : CONTINUE",
+
+};
+#endif
+
+#if _NSYYDEBUG
+int      _nsyydebug;
+#endif
+
+int      _nsyyerrflag;
+int      _nsyychar;
+_NSYYSTYPE  _nsyyval;
+_NSYYSTYPE  _nsyylval;
+int      _nsyynerrs;
+
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+_NSYYLTYPE  _nsyyloc; /* position returned by actions */
+_NSYYLTYPE  _nsyylloc; /* position from the lexer */
+#endif
+
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+#ifndef _NSYYLLOC_DEFAULT
+#define _NSYYLLOC_DEFAULT(loc, rhs, n) \
+do \
+{ \
+    if (n == 0) \
+    { \
+        (loc).first_line   = _NSYYRHSLOC(rhs, 0).last_line; \
+        (loc).first_column = _NSYYRHSLOC(rhs, 0).last_column; \
+        (loc).last_line    = _NSYYRHSLOC(rhs, 0).last_line; \
+        (loc).last_column  = _NSYYRHSLOC(rhs, 0).last_column; \
+    } \
+    else \
+    { \
+        (loc).first_line   = _NSYYRHSLOC(rhs, 1).first_line; \
+        (loc).first_column = _NSYYRHSLOC(rhs, 1).first_column; \
+        (loc).last_line    = _NSYYRHSLOC(rhs, n).last_line; \
+        (loc).last_column  = _NSYYRHSLOC(rhs, n).last_column; \
+    } \
+} while (0)
+#endif /* _NSYYLLOC_DEFAULT */
+#endif /* defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED) */
+#if _NSYYBTYACC
+
+#ifndef _NSYYLVQUEUEGROWTH
+#define _NSYYLVQUEUEGROWTH 32
+#endif
+#endif /* _NSYYBTYACC */
+
+/* define the initial stack-sizes */
+#ifdef _NSYYSTACKSIZE
+#undef _NSYYMAXDEPTH
+#define _NSYYMAXDEPTH  _NSYYSTACKSIZE
+#else
+#ifdef _NSYYMAXDEPTH
+#define _NSYYSTACKSIZE _NSYYMAXDEPTH
+#else
+#define _NSYYSTACKSIZE 10000
+#define _NSYYMAXDEPTH  10000
+#endif
+#endif
+
+#ifndef _NSYYINITSTACKSIZE
+#define _NSYYINITSTACKSIZE 200
+#endif
+
+typedef struct {
+    unsigned stacksize;
+    _NSYYINT    *s_base;
+    _NSYYINT    *s_mark;
+    _NSYYINT    *s_last;
+    _NSYYSTYPE  *l_base;
+    _NSYYSTYPE  *l_mark;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _NSYYLTYPE  *p_base;
+    _NSYYLTYPE  *p_mark;
+#endif
+} _NSYYSTACKDATA;
+#if _NSYYBTYACC
+
+struct _NSYYParseState_s
+{
+    struct _NSYYParseState_s *save;    /* Previously saved parser state */
+    _NSYYSTACKDATA            _nsyystack; /* saved parser stack */
+    int                    state;   /* saved parser state */
+    int                    errflag; /* saved error recovery status */
+    int                    lexeme;  /* saved index of the conflict lexeme in the lexical queue */
+    _NSYYINT                  ctry;    /* saved index in _nsyyctable[] for this conflict */
+};
+typedef struct _NSYYParseState_s _NSYYParseState;
+#endif /* _NSYYBTYACC */
+/* variables for the parser stack */
+static _NSYYSTACKDATA _nsyystack;
+#if _NSYYBTYACC
+
+/* Current parser state */
+static _NSYYParseState *_nsyyps = 0;
+
+/* _nsyypath != NULL: do the full parse, starting at *_nsyypath parser state. */
+static _NSYYParseState *_nsyypath = 0;
+
+/* Base of the lexical value queue */
+static _NSYYSTYPE *_nsyylvals = 0;
+
+/* Current position at lexical value queue */
+static _NSYYSTYPE *_nsyylvp = 0;
+
+/* End position of lexical value queue */
+static _NSYYSTYPE *_nsyylve = 0;
+
+/* The last allocated position at the lexical value queue */
+static _NSYYSTYPE *_nsyylvlim = 0;
+
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+/* Base of the lexical position queue */
+static _NSYYLTYPE *_nsyylpsns = 0;
+
+/* Current position at lexical position queue */
+static _NSYYLTYPE *_nsyylpp = 0;
+
+/* End position of lexical position queue */
+static _NSYYLTYPE *_nsyylpe = 0;
+
+/* The last allocated position at the lexical position queue */
+static _NSYYLTYPE *_nsyylplim = 0;
+#endif
+
+/* Current position at lexical token queue */
+static _NSYYINT  *_nsyylexp = 0;
+
+static _NSYYINT  *_nsyylexemes = 0;
+#endif /* _NSYYBTYACC */
+#line 155 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+
+static void
+_nsaddsrctomap(const char *elem)
+{
+	unsigned int	i;
+	int		lineno;
+
+	_DIAGASSERT(elem != NULL);
+
+	lineno = _ns_nsyylineno - (*_ns_nsyytext == '\n' ? 1 : 0);
+	if (curdbt.srclistsize > 0) {
+		if ((strcasecmp(elem, NSSRC_COMPAT) == 0) ||
+		    (strcasecmp(curdbt.srclist[0].name, NSSRC_COMPAT) == 0)) {
+			log_warn(
+			    "libc nsdispatch: %s line %d: %s",
+			    _PATH_NS_CONF, lineno,
+			    "'compat' used with other sources");
+			return;
+		}
+	}
+	for (i = 0; i < curdbt.srclistsize; i++) {
+		if (strcasecmp(curdbt.srclist[i].name, elem) == 0) {
+			log_warn(
+			    "libc nsdispatch: %s line %d: %s '%s'",
+			    _PATH_NS_CONF, lineno,
+			    "duplicate source", elem);
+			return;
+		}
+	}
+	cursrc.name = elem;
+	if (_nsdbtaddsrc(&curdbt, &cursrc) == -1) {
+		log_warn(
+		    "libc nsdispatch: %s line %d: %s '%s'",
+		    _PATH_NS_CONF, lineno,
+		    "error adding", elem);
+	}
+}
+#line 462 "nsparser.c"
+
+/* For use in generated program */
+#define _nsyydepth (int)(_nsyystack.s_mark - _nsyystack.s_base)
+#if _NSYYBTYACC
+#define _nsyytrial (_nsyyps->save)
+#endif /* _NSYYBTYACC */
+
+#if _NSYYDEBUG
+#include <stdio.h>	/* needed for printf */
+#endif
+
+#include <stdlib.h>	/* needed for malloc, etc */
+#include <string.h>	/* needed for memset */
+
+/* allocate initial stack or double stack size, up to _NSYYMAXDEPTH */
+static int _nsyygrowstack(_NSYYSTACKDATA *data)
+{
+    int i;
+    unsigned newsize;
+    _NSYYINT *newss;
+    _NSYYSTYPE *newvs;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _NSYYLTYPE *newps;
+#endif
+
+    if ((newsize = data->stacksize) == 0)
+        newsize = _NSYYINITSTACKSIZE;
+    else if (newsize >= _NSYYMAXDEPTH)
+        return _NSYYENOMEM;
+    else if ((newsize *= 2) > _NSYYMAXDEPTH)
+        newsize = _NSYYMAXDEPTH;
+
+    i = (int) (data->s_mark - data->s_base);
+    newss = (_NSYYINT *)realloc(data->s_base, newsize * sizeof(*newss));
+    if (newss == 0)
+        return _NSYYENOMEM;
+
+    data->s_base = newss;
+    data->s_mark = newss + i;
+
+    newvs = (_NSYYSTYPE *)realloc(data->l_base, newsize * sizeof(*newvs));
+    if (newvs == 0)
+        return _NSYYENOMEM;
+
+    data->l_base = newvs;
+    data->l_mark = newvs + i;
+
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    newps = (_NSYYLTYPE *)realloc(data->p_base, newsize * sizeof(*newps));
+    if (newps == 0)
+        return _NSYYENOMEM;
+
+    data->p_base = newps;
+    data->p_mark = newps + i;
+#endif
+
+    data->stacksize = newsize;
+    data->s_last = data->s_base + newsize - 1;
+
+#if _NSYYDEBUG
+    if (_nsyydebug)
+        fprintf(stderr, "%sdebug: stack size increased to %d\n", _NSYYPREFIX, newsize);
+#endif
+    return 0;
+}
+
+#if _NSYYPURE || defined(_NSYY_NO_LEAKS)
+static void _nsyyfreestack(_NSYYSTACKDATA *data)
+{
+    free(data->s_base);
+    free(data->l_base);
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    free(data->p_base);
+#endif
+    memset(data, 0, sizeof(*data));
+}
+#else
+#define _nsyyfreestack(data) /* nothing */
+#endif /* _NSYYPURE || defined(_NSYY_NO_LEAKS) */
+#if _NSYYBTYACC
+
+static _NSYYParseState *
+_nsyyNewState(unsigned size)
+{
+    _NSYYParseState *p = (_NSYYParseState *) malloc(sizeof(_NSYYParseState));
+    if (p == NULL) return NULL;
+
+    p->_nsyystack.stacksize = size;
+    if (size == 0)
+    {
+        p->_nsyystack.s_base = NULL;
+        p->_nsyystack.l_base = NULL;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        p->_nsyystack.p_base = NULL;
+#endif
+        return p;
+    }
+    p->_nsyystack.s_base    = (_NSYYINT *) malloc(size * sizeof(_NSYYINT));
+    if (p->_nsyystack.s_base == NULL) return NULL;
+    p->_nsyystack.l_base    = (_NSYYSTYPE *) malloc(size * sizeof(_NSYYSTYPE));
+    if (p->_nsyystack.l_base == NULL) return NULL;
+    memset(p->_nsyystack.l_base, 0, size * sizeof(_NSYYSTYPE));
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    p->_nsyystack.p_base    = (_NSYYLTYPE *) malloc(size * sizeof(_NSYYLTYPE));
+    if (p->_nsyystack.p_base == NULL) return NULL;
+    memset(p->_nsyystack.p_base, 0, size * sizeof(_NSYYLTYPE));
+#endif
+
+    return p;
+}
+
+static void
+_nsyyFreeState(_NSYYParseState *p)
+{
+    _nsyyfreestack(&p->_nsyystack);
+    free(p);
+}
+#endif /* _NSYYBTYACC */
+
+#define _NSYYABORT  goto _nsyyabort
+#define _NSYYREJECT goto _nsyyabort
+#define _NSYYACCEPT goto _nsyyaccept
+#define _NSYYERROR  goto _nsyyerrlab
+#if _NSYYBTYACC
+#define _NSYYVALID        do { if (_nsyyps->save)            goto _nsyyvalid; } while(0)
+#define _NSYYVALID_NESTED do { if (_nsyyps->save && \
+                                _nsyyps->save->save == 0) goto _nsyyvalid; } while(0)
+#endif /* _NSYYBTYACC */
+
+int
+_NSYYPARSE_DECL()
+{
+    int _nsyym, _nsyyn, _nsyystate, _nsyyresult;
+#if _NSYYBTYACC
+    int _nsyynewerrflag;
+    _NSYYParseState *_nsyyerrctx = NULL;
+#endif /* _NSYYBTYACC */
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _NSYYLTYPE  _nsyyerror_loc_range[3]; /* position of error start/end (0 unused) */
+#endif
+#if _NSYYDEBUG
+    const char *_nsyys;
+
+    if ((_nsyys = getenv("_NSYYDEBUG")) != 0)
+    {
+        _nsyyn = *_nsyys;
+        if (_nsyyn >= '0' && _nsyyn <= '9')
+            _nsyydebug = _nsyyn - '0';
+    }
+    if (_nsyydebug)
+        fprintf(stderr, "%sdebug[<# of symbols on state stack>]\n", _NSYYPREFIX);
+#endif
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    memset(_nsyyerror_loc_range, 0, sizeof(_nsyyerror_loc_range));
+#endif
+
+#if _NSYYBTYACC
+    _nsyyps = _nsyyNewState(0); if (_nsyyps == 0) goto _nsyyenomem;
+    _nsyyps->save = 0;
+#endif /* _NSYYBTYACC */
+    _nsyym = 0;
+    /* _nsyyn is set below */
+    _nsyynerrs = 0;
+    _nsyyerrflag = 0;
+    _nsyychar = _NSYYEMPTY;
+    _nsyystate = 0;
+
+#if _NSYYPURE
+    memset(&_nsyystack, 0, sizeof(_nsyystack));
+#endif
+
+    if (_nsyystack.s_base == NULL && _nsyygrowstack(&_nsyystack) == _NSYYENOMEM) goto _nsyyoverflow;
+    _nsyystack.s_mark = _nsyystack.s_base;
+    _nsyystack.l_mark = _nsyystack.l_base;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _nsyystack.p_mark = _nsyystack.p_base;
+#endif
+    _nsyystate = 0;
+    *_nsyystack.s_mark = 0;
+
+_nsyyloop:
+    if ((_nsyyn = _nsyydefred[_nsyystate]) != 0) goto _nsyyreduce;
+    if (_nsyychar < 0)
+    {
+#if _NSYYBTYACC
+        do {
+        if (_nsyylvp < _nsyylve)
+        {
+            /* we're currently re-reading tokens */
+            _nsyylval = *_nsyylvp++;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            _nsyylloc = *_nsyylpp++;
+#endif
+            _nsyychar = *_nsyylexp++;
+            break;
+        }
+        if (_nsyyps->save)
+        {
+            /* in trial mode; save scanner results for future parse attempts */
+            if (_nsyylvp == _nsyylvlim)
+            {   /* Enlarge lexical value queue */
+                size_t p = (size_t) (_nsyylvp - _nsyylvals);
+                size_t s = (size_t) (_nsyylvlim - _nsyylvals);
+
+                s += _NSYYLVQUEUEGROWTH;
+                if ((_nsyylexemes = (_NSYYINT *)realloc(_nsyylexemes, s * sizeof(_NSYYINT))) == NULL) goto _nsyyenomem;
+                if ((_nsyylvals   = (_NSYYSTYPE *)realloc(_nsyylvals, s * sizeof(_NSYYSTYPE))) == NULL) goto _nsyyenomem;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                if ((_nsyylpsns   = (_NSYYLTYPE *)realloc(_nsyylpsns, s * sizeof(_NSYYLTYPE))) == NULL) goto _nsyyenomem;
+#endif
+                _nsyylvp   = _nsyylve = _nsyylvals + p;
+                _nsyylvlim = _nsyylvals + s;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                _nsyylpp   = _nsyylpe = _nsyylpsns + p;
+                _nsyylplim = _nsyylpsns + s;
+#endif
+                _nsyylexp  = _nsyylexemes + p;
+            }
+            *_nsyylexp = (_NSYYINT) _NSYYLEX;
+            *_nsyylvp++ = _nsyylval;
+            _nsyylve++;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            *_nsyylpp++ = _nsyylloc;
+            _nsyylpe++;
+#endif
+            _nsyychar = *_nsyylexp++;
+            break;
+        }
+        /* normal operation, no conflict encountered */
+#endif /* _NSYYBTYACC */
+        _nsyychar = _NSYYLEX;
+#if _NSYYBTYACC
+        } while (0);
+#endif /* _NSYYBTYACC */
+        if (_nsyychar < 0) _nsyychar = _NSYYEOF;
+#if _NSYYDEBUG
+        if (_nsyydebug)
+        {
+            if ((_nsyys = _nsyyname[_NSYYTRANSLATE(_nsyychar)]) == NULL) _nsyys = _nsyyname[_NSYYUNDFTOKEN];
+            fprintf(stderr, "%s[%d]: state %d, reading token %d (%s)",
+                            _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyychar, _nsyys);
+#ifdef _NSYYSTYPE_TOSTRING
+#if _NSYYBTYACC
+            if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+                fprintf(stderr, " <%s>", _NSYYSTYPE_TOSTRING(_nsyychar, _nsyylval));
+#endif
+            fputc('\n', stderr);
+        }
+#endif
+    }
+#if _NSYYBTYACC
+
+    /* Do we have a conflict? */
+    if (((_nsyyn = _nsyycindex[_nsyystate]) != 0) && (_nsyyn += _nsyychar) >= 0 &&
+        _nsyyn <= _NSYYTABLESIZE && _nsyycheck[_nsyyn] == (_NSYYINT) _nsyychar)
+    {
+        _NSYYINT ctry;
+
+        if (_nsyypath)
+        {
+            _NSYYParseState *save;
+#if _NSYYDEBUG
+            if (_nsyydebug)
+                fprintf(stderr, "%s[%d]: CONFLICT in state %d: following successful trial parse\n",
+                                _NSYYDEBUGSTR, _nsyydepth, _nsyystate);
+#endif
+            /* Switch to the next conflict context */
+            save = _nsyypath;
+            _nsyypath = save->save;
+            save->save = NULL;
+            ctry = save->ctry;
+            if (save->state != _nsyystate) _NSYYABORT;
+            _nsyyFreeState(save);
+
+        }
+        else
+        {
+
+            /* Unresolved conflict - start/continue trial parse */
+            _NSYYParseState *save;
+#if _NSYYDEBUG
+            if (_nsyydebug)
+            {
+                fprintf(stderr, "%s[%d]: CONFLICT in state %d. ", _NSYYDEBUGSTR, _nsyydepth, _nsyystate);
+                if (_nsyyps->save)
+                    fputs("ALREADY in conflict, continuing trial parse.\n", stderr);
+                else
+                    fputs("Starting trial parse.\n", stderr);
+            }
+#endif
+            save                  = _nsyyNewState((unsigned)(_nsyystack.s_mark - _nsyystack.s_base + 1));
+            if (save == NULL) goto _nsyyenomem;
+            save->save            = _nsyyps->save;
+            save->state           = _nsyystate;
+            save->errflag         = _nsyyerrflag;
+            save->_nsyystack.s_mark  = save->_nsyystack.s_base + (_nsyystack.s_mark - _nsyystack.s_base);
+            memcpy (save->_nsyystack.s_base, _nsyystack.s_base, (size_t) (_nsyystack.s_mark - _nsyystack.s_base + 1) * sizeof(_NSYYINT));
+            save->_nsyystack.l_mark  = save->_nsyystack.l_base + (_nsyystack.l_mark - _nsyystack.l_base);
+            memcpy (save->_nsyystack.l_base, _nsyystack.l_base, (size_t) (_nsyystack.l_mark - _nsyystack.l_base + 1) * sizeof(_NSYYSTYPE));
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            save->_nsyystack.p_mark  = save->_nsyystack.p_base + (_nsyystack.p_mark - _nsyystack.p_base);
+            memcpy (save->_nsyystack.p_base, _nsyystack.p_base, (size_t) (_nsyystack.p_mark - _nsyystack.p_base + 1) * sizeof(_NSYYLTYPE));
+#endif
+            ctry                  = _nsyytable[_nsyyn];
+            if (_nsyyctable[ctry] == -1)
+            {
+#if _NSYYDEBUG
+                if (_nsyydebug && _nsyychar >= _NSYYEOF)
+                    fprintf(stderr, "%s[%d]: backtracking 1 token\n", _NSYYDEBUGSTR, _nsyydepth);
+#endif
+                ctry++;
+            }
+            save->ctry = ctry;
+            if (_nsyyps->save == NULL)
+            {
+                /* If this is a first conflict in the stack, start saving lexemes */
+                if (!_nsyylexemes)
+                {
+                    _nsyylexemes = (_NSYYINT *) malloc((_NSYYLVQUEUEGROWTH) * sizeof(_NSYYINT));
+                    if (_nsyylexemes == NULL) goto _nsyyenomem;
+                    _nsyylvals   = (_NSYYSTYPE *) malloc((_NSYYLVQUEUEGROWTH) * sizeof(_NSYYSTYPE));
+                    if (_nsyylvals == NULL) goto _nsyyenomem;
+                    _nsyylvlim   = _nsyylvals + _NSYYLVQUEUEGROWTH;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                    _nsyylpsns   = (_NSYYLTYPE *) malloc((_NSYYLVQUEUEGROWTH) * sizeof(_NSYYLTYPE));
+                    if (_nsyylpsns == NULL) goto _nsyyenomem;
+                    _nsyylplim   = _nsyylpsns + _NSYYLVQUEUEGROWTH;
+#endif
+                }
+                if (_nsyylvp == _nsyylve)
+                {
+                    _nsyylvp  = _nsyylve = _nsyylvals;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                    _nsyylpp  = _nsyylpe = _nsyylpsns;
+#endif
+                    _nsyylexp = _nsyylexemes;
+                    if (_nsyychar >= _NSYYEOF)
+                    {
+                        *_nsyylve++ = _nsyylval;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                        *_nsyylpe++ = _nsyylloc;
+#endif
+                        *_nsyylexp  = (_NSYYINT) _nsyychar;
+                        _nsyychar   = _NSYYEMPTY;
+                    }
+                }
+            }
+            if (_nsyychar >= _NSYYEOF)
+            {
+                _nsyylvp--;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                _nsyylpp--;
+#endif
+                _nsyylexp--;
+                _nsyychar = _NSYYEMPTY;
+            }
+            save->lexeme = (int) (_nsyylvp - _nsyylvals);
+            _nsyyps->save   = save;
+        }
+        if (_nsyytable[_nsyyn] == ctry)
+        {
+#if _NSYYDEBUG
+            if (_nsyydebug)
+                fprintf(stderr, "%s[%d]: state %d, shifting to state %d\n",
+                                _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyyctable[ctry]);
+#endif
+            if (_nsyychar < 0)
+            {
+                _nsyylvp++;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                _nsyylpp++;
+#endif
+                _nsyylexp++;
+            }
+            if (_nsyystack.s_mark >= _nsyystack.s_last && _nsyygrowstack(&_nsyystack) == _NSYYENOMEM)
+                goto _nsyyoverflow;
+            _nsyystate = _nsyyctable[ctry];
+            *++_nsyystack.s_mark = (_NSYYINT) _nsyystate;
+            *++_nsyystack.l_mark = _nsyylval;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            *++_nsyystack.p_mark = _nsyylloc;
+#endif
+            _nsyychar  = _NSYYEMPTY;
+            if (_nsyyerrflag > 0) --_nsyyerrflag;
+            goto _nsyyloop;
+        }
+        else
+        {
+            _nsyyn = _nsyyctable[ctry];
+            goto _nsyyreduce;
+        }
+    } /* End of code dealing with conflicts */
+#endif /* _NSYYBTYACC */
+    if (((_nsyyn = _nsyysindex[_nsyystate]) != 0) && (_nsyyn += _nsyychar) >= 0 &&
+            _nsyyn <= _NSYYTABLESIZE && _nsyycheck[_nsyyn] == (_NSYYINT) _nsyychar)
+    {
+#if _NSYYDEBUG
+        if (_nsyydebug)
+            fprintf(stderr, "%s[%d]: state %d, shifting to state %d\n",
+                            _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyytable[_nsyyn]);
+#endif
+        if (_nsyystack.s_mark >= _nsyystack.s_last && _nsyygrowstack(&_nsyystack) == _NSYYENOMEM) goto _nsyyoverflow;
+        _nsyystate = _nsyytable[_nsyyn];
+        *++_nsyystack.s_mark = _nsyytable[_nsyyn];
+        *++_nsyystack.l_mark = _nsyylval;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        *++_nsyystack.p_mark = _nsyylloc;
+#endif
+        _nsyychar = _NSYYEMPTY;
+        if (_nsyyerrflag > 0)  --_nsyyerrflag;
+        goto _nsyyloop;
+    }
+    if (((_nsyyn = _nsyyrindex[_nsyystate]) != 0) && (_nsyyn += _nsyychar) >= 0 &&
+            _nsyyn <= _NSYYTABLESIZE && _nsyycheck[_nsyyn] == (_NSYYINT) _nsyychar)
+    {
+        _nsyyn = _nsyytable[_nsyyn];
+        goto _nsyyreduce;
+    }
+    if (_nsyyerrflag != 0) goto _nsyyinrecovery;
+#if _NSYYBTYACC
+
+    _nsyynewerrflag = 1;
+    goto _nsyyerrhandler;
+    goto _nsyyerrlab; /* redundant goto avoids 'unused label' warning */
+
+_nsyyerrlab:
+    /* explicit _NSYYERROR from an action -- pop the rhs of the rule reduced
+     * before looking for error recovery */
+    _nsyystack.s_mark -= _nsyym;
+    _nsyystate = *_nsyystack.s_mark;
+    _nsyystack.l_mark -= _nsyym;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _nsyystack.p_mark -= _nsyym;
+#endif
+
+    _nsyynewerrflag = 0;
+_nsyyerrhandler:
+    while (_nsyyps->save)
+    {
+        int ctry;
+        _NSYYParseState *save = _nsyyps->save;
+#if _NSYYDEBUG
+        if (_nsyydebug)
+            fprintf(stderr, "%s[%d]: ERROR in state %d, CONFLICT BACKTRACKING to state %d, %d tokens\n",
+                            _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyyps->save->state,
+                    (int)(_nsyylvp - _nsyylvals - _nsyyps->save->lexeme));
+#endif
+        /* Memorize most forward-looking error state in case it's really an error. */
+        if (_nsyyerrctx == NULL || _nsyyerrctx->lexeme < _nsyylvp - _nsyylvals)
+        {
+            /* Free old saved error context state */
+            if (_nsyyerrctx) _nsyyFreeState(_nsyyerrctx);
+            /* Create and fill out new saved error context state */
+            _nsyyerrctx                 = _nsyyNewState((unsigned)(_nsyystack.s_mark - _nsyystack.s_base + 1));
+            if (_nsyyerrctx == NULL) goto _nsyyenomem;
+            _nsyyerrctx->save           = _nsyyps->save;
+            _nsyyerrctx->state          = _nsyystate;
+            _nsyyerrctx->errflag        = _nsyyerrflag;
+            _nsyyerrctx->_nsyystack.s_mark = _nsyyerrctx->_nsyystack.s_base + (_nsyystack.s_mark - _nsyystack.s_base);
+            memcpy (_nsyyerrctx->_nsyystack.s_base, _nsyystack.s_base, (size_t) (_nsyystack.s_mark - _nsyystack.s_base + 1) * sizeof(_NSYYINT));
+            _nsyyerrctx->_nsyystack.l_mark = _nsyyerrctx->_nsyystack.l_base + (_nsyystack.l_mark - _nsyystack.l_base);
+            memcpy (_nsyyerrctx->_nsyystack.l_base, _nsyystack.l_base, (size_t) (_nsyystack.l_mark - _nsyystack.l_base + 1) * sizeof(_NSYYSTYPE));
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            _nsyyerrctx->_nsyystack.p_mark = _nsyyerrctx->_nsyystack.p_base + (_nsyystack.p_mark - _nsyystack.p_base);
+            memcpy (_nsyyerrctx->_nsyystack.p_base, _nsyystack.p_base, (size_t) (_nsyystack.p_mark - _nsyystack.p_base + 1) * sizeof(_NSYYLTYPE));
+#endif
+            _nsyyerrctx->lexeme         = (int) (_nsyylvp - _nsyylvals);
+        }
+        _nsyylvp          = _nsyylvals   + save->lexeme;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        _nsyylpp          = _nsyylpsns   + save->lexeme;
+#endif
+        _nsyylexp         = _nsyylexemes + save->lexeme;
+        _nsyychar         = _NSYYEMPTY;
+        _nsyystack.s_mark = _nsyystack.s_base + (save->_nsyystack.s_mark - save->_nsyystack.s_base);
+        memcpy (_nsyystack.s_base, save->_nsyystack.s_base, (size_t) (_nsyystack.s_mark - _nsyystack.s_base + 1) * sizeof(_NSYYINT));
+        _nsyystack.l_mark = _nsyystack.l_base + (save->_nsyystack.l_mark - save->_nsyystack.l_base);
+        memcpy (_nsyystack.l_base, save->_nsyystack.l_base, (size_t) (_nsyystack.l_mark - _nsyystack.l_base + 1) * sizeof(_NSYYSTYPE));
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        _nsyystack.p_mark = _nsyystack.p_base + (save->_nsyystack.p_mark - save->_nsyystack.p_base);
+        memcpy (_nsyystack.p_base, save->_nsyystack.p_base, (size_t) (_nsyystack.p_mark - _nsyystack.p_base + 1) * sizeof(_NSYYLTYPE));
+#endif
+        ctry           = ++save->ctry;
+        _nsyystate        = save->state;
+        /* We tried shift, try reduce now */
+        if ((_nsyyn = _nsyyctable[ctry]) >= 0) goto _nsyyreduce;
+        _nsyyps->save     = save->save;
+        save->save     = NULL;
+        _nsyyFreeState(save);
+
+        /* Nothing left on the stack -- error */
+        if (!_nsyyps->save)
+        {
+#if _NSYYDEBUG
+            if (_nsyydebug)
+                fprintf(stderr, "%sdebug[%d,trial]: trial parse FAILED, entering ERROR mode\n",
+                                _NSYYPREFIX, _nsyydepth);
+#endif
+            /* Restore state as it was in the most forward-advanced error */
+            _nsyylvp          = _nsyylvals   + _nsyyerrctx->lexeme;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            _nsyylpp          = _nsyylpsns   + _nsyyerrctx->lexeme;
+#endif
+            _nsyylexp         = _nsyylexemes + _nsyyerrctx->lexeme;
+            _nsyychar         = _nsyylexp[-1];
+            _nsyylval         = _nsyylvp[-1];
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            _nsyylloc         = _nsyylpp[-1];
+#endif
+            _nsyystack.s_mark = _nsyystack.s_base + (_nsyyerrctx->_nsyystack.s_mark - _nsyyerrctx->_nsyystack.s_base);
+            memcpy (_nsyystack.s_base, _nsyyerrctx->_nsyystack.s_base, (size_t) (_nsyystack.s_mark - _nsyystack.s_base + 1) * sizeof(_NSYYINT));
+            _nsyystack.l_mark = _nsyystack.l_base + (_nsyyerrctx->_nsyystack.l_mark - _nsyyerrctx->_nsyystack.l_base);
+            memcpy (_nsyystack.l_base, _nsyyerrctx->_nsyystack.l_base, (size_t) (_nsyystack.l_mark - _nsyystack.l_base + 1) * sizeof(_NSYYSTYPE));
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            _nsyystack.p_mark = _nsyystack.p_base + (_nsyyerrctx->_nsyystack.p_mark - _nsyyerrctx->_nsyystack.p_base);
+            memcpy (_nsyystack.p_base, _nsyyerrctx->_nsyystack.p_base, (size_t) (_nsyystack.p_mark - _nsyystack.p_base + 1) * sizeof(_NSYYLTYPE));
+#endif
+            _nsyystate        = _nsyyerrctx->state;
+            _nsyyFreeState(_nsyyerrctx);
+            _nsyyerrctx       = NULL;
+        }
+        _nsyynewerrflag = 1;
+    }
+    if (_nsyynewerrflag == 0) goto _nsyyinrecovery;
+#endif /* _NSYYBTYACC */
+
+    _NSYYERROR_CALL("syntax error");
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _nsyyerror_loc_range[1] = _nsyylloc; /* lookahead position is error start position */
+#endif
+
+#if !_NSYYBTYACC
+    goto _nsyyerrlab; /* redundant goto avoids 'unused label' warning */
+_nsyyerrlab:
+#endif
+    ++_nsyynerrs;
+
+_nsyyinrecovery:
+    if (_nsyyerrflag < 3)
+    {
+        _nsyyerrflag = 3;
+        for (;;)
+        {
+            if (((_nsyyn = _nsyysindex[*_nsyystack.s_mark]) != 0) && (_nsyyn += _NSYYERRCODE) >= 0 &&
+                    _nsyyn <= _NSYYTABLESIZE && _nsyycheck[_nsyyn] == (_NSYYINT) _NSYYERRCODE)
+            {
+#if _NSYYDEBUG
+                if (_nsyydebug)
+                    fprintf(stderr, "%s[%d]: state %d, error recovery shifting to state %d\n",
+                                    _NSYYDEBUGSTR, _nsyydepth, *_nsyystack.s_mark, _nsyytable[_nsyyn]);
+#endif
+                if (_nsyystack.s_mark >= _nsyystack.s_last && _nsyygrowstack(&_nsyystack) == _NSYYENOMEM) goto _nsyyoverflow;
+                _nsyystate = _nsyytable[_nsyyn];
+                *++_nsyystack.s_mark = _nsyytable[_nsyyn];
+                *++_nsyystack.l_mark = _nsyylval;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                /* lookahead position is error end position */
+                _nsyyerror_loc_range[2] = _nsyylloc;
+                _NSYYLLOC_DEFAULT(_nsyyloc, _nsyyerror_loc_range, 2); /* position of error span */
+                *++_nsyystack.p_mark = _nsyyloc;
+#endif
+                goto _nsyyloop;
+            }
+            else
+            {
+#if _NSYYDEBUG
+                if (_nsyydebug)
+                    fprintf(stderr, "%s[%d]: error recovery discarding state %d\n",
+                                    _NSYYDEBUGSTR, _nsyydepth, *_nsyystack.s_mark);
+#endif
+                if (_nsyystack.s_mark <= _nsyystack.s_base) goto _nsyyabort;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                /* the current TOS position is the error start position */
+                _nsyyerror_loc_range[1] = *_nsyystack.p_mark;
+#endif
+#if defined(_NSYYDESTRUCT_CALL)
+#if _NSYYBTYACC
+                if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                    _NSYYDESTRUCT_CALL("error: discarding state",
+                                    _nsyystos[*_nsyystack.s_mark], _nsyystack.l_mark, _nsyystack.p_mark);
+#else
+                    _NSYYDESTRUCT_CALL("error: discarding state",
+                                    _nsyystos[*_nsyystack.s_mark], _nsyystack.l_mark);
+#endif /* defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED) */
+#endif /* defined(_NSYYDESTRUCT_CALL) */
+                --_nsyystack.s_mark;
+                --_nsyystack.l_mark;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                --_nsyystack.p_mark;
+#endif
+            }
+        }
+    }
+    else
+    {
+        if (_nsyychar == _NSYYEOF) goto _nsyyabort;
+#if _NSYYDEBUG
+        if (_nsyydebug)
+        {
+            if ((_nsyys = _nsyyname[_NSYYTRANSLATE(_nsyychar)]) == NULL) _nsyys = _nsyyname[_NSYYUNDFTOKEN];
+            fprintf(stderr, "%s[%d]: state %d, error recovery discarding token %d (%s)\n",
+                            _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyychar, _nsyys);
+        }
+#endif
+#if defined(_NSYYDESTRUCT_CALL)
+#if _NSYYBTYACC
+        if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+            _NSYYDESTRUCT_CALL("error: discarding token", _nsyychar, &_nsyylval, &_nsyylloc);
+#else
+            _NSYYDESTRUCT_CALL("error: discarding token", _nsyychar, &_nsyylval);
+#endif /* defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED) */
+#endif /* defined(_NSYYDESTRUCT_CALL) */
+        _nsyychar = _NSYYEMPTY;
+        goto _nsyyloop;
+    }
+
+_nsyyreduce:
+    _nsyym = _nsyylen[_nsyyn];
+#if _NSYYDEBUG
+    if (_nsyydebug)
+    {
+        fprintf(stderr, "%s[%d]: state %d, reducing by rule %d (%s)",
+                        _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyyn, _nsyyrule[_nsyyn]);
+#ifdef _NSYYSTYPE_TOSTRING
+#if _NSYYBTYACC
+        if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+            if (_nsyym > 0)
+            {
+                int i;
+                fputc('<', stderr);
+                for (i = _nsyym; i > 0; i--)
+                {
+                    if (i != _nsyym) fputs(", ", stderr);
+                    fputs(_NSYYSTYPE_TOSTRING(_nsyystos[_nsyystack.s_mark[1-i]],
+                                           _nsyystack.l_mark[1-i]), stderr);
+                }
+                fputc('>', stderr);
+            }
+#endif
+        fputc('\n', stderr);
+    }
+#endif
+    if (_nsyym > 0)
+        _nsyyval = _nsyystack.l_mark[1-_nsyym];
+    else
+        memset(&_nsyyval, 0, sizeof _nsyyval);
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+
+    /* Perform position reduction */
+    memset(&_nsyyloc, 0, sizeof(_nsyyloc));
+#if _NSYYBTYACC
+    if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+    {
+        _NSYYLLOC_DEFAULT(_nsyyloc, &_nsyystack.p_mark[-_nsyym], _nsyym);
+        /* just in case _NSYYERROR is invoked within the action, save
+           the start of the rhs as the error start position */
+        _nsyyerror_loc_range[1] = _nsyystack.p_mark[1-_nsyym];
+    }
+#endif
+
+    switch (_nsyyn)
+    {
+case 7:
+#line 85 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{
+			int lineno;
+
+			lineno = _ns_nsyylineno - (*_ns_nsyytext == '\n' ? 1 : 0);
+			if (_nsdbtput(&curdbt) == -1)
+				log_warn(
+				    "libc nsdispatch: %s line %d: %s",
+				    _PATH_NS_CONF, lineno,
+				    "error adding entry");
+		}
+#line 1144 "nsparser.c"
+break;
+case 8:
+#line 96 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{
+			_nsyyerrok;
+		}
+#line 1151 "nsparser.c"
+break;
+case 9:
+#line 103 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{
+			curdbt.name = _nsyylval.str;
+			curdbt.srclist = NULL;
+			curdbt.srclistsize = 0;
+		}
+#line 1160 "nsparser.c"
+break;
+case 12:
+#line 117 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{
+			cursrc.flags = NS_SUCCESS;
+			_nsaddsrctomap(_nsyystack.l_mark[0].str);
+		}
+#line 1168 "nsparser.c"
+break;
+case 13:
+#line 121 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ cursrc.flags = NS_SUCCESS; }
+#line 1173 "nsparser.c"
+break;
+case 14:
+#line 122 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{
+			_nsaddsrctomap(_nsyystack.l_mark[-4].str);
+		}
+#line 1180 "nsparser.c"
+break;
+case 17:
+#line 134 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{
+			if (_nsyystack.l_mark[0].mapval)		/* if action == RETURN set RETURN bit */
+				cursrc.flags |= _nsyystack.l_mark[-2].mapval;  
+			else		/* else unset it */
+				cursrc.flags &= ~_nsyystack.l_mark[-2].mapval;
+		}
+#line 1190 "nsparser.c"
+break;
+case 18:
+#line 143 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ _nsyyval.mapval = NS_SUCCESS; }
+#line 1195 "nsparser.c"
+break;
+case 19:
+#line 144 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ _nsyyval.mapval = NS_UNAVAIL; }
+#line 1200 "nsparser.c"
+break;
+case 20:
+#line 145 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ _nsyyval.mapval = NS_NOTFOUND; }
+#line 1205 "nsparser.c"
+break;
+case 21:
+#line 146 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ _nsyyval.mapval = NS_TRYAGAIN; }
+#line 1210 "nsparser.c"
+break;
+case 22:
+#line 150 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ _nsyyval.mapval = 1L; }
+#line 1215 "nsparser.c"
+break;
+case 23:
+#line 151 "/home/marven/Git/cheviot/bsdutils/lib/nsparser.y"
+	{ _nsyyval.mapval = 0L; }
+#line 1220 "nsparser.c"
+break;
+#line 1222 "nsparser.c"
+    default:
+        break;
+    }
+    _nsyystack.s_mark -= _nsyym;
+    _nsyystate = *_nsyystack.s_mark;
+    _nsyystack.l_mark -= _nsyym;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _nsyystack.p_mark -= _nsyym;
+#endif
+    _nsyym = _nsyylhs[_nsyyn];
+    if (_nsyystate == 0 && _nsyym == 0)
+    {
+#if _NSYYDEBUG
+        if (_nsyydebug)
+        {
+            fprintf(stderr, "%s[%d]: after reduction, ", _NSYYDEBUGSTR, _nsyydepth);
+#ifdef _NSYYSTYPE_TOSTRING
+#if _NSYYBTYACC
+            if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+                fprintf(stderr, "result is <%s>, ", _NSYYSTYPE_TOSTRING(_nsyystos[_NSYYFINAL], _nsyyval));
+#endif
+            fprintf(stderr, "shifting from state 0 to final state %d\n", _NSYYFINAL);
+        }
+#endif
+        _nsyystate = _NSYYFINAL;
+        *++_nsyystack.s_mark = _NSYYFINAL;
+        *++_nsyystack.l_mark = _nsyyval;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        *++_nsyystack.p_mark = _nsyyloc;
+#endif
+        if (_nsyychar < 0)
+        {
+#if _NSYYBTYACC
+            do {
+            if (_nsyylvp < _nsyylve)
+            {
+                /* we're currently re-reading tokens */
+                _nsyylval = *_nsyylvp++;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                _nsyylloc = *_nsyylpp++;
+#endif
+                _nsyychar = *_nsyylexp++;
+                break;
+            }
+            if (_nsyyps->save)
+            {
+                /* in trial mode; save scanner results for future parse attempts */
+                if (_nsyylvp == _nsyylvlim)
+                {   /* Enlarge lexical value queue */
+                    size_t p = (size_t) (_nsyylvp - _nsyylvals);
+                    size_t s = (size_t) (_nsyylvlim - _nsyylvals);
+
+                    s += _NSYYLVQUEUEGROWTH;
+                    if ((_nsyylexemes = (_NSYYINT *)realloc(_nsyylexemes, s * sizeof(_NSYYINT))) == NULL)
+                        goto _nsyyenomem;
+                    if ((_nsyylvals   = (_NSYYSTYPE *)realloc(_nsyylvals, s * sizeof(_NSYYSTYPE))) == NULL)
+                        goto _nsyyenomem;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                    if ((_nsyylpsns   = (_NSYYLTYPE *)realloc(_nsyylpsns, s * sizeof(_NSYYLTYPE))) == NULL)
+                        goto _nsyyenomem;
+#endif
+                    _nsyylvp   = _nsyylve = _nsyylvals + p;
+                    _nsyylvlim = _nsyylvals + s;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                    _nsyylpp   = _nsyylpe = _nsyylpsns + p;
+                    _nsyylplim = _nsyylpsns + s;
+#endif
+                    _nsyylexp  = _nsyylexemes + p;
+                }
+                *_nsyylexp = (_NSYYINT) _NSYYLEX;
+                *_nsyylvp++ = _nsyylval;
+                _nsyylve++;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+                *_nsyylpp++ = _nsyylloc;
+                _nsyylpe++;
+#endif
+                _nsyychar = *_nsyylexp++;
+                break;
+            }
+            /* normal operation, no conflict encountered */
+#endif /* _NSYYBTYACC */
+            _nsyychar = _NSYYLEX;
+#if _NSYYBTYACC
+            } while (0);
+#endif /* _NSYYBTYACC */
+            if (_nsyychar < 0) _nsyychar = _NSYYEOF;
+#if _NSYYDEBUG
+            if (_nsyydebug)
+            {
+                if ((_nsyys = _nsyyname[_NSYYTRANSLATE(_nsyychar)]) == NULL) _nsyys = _nsyyname[_NSYYUNDFTOKEN];
+                fprintf(stderr, "%s[%d]: state %d, reading token %d (%s)\n",
+                                _NSYYDEBUGSTR, _nsyydepth, _NSYYFINAL, _nsyychar, _nsyys);
+            }
+#endif
+        }
+        if (_nsyychar == _NSYYEOF) goto _nsyyaccept;
+        goto _nsyyloop;
+    }
+    if (((_nsyyn = _nsyygindex[_nsyym]) != 0) && (_nsyyn += _nsyystate) >= 0 &&
+            _nsyyn <= _NSYYTABLESIZE && _nsyycheck[_nsyyn] == (_NSYYINT) _nsyystate)
+        _nsyystate = _nsyytable[_nsyyn];
+    else
+        _nsyystate = _nsyydgoto[_nsyym];
+#if _NSYYDEBUG
+    if (_nsyydebug)
+    {
+        fprintf(stderr, "%s[%d]: after reduction, ", _NSYYDEBUGSTR, _nsyydepth);
+#ifdef _NSYYSTYPE_TOSTRING
+#if _NSYYBTYACC
+        if (!_nsyytrial)
+#endif /* _NSYYBTYACC */
+            fprintf(stderr, "result is <%s>, ", _NSYYSTYPE_TOSTRING(_nsyystos[_nsyystate], _nsyyval));
+#endif
+        fprintf(stderr, "shifting from state %d to state %d\n", *_nsyystack.s_mark, _nsyystate);
+    }
+#endif
+    if (_nsyystack.s_mark >= _nsyystack.s_last && _nsyygrowstack(&_nsyystack) == _NSYYENOMEM) goto _nsyyoverflow;
+    *++_nsyystack.s_mark = (_NSYYINT) _nsyystate;
+    *++_nsyystack.l_mark = _nsyyval;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    *++_nsyystack.p_mark = _nsyyloc;
+#endif
+    goto _nsyyloop;
+#if _NSYYBTYACC
+
+    /* Reduction declares that this path is valid. Set _nsyypath and do a full parse */
+_nsyyvalid:
+    if (_nsyypath) _NSYYABORT;
+    while (_nsyyps->save)
+    {
+        _NSYYParseState *save = _nsyyps->save;
+        _nsyyps->save = save->save;
+        save->save = _nsyypath;
+        _nsyypath = save;
+    }
+#if _NSYYDEBUG
+    if (_nsyydebug)
+        fprintf(stderr, "%s[%d]: state %d, CONFLICT trial successful, backtracking to state %d, %d tokens\n",
+                        _NSYYDEBUGSTR, _nsyydepth, _nsyystate, _nsyypath->state, (int)(_nsyylvp - _nsyylvals - _nsyypath->lexeme));
+#endif
+    if (_nsyyerrctx)
+    {
+        _nsyyFreeState(_nsyyerrctx);
+        _nsyyerrctx = NULL;
+    }
+    _nsyylvp          = _nsyylvals + _nsyypath->lexeme;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _nsyylpp          = _nsyylpsns + _nsyypath->lexeme;
+#endif
+    _nsyylexp         = _nsyylexemes + _nsyypath->lexeme;
+    _nsyychar         = _NSYYEMPTY;
+    _nsyystack.s_mark = _nsyystack.s_base + (_nsyypath->_nsyystack.s_mark - _nsyypath->_nsyystack.s_base);
+    memcpy (_nsyystack.s_base, _nsyypath->_nsyystack.s_base, (size_t) (_nsyystack.s_mark - _nsyystack.s_base + 1) * sizeof(_NSYYINT));
+    _nsyystack.l_mark = _nsyystack.l_base + (_nsyypath->_nsyystack.l_mark - _nsyypath->_nsyystack.l_base);
+    memcpy (_nsyystack.l_base, _nsyypath->_nsyystack.l_base, (size_t) (_nsyystack.l_mark - _nsyystack.l_base + 1) * sizeof(_NSYYSTYPE));
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+    _nsyystack.p_mark = _nsyystack.p_base + (_nsyypath->_nsyystack.p_mark - _nsyypath->_nsyystack.p_base);
+    memcpy (_nsyystack.p_base, _nsyypath->_nsyystack.p_base, (size_t) (_nsyystack.p_mark - _nsyystack.p_base + 1) * sizeof(_NSYYLTYPE));
+#endif
+    _nsyystate        = _nsyypath->state;
+    goto _nsyyloop;
+#endif /* _NSYYBTYACC */
+
+_nsyyoverflow:
+    _NSYYERROR_CALL("yacc stack overflow");
+#if _NSYYBTYACC
+    goto _nsyyabort_nomem;
+_nsyyenomem:
+    _NSYYERROR_CALL("memory exhausted");
+_nsyyabort_nomem:
+#endif /* _NSYYBTYACC */
+    _nsyyresult = 2;
+    goto _nsyyreturn;
+
+_nsyyabort:
+    _nsyyresult = 1;
+    goto _nsyyreturn;
+
+_nsyyaccept:
+#if _NSYYBTYACC
+    if (_nsyyps->save) goto _nsyyvalid;
+#endif /* _NSYYBTYACC */
+    _nsyyresult = 0;
+
+_nsyyreturn:
+#if defined(_NSYYDESTRUCT_CALL)
+    if (_nsyychar != _NSYYEOF && _nsyychar != _NSYYEMPTY)
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        _NSYYDESTRUCT_CALL("cleanup: discarding token", _nsyychar, &_nsyylval, &_nsyylloc);
+#else
+        _NSYYDESTRUCT_CALL("cleanup: discarding token", _nsyychar, &_nsyylval);
+#endif /* defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED) */
+
+    {
+        _NSYYSTYPE *pv;
+#if defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED)
+        _NSYYLTYPE *pp;
+
+        for (pv = _nsyystack.l_base, pp = _nsyystack.p_base; pv <= _nsyystack.l_mark; ++pv, ++pp)
+             _NSYYDESTRUCT_CALL("cleanup: discarding state",
+                             _nsyystos[*(_nsyystack.s_base + (pv - _nsyystack.l_base))], pv, pp);
+#else
+        for (pv = _nsyystack.l_base; pv <= _nsyystack.l_mark; ++pv)
+             _NSYYDESTRUCT_CALL("cleanup: discarding state",
+                             _nsyystos[*(_nsyystack.s_base + (pv - _nsyystack.l_base))], pv);
+#endif /* defined(_NSYYLTYPE) || defined(_NSYYLTYPE_IS_DECLARED) */
+    }
+#endif /* defined(_NSYYDESTRUCT_CALL) */
+
+#if _NSYYBTYACC
+    if (_nsyyerrctx)
+    {
+        _nsyyFreeState(_nsyyerrctx);
+        _nsyyerrctx = NULL;
+    }
+    while (_nsyyps)
+    {
+        _NSYYParseState *save = _nsyyps;
+        _nsyyps = save->save;
+        save->save = NULL;
+        _nsyyFreeState(save);
+    }
+    while (_nsyypath)
+    {
+        _NSYYParseState *save = _nsyypath;
+        _nsyypath = save->save;
+        save->save = NULL;
+        _nsyyFreeState(save);
+    }
+#endif /* _NSYYBTYACC */
+    _nsyyfreestack(&_nsyystack);
+    return (_nsyyresult);
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsparser.h third_party/newlib-4.1.0/newlib/libc/sys/arm/nsparser.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsparser.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/nsparser.h	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,25 @@
+#ifndef _yy_defines_h_
+#define _yy_defines_h_
+
+#define NL 257
+#define SUCCESS 258
+#define UNAVAIL 259
+#define NOTFOUND 260
+#define TRYAGAIN 261
+#define RETURN 262
+#define CONTINUE 263
+#define STRING 264
+#ifdef SYYSTYPE
+#undef  SYYSTYPE_IS_DECLARED
+#define SYYSTYPE_IS_DECLARED 1
+#endif
+#ifndef _NSYYSTYPE_IS_DECLARED
+#define _NSYYSTYPE_IS_DECLARED 1
+typedef union _NSYYSTYPE {
+	char *str;
+	int   mapval;
+} _NSYYSTYPE;
+#endif /* !_NSYYSTYPE_IS_DECLARED */
+extern _NSYYSTYPE _nsyylval;
+
+#endif /* _yy_defines_h_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsparser.y.txt third_party/newlib-4.1.0/newlib/libc/sys/arm/nsparser.y.txt
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/nsparser.y.txt	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/nsparser.y.txt	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,191 @@
+%{
+/*	$NetBSD: nsparser.y,v 1.12 2012/03/20 17:44:18 matt Exp $	*/
+
+/*-
+ * Copyright (c) 1997, 1998, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Luke Mewburn.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: nsparser.y,v 1.12 2012/03/20 17:44:18 matt Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <assert.h>
+#define _NS_PRIVATE
+#include <nsswitch.h>
+#include <stdio.h>
+#include <string.h>
+//#include <syslog.h>
+#include <sys/debug.h>
+
+static	void	_nsaddsrctomap(const char *);
+
+static	ns_dbt		curdbt;
+static	ns_src		cursrc;
+
+extern char *	_nsyytext;
+extern int _nsyylineno;
+%}
+
+%union {
+	char *str;
+	int   mapval;
+}
+
+%token	NL
+%token	SUCCESS UNAVAIL NOTFOUND TRYAGAIN
+%token	RETURN CONTINUE
+%token	<str> STRING
+
+%type	<mapval> Status Action
+
+%%
+
+File
+	:	/* empty */
+	| Lines
+	;
+
+Lines
+	: Entry
+	| Lines Entry
+	;
+
+Entry
+	: NL
+	| Database ':' NL
+	| Database ':' Srclist NL
+		{
+			int lineno;
+
+			lineno = _nsyylineno - (*_nsyytext == '\n' ? 1 : 0);
+			if (_nsdbtput(&curdbt) == -1)
+				log_warn(
+				    "libc nsdispatch: %s line %d: %s",
+				    _PATH_NS_CONF, lineno,
+				    "error adding entry");
+		}
+	| error NL
+		{
+			yyerrok;
+		}
+	;
+
+Database
+	: STRING
+		{
+			curdbt.name = yylval.str;
+			curdbt.srclist = NULL;
+			curdbt.srclistsize = 0;
+		}
+	;
+
+Srclist
+	: Item
+	| Srclist Item
+	;
+
+Item
+	: STRING
+		{
+			cursrc.flags = NS_SUCCESS;
+			_nsaddsrctomap($1);
+		}
+	| STRING '[' { cursrc.flags = NS_SUCCESS; } Criteria ']'
+		{
+			_nsaddsrctomap($1);
+		}
+	;
+
+Criteria
+	: Criterion
+	| Criteria Criterion
+	;
+
+Criterion
+	: Status '=' Action
+		{
+			if ($3)		/* if action == RETURN set RETURN bit */
+				cursrc.flags |= $1;  
+			else		/* else unset it */
+				cursrc.flags &= ~$1;
+		}
+	;
+
+Status
+	: SUCCESS	{ $$ = NS_SUCCESS; }
+	| UNAVAIL	{ $$ = NS_UNAVAIL; }
+	| NOTFOUND	{ $$ = NS_NOTFOUND; }
+	| TRYAGAIN	{ $$ = NS_TRYAGAIN; }
+	;
+
+Action
+	: RETURN	{ $$ = 1L; }
+	| CONTINUE	{ $$ = 0L; }
+	;
+
+%%
+
+static void
+_nsaddsrctomap(const char *elem)
+{
+	unsigned int	i;
+	int		lineno;
+
+	_DIAGASSERT(elem != NULL);
+
+	lineno = _nsyylineno - (*_nsyytext == '\n' ? 1 : 0);
+	if (curdbt.srclistsize > 0) {
+		if ((strcasecmp(elem, NSSRC_COMPAT) == 0) ||
+		    (strcasecmp(curdbt.srclist[0].name, NSSRC_COMPAT) == 0)) {
+			log_warn(
+			    "libc nsdispatch: %s line %d: %s",
+			    _PATH_NS_CONF, lineno,
+			    "'compat' used with other sources");
+			return;
+		}
+	}
+	for (i = 0; i < curdbt.srclistsize; i++) {
+		if (strcasecmp(curdbt.srclist[i].name, elem) == 0) {
+			log_warn(
+			    "libc nsdispatch: %s line %d: %s '%s'",
+			    _PATH_NS_CONF, lineno,
+			    "duplicate source", elem);
+			return;
+		}
+	}
+	cursrc.name = elem;
+	if (_nsdbtaddsrc(&curdbt, &cursrc) == -1) {
+		log_warn(
+		    "libc nsdispatch: %s line %d: %s '%s'",
+		    _PATH_NS_CONF, lineno,
+		    "error adding", elem);
+	}
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/open.c third_party/newlib-4.1.0/newlib/libc/sys/arm/open.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/open.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/open.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,38 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+
+
+/*
+ *
+ */
+int open (const char *file, int flags, ...)
+{
+    int mode;
+    int fd;
+
+    va_list ap;
+
+    va_start(ap, flags);
+
+    if (flags & O_CREAT)
+        mode = va_arg(ap, int);
+    else
+        mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
+
+    va_end(ap);
+
+    fd = _swi_open (file, flags, mode);
+
+    if (fd < 0) {
+        errno = -fd;
+        return -1;
+    }
+
+    return fd;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/opendir.c third_party/newlib-4.1.0/newlib/libc/sys/arm/opendir.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/opendir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/opendir.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,54 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+DIR *opendir (const char *path)
+{
+    DIR *dir;
+    void *buf;
+    int fd;
+
+    if ((dir = malloc(sizeof (DIR))) == NULL) {
+        return NULL;
+    }
+    
+    if ((buf = malloc(DIRENTS_BUF_SZ)) == NULL) {
+        free (dir);
+        return NULL;
+    }	
+      
+    fd = _swi_opendir(path);
+
+    if (fd < 0) {
+        free(buf);
+        free(dir);
+        errno = -fd;
+        return NULL;
+    }
+		
+    dir->fd = fd;
+    dir->buf = buf;
+    dir->buf_offset = 0; 
+    dir->buf_sz = 0;
+    dir->eof = false;
+    return dir;
+}
+
+
+/*
+ *
+ */
+int dirfd(DIR *dirp)
+{
+    return dirp->fd;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/pathconf.c third_party/newlib-4.1.0/newlib/libc/sys/arm/pathconf.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/pathconf.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/pathconf.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,21 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+
+
+long fpathconf(int filedes, int name)
+{
+    return -1;
+}
+
+
+long pathconf(const char *path, int name)
+{
+    return -1;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/pipe.c third_party/newlib-4.1.0/newlib/libc/sys/arm/pipe.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/pipe.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/pipe.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,24 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ * pipe()
+ */ 
+int pipe (int fdp[2])
+{
+    int sc;
+
+    sc = _swi_pipe(fdp);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/popen.c third_party/newlib-4.1.0/newlib/libc/sys/arm/popen.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/popen.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/popen.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,28 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <stdio.h>
+
+
+/*
+ *
+ */
+FILE *popen (const char *command, const char *mode)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+int pclose (FILE *stream)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/pwcache.c third_party/newlib-4.1.0/newlib/libc/sys/arm/pwcache.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/pwcache.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/pwcache.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,643 @@
+/*	$NetBSD: pwcache.c,v 1.31 2010/03/23 20:28:59 drochner Exp $	*/
+
+/*-
+ * Copyright (c) 1992 Keith Muller.
+ * Copyright (c) 1992, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Keith Muller of the University of California, San Diego.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 2002 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+/*
+ * XXX Undefine the renames of these functions so that we don't
+ * XXX rename the versions found in the host's <pwd.h> by mistake!
+ */
+#undef group_from_gid
+#undef user_from_uid
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)cache.c	8.1 (Berkeley) 5/31/93";
+#else
+__RCSID("$NetBSD: pwcache.c,v 1.31 2010/03/23 20:28:59 drochner Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <sys/types.h>
+#include <sys/param.h>
+
+#include <assert.h>
+#include <grp.h>
+#include <pwd.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#if HAVE_NBTOOL_CONFIG_H
+/* XXX Now, re-apply the renaming that we undid above. */
+#define	group_from_gid	__nbcompat_group_from_gid
+#define	user_from_uid	__nbcompat_user_from_uid
+#endif
+
+#ifdef __weak_alias
+__weak_alias(user_from_uid,_user_from_uid)
+__weak_alias(group_from_gid,_group_from_gid)
+__weak_alias(pwcache_groupdb,_pwcache_groupdb)
+#endif
+
+#if !HAVE_PWCACHE_USERDB || HAVE_NBTOOL_CONFIG_H
+#include "pwcache.h"
+
+/*
+ * routines that control user, group, uid and gid caches (for the archive
+ * member print routine).
+ * IMPORTANT:
+ * these routines cache BOTH hits and misses, a major performance improvement
+ */
+
+/*
+ * function pointers to various name lookup routines.
+ * these may be changed as necessary.
+ */
+static	int		(*_pwcache_setgroupent)(int)		= setgrent;
+static	void		(*_pwcache_endgrent)(void)		= endgrent;
+static	struct group *	(*_pwcache_getgrnam)(const char *)	= getgrnam;
+static	struct group *	(*_pwcache_getgrgid)(gid_t)		= getgrgid;
+static	int		(*_pwcache_setpassent)(int)		= setpassent;
+static	void		(*_pwcache_endpwent)(void)		= endpwent;
+static	struct passwd *	(*_pwcache_getpwnam)(const char *)	= getpwnam;
+static	struct passwd *	(*_pwcache_getpwuid)(uid_t)		= getpwuid;
+
+/*
+ * internal state
+ */
+static	int	pwopn;		/* is password file open */
+static	int	gropn;		/* is group file open */
+static	UIDC	**uidtb;	/* uid to name cache */
+static	GIDC	**gidtb;	/* gid to name cache */
+static	UIDC	**usrtb;	/* user name to uid cache */
+static	GIDC	**grptb;	/* group name to gid cache */
+
+static	int	uidtb_fail;	/* uidtb_start() failed ? */
+static	int	gidtb_fail;	/* gidtb_start() failed ? */
+static	int	usrtb_fail;	/* usrtb_start() failed ? */
+static	int	grptb_fail;	/* grptb_start() failed ? */
+
+
+static	u_int	st_hash(const char *, size_t, int);
+static	int	uidtb_start(void);
+static	int	gidtb_start(void);
+static	int	usrtb_start(void);
+static	int	grptb_start(void);
+
+
+static u_int
+st_hash(const char *name, size_t len, int tabsz)
+{
+	u_int key = 0;
+
+	_DIAGASSERT(name != NULL);
+
+	while (len--) {
+		key += *name++;
+		key = (key << 8) | (key >> 24);
+	}
+
+	return (key % tabsz);
+}
+
+/*
+ * uidtb_start
+ *	creates an an empty uidtb
+ * Return:
+ *	0 if ok, -1 otherwise
+ */
+static int
+uidtb_start(void)
+{
+
+	if (uidtb != NULL)
+		return (0);
+	if (uidtb_fail)
+		return (-1);
+	if ((uidtb = (UIDC **)calloc(UID_SZ, sizeof(UIDC *))) == NULL) {
+		++uidtb_fail;
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * gidtb_start
+ *	creates an an empty gidtb
+ * Return:
+ *	0 if ok, -1 otherwise
+ */
+static int
+gidtb_start(void)
+{
+
+	if (gidtb != NULL)
+		return (0);
+	if (gidtb_fail)
+		return (-1);
+	if ((gidtb = (GIDC **)calloc(GID_SZ, sizeof(GIDC *))) == NULL) {
+		++gidtb_fail;
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * usrtb_start
+ *	creates an an empty usrtb
+ * Return:
+ *	0 if ok, -1 otherwise
+ */
+static int
+usrtb_start(void)
+{
+
+	if (usrtb != NULL)
+		return (0);
+	if (usrtb_fail)
+		return (-1);
+	if ((usrtb = (UIDC **)calloc(UNM_SZ, sizeof(UIDC *))) == NULL) {
+		++usrtb_fail;
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * grptb_start
+ *	creates an an empty grptb
+ * Return:
+ *	0 if ok, -1 otherwise
+ */
+static int
+grptb_start(void)
+{
+
+	if (grptb != NULL)
+		return (0);
+	if (grptb_fail)
+		return (-1);
+	if ((grptb = (GIDC **)calloc(GNM_SZ, sizeof(GIDC *))) == NULL) {
+		++grptb_fail;
+		return (-1);
+	}
+	return (0);
+}
+
+/*
+ * user_from_uid()
+ *	caches the name (if any) for the uid. If noname clear, we always
+ *	return the stored name (if valid or invalid match).
+ *	We use a simple hash table.
+ * Return
+ *	Pointer to stored name (or a empty string)
+ */
+const char *
+user_from_uid(uid_t uid, int noname)
+{
+	struct passwd *pw;
+	UIDC *ptr, **pptr;
+
+	if ((uidtb == NULL) && (uidtb_start() < 0))
+		return (NULL);
+
+	/*
+	 * see if we have this uid cached
+	 */
+	pptr = uidtb + (uid % UID_SZ);
+	ptr = *pptr;
+
+	if ((ptr != NULL) && (ptr->valid > 0) && (ptr->uid == uid)) {
+		/*
+		 * have an entry for this uid
+		 */
+		if (!noname || (ptr->valid == VALID))
+			return (ptr->name);
+		return (NULL);
+	}
+
+	/*
+	 * No entry for this uid, we will add it
+	 */
+	if (!pwopn) {
+		if (_pwcache_setpassent != NULL)
+			(*_pwcache_setpassent)(1);
+		++pwopn;
+	}
+
+	if (ptr == NULL)
+		*pptr = ptr = (UIDC *)malloc(sizeof(UIDC));
+
+	if ((pw = (*_pwcache_getpwuid)(uid)) == NULL) {
+		/*
+		 * no match for this uid in the local password file
+		 * a string that is the uid in numeric format
+		 */
+		if (ptr == NULL)
+			return (NULL);
+		ptr->uid = uid;
+		(void)snprintf(ptr->name, UNMLEN, "%lu", (long) uid);
+		ptr->valid = INVALID;
+		if (noname)
+			return (NULL);
+	} else {
+		/*
+		 * there is an entry for this uid in the password file
+		 */
+		if (ptr == NULL)
+			return (pw->pw_name);
+		ptr->uid = uid;
+		(void)strlcpy(ptr->name, pw->pw_name, UNMLEN);
+		ptr->valid = VALID;
+	}
+	return (ptr->name);
+}
+
+/*
+ * group_from_gid()
+ *	caches the name (if any) for the gid. If noname clear, we always
+ *	return the stored name (if valid or invalid match).
+ *	We use a simple hash table.
+ * Return
+ *	Pointer to stored name (or a empty string)
+ */
+const char *
+group_from_gid(gid_t gid, int noname)
+{
+	struct group *gr;
+	GIDC *ptr, **pptr;
+
+	if ((gidtb == NULL) && (gidtb_start() < 0))
+		return (NULL);
+
+	/*
+	 * see if we have this gid cached
+	 */
+	pptr = gidtb + (gid % GID_SZ);
+	ptr = *pptr;
+
+	if ((ptr != NULL) && (ptr->valid > 0) && (ptr->gid == gid)) {
+		/*
+		 * have an entry for this gid
+		 */
+		if (!noname || (ptr->valid == VALID))
+			return (ptr->name);
+		return (NULL);
+	}
+
+	/*
+	 * No entry for this gid, we will add it
+	 */
+	if (!gropn) {
+		if (_pwcache_setgroupent != NULL)
+			(*_pwcache_setgroupent)(1);
+		++gropn;
+	}
+
+	if (ptr == NULL)
+		*pptr = ptr = (GIDC *)malloc(sizeof(GIDC));
+
+	if ((gr = (*_pwcache_getgrgid)(gid)) == NULL) {
+		/*
+		 * no match for this gid in the local group file, put in
+		 * a string that is the gid in numberic format
+		 */
+		if (ptr == NULL)
+			return (NULL);
+		ptr->gid = gid;
+		(void)snprintf(ptr->name, GNMLEN, "%lu", (long) gid);
+		ptr->valid = INVALID;
+		if (noname)
+			return (NULL);
+	} else {
+		/*
+		 * there is an entry for this group in the group file
+		 */
+		if (ptr == NULL)
+			return (gr->gr_name);
+		ptr->gid = gid;
+		(void)strlcpy(ptr->name, gr->gr_name, GNMLEN);
+		ptr->valid = VALID;
+	}
+	return (ptr->name);
+}
+
+/*
+ * uid_from_user()
+ *	caches the uid for a given user name. We use a simple hash table.
+ * Return
+ *	the uid (if any) for a user name, or a -1 if no match can be found
+ */
+int
+uid_from_user(const char *name, uid_t *uid)
+{
+	struct passwd *pw;
+	UIDC *ptr, **pptr;
+	size_t namelen;
+
+	/*
+	 * return -1 for mangled names
+	 */
+	if (name == NULL || ((namelen = strlen(name)) == 0))
+		return (-1);
+	if ((usrtb == NULL) && (usrtb_start() < 0))
+		return (-1);
+
+	/*
+	 * look up in hash table, if found and valid return the uid,
+	 * if found and invalid, return a -1
+	 */
+	pptr = usrtb + st_hash(name, namelen, UNM_SZ);
+	ptr = *pptr;
+
+	if ((ptr != NULL) && (ptr->valid > 0) && !strcmp(name, ptr->name)) {
+		if (ptr->valid == INVALID)
+			return (-1);
+		*uid = ptr->uid;
+		return (0);
+	}
+
+	if (!pwopn) {
+		if (_pwcache_setpassent != NULL)
+			(*_pwcache_setpassent)(1);
+		++pwopn;
+	}
+
+	if (ptr == NULL)
+		*pptr = ptr = (UIDC *)malloc(sizeof(UIDC));
+
+	/*
+	 * no match, look it up, if no match store it as an invalid entry,
+	 * or store the matching uid
+	 */
+	if (ptr == NULL) {
+		if ((pw = (*_pwcache_getpwnam)(name)) == NULL)
+			return (-1);
+		*uid = pw->pw_uid;
+		return (0);
+	}
+	(void)strlcpy(ptr->name, name, UNMLEN);
+	if ((pw = (*_pwcache_getpwnam)(name)) == NULL) {
+		ptr->valid = INVALID;
+		return (-1);
+	}
+	ptr->valid = VALID;
+	*uid = ptr->uid = pw->pw_uid;
+	return (0);
+}
+
+/*
+ * gid_from_group()
+ *	caches the gid for a given group name. We use a simple hash table.
+ * Return
+ *	the gid (if any) for a group name, or a -1 if no match can be found
+ */
+int
+gid_from_group(const char *name, gid_t *gid)
+{
+	struct group *gr;
+	GIDC *ptr, **pptr;
+	size_t namelen;
+
+	/*
+	 * return -1 for mangled names
+	 */
+	if (name == NULL || ((namelen = strlen(name)) == 0))
+		return (-1);
+	if ((grptb == NULL) && (grptb_start() < 0))
+		return (-1);
+
+	/*
+	 * look up in hash table, if found and valid return the uid,
+	 * if found and invalid, return a -1
+	 */
+	pptr = grptb + st_hash(name, namelen, GID_SZ);
+	ptr = *pptr;
+
+	if ((ptr != NULL) && (ptr->valid > 0) && !strcmp(name, ptr->name)) {
+		if (ptr->valid == INVALID)
+			return (-1);
+		*gid = ptr->gid;
+		return (0);
+	}
+
+	if (!gropn) {
+		if (_pwcache_setgroupent != NULL)
+			(*_pwcache_setgroupent)(1);
+		++gropn;
+	}
+
+	if (ptr == NULL)
+		*pptr = ptr = (GIDC *)malloc(sizeof(GIDC));
+
+	/*
+	 * no match, look it up, if no match store it as an invalid entry,
+	 * or store the matching gid
+	 */
+	if (ptr == NULL) {
+		if ((gr = (*_pwcache_getgrnam)(name)) == NULL)
+			return (-1);
+		*gid = gr->gr_gid;
+		return (0);
+	}
+
+	(void)strlcpy(ptr->name, name, GNMLEN);
+	if ((gr = (*_pwcache_getgrnam)(name)) == NULL) {
+		ptr->valid = INVALID;
+		return (-1);
+	}
+	ptr->valid = VALID;
+	*gid = ptr->gid = gr->gr_gid;
+	return (0);
+}
+
+#define FLUSHTB(arr, len, fail)				\
+	do {						\
+		if (arr != NULL) {			\
+			for (i = 0; i < len; i++)	\
+				if (arr[i] != NULL)	\
+					free(arr[i]);	\
+			arr = NULL;			\
+		}					\
+		fail = 0;				\
+	} while (/* CONSTCOND */0);
+
+int
+pwcache_userdb(
+	int		(*a_setpassent)(int),
+	void		(*a_endpwent)(void),
+	struct passwd *	(*a_getpwnam)(const char *),
+	struct passwd *	(*a_getpwuid)(uid_t))
+{
+	int i;
+
+		/* a_setpassent and a_endpwent may be NULL */
+	if (a_getpwnam == NULL || a_getpwuid == NULL)
+		return (-1);
+
+	if (_pwcache_endpwent != NULL)
+		(*_pwcache_endpwent)();
+	FLUSHTB(uidtb, UID_SZ, uidtb_fail);
+	FLUSHTB(usrtb, UNM_SZ, usrtb_fail);
+	pwopn = 0;
+	_pwcache_setpassent = a_setpassent;
+	_pwcache_endpwent = a_endpwent;
+	_pwcache_getpwnam = a_getpwnam;
+	_pwcache_getpwuid = a_getpwuid;
+
+	return (0);
+}
+
+int
+pwcache_groupdb(
+	int		(*a_setgroupent)(int),
+	void		(*a_endgrent)(void),
+	struct group *	(*a_getgrnam)(const char *),
+	struct group *	(*a_getgrgid)(gid_t))
+{
+	int i;
+
+		/* a_setgroupent and a_endgrent may be NULL */
+	if (a_getgrnam == NULL || a_getgrgid == NULL)
+		return (-1);
+
+	if (_pwcache_endgrent != NULL)
+		(*_pwcache_endgrent)();
+	FLUSHTB(gidtb, GID_SZ, gidtb_fail);
+	FLUSHTB(grptb, GNM_SZ, grptb_fail);
+	gropn = 0;
+	_pwcache_setgroupent = a_setgroupent;
+	_pwcache_endgrent = a_endgrent;
+	_pwcache_getgrnam = a_getgrnam;
+	_pwcache_getgrgid = a_getgrgid;
+
+	return (0);
+}
+
+
+#ifdef TEST_PWCACHE
+
+struct passwd *
+test_getpwnam(const char *name)
+{
+	static struct passwd foo;
+
+	memset(&foo, 0, sizeof(foo));
+	if (strcmp(name, "toor") == 0) {
+		foo.pw_uid = 666;
+		return &foo;
+	}
+	return (getpwnam(name));
+}
+
+int
+main(int argc, char *argv[])
+{
+	uid_t	u;
+	int	r, i;
+
+	printf("pass 1 (default userdb)\n");
+	for (i = 1; i < argc; i++) {
+		printf("i: %d, pwopn %d usrtb_fail %d usrtb %p\n",
+		    i, pwopn, usrtb_fail, usrtb);
+		r = uid_from_user(argv[i], &u);
+		if (r == -1)
+			printf("  uid_from_user %s: failed\n", argv[i]);
+		else
+			printf("  uid_from_user %s: %d\n", argv[i], u);
+	}
+	printf("pass 1 finish: pwopn %d usrtb_fail %d usrtb %p\n",
+		    pwopn, usrtb_fail, usrtb);
+
+	puts("");
+	printf("pass 2 (replacement userdb)\n");
+	printf("pwcache_userdb returned %d\n",
+	    pwcache_userdb(setpassent, test_getpwnam, getpwuid));
+	printf("pwopn %d usrtb_fail %d usrtb %p\n", pwopn, usrtb_fail, usrtb);
+
+	for (i = 1; i < argc; i++) {
+		printf("i: %d, pwopn %d usrtb_fail %d usrtb %p\n",
+		    i, pwopn, usrtb_fail, usrtb);
+		u = -1;
+		r = uid_from_user(argv[i], &u);
+		if (r == -1)
+			printf("  uid_from_user %s: failed\n", argv[i]);
+		else
+			printf("  uid_from_user %s: %d\n", argv[i], u);
+	}
+	printf("pass 2 finish: pwopn %d usrtb_fail %d usrtb %p\n",
+		    pwopn, usrtb_fail, usrtb);
+
+	puts("");
+	printf("pass 3 (null pointers)\n");
+	printf("pwcache_userdb returned %d\n",
+	    pwcache_userdb(NULL, NULL, NULL));
+
+	return (0);
+}
+#endif	/* TEST_PWCACHE */
+#endif	/* !HAVE_PWCACHE_USERDB */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/read.c third_party/newlib-4.1.0/newlib/libc/sys/arm/read.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/read.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/read.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+ssize_t read (int fd, void *buf, size_t nbyte)
+{
+  ssize_t sz;
+
+  sz = _swi_read(fd, buf, nbyte);
+
+  if (sz < 0) {
+    errno = -sz;
+    return -1;
+  }
+
+  return sz;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/readdir.c third_party/newlib-4.1.0/newlib/libc/sys/arm/readdir.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/readdir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/readdir.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,50 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/debug.h>
+#include <string.h>
+
+/*
+ *
+ */
+struct dirent *readdir(DIR *dir)
+{
+  struct dirent *dent;
+  int sz;
+  
+  if (dir == NULL) {
+    errno = EINVAL;
+    return NULL;
+  }
+
+  if (dir->eof == true) {
+    return NULL;
+  }
+    
+  if (dir->buf_offset >= dir->buf_sz)
+  {   
+    sz = _swi_readdir (dir->fd, dir->buf, DIRENTS_BUF_SZ);
+
+    if (sz < 0) {
+      errno = -sz;
+      dir->buf_sz = 0;
+      dir->eof = true;
+      return NULL;
+    } else if (sz == 0) {
+      dir->buf_sz = 0;
+      dir->eof = true;
+      return NULL;
+    } if (sz > DIRENTS_BUF_SZ) {
+      exit(-1);
+    }
+
+    dir->buf_sz = sz; 
+    dir->buf_offset = 0;
+  }
+    
+  dent = (struct dirent *)((uint8_t *)dir->buf + dir->buf_offset);
+  dir->buf_offset += dent->d_reclen;
+  return dent;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/readme.txt third_party/newlib-4.1.0/newlib/libc/sys/arm/readme.txt
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/readme.txt	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,9 @@
+
+When adding files to this directory, add the name
+of the object file to makefile.am then run the following
+commands in this directory.
+
+
+aclocal -I ../../..
+autoconf
+automake --cygnus --add-missing Makefile
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/reallocarray.c third_party/newlib-4.1.0/newlib/libc/sys/arm/reallocarray.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/reallocarray.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/reallocarray.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,52 @@
+/*	$NetBSD: reallocarray.c,v 1.5 2015/07/26 02:22:33 kamil Exp $	*/
+/*	$OpenBSD: reallocarray.c,v 1.1 2014/05/08 21:43:49 deraadt Exp $	*/
+
+/*-
+ * Copyright (c) 2015 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Christos Zoulas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__RCSID("$NetBSD: reallocarray.c,v 1.5 2015/07/26 02:22:33 kamil Exp $");
+
+#define _OPENBSD_SOURCE
+#include <errno.h>
+#include <stdlib.h>
+
+void *
+reallocarray(void *optr, size_t nmemb, size_t size)
+{
+	if (nmemb == 0 || size == 0)
+		return realloc(optr, 0);
+
+	int e = reallocarr(&optr, nmemb, size);
+
+	if (e == 0)
+		return optr;
+	errno = e;
+	return NULL;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/reallocarr.c third_party/newlib-4.1.0/newlib/libc/sys/arm/reallocarr.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/reallocarr.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/reallocarr.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,95 @@
+/* $NetBSD: reallocarr.c,v 1.5 2015/08/20 22:27:49 kamil Exp $ */
+
+/*-
+ * Copyright (c) 2015 Joerg Sonnenberger <joerg@NetBSD.org>.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
+ * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
+ * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
+ * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
+ * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
+ * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
+ * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+__RCSID("$NetBSD: reallocarr.c,v 1.5 2015/08/20 22:27:49 kamil Exp $");
+
+#include "namespace.h"
+#include <errno.h>
+/* Old POSIX has SIZE_MAX in limits.h */
+#include <limits.h>
+#include <stdint.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef _LIBC
+#ifdef __weak_alias
+__weak_alias(reallocarr, _reallocarr)
+#endif
+#endif
+
+#define SQRT_SIZE_MAX (((size_t)1) << (sizeof(size_t) * CHAR_BIT / 2))
+
+#if !HAVE_REALLOCARR
+int
+reallocarr(void *ptr, size_t number, size_t size)
+{
+	int saved_errno, result;
+	void *optr;
+	void *nptr;
+
+	saved_errno = errno;
+	memcpy(&optr, ptr, sizeof(ptr));
+	if (number == 0 || size == 0) {
+		free(optr);
+		nptr = NULL;
+		memcpy(ptr, &nptr, sizeof(ptr));
+		errno = saved_errno;
+		return 0;
+	}
+
+	/*
+	 * Try to avoid division here.
+	 *
+	 * It isn't possible to overflow during multiplication if neither
+	 * operand uses any of the most significant half of the bits.
+	 */
+	if (__predict_false((number|size) >= SQRT_SIZE_MAX &&
+	                    number > SIZE_MAX / size)) {
+		errno = saved_errno;
+		return EOVERFLOW;
+	}
+
+	nptr = realloc(optr, number * size);
+	if (__predict_false(nptr == NULL)) {
+		result = errno;
+	} else {
+		result = 0;
+		memcpy(ptr, &nptr, sizeof(ptr));
+	}
+	errno = saved_errno;
+	return result;
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/rename.c third_party/newlib-4.1.0/newlib/libc/sys/arm/rename.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/rename.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/rename.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,26 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ * open();
+ *
+ * Needs fixing, to use the vararg 'mode' depending on flags.
+ */
+
+int rename (const char *oldname, const char *newname)
+{
+    int sc;
+
+    sc = _swi_rename(oldname, newname);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/resource.c third_party/newlib-4.1.0/newlib/libc/sys/arm/resource.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/resource.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/resource.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,83 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+
+
+/*
+ *
+ */
+int getpriority(int which, id_t who)
+{
+	int sc;
+	int prio;
+	
+	if (which != PRIO_PROCESS) {
+		errno = ENOSYS;
+		return -1;
+	}
+
+	sc = _swi_get_priority(who, &prio);
+	if (sc != 0) {
+		errno = -sc;
+		return -1;
+	}
+
+	errno = 0;
+	return prio;
+}
+
+
+/*
+ *
+ */
+int setpriority(int which, id_t who, int prio)
+{
+	int sc;
+	
+	if (which != PRIO_PROCESS) {
+		errno = ENOSYS;
+		return -1;
+	}
+
+	sc = _swi_setpriority(who, prio);
+	if (sc < 0) {
+		errno = -sc;
+		return -1;
+	}
+
+	return sc;
+}
+
+
+/*
+ *
+ */
+int getrlimit(int resource, struct rlimit *rlp)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+
+/*
+ *
+ */
+int setrlimit(int resource, const struct rlimit *rlp)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+
+/*
+ *
+ */
+int getrusage(int who, struct rusage *usage)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/rewinddir.c third_party/newlib-4.1.0/newlib/libc/sys/arm/rewinddir.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/rewinddir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/rewinddir.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,31 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+void rewinddir (DIR *dir)
+{    	
+    int sc;
+    
+    if (dir == NULL)
+    {
+        errno = EINVAL;
+        return;
+    }
+
+    sc = _swi_rewinddir(dir->fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return;
+    }
+
+    dir->buf_offset = 0;
+    dir->buf_sz = 0;
+    dir->eof = false;    
+    return;
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/select.c third_party/newlib-4.1.0/newlib/libc/sys/arm/select.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/select.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/select.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,48 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/signal.h>
+
+
+/*
+ *
+ */
+int poll (struct pollfd *pfds, nfds_t nfds, int timeout)
+{
+    int sc;
+
+    sc = _swi_poll (pfds, nfds, timeout);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }  
+    return sc;
+}
+
+
+/*
+ *
+ */
+int pselect(int nfds, fd_set *readfds,
+       fd_set *writefds, fd_set *errorfds,
+       const struct timespec *timeout,
+       const sigset_t *sigmask)
+{
+	  errno = EINTR;
+	  return -1;
+}
+
+       
+/* 
+ *
+ */    
+int select(int nfds, fd_set *readfds,
+       fd_set *writefds, fd_set *errorfds,
+       struct timeval *timeout)
+{
+	  errno = EINTR;
+	  return -1;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/setmode.c third_party/newlib-4.1.0/newlib/libc/sys/arm/setmode.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/setmode.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/setmode.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,480 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1989, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Dave Borman at Cray Research, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+__SCCSID("@(#)setmode.c	8.2 (Berkeley) 3/25/94");
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <sys/stat.h>
+
+#include <ctype.h>
+#include <errno.h>
+#include <limits.h>
+#include <signal.h>
+#include <stddef.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#ifdef SETMODE_DEBUG
+#include <stdio.h>
+#endif
+
+#define	SET_LEN	6		/* initial # of bitcmd struct to malloc */
+#define	SET_LEN_INCR 4		/* # of bitcmd structs to add as needed */
+
+typedef struct bitcmd {
+	char	cmd;
+	char	cmd2;
+	mode_t	bits;
+} BITCMD;
+
+#define	CMD2_CLR	0x01
+#define	CMD2_SET	0x02
+#define	CMD2_GBITS	0x04
+#define	CMD2_OBITS	0x08
+#define	CMD2_UBITS	0x10
+
+static mode_t	 get_current_umask(void);
+static BITCMD	*addcmd(BITCMD *, mode_t, mode_t, mode_t, mode_t);
+static void	 compress_mode(BITCMD *);
+#ifdef SETMODE_DEBUG
+static void	 dumpmode(BITCMD *);
+#endif
+
+/*
+ * Given the old mode and an array of bitcmd structures, apply the operations
+ * described in the bitcmd structures to the old mode, and return the new mode.
+ * Note that there is no '=' command; a strict assignment is just a '-' (clear
+ * bits) followed by a '+' (set bits).
+ */
+mode_t
+getmode(const void *bbox, mode_t omode)
+{
+	const BITCMD *set;
+	mode_t clrval, newmode, value;
+
+	set = (const BITCMD *)bbox;
+	newmode = omode;
+	for (value = 0;; set++)
+		switch(set->cmd) {
+		/*
+		 * When copying the user, group or other bits around, we "know"
+		 * where the bits are in the mode so that we can do shifts to
+		 * copy them around.  If we don't use shifts, it gets real
+		 * grundgy with lots of single bit checks and bit sets.
+		 */
+		case 'u':
+			value = (newmode & S_IRWXU) >> 6;
+			goto common;
+
+		case 'g':
+			value = (newmode & S_IRWXG) >> 3;
+			goto common;
+
+		case 'o':
+			value = newmode & S_IRWXO;
+common:			if (set->cmd2 & CMD2_CLR) {
+				clrval =
+				    (set->cmd2 & CMD2_SET) ?  S_IRWXO : value;
+				if (set->cmd2 & CMD2_UBITS)
+					newmode &= ~((clrval<<6) & set->bits);
+				if (set->cmd2 & CMD2_GBITS)
+					newmode &= ~((clrval<<3) & set->bits);
+				if (set->cmd2 & CMD2_OBITS)
+					newmode &= ~(clrval & set->bits);
+			}
+			if (set->cmd2 & CMD2_SET) {
+				if (set->cmd2 & CMD2_UBITS)
+					newmode |= (value<<6) & set->bits;
+				if (set->cmd2 & CMD2_GBITS)
+					newmode |= (value<<3) & set->bits;
+				if (set->cmd2 & CMD2_OBITS)
+					newmode |= value & set->bits;
+			}
+			break;
+
+		case '+':
+			newmode |= set->bits;
+			break;
+
+		case '-':
+			newmode &= ~set->bits;
+			break;
+
+		case 'X':
+			if (omode & (S_IFDIR|S_IXUSR|S_IXGRP|S_IXOTH))
+				newmode |= set->bits;
+			break;
+
+		case '\0':
+		default:
+#ifdef SETMODE_DEBUG
+			(void)printf("getmode:%04o -> %04o\n", omode, newmode);
+#endif
+			return (newmode);
+		}
+}
+
+#define	ADDCMD(a, b, c, d)						\
+	if (set >= endset) {						\
+		BITCMD *newset;						\
+		setlen += SET_LEN_INCR;					\
+		newset = reallocarray(saveset, setlen, sizeof(BITCMD));	\
+		if (newset == NULL)					\
+			goto out;					\
+		set = newset + (set - saveset);				\
+		saveset = newset;					\
+		endset = newset + (setlen - 2);				\
+	}								\
+	set = addcmd(set, (mode_t)(a), (mode_t)(b), (mode_t)(c), (d))
+
+#define	STANDARD_BITS	(S_ISUID|S_ISGID|S_IRWXU|S_IRWXG|S_IRWXO)
+
+void *
+setmode(const char *p)
+{
+	int serrno;
+	char op, *ep;
+	BITCMD *set, *saveset, *endset;
+	mode_t mask, perm, permXbits, who;
+	long perml;
+	int equalopdone;
+	u_int setlen;
+
+	if (!*p) {
+		errno = EINVAL;
+		return (NULL);
+	}
+
+	/*
+	 * Get a copy of the mask for the permissions that are mask relative.
+	 * Flip the bits, we want what's not set.
+	 */
+	mask = ~get_current_umask();
+
+	setlen = SET_LEN + 2;
+
+	if ((set = malloc(setlen * sizeof(BITCMD))) == NULL)
+		return (NULL);
+	saveset = set;
+	endset = set + (setlen - 2);
+
+	/*
+	 * If an absolute number, get it and return; disallow non-octal digits
+	 * or illegal bits.
+	 */
+	if (isdigit((unsigned char)*p)) {
+		errno = 0;
+		perml = strtol(p, &ep, 8);
+		if (*ep) {
+			errno = EINVAL;
+			goto out;
+		}
+		if (errno == ERANGE && (perml == LONG_MAX || perml == LONG_MIN))
+			goto out;
+		if (perml & ~(STANDARD_BITS|S_ISVTX)) {
+			errno = EINVAL;
+			goto out;
+		}
+		perm = (mode_t)perml;
+		ADDCMD('=', (STANDARD_BITS|S_ISVTX), perm, mask);
+		set->cmd = 0;
+		return (saveset);
+	}
+
+	/*
+	 * Build list of structures to set/clear/copy bits as described by
+	 * each clause of the symbolic mode.
+	 */
+	equalopdone = 0;
+	for (;;) {
+		/* First, find out which bits might be modified. */
+		for (who = 0;; ++p) {
+			switch (*p) {
+			case 'a':
+				who |= STANDARD_BITS;
+				break;
+			case 'u':
+				who |= S_ISUID|S_IRWXU;
+				break;
+			case 'g':
+				who |= S_ISGID|S_IRWXG;
+				break;
+			case 'o':
+				who |= S_IRWXO;
+				break;
+			default:
+				goto getop;
+			}
+		}
+
+getop:		if ((op = *p++) != '+' && op != '-' && op != '=') {
+			errno = EINVAL;
+			goto out;
+		}
+		if (op == '=')
+			equalopdone = 0;
+
+		who &= ~S_ISVTX;
+		for (perm = 0, permXbits = 0;; ++p) {
+			switch (*p) {
+			case 'r':
+				perm |= S_IRUSR|S_IRGRP|S_IROTH;
+				break;
+			case 's':
+				/* If only "other" bits ignore set-id. */
+				if (!who || who & ~S_IRWXO)
+					perm |= S_ISUID|S_ISGID;
+				break;
+			case 't':
+				/* If only "other" bits ignore sticky. */
+				if (!who || who & ~S_IRWXO) {
+					who |= S_ISVTX;
+					perm |= S_ISVTX;
+				}
+				break;
+			case 'w':
+				perm |= S_IWUSR|S_IWGRP|S_IWOTH;
+				break;
+			case 'X':
+				permXbits = S_IXUSR|S_IXGRP|S_IXOTH;
+				break;
+			case 'x':
+				perm |= S_IXUSR|S_IXGRP|S_IXOTH;
+				break;
+			case 'u':
+			case 'g':
+			case 'o':
+				/*
+				 * When ever we hit 'u', 'g', or 'o', we have
+				 * to flush out any partial mode that we have,
+				 * and then do the copying of the mode bits.
+				 */
+				if (perm) {
+					ADDCMD(op, who, perm, mask);
+					perm = 0;
+				}
+				if (op == '=')
+					equalopdone = 1;
+				if (op == '+' && permXbits) {
+					ADDCMD('X', who, permXbits, mask);
+					permXbits = 0;
+				}
+				ADDCMD(*p, who, op, mask);
+				break;
+
+			default:
+				/*
+				 * Add any permissions that we haven't already
+				 * done.
+				 */
+				if (perm || (op == '=' && !equalopdone)) {
+					if (op == '=')
+						equalopdone = 1;
+					ADDCMD(op, who, perm, mask);
+					perm = 0;
+				}
+				if (permXbits) {
+					ADDCMD('X', who, permXbits, mask);
+					permXbits = 0;
+				}
+				goto apply;
+			}
+		}
+
+apply:		if (!*p)
+			break;
+		if (*p != ',')
+			goto getop;
+		++p;
+	}
+	set->cmd = 0;
+#ifdef SETMODE_DEBUG
+	(void)printf("Before compress_mode()\n");
+	dumpmode(saveset);
+#endif
+	compress_mode(saveset);
+#ifdef SETMODE_DEBUG
+	(void)printf("After compress_mode()\n");
+	dumpmode(saveset);
+#endif
+	return (saveset);
+out:
+	serrno = errno;
+	free(saveset);
+	errno = serrno;
+	return NULL;
+}
+
+static mode_t
+get_current_umask(void)
+{
+	sigset_t sigset, sigoset;
+	mode_t mask;
+
+#ifdef KERN_PROC_UMASK
+	/*
+	 * First try requesting the umask without temporarily modifying it.
+	 * Note that this does not work if the sysctl
+	 * security.bsd.unprivileged_proc_debug is set to 0.
+	 */
+	len = sizeof(smask);
+	if (sysctl((int[4]){ CTL_KERN, KERN_PROC, KERN_PROC_UMASK, 0 },
+	    4, &smask, &len, NULL, 0) == 0)
+		return (smask);
+#endif
+	/*
+	 * Since it's possible that the caller is opening files inside a signal
+	 * handler, protect them as best we can.
+	 */
+	sigfillset(&sigset);
+	(void)sigprocmask(SIG_BLOCK, &sigset, &sigoset);
+	(void)umask(mask = umask(0));
+	(void)sigprocmask(SIG_SETMASK, &sigoset, NULL);
+	return (mask);
+}
+
+static BITCMD *
+addcmd(BITCMD *set, mode_t op, mode_t who, mode_t oparg, mode_t mask)
+{
+	switch (op) {
+	case '=':
+		set->cmd = '-';
+		set->bits = who ? who : STANDARD_BITS;
+		set++;
+
+		op = '+';
+		/* FALLTHROUGH */
+	case '+':
+	case '-':
+	case 'X':
+		set->cmd = op;
+		set->bits = (who ? who : mask) & oparg;
+		break;
+
+	case 'u':
+	case 'g':
+	case 'o':
+		set->cmd = op;
+		if (who) {
+			set->cmd2 = ((who & S_IRUSR) ? CMD2_UBITS : 0) |
+				    ((who & S_IRGRP) ? CMD2_GBITS : 0) |
+				    ((who & S_IROTH) ? CMD2_OBITS : 0);
+			set->bits = (mode_t)~0;
+		} else {
+			set->cmd2 = CMD2_UBITS | CMD2_GBITS | CMD2_OBITS;
+			set->bits = mask;
+		}
+
+		if (oparg == '+')
+			set->cmd2 |= CMD2_SET;
+		else if (oparg == '-')
+			set->cmd2 |= CMD2_CLR;
+		else if (oparg == '=')
+			set->cmd2 |= CMD2_SET|CMD2_CLR;
+		break;
+	}
+	return (set + 1);
+}
+
+#ifdef SETMODE_DEBUG
+static void
+dumpmode(BITCMD *set)
+{
+	for (; set->cmd; ++set)
+		(void)printf("cmd: '%c' bits %04o%s%s%s%s%s%s\n",
+		    set->cmd, set->bits, set->cmd2 ? " cmd2:" : "",
+		    set->cmd2 & CMD2_CLR ? " CLR" : "",
+		    set->cmd2 & CMD2_SET ? " SET" : "",
+		    set->cmd2 & CMD2_UBITS ? " UBITS" : "",
+		    set->cmd2 & CMD2_GBITS ? " GBITS" : "",
+		    set->cmd2 & CMD2_OBITS ? " OBITS" : "");
+}
+#endif
+
+/*
+ * Given an array of bitcmd structures, compress by compacting consecutive
+ * '+', '-' and 'X' commands into at most 3 commands, one of each.  The 'u',
+ * 'g' and 'o' commands continue to be separate.  They could probably be
+ * compacted, but it's not worth the effort.
+ */
+static void
+compress_mode(BITCMD *set)
+{
+	BITCMD *nset;
+	int setbits, clrbits, Xbits, op;
+
+	for (nset = set;;) {
+		/* Copy over any 'u', 'g' and 'o' commands. */
+		while ((op = nset->cmd) != '+' && op != '-' && op != 'X') {
+			*set++ = *nset++;
+			if (!op)
+				return;
+		}
+
+		for (setbits = clrbits = Xbits = 0;; nset++) {
+			if ((op = nset->cmd) == '-') {
+				clrbits |= nset->bits;
+				setbits &= ~nset->bits;
+				Xbits &= ~nset->bits;
+			} else if (op == '+') {
+				setbits |= nset->bits;
+				clrbits &= ~nset->bits;
+				Xbits &= ~nset->bits;
+			} else if (op == 'X')
+				Xbits |= nset->bits & ~setbits;
+			else
+				break;
+		}
+		if (clrbits) {
+			set->cmd = '-';
+			set->cmd2 = 0;
+			set->bits = clrbits;
+			set++;
+		}
+		if (setbits) {
+			set->cmd = '+';
+			set->cmd2 = 0;
+			set->bits = setbits;
+			set++;
+		}
+		if (Xbits) {
+			set->cmd = 'X';
+			set->cmd2 = 0;
+			set->bits = Xbits;
+			set++;
+		}
+	}
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/setproctitle.c third_party/newlib-4.1.0/newlib/libc/sys/arm/setproctitle.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/setproctitle.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/setproctitle.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,99 @@
+/* $NetBSD: setproctitle.c,v 1.22 2008/01/03 04:26:27 christos Exp $ */
+
+/*
+ * Copyright (c) 1994, 1995 Christopher G. Demetriou
+ * All rights reserved.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *          This product includes software developed for the
+ *          NetBSD Project.  See http://www.NetBSD.org/ for
+ *          information about NetBSD.
+ * 4. The name of the author may not be used to endorse or promote products
+ *    derived from this software without specific prior written permission.
+ * 
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+ * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+ * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+ * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+ * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+ * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ * 
+ * <<Id: LICENSE,v 1.2 2000/06/14 15:57:33 cgd Exp>>
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: setproctitle.c,v 1.22 2008/01/03 04:26:27 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <sys/param.h>
+#include <sys/types.h>
+//#include <sys/exec.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef __weak_alias
+__weak_alias(setproctitle,_setproctitle)
+#endif
+
+#define	MAX_PROCTITLE	2048
+
+/*
+ * For compatibility with old versions of crt0 that didn't define __ps_strings,
+ * define it as a common here.
+ */
+//struct ps_strings *__ps_strings;
+
+void
+setproctitle(const char *fmt, ...)
+{
+	static char buf[MAX_PROCTITLE], *bufp;
+	const char *pname = getprogname();
+
+	if (fmt != NULL) {
+		int len = snprintf(buf, sizeof(buf), "%s: ", pname);
+		if (len >= 0) {
+			va_list ap;
+
+			va_start(ap, fmt);
+			(void)vsnprintf(buf + len, sizeof(buf) - len, fmt, ap);
+			va_end(ap);
+		}
+	} else
+		(void)snprintf(buf, sizeof(buf), "%s", pname);
+
+	bufp = buf;
+
+#ifdef	USRSTACK
+	/*
+	 * For compatibility with old versions of crt0 and old kernels, set
+	 * __ps_strings to a default value if it's null.
+	 * But only if USRSTACK is defined.  It might not be defined if
+	 * user-level code can not assume it's a constant (i.e. m68k).
+	 */
+	if (__ps_strings == 0)
+		__ps_strings = PS_STRINGS;
+#endif	/* USRSTACK */
+
+/*	if (__ps_strings != 0) {
+		__ps_strings->ps_nargvstr = 1;
+		__ps_strings->ps_argvstr = &bufp;
+	}
+*/	
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/siglist.c third_party/newlib-4.1.0/newlib/libc/sys/arm/siglist.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/siglist.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/siglist.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,114 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <signal.h>
+#include <stdio.h>
+
+/*
+ *
+ */ 
+const char * const sys_siglist[NSIG] =
+{
+	/*  0           */ "Unknown Signal",
+	/*  1 SIGHUP    */ "Hangup",
+	/*  2 SIGINT    */ "Interrupt",
+	/*  3 SIGQUIT   */ "Quit",
+	/*  4 SIGILL    */ "Illegal instruction",
+	/*  5 SIGTRAP   */ "BPT trace/trap",
+	/*  6 SIGABORT  */ "ABORT instruction",
+	/*  7 SIGEMT    */ "EMT instruction",
+	/*  8 SIGFPE    */ "Floating point exception",
+	/*  9 SIGKILL   */ "Killed",
+	/* 10 SIGBUS    */ "Bus error",
+	/* 11 SIGSEGV   */ "Segmentation fault",
+	/* 12 SIGSYS    */ "Bad system call",
+	/* 13 SIGPIPE   */ "Broken pipe",
+	/* 14 SIGALRM   */ "Alarm clock",
+	/* 15 SIGTERM   */ "Terminated",
+	/* 16 SIGURG    */ "Urgent IO condition",
+	/* 17 SIGSTOP   */ "Stopped (signal)",
+	/* 18 SIGTSTP   */ "Stopped",
+	/* 19 SIGCONT   */ "Continue",
+	/* 20 SIGCHLD   */ "Child death or stop",
+	/* 21 SIGTTIN   */ "Stopped (tty input)",
+	/* 22 SIGTTOU   */ "Stopped (tty output)",
+	/* 23 SIGIO     */ "I/O ready",
+	/* 24 SIGXCPU   */ "CPU limit",
+	/* 25 SIGXFSZ   */ "File limit",
+	/* 26 SIGVTALRM */ "Alarm (virtual)",
+	/* 27 SIGPROF   */ "Alarm (profile)",
+	/* 28 SIGWINCH  */ "Window changed",
+	/* 29 SIGLOST   */ "Record lock",
+	/* 30 SIGUSR1   */ "User signal 1",
+	/* 31 SIGUSR2   */ "User signal 2"
+};
+
+
+/*
+ *
+ */
+const char * const sys_signame[NSIG] =
+{
+	/*  0           */ "signal 0",
+	/*  1 SIGHUP    */ "hup",
+	/*  2 SIGINT    */ "int",
+	/*  3 SIGQUIT   */ "quit",
+	/*  4 SIGILL    */ "ill",
+	/*  5 SIGTRAP   */ "trap",
+	/*  6 SIGABORT  */ "abort",
+	/*  7 SIGEMT    */ "emt",
+	/*  8 SIGFPE    */ "fpe",
+	/*  9 SIGKILL   */ "kill",
+	/* 10 SIGBUS    */ "bus",
+	/* 11 SIGSEGV   */ "segv",
+	/* 12 SIGSYS    */ "sys",
+	/* 13 SIGPIPE   */ "pipe",
+	/* 14 SIGALRM   */ "alrm",
+	/* 15 SIGTERM   */ "term",
+	/* 16 SIGURG    */ "urg",
+	/* 17 SIGSTOP   */ "stop",
+	/* 18 SIGTSTP   */ "tstp",
+	/* 19 SIGCONT   */ "cont",
+	/* 20 SIGCHLD   */ "chld",
+	/* 21 SIGTTIN   */ "ttin",
+	/* 22 SIGTTOU   */ "ttou",
+	/* 23 SIGIO     */ "io",
+	/* 24 SIGXCPU   */ "xcpu",
+	/* 25 SIGXFSZ   */ "xfsz",
+	/* 26 SIGVTALRM */ "vtalrm",
+	/* 27 SIGPROF   */ "prof",
+	/* 28 SIGWINCH  */ "winch",
+	/* 29 SIGLOST   */ "lost",
+	/* 30 SIGUSR1   */ "usr1",
+	/* 31 SIGUSR2   */ "usr2"
+};
+
+
+/*
+ * 
+ */
+char *strsignal (int sig)
+{
+	if (sig > 0 && sig <NSIG)
+		return (char *) sys_siglist[sig];
+	else
+		return "Unknown signal";
+}
+
+
+/*
+ *
+ */
+void psignal (int sig, const char *s)
+{
+	const char *sig_str;
+	
+	if (sig > 0 && sig < NSIG)
+		sig_str = sys_siglist[sig];
+	else
+		sig_str = "Unknown signal";
+
+	printf ("%s: %s\n", s, sig_str);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/signal.c third_party/newlib-4.1.0/newlib/libc/sys/arm/signal.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/signal.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/signal.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,131 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <signal.h>
+#include <sys/signal.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+_sig_func_ptr signal (int sig, _sig_func_ptr handler)
+{
+    struct sigaction act;
+
+    act.sa_flags = SA_RESETHAND;
+    act.sa_mask = 0;
+    act.sa_handler = handler;
+	
+    sigaction (sig, &act, NULL);
+}
+
+
+/*
+ *
+ */
+int kill (int pid, int sig)
+{
+    int sc;
+
+    sc = _swi_kill(pid, sig);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+    int sc;
+
+    sc = _swi_sigaction(sig, act, oact);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int raise (int sig)
+{
+    int sc;
+
+    sc = _swi_kill(getpid(), sig);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigprocmask (int how, const sigset_t *set, sigset_t *oset)
+{
+    int sc;
+
+    sc = _swi_sigprocmask(how, set, oset);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigsuspend (const sigset_t *sigmask)
+{
+    int sc;
+
+    sc = _swi_sigsuspend(sigmask);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigpending (sigset_t *set)
+{
+    int sc;
+
+    sc = _swi_sigpending(set);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/signames.c third_party/newlib-4.1.0/newlib/libc/sys/arm/signames.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/signames.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/signames.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,174 @@
+/*
+ * No copyright is claimed.  This code is in the public domain; do with
+ * it what you wish.
+
+ * Written by:
+ *  Sami Kerola <kerolasa@iki.fi>
+ *  Karel Zak <kzak@redhat.com>
+ *  Niklas Hambüchen <mail@nh2.me>
+ */
+
+#include <ctype.h>		/* for isdigit() */
+#include <stdlib.h>
+#include <signal.h>
+#include <unistd.h>
+#include <string.h>
+#include <errno.h>
+
+#include "compat.h"
+
+#define ARRAY_SIZE(x) (sizeof(x) / sizeof(*x))
+
+static const struct ul_signal_name {
+	const char *name;
+	int val;
+} ul_signames[] = {
+	/* POSIX signals */
+	{ "HUP",	SIGHUP },	/* 1 */
+	{ "INT",	SIGINT },	/* 2 */
+	{ "QUIT",	SIGQUIT },	/* 3 */
+	{ "ILL",	SIGILL },	/* 4 */
+#ifdef SIGTRAP
+	{ "TRAP",	SIGTRAP },	/* 5 */
+#endif
+	{ "ABRT",	SIGABRT },	/* 6 */
+#ifdef SIGIOT
+	{ "IOT",	SIGIOT },	/* 6, same as SIGABRT */
+#endif
+#ifdef SIGEMT
+	{ "EMT",	SIGEMT },	/* 7 (mips,alpha,sparc*) */
+#endif
+#ifdef SIGBUS
+	{ "BUS",	SIGBUS },	/* 7 (arm,i386,m68k,ppc), 10 (mips,alpha,sparc*) */
+#endif
+	{ "FPE",	SIGFPE },	/* 8 */
+	{ "KILL",	SIGKILL },	/* 9 */
+	{ "USR1",	SIGUSR1 },	/* 10 (arm,i386,m68k,ppc), 30 (alpha,sparc*), 16 (mips) */
+	{ "SEGV",	SIGSEGV },	/* 11 */
+	{ "USR2",	SIGUSR2 },	/* 12 (arm,i386,m68k,ppc), 31 (alpha,sparc*), 17 (mips) */
+	{ "PIPE",	SIGPIPE },	/* 13 */
+	{ "ALRM",	SIGALRM },	/* 14 */
+	{ "TERM",	SIGTERM },	/* 15 */
+#ifdef SIGSTKFLT
+	{ "STKFLT",	SIGSTKFLT },	/* 16 (arm,i386,m68k,ppc) */
+#endif
+	{ "CHLD",	SIGCHLD },	/* 17 (arm,i386,m68k,ppc), 20 (alpha,sparc*), 18 (mips) */
+#ifdef SIGCLD
+	{ "CLD",	SIGCLD },	/* same as SIGCHLD (mips) */
+#endif
+	{ "CONT",	SIGCONT },	/* 18 (arm,i386,m68k,ppc), 19 (alpha,sparc*), 25 (mips) */
+	{ "STOP",	SIGSTOP },	/* 19 (arm,i386,m68k,ppc), 17 (alpha,sparc*), 23 (mips) */
+	{ "TSTP",	SIGTSTP },	/* 20 (arm,i386,m68k,ppc), 18 (alpha,sparc*), 24 (mips) */
+	{ "TTIN",	SIGTTIN },	/* 21 (arm,i386,m68k,ppc,alpha,sparc*), 26 (mips) */
+	{ "TTOU",	SIGTTOU },	/* 22 (arm,i386,m68k,ppc,alpha,sparc*), 27 (mips) */
+#ifdef SIGURG
+	{ "URG",	SIGURG },	/* 23 (arm,i386,m68k,ppc), 16 (alpha,sparc*), 21 (mips) */
+#endif
+#ifdef SIGXCPU
+	{ "XCPU",	SIGXCPU },	/* 24 (arm,i386,m68k,ppc,alpha,sparc*), 30 (mips) */
+#endif
+#ifdef SIGXFSZ
+	{ "XFSZ",	SIGXFSZ },	/* 25 (arm,i386,m68k,ppc,alpha,sparc*), 31 (mips) */
+#endif
+#ifdef SIGVTALRM
+	{ "VTALRM",	SIGVTALRM },	/* 26 (arm,i386,m68k,ppc,alpha,sparc*), 28 (mips) */
+#endif
+#ifdef SIGPROF
+	{ "PROF",	SIGPROF },	/* 27 (arm,i386,m68k,ppc,alpha,sparc*), 29 (mips) */
+#endif
+#ifdef SIGWINCH
+	{ "WINCH",	SIGWINCH },	/* 28 (arm,i386,m68k,ppc,alpha,sparc*), 20 (mips) */
+#endif
+#ifdef SIGIO
+	{ "IO",		SIGIO },	/* 29 (arm,i386,m68k,ppc), 23 (alpha,sparc*), 22 (mips) */
+#endif
+#ifdef SIGPOLL
+	{ "POLL",	SIGPOLL },	/* same as SIGIO */
+#endif
+#ifdef SIGINFO
+	{ "INFO",	SIGINFO },	/* 29 (alpha) */
+#endif
+#ifdef SIGLOST
+	{ "LOST",	SIGLOST },	/* 29 (arm,i386,m68k,ppc,sparc*) */
+#endif
+#ifdef SIGPWR
+	{ "PWR",	SIGPWR },	/* 30 (arm,i386,m68k,ppc), 29 (alpha,sparc*), 19 (mips) */
+#endif
+#ifdef SIGUNUSED
+	{ "UNUSED",	SIGUNUSED },	/* 31 (arm,i386,m68k,ppc) */
+#endif
+#ifdef SIGSYS
+	{ "SYS",	SIGSYS },	/* 31 (mips,alpha,sparc*) */
+#endif
+};
+
+#ifdef SIGRTMIN
+static int rtsig_to_signum(const char *sig)
+{
+	int num, maxi = 0;
+	char *ep = NULL;
+
+	if (strncasecmp(sig, "min+", 4) == 0)
+		sig += 4;
+	else if (strncasecmp(sig, "max-", 4) == 0) {
+		sig += 4;
+		maxi = 1;
+	}
+	if (!isdigit(*sig))
+		return -1;
+	errno = 0;
+	num = strtol(sig, &ep, 10);
+	if (!ep || sig == ep || errno || num < 0)
+		return -1;
+	num = maxi ? SIGRTMAX - num : SIGRTMIN + num;
+	if (num < SIGRTMIN || SIGRTMAX < num)
+		return -1;
+	return num;
+}
+#endif
+
+int signame_to_signum(const char *sig)
+{
+	size_t n;
+
+	if (!strncasecmp(sig, "sig", 3))
+		sig += 3;
+#ifdef SIGRTMIN
+	/* RT signals */
+	if (!strncasecmp(sig, "rt", 2))
+		return rtsig_to_signum(sig + 2);
+#endif
+	/* Normal signals */
+	for (n = 0; n < ARRAY_SIZE(ul_signames); n++) {
+		if (!strcasecmp(ul_signames[n].name, sig))
+			return ul_signames[n].val;
+	}
+	return -1;
+}
+
+const char *signum_to_signame(int signum)
+{
+	size_t n;
+
+	for (n = 0; n < ARRAY_SIZE(ul_signames); n++) {
+		if (ul_signames[n].val == signum) {
+			return ul_signames[n].name;
+		}
+	}
+
+	return NULL;
+}
+
+int get_signame_by_idx(size_t idx, const char **signame, int *signum)
+{
+	if (idx >= ARRAY_SIZE(ul_signames))
+		return -1;
+
+	if (signame)
+		*signame = ul_signames[idx].name;
+	if (signum)
+		*signum = ul_signames[idx].val;
+	return 0;
+
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sigtramp.s third_party/newlib-4.1.0/newlib/libc/sys/arm/sigtramp.s
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sigtramp.s	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sigtramp.s	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,66 @@
+.global __kielder_sigtramp
+.equ SF_SIGNUM,     0
+.equ SF_SIGINFO,    4
+.equ SF_UCONTEXT,   8
+.equ SF_SIGHANDLER, 12
+
+
+
+
+.text
+.align 16
+
+
+
+
+/ ****************************************************************************
+/ __kielder_sigtramp:
+/
+/ 
+/ Kernel passes control to __sigtramp to begin signal handling.
+/ A sigframe is placed on the stack by the kernel, stack pointer points to
+/ the sigframe structure.
+
+
+
+__kielder_sigtramp:
+	movl SF_SIGINFO(%esp), %eax
+	cmpl $0x00000000, %eax
+	jne Lcall_siginfohandler
+
+
+Lcall_sighandler:
+	movl SF_SIGNUM(%esp), %eax
+	movl SF_SIGHANDLER(%esp), %edx
+	
+	push %eax
+	call *%edx
+	
+	add $4, %esp
+	movl %esp, %ebx
+	movl $0xffffffff, %eax
+	int $0x30
+	
+	
+Lcall_siginfohandler:
+	movl SF_UCONTEXT(%esp), %eax
+	movl SF_SIGINFO(%esp), %ebx
+	movl SF_SIGNUM(%esp), %ecx
+	movl SF_SIGHANDLER(%esp), %edx
+		
+	push %eax
+	push %ebx
+	push %ecx
+	
+	call *%edx
+
+	add $4, %esp
+	movl %esp, %ebx
+	movl $0xffffffff, %eax
+	int $0x30
+
+
+
+
+	
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sleep.c third_party/newlib-4.1.0/newlib/libc/sys/arm/sleep.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sleep.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sleep.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,43 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/* @brief Sleep for a number of seconds
+ *
+ */
+unsigned int sleep (unsigned int seconds)
+{
+    int sc;
+
+    sc = _swi_sleep(seconds);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ *
+ */
+int nanosleep (const struct timespec *req, struct timespec *rem)
+{
+    int sc;
+
+    sc = _swi_nanosleep(req, rem);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;	
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/stat.c third_party/newlib-4.1.0/newlib/libc/sys/arm/stat.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/stat.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/stat.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,77 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int fstat(int fd, struct stat *buf)
+{
+    int sc;
+    
+    sc = _swi_fstat(fd, buf);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int stat (const char *path, struct stat *buf)
+{
+    int sc;
+
+    sc = _swi_stat(path, buf);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int lstat (const char *pathname, struct stat *st)
+{
+    return stat(pathname, st);
+}
+
+
+/*
+ *
+ */
+int statfs(const char *path, struct statfs *buf)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+/*
+ *
+ */
+int fstatfs(int fd, struct statfs *buf)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/statvfs.c third_party/newlib-4.1.0/newlib/libc/sys/arm/statvfs.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/statvfs.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/statvfs.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,44 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int fstatvfs (int fd, struct statvfs *st)
+{
+  errno = ENOSYS;
+	return -1;
+}
+
+
+/*
+ *
+ */
+int statvfs (const char *pathname, struct statvfs *st)
+{
+	int fd;
+	
+	
+	if ((fd = open (pathname, O_RDONLY)) < 0) {
+		return -1;
+	}
+	
+	if (fstatvfs (fd, st) < 0) {
+		return -1;
+  }
+  
+	if (close(fd) <	0) {
+		return -1;
+	}
+	
+	return 0;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/stringlist.c third_party/newlib-4.1.0/newlib/libc/sys/arm/stringlist.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/stringlist.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/stringlist.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,158 @@
+/*	$NetBSD: stringlist.c,v 1.14 2015/05/21 01:29:13 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1994, 1999 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Christos Zoulas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: stringlist.c,v 1.14 2015/05/21 01:29:13 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <stringlist.h>
+
+#ifdef __weak_alias
+__weak_alias(sl_add,_sl_add)
+__weak_alias(sl_find,_sl_find)
+__weak_alias(sl_free,_sl_free)
+__weak_alias(sl_init,_sl_init)
+__weak_alias(sl_delete,_sl_delete)
+#endif
+
+#define _SL_CHUNKSIZE	20
+
+/*
+ * sl_init(): Initialize a string list
+ */
+StringList *
+sl_init(void)
+{
+	StringList *sl;
+
+	sl = malloc(sizeof(StringList));
+	if (sl == NULL)
+		return NULL;
+
+	sl->sl_cur = 0;
+	sl->sl_max = _SL_CHUNKSIZE;
+	sl->sl_str = NULL;
+	errno = reallocarr(&sl->sl_str, sl->sl_max, sizeof(char *));
+	if (errno) {
+		free(sl);
+		sl = NULL;
+	}
+	return sl;
+}
+
+
+/*
+ * sl_add(): Add an item to the string list
+ */
+int
+sl_add(StringList *sl, char *name)
+{
+
+	_DIAGASSERT(sl != NULL);
+
+	if (sl->sl_cur == sl->sl_max - 1) {
+		char	**new = sl->sl_str;
+
+		errno = reallocarr(&new, (sl->sl_max + _SL_CHUNKSIZE),
+		    sizeof(char *));
+		if (errno)
+			return -1;
+		sl->sl_max += _SL_CHUNKSIZE;
+		sl->sl_str = new;
+	}
+	sl->sl_str[sl->sl_cur++] = name;
+	return 0;
+}
+
+
+/*
+ * sl_free(): Free a stringlist
+ */
+void
+sl_free(StringList *sl, int all)
+{
+	size_t i;
+
+	if (sl == NULL)
+		return;
+	if (sl->sl_str) {
+		if (all)
+			for (i = 0; i < sl->sl_cur; i++)
+				free(sl->sl_str[i]);
+		free(sl->sl_str);
+	}
+	free(sl);
+}
+
+
+/*
+ * sl_find(): Find a name in the string list
+ */
+char *
+sl_find(StringList *sl, const char *name)
+{
+	size_t i;
+
+	_DIAGASSERT(sl != NULL);
+
+	for (i = 0; i < sl->sl_cur; i++)
+		if (strcmp(sl->sl_str[i], name) == 0)
+			return sl->sl_str[i];
+
+	return NULL;
+}
+
+int
+sl_delete(StringList *sl, const char *name, int all)
+{
+	size_t i, j;
+
+	for (i = 0; i < sl->sl_cur; i++)
+		if (strcmp(sl->sl_str[i], name) == 0) {
+			if (all)
+				free(sl->sl_str[i]);
+			for (j = i + 1; j < sl->sl_cur; j++)
+				sl->sl_str[j - 1] = sl->sl_str[j];
+			sl->sl_str[--sl->sl_cur] = NULL;
+			return 0;
+		}
+	return -1;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/strmode.c third_party/newlib-4.1.0/newlib/libc/sys/arm/strmode.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/strmode.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/strmode.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,150 @@
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1990, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)strmode.c	8.3 (Berkeley) 8/15/94";
+#endif /* LIBC_SCCS and not lint */
+#include <sys/cdefs.h>
+__FBSDID("$FreeBSD$");
+
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <string.h>
+
+void
+strmode(/* mode_t */ int mode, char *p)
+{
+	 /* print type */
+	switch (mode & S_IFMT) {
+	case S_IFDIR:			/* directory */
+		*p++ = 'd';
+		break;
+	case S_IFCHR:			/* character special */
+		*p++ = 'c';
+		break;
+	case S_IFBLK:			/* block special */
+		*p++ = 'b';
+		break;
+	case S_IFREG:			/* regular */
+		*p++ = '-';
+		break;
+	case S_IFLNK:			/* symbolic link */
+		*p++ = 'l';
+		break;
+	case S_IFSOCK:			/* socket */
+		*p++ = 's';
+		break;
+#ifdef S_IFIFO
+	case S_IFIFO:			/* fifo */
+		*p++ = 'p';
+		break;
+#endif
+#ifdef S_IFWHT
+	case S_IFWHT:			/* whiteout */
+		*p++ = 'w';
+		break;
+#endif
+	default:			/* unknown */
+		*p++ = '?';
+		break;
+	}
+	/* usr */
+	if (mode & S_IRUSR)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWUSR)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	switch (mode & (S_IXUSR | S_ISUID)) {
+	case 0:
+		*p++ = '-';
+		break;
+	case S_IXUSR:
+		*p++ = 'x';
+		break;
+	case S_ISUID:
+		*p++ = 'S';
+		break;
+	case S_IXUSR | S_ISUID:
+		*p++ = 's';
+		break;
+	}
+	/* group */
+	if (mode & S_IRGRP)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWGRP)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	switch (mode & (S_IXGRP | S_ISGID)) {
+	case 0:
+		*p++ = '-';
+		break;
+	case S_IXGRP:
+		*p++ = 'x';
+		break;
+	case S_ISGID:
+		*p++ = 'S';
+		break;
+	case S_IXGRP | S_ISGID:
+		*p++ = 's';
+		break;
+	}
+	/* other */
+	if (mode & S_IROTH)
+		*p++ = 'r';
+	else
+		*p++ = '-';
+	if (mode & S_IWOTH)
+		*p++ = 'w';
+	else
+		*p++ = '-';
+	switch (mode & (S_IXOTH | S_ISVTX)) {
+	case 0:
+		*p++ = '-';
+		break;
+	case S_IXOTH:
+		*p++ = 'x';
+		break;
+	case S_ISVTX:
+		*p++ = 'T';
+		break;
+	case S_IXOTH | S_ISVTX:
+		*p++ = 't';
+		break;
+	}
+	*p++ = ' ';
+	*p = '\0';
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/swi.h third_party/newlib-4.1.0/newlib/libc/sys/arm/swi.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/swi.h	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/swi.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-#include "arm.h"
-
-/* SWI numbers for RDP (Demon) monitor.  */
-#define SWI_WriteC                 0x0
-#define SWI_Write0                 0x2
-#define SWI_ReadC                  0x4
-#define SWI_CLI                    0x5
-#define SWI_GetEnv                 0x10
-#define SWI_Exit                   0x11
-#define SWI_EnterOS                0x16
-
-#define SWI_GetErrno               0x60
-#define SWI_Clock                  0x61
-#define SWI_Time                   0x63
-#define SWI_Remove                 0x64
-#define SWI_Rename                 0x65
-#define SWI_Open                   0x66
-
-#define SWI_Close                  0x68
-#define SWI_Write                  0x69
-#define SWI_Read                   0x6a
-#define SWI_Seek                   0x6b
-#define SWI_Flen                   0x6c
-
-#define SWI_IsTTY                  0x6e
-#define SWI_TmpNam                 0x6f
-#define SWI_InstallHandler         0x70
-#define SWI_GenerateError          0x71
-
-
-/* Now the SWI numbers and reason codes for RDI (Angel) monitors.  */
-#define AngelSWI_ARM 			0x123456
-#ifdef __thumb__
-#define AngelSWI 			0xAB
-#else
-#define AngelSWI 			AngelSWI_ARM
-#endif
-/* For thumb only architectures use the BKPT instruction instead of SWI.  */
-#ifdef THUMB_VXM
-#define AngelSWIInsn			"bkpt"
-#define AngelSWIAsm			bkpt
-#else
-#define AngelSWIInsn			"swi"
-#define AngelSWIAsm			swi
-#endif
-
-/* The reason codes:  */
-#define AngelSWI_Reason_Open		0x01
-#define AngelSWI_Reason_Close		0x02
-#define AngelSWI_Reason_WriteC		0x03
-#define AngelSWI_Reason_Write0		0x04
-#define AngelSWI_Reason_Write		0x05
-#define AngelSWI_Reason_Read		0x06
-#define AngelSWI_Reason_ReadC		0x07
-#define AngelSWI_Reason_IsTTY		0x09
-#define AngelSWI_Reason_Seek		0x0A
-#define AngelSWI_Reason_FLen		0x0C
-#define AngelSWI_Reason_TmpNam		0x0D
-#define AngelSWI_Reason_Remove		0x0E
-#define AngelSWI_Reason_Rename		0x0F
-#define AngelSWI_Reason_Clock		0x10
-#define AngelSWI_Reason_Time		0x11
-#define AngelSWI_Reason_System		0x12
-#define AngelSWI_Reason_Errno		0x13
-#define AngelSWI_Reason_GetCmdLine 	0x15
-#define AngelSWI_Reason_HeapInfo 	0x16
-#define AngelSWI_Reason_EnterSVC 	0x17
-#define AngelSWI_Reason_ReportException 0x18
-#define ADP_Stopped_ApplicationExit 	((2 << 16) + 38)
-#define ADP_Stopped_RunTimeError 	((2 << 16) + 35)
-
-#if defined(ARM_RDI_MONITOR) && !defined(__ASSEMBLER__)
-
-static inline int
-do_AngelSWI (int reason, void * arg)
-{
-  int value;
-  asm volatile ("mov r0, %1; mov r1, %2; " AngelSWIInsn " %a3; mov %0, r0"
-       : "=r" (value) /* Outputs */
-       : "r" (reason), "r" (arg), "i" (AngelSWI) /* Inputs */
-       : "r0", "r1", "r2", "r3", "ip", "lr", "memory", "cc"
-		/* Clobbers r0 and r1, and lr if in supervisor mode */);
-                /* Accordingly to page 13-77 of ARM DUI 0040D other registers
-                   can also be clobbered.  Some memory positions may also be
-                   changed by a system call, so they should not be kept in
-                   registers. Note: we are assuming the manual is right and
-                   Angel is respecting the APCS.  */
-  return value;
-}
-
-#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sync.c third_party/newlib-4.1.0/newlib/libc/sys/arm/sync.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sync.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sync.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,41 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/* @brief sync a specific file to non-volatile storage
+ *
+ */
+int fsync (int fd)
+{
+    int sc;
+
+    sc = _swi_fsync(fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/* @brief sync all files to non-volatile storage
+ *
+ */
+int sync (void)
+{
+    int sc;
+
+    sc = _swi_sync();
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/cdefs.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/cdefs.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/cdefs.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/cdefs.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,736 @@
+/* libc/sys/linux/sys/cdefs.h - Helper macros for K&R vs. ANSI C compat. */
+
+/* Written 2000 by Werner Almesberger */
+
+/*-
+ * SPDX-License-Identifier: BSD-3-Clause
+ *
+ * Copyright (c) 1991, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * This code is derived from software contributed to Berkeley by
+ * Berkeley Software Design, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)cdefs.h	8.8 (Berkeley) 1/9/95
+ * $FreeBSD$
+ */
+
+#ifndef	_SYS_CDEFS_H_
+#define	_SYS_CDEFS_H_
+
+#include <machine/_default_types.h>
+#include <sys/features.h>
+#include <stddef.h>
+
+#define __PMT(args)	args
+#define __DOTS    	, ...
+#define __THROW
+
+#ifdef __GNUC__
+# define __ASMNAME(cname)  __XSTRING (__USER_LABEL_PREFIX__) cname
+#endif
+
+#define __ptr_t void *
+#define __long_double_t  long double
+
+#define __attribute_malloc__
+#define __attribute_pure__
+#define __attribute_format_strfmon__(a,b)
+#define __flexarr      [0]
+
+#ifndef __BOUNDED_POINTERS__
+# define __bounded      /* nothing */
+# define __unbounded    /* nothing */
+# define __ptrvalue     /* nothing */
+#endif
+
+/*
+ * Testing against Clang-specific extensions.
+ */
+#ifndef	__has_attribute
+#define	__has_attribute(x)	0
+#endif
+#ifndef	__has_extension
+#define	__has_extension		__has_feature
+#endif
+#ifndef	__has_feature
+#define	__has_feature(x)	0
+#endif
+#ifndef	__has_include
+#define	__has_include(x)	0
+#endif
+#ifndef	__has_builtin
+#define	__has_builtin(x)	0
+#endif
+
+#if defined(__cplusplus)
+#define	__BEGIN_DECLS	extern "C" {
+#define	__END_DECLS	}
+#else
+#define	__BEGIN_DECLS
+#define	__END_DECLS
+#endif
+
+/*
+ * This code has been put in place to help reduce the addition of
+ * compiler specific defines in FreeBSD code.  It helps to aid in
+ * having a compiler-agnostic source tree.
+ */
+
+#if defined(__GNUC__) || defined(__INTEL_COMPILER)
+
+#if __GNUC__ >= 3 || defined(__INTEL_COMPILER)
+#define	__GNUCLIKE_ASM 3
+#define	__GNUCLIKE_MATH_BUILTIN_CONSTANTS
+#else
+#define	__GNUCLIKE_ASM 2
+#endif
+#define	__GNUCLIKE___TYPEOF 1
+#define	__GNUCLIKE___OFFSETOF 1
+#define	__GNUCLIKE___SECTION 1
+
+#ifndef __INTEL_COMPILER
+#define	__GNUCLIKE_CTOR_SECTION_HANDLING 1
+#endif
+
+#define	__GNUCLIKE_BUILTIN_CONSTANT_P 1
+#if defined(__INTEL_COMPILER) && defined(__cplusplus) && \
+   __INTEL_COMPILER < 800
+#undef __GNUCLIKE_BUILTIN_CONSTANT_P
+#endif
+
+#if (__GNUC_MINOR__ > 95 || __GNUC__ >= 3)
+#define	__GNUCLIKE_BUILTIN_VARARGS 1
+#define	__GNUCLIKE_BUILTIN_STDARG 1
+#define	__GNUCLIKE_BUILTIN_VAALIST 1
+#endif
+
+#if defined(__GNUC__)
+#define	__GNUC_VA_LIST_COMPATIBILITY 1
+#endif
+
+/*
+ * Compiler memory barriers, specific to gcc and clang.
+ */
+#if defined(__GNUC__)
+#define	__compiler_membar()	__asm __volatile(" " : : : "memory")
+#endif
+
+#ifndef __INTEL_COMPILER
+#define	__GNUCLIKE_BUILTIN_NEXT_ARG 1
+#define	__GNUCLIKE_MATH_BUILTIN_RELOPS
+#endif
+
+#define	__GNUCLIKE_BUILTIN_MEMCPY 1
+
+/* XXX: if __GNUC__ >= 2: not tested everywhere originally, where replaced */
+#define	__CC_SUPPORTS_INLINE 1
+#define	__CC_SUPPORTS___INLINE 1
+#define	__CC_SUPPORTS___INLINE__ 1
+
+#define	__CC_SUPPORTS___FUNC__ 1
+#define	__CC_SUPPORTS_WARNING 1
+
+#define	__CC_SUPPORTS_VARADIC_XXX 1 /* see varargs.h */
+
+#define	__CC_SUPPORTS_DYNAMIC_ARRAY_INIT 1
+
+#endif /* __GNUC__ || __INTEL_COMPILER */
+
+/*
+ * The __CONCAT macro is used to concatenate parts of symbol names, e.g.
+ * with "#define OLD(foo) __CONCAT(old,foo)", OLD(foo) produces oldfoo.
+ * The __CONCAT macro is a bit tricky to use if it must work in non-ANSI
+ * mode -- there must be no spaces between its arguments, and for nested
+ * __CONCAT's, all the __CONCAT's must be at the left.  __CONCAT can also
+ * concatenate double-quoted strings produced by the __STRING macro, but
+ * this only works with ANSI C.
+ *
+ * __XSTRING is like __STRING, but it expands any macros in its argument
+ * first.  It is only available with ANSI C.
+ */
+#if defined(__STDC__) || defined(__cplusplus)
+#define	__P(protos)	protos		/* full-blown ANSI C */
+#define	__CONCAT1(x,y)	x ## y
+#define	__CONCAT(x,y)	__CONCAT1(x,y)
+#define	__STRING(x)	#x		/* stringify without expanding x */
+#define	__XSTRING(x)	__STRING(x)	/* expand x, then stringify */
+
+#define __UNCONST(a)	((void *)(unsigned long)(const void *)(a))
+#define __UNVOLATILE(a)	((void *)(unsigned long)(volatile void *)(a))
+
+#define	__aconst
+#define	__const		const		/* define reserved names to standard */
+#define	__signed	signed
+#define	__volatile	volatile
+#if defined(__cplusplus)
+#define	__inline	inline		/* convert to C++ keyword */
+#else
+#if !(defined(__CC_SUPPORTS___INLINE))
+#define	__inline			/* delete GCC keyword */
+#endif /* ! __CC_SUPPORTS___INLINE */
+#endif /* !__cplusplus */
+
+#else	/* !(__STDC__ || __cplusplus) */
+#define	__P(protos)	()		/* traditional C preprocessor */
+#define	__CONCAT(x,y)	x/**/y
+#define	__STRING(x)	"x"
+
+#if !defined(__CC_SUPPORTS___INLINE)
+#define	__const				/* delete pseudo-ANSI C keywords */
+#define	__inline
+#define	__signed
+#define	__volatile
+/*
+ * In non-ANSI C environments, new programs will want ANSI-only C keywords
+ * deleted from the program and old programs will want them left alone.
+ * When using a compiler other than gcc, programs using the ANSI C keywords
+ * const, inline etc. as normal identifiers should define -DNO_ANSI_KEYWORDS.
+ * When using "gcc -traditional", we assume that this is the intent; if
+ * __GNUC__ is defined but __STDC__ is not, we leave the new keywords alone.
+ */
+#ifndef	NO_ANSI_KEYWORDS
+#define	const				/* delete ANSI C keywords */
+#define	inline
+#define	signed
+#define	volatile
+#endif	/* !NO_ANSI_KEYWORDS */
+#endif	/* !__CC_SUPPORTS___INLINE */
+#endif	/* !(__STDC__ || __cplusplus) */
+
+/*
+ * Compiler-dependent macros to help declare dead (non-returning) and
+ * pure (no side effects) functions, and unused variables.  They are
+ * null except for versions of gcc that are known to support the features
+ * properly (old versions of gcc-2 supported the dead and pure features
+ * in a different (wrong) way).  If we do not provide an implementation
+ * for a given compiler, let the compile fail if it is told to use
+ * a feature that we cannot live without.
+ */
+#define	__weak_symbol	__attribute__((__weak__))
+#if !__GNUC_PREREQ__(2, 5) && !defined(__INTEL_COMPILER)
+#define __dead
+#define	__dead2
+#define	__pure2
+#define	__unused
+#endif
+#if __GNUC__ == 2 && __GNUC_MINOR__ >= 5 && __GNUC_MINOR__ < 7 && !defined(__INTEL_COMPILER)
+#define __dead
+#define	__dead2		__attribute__((__noreturn__))
+#define	__pure2		__attribute__((__const__))
+#define	__unused
+/* XXX Find out what to do for __packed, __aligned and __section */
+#endif
+#if __GNUC_PREREQ__(2, 7) || defined(__INTEL_COMPILER)
+#define __dead
+#define	__dead2		__attribute__((__noreturn__))
+#define	__pure2		__attribute__((__const__))
+#define	__unused	__attribute__((__unused__))
+#define	__used		__attribute__((__used__))
+#define	__packed	__attribute__((__packed__))
+#define	__aligned(x)	__attribute__((__aligned__(x)))
+#define	__section(x)	__attribute__((__section__(x)))
+#endif
+#if __GNUC_PREREQ__(4, 3) || __has_attribute(__alloc_size__)
+#define	__alloc_size(x)	__attribute__((__alloc_size__(x)))
+#define	__alloc_size2(n, x)	__attribute__((__alloc_size__(n, x)))
+#else
+#define	__alloc_size(x)
+#define	__alloc_size2(n, x)
+#endif
+#if __GNUC_PREREQ__(4, 9) || __has_attribute(__alloc_align__)
+#define	__alloc_align(x)	__attribute__((__alloc_align__(x)))
+#else
+#define	__alloc_align(x)
+#endif
+
+#if !__GNUC_PREREQ__(2, 95)
+#define	__alignof(x)	__offsetof(struct { char __a; x __b; }, __b)
+#endif
+
+/*
+ * Keywords added in C11.
+ */
+
+#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 201112L
+
+#if !__has_extension(c_alignas)
+#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
+    __has_extension(cxx_alignas)
+#define	_Alignas(x)		alignas(x)
+#else
+/* XXX: Only emulates _Alignas(constant-expression); not _Alignas(type-name). */
+#define	_Alignas(x)		__aligned(x)
+#endif
+#endif
+
+#if defined(__cplusplus) && __cplusplus >= 201103L
+#define	_Alignof(x)		alignof(x)
+#else
+#define	_Alignof(x)		__alignof(x)
+#endif
+
+#if !defined(__cplusplus) && !__has_extension(c_atomic) && \
+	!__has_extension(cxx_atomic) && !__GNUC_PREREQ__(4, 7)
+/*
+ * No native support for _Atomic(). Place object in structure to prevent
+ * most forms of direct non-atomic access.
+ */
+#define	_Atomic(T)		struct { T volatile __val; }
+#endif
+
+#if defined(__cplusplus) && __cplusplus >= 201103L
+#define	_Noreturn		[[noreturn]]
+#else
+#define	_Noreturn		__dead2
+#endif
+
+#if !__has_extension(c_static_assert)
+#if (defined(__cplusplus) && __cplusplus >= 201103L) || \
+    __has_extension(cxx_static_assert)
+#define	_Static_assert(x, y)	static_assert(x, y)
+#elif __GNUC_PREREQ__(4,6) && !defined(__cplusplus)
+/* Nothing, gcc 4.6 and higher has _Static_assert built-in */
+#elif defined(__COUNTER__)
+#define	_Static_assert(x, y)	__Static_assert(x, __COUNTER__)
+#define	__Static_assert(x, y)	___Static_assert(x, y)
+#define	___Static_assert(x, y)	typedef char __assert_ ## y[(x) ? 1 : -1] \
+				__unused
+#else
+#define	_Static_assert(x, y)	struct __hack
+#endif
+#endif
+
+#if !__has_extension(c_thread_local)
+/*
+ * XXX: Some compilers (Clang 3.3, GCC 4.7) falsely announce C++11 mode
+ * without actually supporting the thread_local keyword. Don't check for
+ * the presence of C++11 when defining _Thread_local.
+ */
+#if /* (defined(__cplusplus) && __cplusplus >= 201103L) || */ \
+    __has_extension(cxx_thread_local)
+#define	_Thread_local		thread_local
+#else
+#define	_Thread_local		__thread
+#endif
+#endif
+
+#endif /* __STDC_VERSION__ || __STDC_VERSION__ < 201112L */
+
+/*
+ * Emulation of C11 _Generic().  Unlike the previously defined C11
+ * keywords, it is not possible to implement this using exactly the same
+ * syntax.  Therefore implement something similar under the name
+ * __generic().  Unlike _Generic(), this macro can only distinguish
+ * between a single type, so it requires nested invocations to
+ * distinguish multiple cases.
+ */
+
+#if (defined(__STDC_VERSION__) && __STDC_VERSION__ >= 201112L) || \
+    __has_extension(c_generic_selections)
+#define	__generic(expr, t, yes, no)					\
+	_Generic(expr, t: yes, default: no)
+#elif __GNUC_PREREQ__(3, 1) && !defined(__cplusplus)
+#define	__generic(expr, t, yes, no)					\
+	__builtin_choose_expr(						\
+	    __builtin_types_compatible_p(__typeof(expr), t), yes, no)
+#endif
+
+/*
+ * C99 Static array indices in function parameter declarations.  Syntax such as:
+ * void bar(int myArray[static 10]);
+ * is allowed in C99 but not in C++.  Define __min_size appropriately so
+ * headers using it can be compiled in either language.  Use like this:
+ * void bar(int myArray[__min_size(10)]);
+ */
+#if !defined(__cplusplus) && \
+    (defined(__clang__) || __GNUC_PREREQ__(4, 6)) && \
+    (!defined(__STDC_VERSION__) || (__STDC_VERSION__ >= 199901))
+#define __min_size(x)	static (x)
+#else
+#define __min_size(x)	(x)
+#endif
+
+#if __GNUC_PREREQ__(2, 96)
+#define	__malloc_like	__attribute__((__malloc__))
+#define	__pure		__attribute__((__pure__))
+#else
+#define	__malloc_like
+#define	__pure
+#endif
+
+#if __GNUC_PREREQ__(3, 1) || (defined(__INTEL_COMPILER) && __INTEL_COMPILER >= 800)
+#define	__always_inline	__inline__ __attribute__((__always_inline__))
+#else
+#define	__always_inline
+#endif
+
+#if __GNUC_PREREQ__(3, 1)
+#define	__noinline	__attribute__ ((__noinline__))
+#else
+#define	__noinline
+#endif
+
+#if __GNUC_PREREQ__(3, 3)
+#define	__nonnull(x)	__attribute__((__nonnull__ x))
+#define	__nonnull_all	__attribute__((__nonnull__))
+#else
+#define	__nonnull(x)
+#define	__nonnull_all
+#endif
+
+#if __GNUC_PREREQ__(3, 4)
+#define	__fastcall	__attribute__((__fastcall__))
+#define	__result_use_check	__attribute__((__warn_unused_result__))
+#else
+#define	__fastcall
+#define	__result_use_check
+#endif
+
+#if __GNUC_PREREQ__(4, 1)
+#define	__returns_twice	__attribute__((__returns_twice__))
+#else
+#define	__returns_twice
+#endif
+
+#if __GNUC_PREREQ__(4, 6) || __has_builtin(__builtin_unreachable)
+#define	__unreachable()	__builtin_unreachable()
+#else
+#define	__unreachable()	((void)0)
+#endif
+
+/* XXX: should use `#if __STDC_VERSION__ < 199901'. */
+#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
+#define	__func__	NULL
+#endif
+
+/*
+ * GCC 2.95 provides `__restrict' as an extension to C90 to support the
+ * C99-specific `restrict' type qualifier.  We happen to use `__restrict' as
+ * a way to define the `restrict' type qualifier without disturbing older
+ * software that is unaware of C99 keywords.
+ */
+#if !(__GNUC__ == 2 && __GNUC_MINOR__ == 95)
+#if !defined(__STDC_VERSION__) || __STDC_VERSION__ < 199901
+#define	__restrict
+#else
+#define	__restrict	restrict
+#endif
+#endif
+
+/*
+ * GNU C version 2.96 adds explicit branch prediction so that
+ * the CPU back-end can hint the processor and also so that
+ * code blocks can be reordered such that the predicted path
+ * sees a more linear flow, thus improving cache behavior, etc.
+ *
+ * The following two macros provide us with a way to utilize this
+ * compiler feature.  Use __predict_true() if you expect the expression
+ * to evaluate to true, and __predict_false() if you expect the
+ * expression to evaluate to false.
+ *
+ * A few notes about usage:
+ *
+ *	* Generally, __predict_false() error condition checks (unless
+ *	  you have some _strong_ reason to do otherwise, in which case
+ *	  document it), and/or __predict_true() `no-error' condition
+ *	  checks, assuming you want to optimize for the no-error case.
+ *
+ *	* Other than that, if you don't know the likelihood of a test
+ *	  succeeding from empirical or other `hard' evidence, don't
+ *	  make predictions.
+ *
+ *	* These are meant to be used in places that are run `a lot'.
+ *	  It is wasteful to make predictions in code that is run
+ *	  seldomly (e.g. at subsystem initialization time) as the
+ *	  basic block reordering that this affects can often generate
+ *	  larger code.
+ */
+#if __GNUC_PREREQ__(2, 96)
+#define	__predict_true(exp)     __builtin_expect((exp), 1)
+#define	__predict_false(exp)    __builtin_expect((exp), 0)
+#else
+#define	__predict_true(exp)     (exp)
+#define	__predict_false(exp)    (exp)
+#endif
+
+#if __GNUC_PREREQ__(4, 0)
+#define	__null_sentinel	__attribute__((__sentinel__))
+#define	__exported	__attribute__((__visibility__("default")))
+/* Only default visibility is supported on PE/COFF targets. */
+#ifndef __CYGWIN__
+#define	__hidden	__attribute__((__visibility__("hidden")))
+#else
+#define	__hidden
+#endif
+#else
+#define	__null_sentinel
+#define	__exported
+#define	__hidden
+#endif
+
+#define __offsetof(type, field)	offsetof(type, field)
+#define	__rangeof(type, start, end) \
+	(__offsetof(type, end) - __offsetof(type, start))
+
+/*
+ * Given the pointer x to the member m of the struct s, return
+ * a pointer to the containing structure.  When using GCC, we first
+ * assign pointer x to a local variable, to check that its type is
+ * compatible with member m.
+ */
+#if __GNUC_PREREQ__(3, 1)
+#define	__containerof(x, s, m) ({					\
+	const volatile __typeof(((s *)0)->m) *__x = (x);		\
+	__DEQUALIFY(s *, (const volatile char *)__x - __offsetof(s, m));\
+})
+#else
+#define	__containerof(x, s, m)						\
+	__DEQUALIFY(s *, (const volatile char *)(x) - __offsetof(s, m))
+#endif
+
+/*
+ * Compiler-dependent macros to declare that functions take printf-like
+ * or scanf-like arguments.  They are null except for versions of gcc
+ * that are known to support the features properly (old versions of gcc-2
+ * didn't permit keeping the keywords out of the application namespace).
+ */
+#if !__GNUC_PREREQ__(2, 7) && !defined(__INTEL_COMPILER)
+#define	__printflike(fmtarg, firstvararg)
+#define	__scanflike(fmtarg, firstvararg)
+#define	__format_arg(fmtarg)
+#define	__strfmonlike(fmtarg, firstvararg)
+#define	__strftimelike(fmtarg, firstvararg)
+#else
+#define	__printflike(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__printf__, fmtarg, firstvararg)))
+#define	__scanflike(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))
+#define	__format_arg(fmtarg)	__attribute__((__format_arg__ (fmtarg)))
+#define	__strfmonlike(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))
+#define	__strftimelike(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__strftime__, fmtarg, firstvararg)))
+#endif
+
+/* Compiler-dependent macros that rely on FreeBSD-specific extensions. */
+#if defined(__FreeBSD_cc_version) && __FreeBSD_cc_version >= 300001 && \
+    defined(__GNUC__) && !defined(__INTEL_COMPILER)
+#define	__printf0like(fmtarg, firstvararg) \
+	    __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))
+#else
+#define	__printf0like(fmtarg, firstvararg)
+#endif
+
+#if defined(__GNUC__) || defined(__INTEL_COMPILER)
+#ifndef __INTEL_COMPILER
+#define	__strong_reference(sym,aliassym)	\
+	extern __typeof (sym) aliassym __attribute__ ((__alias__ (#sym)))
+#endif
+#ifdef __ELF__
+#ifdef __STDC__
+#define	__weak_reference(sym,alias)	\
+	__asm__(".weak " #alias);	\
+	__asm__(".equ "  #alias ", " #sym)
+#define	__warn_references(sym,msg)	\
+	__asm__(".section .gnu.warning." #sym);	\
+	__asm__(".asciz \"" msg "\"");	\
+	__asm__(".previous")
+#define	__sym_compat(sym,impl,verid)	\
+	__asm__(".symver " #impl ", " #sym "@" #verid)
+#define	__sym_default(sym,impl,verid)	\
+	__asm__(".symver " #impl ", " #sym "@@" #verid)
+#else
+#define	__weak_reference(sym,alias)	\
+	__asm__(".weak alias");		\
+	__asm__(".equ alias, sym")
+#define	__warn_references(sym,msg)	\
+	__asm__(".section .gnu.warning.sym"); \
+	__asm__(".asciz \"msg\"");	\
+	__asm__(".previous")
+#define	__sym_compat(sym,impl,verid)	\
+	__asm__(".symver impl, sym@verid")
+#define	__sym_default(impl,sym,verid)	\
+	__asm__(".symver impl, sym@@verid")
+#endif	/* __STDC__ */
+#else	/* !__ELF__ */
+#ifdef __STDC__
+#define	__weak_reference(sym,alias)	\
+	__asm__(".stabs \"_" #alias "\",11,0,0,0");	\
+	__asm__(".stabs \"_" #sym "\",1,0,0,0")
+#define	__warn_references(sym,msg)	\
+	__asm__(".stabs \"" msg "\",30,0,0,0");		\
+	__asm__(".stabs \"_" #sym "\",1,0,0,0")
+#else
+#define	__weak_reference(sym,alias)	\
+	__asm__(".stabs \"_/**/alias\",11,0,0,0");	\
+	__asm__(".stabs \"_/**/sym\",1,0,0,0")
+#define	__warn_references(sym,msg)	\
+	__asm__(".stabs msg,30,0,0,0");			\
+	__asm__(".stabs \"_/**/sym\",1,0,0,0")
+#endif	/* __STDC__ */
+#endif	/* __ELF__ */
+#endif	/* __GNUC__ || __INTEL_COMPILER */
+
+#ifndef	__FBSDID
+#define	__FBSDID(s)	struct __hack
+#endif
+
+#ifndef	__RCSID
+#define	__RCSID(s)	struct __hack
+#endif
+
+#ifndef	__RCSID_SOURCE
+#define	__RCSID_SOURCE(s)	struct __hack
+#endif
+
+#ifndef	__SCCSID
+#define	__SCCSID(s)	struct __hack
+#endif
+
+#ifndef	__COPYRIGHT
+#define	__COPYRIGHT(s)	struct __hack
+#endif
+
+#ifndef	__DECONST
+#define	__DECONST(type, var)	((type)(__uintptr_t)(const void *)(var))
+#endif
+
+#ifndef	__DEVOLATILE
+#define	__DEVOLATILE(type, var)	((type)(__uintptr_t)(volatile void *)(var))
+#endif
+
+#ifndef	__DEQUALIFY
+#define	__DEQUALIFY(type, var)	((type)(__uintptr_t)(const volatile void *)(var))
+#endif
+
+/*
+ * Nullability qualifiers: currently only supported by Clang.
+ */
+#if !(defined(__clang__) && __has_feature(nullability))
+#define	_Nonnull
+#define	_Nullable
+#define	_Null_unspecified
+#define	__NULLABILITY_PRAGMA_PUSH
+#define	__NULLABILITY_PRAGMA_POP
+#else
+#define	__NULLABILITY_PRAGMA_PUSH _Pragma("clang diagnostic push")	\
+	_Pragma("clang diagnostic ignored \"-Wnullability-completeness\"")
+#define	__NULLABILITY_PRAGMA_POP _Pragma("clang diagnostic pop")
+#endif
+
+/*
+ * Type Safety Checking
+ *
+ * Clang provides additional attributes to enable checking type safety
+ * properties that cannot be enforced by the C type system. 
+ */
+
+#if __has_attribute(__argument_with_type_tag__) && \
+    __has_attribute(__type_tag_for_datatype__)
+#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx) \
+	    __attribute__((__argument_with_type_tag__(arg_kind, arg_idx, type_tag_idx)))
+#define	__datatype_type_tag(kind, type) \
+	    __attribute__((__type_tag_for_datatype__(kind, type)))
+#else
+#define	__arg_type_tag(arg_kind, arg_idx, type_tag_idx)
+#define	__datatype_type_tag(kind, type)
+#endif
+
+/*
+ * Lock annotations.
+ *
+ * Clang provides support for doing basic thread-safety tests at
+ * compile-time, by marking which locks will/should be held when
+ * entering/leaving a functions.
+ *
+ * Furthermore, it is also possible to annotate variables and structure
+ * members to enforce that they are only accessed when certain locks are
+ * held.
+ */
+
+#if __has_extension(c_thread_safety_attributes)
+#define	__lock_annotate(x)	__attribute__((x))
+#else
+#define	__lock_annotate(x)
+#endif
+
+/* Structure implements a lock. */
+/* FIXME: Use __lockable__, etc. to avoid colliding with user namespace macros,
+ * once clang is fixed: https://bugs.llvm.org/show_bug.cgi?id=34319 */
+#define	__lockable		__lock_annotate(lockable)
+
+/* Function acquires an exclusive or shared lock. */
+#define	__locks_exclusive(...) \
+	__lock_annotate(exclusive_lock_function(__VA_ARGS__))
+#define	__locks_shared(...) \
+	__lock_annotate(shared_lock_function(__VA_ARGS__))
+
+/* Function attempts to acquire an exclusive or shared lock. */
+#define	__trylocks_exclusive(...) \
+	__lock_annotate(exclusive_trylock_function(__VA_ARGS__))
+#define	__trylocks_shared(...) \
+	__lock_annotate(shared_trylock_function(__VA_ARGS__))
+
+/* Function releases a lock. */
+#define	__unlocks(...)		__lock_annotate(unlock_function(__VA_ARGS__))
+
+/* Function asserts that an exclusive or shared lock is held. */
+#define	__asserts_exclusive(...) \
+	__lock_annotate(assert_exclusive_lock(__VA_ARGS__))
+#define	__asserts_shared(...) \
+	__lock_annotate(assert_shared_lock(__VA_ARGS__))
+
+/* Function requires that an exclusive or shared lock is or is not held. */
+#define	__requires_exclusive(...) \
+	__lock_annotate(exclusive_locks_required(__VA_ARGS__))
+#define	__requires_shared(...) \
+	__lock_annotate(shared_locks_required(__VA_ARGS__))
+#define	__requires_unlocked(...) \
+	__lock_annotate(locks_excluded(__VA_ARGS__))
+
+/* Function should not be analyzed. */
+#define	__no_lock_analysis	__lock_annotate(no_thread_safety_analysis)
+
+/*
+ * Function or variable should not be sanitized, i.e. by AddressSanitizer.
+ * GCC has the nosanitize attribute, but as a function attribute only, and
+ * warns on use as a variable attribute.
+ */
+#if __has_attribute(no_sanitize) && defined(__clang__)
+#define __nosanitizeaddress	__attribute__((no_sanitize("address")))
+#define __nosanitizethread	__attribute__((no_sanitize("thread")))
+#else
+#define __nosanitizeaddress
+#define __nosanitizethread
+#endif
+
+/* Guard variables and structure members by lock. */
+#define	__guarded_by(x)		__lock_annotate(guarded_by(x))
+#define	__pt_guarded_by(x)	__lock_annotate(pt_guarded_by(x))
+
+#endif /* !_SYS_CDEFS_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/debug.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/debug.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/debug.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,106 @@
+#ifndef _SYS_DEBUG_H
+#define _SYS_DEBUG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+#if !defined(NDEBUG)
+
+/* @brief   Debug level constants
+ *
+ * Define one of these log level constants at the top of a source file and include
+ * this sys/debug.h header file.  Ensure that NDEBUG is not defined.
+ *
+ * - LOG_LEVEL_ERROR
+ * - LOG_LEVEL_WARN
+ * - LOG_LEVEL_INFO
+ * - LOG_LEVEL_DEBUG
+ * - LOG_LEVEL_TRACE
+ */
+
+// Set a default log level if none are defined
+#if (!defined(LOG_LEVEL_ERROR) && !defined(LOG_LEVEL_WARN) \
+      && !defined(LOG_LEVEL_INFO) && !defined(LOG_LEVEL_DEBUG) \
+      && !defined(LOG_LEVEL_TRACE))
+#define LOG_LEVEL_INFO
+#endif
+
+#if defined(LOG_LEVEL_TRACE)
+#define LOG_LEVEL_DEBUG
+#endif
+
+#if defined(LOG_LEVEL_DEBUG)
+#define LOG_LEVEL_INFO
+#endif
+
+#if defined(LOG_LEVEL_INFO)
+#define LOG_LEVEL_WARN
+#endif
+
+#if defined(LOG_LEVEL_WARN)
+#define LOG_LEVEL_ERROR
+#endif
+
+
+/*
+ * Prototypes
+ */
+void debug_printf(const char *format, ...);
+
+
+/*
+ *
+ */
+#if defined(LOG_LEVEL_ERROR)
+#define log_error(fmt, args...)   debug_printf(fmt, ##args)
+#endif
+
+#if defined(LOG_LEVEL_WARN)
+#define log_warn(fmt, args...)    debug_printf(fmt, ##args)
+#else
+#define log_warn(fmt, args...)
+#endif
+
+#if defined(LOG_LEVEL_INFO)
+#define log_info(fmt, args...)    debug_printf(fmt, ##args)
+#else
+#define log_info(fmt, args...)
+#endif
+
+#if defined(LOG_LEVEL_DEBUG)
+#define log_debug(fmt, args...)   debug_printf(fmt, ##args)
+#else
+#define log_debug(fmt, args...)
+#endif
+
+#if defined(LOG_LEVEL_TRACE)
+#define log_trace(fmt, args...)   debug_printf(fmt, ##args)
+#else
+#define log_trace(fmt, args...)
+#endif
+
+#else
+
+#error "NDEBUG defined"
+
+#define log_error(fmt, args...)
+#define log_warn(fmt, args...)
+#define log_info(fmt, args...)
+#define log_debug(fmt, args...)
+#define log_trace(fmt, args...)
+
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/dirent.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/dirent.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/dirent.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/dirent.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,56 @@
+/*
+ *  $Id: utime.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef __DIRENT_h__
+#define __DIRENT_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *
+ */
+
+#include <sys/types.h>
+#include <limits.h>
+#include <stdbool.h>
+
+#define DIRENTS_BUF_SZ 4096
+
+typedef struct _dir
+{
+	int	fd;
+	void *buf;
+	int buf_sz;
+  int buf_offset;
+  bool eof;
+} DIR;
+
+
+# define __dirfd(dp)	((dp)->fd)
+
+int closedir(DIR *);
+DIR *opendir(const char *);
+struct dirent *readdir(DIR *);
+
+
+
+struct dirent
+{
+    int d_cookie;
+    int d_reclen;  			/* Length of this dirent */
+	long d_ino;
+	char d_name[0];
+};
+
+
+#define DIRENT_ALIGN		32
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/event.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/event.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/event.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/event.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,145 @@
+/*-
+ * Copyright (c) 1999,2000,2001 Jonathan Lemon <jlemon@FreeBSD.org>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	$FreeBSD: src/sys/sys/event.h,v 1.19 2002/03/23 08:46:51 bde Exp $
+ */
+
+#ifndef _SYS_EVENT_H_
+#define _SYS_EVENT_H_
+
+#include <stdint.h>
+
+#define EVFILT_READ		  0
+#define EVFILT_WRITE		1
+#define EVFILT_AIO		  2	/* attached to aio requests */
+#define EVFILT_VNODE		3	/* attached to vnodes */
+#define EVFILT_PROC		  4	/* attached to struct proc */
+#define EVFILT_SIGNAL		5	/* attached to struct proc */
+#define EVFILT_TIMER		6	/* timers */
+#define EVFILT_NETDEV		7	/* network devices */
+#define EVFILT_USER     8
+#define EVFILT_IRQ      9
+#define EVFILT_MSGPORT  10
+
+#define EVFILT_SYSCOUNT		11
+
+
+#define EV_SET(kevp, a, b, c, d, e, f) do {	\
+	(kevp)->ident = (a);			\
+	(kevp)->filter = (b);			\
+	(kevp)->flags = (c);			\
+	(kevp)->fflags = (d);			\
+	(kevp)->data = (e);			\
+	(kevp)->udata = (f);			\
+} while(0)
+
+struct kevent {
+	uintptr_t ident;		/* identifier for this event */
+	int16_t filter;		/* filter for event */
+	uint16_t flags;
+	uint32_t fflags;
+  void *data;
+	void *udata;		/* opaque user data identifier */
+};
+
+/* actions */
+#define EV_ADD		0x0001		/* add event to kq (implies enable) */
+#define EV_DELETE	0x0002		/* delete event from kq */
+#define EV_ENABLE	0x0004		/* enable event */
+#define EV_DISABLE	0x0008		/* disable event (not reported) */
+
+/* flags */
+#define EV_ONESHOT	0x0010		/* only report one occurrence */
+#define EV_CLEAR	0x0020		/* clear event state after reporting */
+
+#define EV_SYSFLAGS	0xF000		/* reserved by system */
+#define EV_FLAG1	0x2000		/* filter-specific flag */
+
+/* returned values */
+#define EV_EOF		0x8000		/* EOF detected */
+#define EV_ERROR	0x4000		/* error, data contains errno */
+
+
+/*
+ * data/hint flags for EVFILT_{READ|WRITE}, shared with userspace
+ */
+#define NOTE_LOWAT	0x0001			/* low water mark */
+
+/*
+ * data/hint flags for EVFILT_VNODE, shared with userspace
+ */
+#define	NOTE_DELETE	0x0001			/* vnode was removed */
+#define	NOTE_WRITE	0x0002			/* data contents changed */
+#define	NOTE_EXTEND	0x0004			/* size increased */
+#define	NOTE_ATTRIB	0x0008			/* attributes changed */
+#define	NOTE_LINK	0x0010			/* link count changed */
+#define	NOTE_RENAME	0x0020			/* vnode was renamed */
+#define	NOTE_REVOKE	0x0040			/* vnode access was revoked */
+
+/*
+ * data/hint flags for EVFILT_PROC, shared with userspace
+ */
+#define	NOTE_EXIT	0x80000000		/* process exited */
+#define	NOTE_FORK	0x40000000		/* process forked */
+#define	NOTE_EXEC	0x20000000		/* process exec'd */
+#define	NOTE_PCTRLMASK	0xf0000000		/* mask for hint bits */
+#define	NOTE_PDATAMASK	0x000fffff		/* mask for pid */
+
+/* additional flags for EVFILT_PROC */
+#define	NOTE_TRACK	0x00000001		/* follow across forks */
+#define	NOTE_TRACKERR	0x00000002		/* could not track child */
+#define	NOTE_CHILD	0x00000004		/* am a child process */
+
+/*
+ * data/hint flags for EVFILT_NETDEV, shared with userspace
+ */
+#define NOTE_LINKUP	0x0001			/* link is up */
+#define NOTE_LINKDOWN	0x0002			/* link is down */
+#define NOTE_LINKINV	0x0004			/* link state is invalid */
+
+/*
+ * data/hint flags for EVFILT_MSGPORT, message ports
+ */
+#define NOTE_MSG          0x10000000    /* Message has arrived on port */
+#define NOTE_PORTIDMASK   0x000000ff
+
+/*
+ * data/hint flags for EVFILT_IRQ, interrupts
+ */
+#define NOTE_INT          0x10000000    /* Interrupt arrival */
+#define NOTE_IRQMASK      0x0000ffff    /* IRQ number */
+
+
+#include <sys/cdefs.h>
+struct timespec;
+
+__BEGIN_DECLS
+int     kqueue(void);
+int     kevent(int kq, const struct kevent *changelist, int nchanges,
+	    struct kevent *eventlist, int nevents,
+	    const struct timespec *timeout);
+__END_DECLS
+
+#endif /* !_SYS_EVENT_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/execargs.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/execargs.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/execargs.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/execargs.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,29 @@
+#ifndef _SYS_EXECARGS_H
+#define _SYS_EXECARGS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+
+
+struct execargs
+{
+    char **argv;
+    int argc;
+    char **envv;
+    int envc;
+    size_t total_size;   
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/fcntl.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/fcntl.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/fcntl.h	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/fcntl.h	2024-03-17 17:47:03.407194450 +0000
@@ -3,10 +3,4 @@
 
 #include <sys/_default_fcntl.h>
 
-/* We want to support O_BINARY for the open syscall.
-   For example, the Demon debug monitor has a separate
-   flag value for "rb" vs "r". */
-#define _FBINARY        0x10000
-#define O_BINARY        _FBINARY
-
 #endif /* _SYS_FCNTL_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/features.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/features.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/features.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/features.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,557 @@
+/*
+ *  Written by Joel Sherrill <joel@OARcorp.com>.
+ *
+ *  COPYRIGHT (c) 1989-2014.
+ *
+ *  On-Line Applications Research Corporation (OAR).
+ *
+ *  Permission to use, copy, modify, and distribute this software for any
+ *  purpose without fee is hereby granted, provided that this entire notice
+ *  is included in all copies of any software which is or includes a copy
+ *  or modification of this software.
+ *
+ *  THIS SOFTWARE IS BEING PROVIDED "AS IS", WITHOUT ANY EXPRESS OR IMPLIED
+ *  WARRANTY.  IN PARTICULAR,  THE AUTHOR MAKES NO REPRESENTATION
+ *  OR WARRANTY OF ANY KIND CONCERNING THE MERCHANTABILITY OF THIS
+ *  SOFTWARE OR ITS FITNESS FOR ANY PARTICULAR PURPOSE.
+ *
+ *  $Id$
+ */
+
+#ifndef _SYS_FEATURES_H
+#define _SYS_FEATURES_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_newlib_version.h>
+
+/* Macro to test version of GCC.  Returns 0 for non-GCC or too old GCC. */
+#ifndef __GNUC_PREREQ
+# if defined __GNUC__ && defined __GNUC_MINOR__
+#  define __GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+# else
+#  define __GNUC_PREREQ(maj, min) 0
+# endif
+#endif /* __GNUC_PREREQ */
+/* Version with trailing underscores for BSD compatibility. */
+#define	__GNUC_PREREQ__(ma, mi)	__GNUC_PREREQ(ma, mi)
+
+
+/*
+ * Feature test macros control which symbols are exposed by the system
+ * headers.  Any of these must be defined before including any headers.
+ *
+ * __STRICT_ANSI__ (defined by gcc -ansi, -std=c90, -std=c99, or -std=c11)
+ *	ISO C
+ *
+ * _POSIX_SOURCE (deprecated by _POSIX_C_SOURCE=1)
+ * _POSIX_C_SOURCE >= 1
+ * 	POSIX.1-1990
+ *
+ * _POSIX_C_SOURCE >= 2
+ * 	POSIX.2-1992
+ *
+ * _POSIX_C_SOURCE >= 199309L
+ * 	POSIX.1b-1993 Real-time extensions
+ *
+ * _POSIX_C_SOURCE >= 199506L
+ * 	POSIX.1c-1995 Threads extensions
+ *
+ * _POSIX_C_SOURCE >= 200112L
+ * 	POSIX.1-2001 and C99
+ *
+ * _POSIX_C_SOURCE >= 200809L
+ * 	POSIX.1-2008
+ *
+ * _XOPEN_SOURCE
+ *	POSIX.1-1990 and XPG4
+ *
+ * _XOPEN_SOURCE_EXTENDED
+ *	SUSv1 (POSIX.2-1992 plus XPG4v2)
+ *
+ * _XOPEN_SOURCE >= 500
+ *	SUSv2 (POSIX.1c-1995 plus XSI)
+ *
+ * _XOPEN_SOURCE >= 600
+ *	SUSv3 (POSIX.1-2001 plus XSI) and C99
+ *
+ * _XOPEN_SOURCE >= 700
+ *	SUSv4 (POSIX.1-2008 plus XSI)
+ *
+ * _ISOC99_SOURCE or gcc -std=c99 or g++
+ * 	ISO C99
+ *
+ * _ISOC11_SOURCE or gcc -std=c11 or g++ -std=c++11
+ * 	ISO C11
+ *
+ * _ATFILE_SOURCE (implied by _POSIX_C_SOURCE >= 200809L)
+ *	"at" functions
+ *
+ * _LARGEFILE_SOURCE (deprecated by _XOPEN_SOURCE >= 500)
+ *	fseeko, ftello
+ *
+ * _GNU_SOURCE
+ * 	All of the above plus GNU extensions
+ *
+ * _BSD_SOURCE (deprecated by _DEFAULT_SOURCE)
+ * _SVID_SOURCE (deprecated by _DEFAULT_SOURCE)
+ * _DEFAULT_SOURCE (or none of the above)
+ * 	POSIX-1.2008 with BSD and SVr4 extensions
+ *
+ * _FORTIFY_SOURCE = 1 or 2
+ * 	Object Size Checking function wrappers
+ */
+
+#ifdef _GNU_SOURCE
+#undef _ATFILE_SOURCE
+#define	_ATFILE_SOURCE		1
+#undef	_DEFAULT_SOURCE
+#define	_DEFAULT_SOURCE		1
+#undef _ISOC99_SOURCE
+#define	_ISOC99_SOURCE		1
+#undef _ISOC11_SOURCE
+#define	_ISOC11_SOURCE		1
+#undef _POSIX_SOURCE
+#define	_POSIX_SOURCE		1
+#undef _POSIX_C_SOURCE
+#define	_POSIX_C_SOURCE		200809L
+#undef _XOPEN_SOURCE
+#define	_XOPEN_SOURCE		700
+#undef _XOPEN_SOURCE_EXTENDED
+#define	_XOPEN_SOURCE_EXTENDED	1
+
+#else // For Cheviot
+
+#undef _ATFILE_SOURCE
+#define	_ATFILE_SOURCE		1
+#undef	_DEFAULT_SOURCE
+#define	_DEFAULT_SOURCE		1
+#undef _ISOC99_SOURCE
+#define	_ISOC99_SOURCE		1
+#undef _ISOC11_SOURCE
+#define	_ISOC11_SOURCE		1
+#undef _POSIX_SOURCE
+#define	_POSIX_SOURCE		1
+#undef _POSIX_C_SOURCE
+#define	_POSIX_C_SOURCE		200809L
+#undef _XOPEN_SOURCE
+#define	_XOPEN_SOURCE		700
+#undef _XOPEN_SOURCE_EXTENDED
+#define	_XOPEN_SOURCE_EXTENDED	1
+
+#endif /* _GNU_SOURCE */
+
+#if defined(_BSD_SOURCE) || defined(_SVID_SOURCE) || \
+   (!defined(__STRICT_ANSI__) && !defined(_ANSI_SOURCE) && \
+   !defined(_ISOC99_SOURCE) && !defined(_POSIX_SOURCE) && \
+   !defined(_POSIX_C_SOURCE) && !defined(_XOPEN_SOURCE))
+#undef _DEFAULT_SOURCE
+#define	_DEFAULT_SOURCE		1
+#endif
+
+#if defined(_DEFAULT_SOURCE)
+#undef _POSIX_SOURCE
+#define	_POSIX_SOURCE		1
+#undef _POSIX_C_SOURCE
+#define	_POSIX_C_SOURCE		200809L
+#endif
+
+#if !defined(_POSIX_SOURCE) && !defined(_POSIX_C_SOURCE) && \
+  ((!defined(__STRICT_ANSI__) && !defined(_ANSI_SOURCE)) || \
+   (_XOPEN_SOURCE - 0) >= 500)
+#define	_POSIX_SOURCE		1
+#if !defined(_XOPEN_SOURCE) || (_XOPEN_SOURCE - 0) >= 700
+#define	_POSIX_C_SOURCE		200809L
+#elif (_XOPEN_SOURCE - 0) >= 600
+#define	_POSIX_C_SOURCE		200112L
+#elif (_XOPEN_SOURCE - 0) >= 500
+#define	_POSIX_C_SOURCE		199506L
+#elif (_XOPEN_SOURCE - 0) < 500
+#define	_POSIX_C_SOURCE		2
+#endif
+#endif
+
+#if defined(_POSIX_C_SOURCE) && _POSIX_C_SOURCE >= 200809
+#undef _ATFILE_SOURCE
+#define	_ATFILE_SOURCE		1
+#endif
+
+/*
+ * The following private macros are used throughout the headers to control
+ * which symbols should be exposed.  They are for internal use only, as
+ * indicated by the leading double underscore, and must never be used outside
+ * of these headers.
+ *
+ * __POSIX_VISIBLE
+ * 	any version of POSIX.1; enabled by default, or with _POSIX_SOURCE,
+ * 	any value of _POSIX_C_SOURCE, or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 2
+ * 	POSIX.2-1992; enabled by default, with _POSIX_C_SOURCE >= 2,
+ * 	or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 199309
+ * 	POSIX.1b-1993; enabled by default, with _POSIX_C_SOURCE >= 199309L,
+ * 	or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 199506
+ * 	POSIX.1c-1995; enabled by default, with _POSIX_C_SOURCE >= 199506L,
+ * 	or _XOPEN_SOURCE >= 500.
+ *
+ * __POSIX_VISIBLE >= 200112
+ * 	POSIX.1-2001; enabled by default, with _POSIX_C_SOURCE >= 200112L,
+ * 	or _XOPEN_SOURCE >= 600.
+ *
+ * __POSIX_VISIBLE >= 200809
+ * 	POSIX.1-2008; enabled by default, with _POSIX_C_SOURCE >= 200809L,
+ * 	or _XOPEN_SOURCE >= 700.
+ *
+ * __XSI_VISIBLE
+ *	XPG4 XSI extensions; enabled with any version of _XOPEN_SOURCE.
+ *
+ * __XSI_VISIBLE >= 4
+ *	SUSv1 XSI extensions; enabled with both _XOPEN_SOURCE and
+ * 	_XOPEN_SOURCE_EXTENDED together.
+ *
+ * __XSI_VISIBLE >= 500
+ *	SUSv2 XSI extensions; enabled with _XOPEN_SOURCE >= 500.
+ *
+ * __XSI_VISIBLE >= 600
+ *	SUSv3 XSI extensions; enabled with _XOPEN_SOURCE >= 600.
+ *
+ * __XSI_VISIBLE >= 700
+ *	SUSv4 XSI extensions; enabled with _XOPEN_SOURCE >= 700.
+ *
+ * __ISO_C_VISIBLE >= 1999
+ * 	ISO C99; enabled with gcc -std=c99 or newer (on by default since GCC 5),
+ * 	any version of C++, or with _ISOC99_SOURCE, _POSIX_C_SOURCE >= 200112L,
+ * 	or _XOPEN_SOURCE >= 600.
+ *
+ * __ISO_C_VISIBLE >= 2011
+ * 	ISO C11; enabled with gcc -std=c11 or newer (on by default since GCC 5),
+ * 	g++ -std=c++11 or newer (on by default since GCC 6), or with
+ * 	_ISOC11_SOURCE.
+ *
+ * __ATFILE_VISIBLE
+ *	"at" functions; enabled by default, with _ATFILE_SOURCE,
+ * 	_POSIX_C_SOURCE >= 200809L, or _XOPEN_SOURCE >= 700.
+ *
+ * __LARGEFILE_VISIBLE
+ *	fseeko, ftello; enabled with _LARGEFILE_SOURCE or _XOPEN_SOURCE >= 500.
+ *
+ * __BSD_VISIBLE
+ * 	BSD extensions; enabled by default, or with _BSD_SOURCE.
+ *
+ * __SVID_VISIBLE
+ * 	SVr4 extensions; enabled by default, or with _SVID_SOURCE.
+ *
+ * __MISC_VISIBLE
+ * 	Extensions found in both BSD and SVr4 (shorthand for
+ * 	(__BSD_VISIBLE || __SVID_VISIBLE)), or newlib-specific
+ * 	extensions; enabled by default.
+ *
+ * __GNU_VISIBLE
+ * 	GNU extensions; enabled with _GNU_SOURCE.
+ *
+ * __SSP_FORTIFY_LEVEL
+ * 	Object Size Checking; defined to 0 (off), 1, or 2.
+ *
+ * In all cases above, "enabled by default" means either by defining
+ * _DEFAULT_SOURCE, or by not defining any of the public feature test macros.
+ */
+
+#ifdef _ATFILE_SOURCE
+#define	__ATFILE_VISIBLE	1
+#else
+#define	__ATFILE_VISIBLE	0
+#endif
+
+#ifdef _DEFAULT_SOURCE
+#define	__BSD_VISIBLE		1
+#else
+#define	__BSD_VISIBLE		0
+#endif
+
+#ifdef _GNU_SOURCE
+#define	__GNU_VISIBLE		1
+#else
+#define	__GNU_VISIBLE		0
+#endif
+
+#if defined(_ISOC11_SOURCE) || \
+  (__STDC_VERSION__ - 0) >= 201112L || (__cplusplus - 0) >= 201103L
+#define	__ISO_C_VISIBLE		2011
+#elif defined(_ISOC99_SOURCE) || (_POSIX_C_SOURCE - 0) >= 200112L || \
+  (__STDC_VERSION__ - 0) >= 199901L || defined(__cplusplus)
+#define	__ISO_C_VISIBLE		1999
+#else
+#define	__ISO_C_VISIBLE		1990
+#endif
+
+#if defined(_LARGEFILE_SOURCE) || (_XOPEN_SOURCE - 0) >= 500
+#define	__LARGEFILE_VISIBLE	1
+#else
+#define	__LARGEFILE_VISIBLE	0
+#endif
+
+#ifdef _DEFAULT_SOURCE
+#define	__MISC_VISIBLE		1
+#else
+#define	__MISC_VISIBLE		0
+#endif
+
+#if (_POSIX_C_SOURCE - 0) >= 200809L
+#define	__POSIX_VISIBLE		200809
+#elif (_POSIX_C_SOURCE - 0) >= 200112L
+#define	__POSIX_VISIBLE		200112
+#elif (_POSIX_C_SOURCE - 0) >= 199506L
+#define	__POSIX_VISIBLE		199506
+#elif (_POSIX_C_SOURCE - 0) >= 199309L
+#define	__POSIX_VISIBLE		199309
+#elif (_POSIX_C_SOURCE - 0) >= 2 || defined(_XOPEN_SOURCE)
+#define	__POSIX_VISIBLE		199209
+#elif defined(_POSIX_SOURCE) || defined(_POSIX_C_SOURCE)
+#define	__POSIX_VISIBLE		199009
+#else
+#define	__POSIX_VISIBLE		0
+#endif
+
+#ifdef _DEFAULT_SOURCE
+#define	__SVID_VISIBLE		1
+#else
+#define	__SVID_VISIBLE		0
+#endif
+
+#if (_XOPEN_SOURCE - 0) >= 700
+#define	__XSI_VISIBLE		700
+#elif (_XOPEN_SOURCE - 0) >= 600
+#define	__XSI_VISIBLE		600
+#elif (_XOPEN_SOURCE - 0) >= 500
+#define	__XSI_VISIBLE		500
+#elif defined(_XOPEN_SOURCE) && defined(_XOPEN_SOURCE_EXTENDED)
+#define	__XSI_VISIBLE		4
+#elif defined(_XOPEN_SOURCE)
+#define	__XSI_VISIBLE		1
+#else
+#define	__XSI_VISIBLE		0
+#endif
+
+#if _FORTIFY_SOURCE > 0 && !defined(__cplusplus) && !defined(__lint__) && \
+   (__OPTIMIZE__ > 0 || defined(__clang__)) && __GNUC_PREREQ__(4, 1)
+#  if _FORTIFY_SOURCE > 1
+#    define __SSP_FORTIFY_LEVEL 2
+#  else
+#    define __SSP_FORTIFY_LEVEL 1
+#  endif
+#else
+#  define __SSP_FORTIFY_LEVEL 0
+#endif
+
+/* RTEMS adheres to POSIX -- 1003.1b with some features from annexes.  */
+
+#ifdef __rtems__
+#define _POSIX_JOB_CONTROL     		1
+#define _POSIX_SAVED_IDS       		1
+#define _POSIX_VERSION			199309L
+#define _POSIX_ASYNCHRONOUS_IO		1
+#define _POSIX_FSYNC			1
+#define _POSIX_MAPPED_FILES		1
+#define _POSIX_MEMLOCK			1
+#define _POSIX_MEMLOCK_RANGE		1
+#define _POSIX_MEMORY_PROTECTION	1
+#define _POSIX_MESSAGE_PASSING		1
+#define _POSIX_MONOTONIC_CLOCK		200112L
+#define _POSIX_CLOCK_SELECTION		200112L
+#define _POSIX_PRIORITIZED_IO		1
+#define _POSIX_PRIORITY_SCHEDULING	1
+#define _POSIX_REALTIME_SIGNALS		1
+#define _POSIX_SEMAPHORES		1
+#define _POSIX_SHARED_MEMORY_OBJECTS	1
+#define _POSIX_SYNCHRONIZED_IO		1
+#define _POSIX_TIMERS			1
+#define _POSIX_BARRIERS                 200112L
+#define _POSIX_READER_WRITER_LOCKS      200112L
+#define _POSIX_SPIN_LOCKS               200112L
+
+
+/* In P1003.1b but defined by drafts at least as early as P1003.1c/D10  */
+#define _POSIX_THREADS				1
+#define _POSIX_THREAD_ATTR_STACKADDR		1
+#define _POSIX_THREAD_ATTR_STACKSIZE		1
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
+#define _POSIX_THREAD_PRIO_INHERIT		1
+#define _POSIX_THREAD_PRIO_PROTECT		1
+#define _POSIX_THREAD_PROCESS_SHARED		1
+#define _POSIX_THREAD_SAFE_FUNCTIONS		1
+
+/* P1003.4b/D8 defines the constants below this comment. */
+#define _POSIX_SPAWN				1
+#define _POSIX_TIMEOUTS				1
+#define _POSIX_CPUTIME				1
+#define _POSIX_THREAD_CPUTIME			1
+#define _POSIX_SPORADIC_SERVER			1
+#define _POSIX_THREAD_SPORADIC_SERVER		1
+#define _POSIX_DEVICE_CONTROL			1
+#define _POSIX_DEVCTL_DIRECTION			1
+#define _POSIX_INTERRUPT_CONTROL		1
+#define _POSIX_ADVISORY_INFO			1
+
+/* UNIX98 added some new pthread mutex attributes */
+#define _UNIX98_THREAD_MUTEX_ATTRIBUTES         1
+
+/* POSIX 1003.26-2003 defined device control method */
+#define _POSIX_26_VERSION			200312L
+
+#endif
+
+/* XMK loosely adheres to POSIX -- 1003.1 */
+#ifdef __XMK__
+#define _POSIX_THREADS				1
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	1
+#endif
+
+
+#ifdef __svr4__
+# define _POSIX_JOB_CONTROL     1
+# define _POSIX_SAVED_IDS       1
+# define _POSIX_VERSION 199009L
+#endif
+
+#ifdef __CYGWIN__
+
+#if __POSIX_VISIBLE >= 200809
+#define _POSIX_VERSION				200809L
+#define _POSIX2_VERSION				200809L
+#elif __POSIX_VISIBLE >= 200112
+#define _POSIX_VERSION				200112L
+#define _POSIX2_VERSION				200112L
+#elif __POSIX_VISIBLE >= 199506
+#define _POSIX_VERSION				199506L
+#define _POSIX2_VERSION				199506L
+#elif __POSIX_VISIBLE >= 199309
+#define _POSIX_VERSION				199309L
+#define _POSIX2_VERSION				199209L
+#elif __POSIX_VISIBLE >= 199209
+#define _POSIX_VERSION				199009L
+#define _POSIX2_VERSION				199209L
+#elif __POSIX_VISIBLE
+#define _POSIX_VERSION				199009L
+#endif
+#if __XSI_VISIBLE >= 4
+#define _XOPEN_VERSION				__XSI_VISIBLE
+#endif
+
+#define _POSIX_ADVISORY_INFO			200809L
+#define _POSIX_ASYNCHRONOUS_IO			200809L
+#define _POSIX_BARRIERS				200809L
+#define _POSIX_CHOWN_RESTRICTED			     1
+#define _POSIX_CLOCK_SELECTION			200809L
+#define _POSIX_CPUTIME				200809L
+#define _POSIX_FSYNC				200809L
+#define _POSIX_IPV6				200809L
+#define _POSIX_JOB_CONTROL			     1
+#define _POSIX_MAPPED_FILES			200809L
+/* #define _POSIX_MEMLOCK			    -1 */
+#define _POSIX_MEMLOCK_RANGE			200809L
+#define _POSIX_MEMORY_PROTECTION		200809L
+#define _POSIX_MESSAGE_PASSING			200809L
+#define _POSIX_MONOTONIC_CLOCK			200809L
+#define _POSIX_NO_TRUNC				     1
+/* #define _POSIX_PRIORITIZED_IO		    -1 */
+#define _POSIX_PRIORITY_SCHEDULING		200809L
+#define _POSIX_RAW_SOCKETS			200809L
+#define _POSIX_READER_WRITER_LOCKS		200809L
+#define _POSIX_REALTIME_SIGNALS			200809L
+#define _POSIX_REGEXP				     1
+#define _POSIX_SAVED_IDS			     1
+#define _POSIX_SEMAPHORES			200809L
+#define _POSIX_SHARED_MEMORY_OBJECTS		200809L
+#define _POSIX_SHELL				     1
+#define _POSIX_SPAWN				200809L
+#define _POSIX_SPIN_LOCKS			200809L
+/* #define _POSIX_SPORADIC_SERVER		    -1 */
+#define _POSIX_SYNCHRONIZED_IO			200809L
+#define _POSIX_THREAD_ATTR_STACKADDR		200809L
+#define _POSIX_THREAD_ATTR_STACKSIZE		200809L
+#define _POSIX_THREAD_CPUTIME			200809L
+/* #define _POSIX_THREAD_PRIO_INHERIT		    -1 */
+/* #define _POSIX_THREAD_PRIO_PROTECT		    -1 */
+#define _POSIX_THREAD_PRIORITY_SCHEDULING	200809L
+#define _POSIX_THREAD_PROCESS_SHARED		200809L
+#define _POSIX_THREAD_SAFE_FUNCTIONS		200809L
+/* #define _POSIX_THREAD_SPORADIC_SERVER	    -1 */
+#define _POSIX_THREADS				200809L
+#define _POSIX_TIMEOUTS				200809L
+#define _POSIX_TIMERS				200809L
+/* #define _POSIX_TRACE				    -1 */
+/* #define _POSIX_TRACE_EVENT_FILTER		    -1 */
+/* #define _POSIX_TRACE_INHERIT			    -1 */
+/* #define _POSIX_TRACE_LOG			    -1 */
+/* #define _POSIX_TYPED_MEMORY_OBJECTS		    -1 */
+#define _POSIX_VDISABLE				   '\0'
+
+#if __POSIX_VISIBLE >= 2
+#define _POSIX2_C_VERSION			_POSIX2_VERSION
+#define _POSIX2_C_BIND				_POSIX2_VERSION
+#define _POSIX2_C_DEV				_POSIX2_VERSION
+#define _POSIX2_CHAR_TERM			_POSIX2_VERSION
+/* #define _POSIX2_FORT_DEV			    -1 */
+/* #define _POSIX2_FORT_RUN			    -1 */
+/* #define _POSIX2_LOCALEDEF			    -1 */
+/* #define _POSIX2_PBS				    -1 */
+/* #define _POSIX2_PBS_ACCOUNTING		    -1 */
+/* #define _POSIX2_PBS_CHECKPOINT		    -1 */
+/* #define _POSIX2_PBS_LOCATE			    -1 */
+/* #define _POSIX2_PBS_MESSAGE			    -1 */
+/* #define _POSIX2_PBS_TRACK			    -1 */
+#define _POSIX2_SW_DEV				_POSIX2_VERSION
+#define _POSIX2_UPE				_POSIX2_VERSION
+#endif /* __POSIX_VISIBLE >= 2 */
+
+#define _POSIX_V6_ILP32_OFF32			    -1
+#ifdef __LP64__
+#define _POSIX_V6_ILP32_OFFBIG			    -1
+#define _POSIX_V6_LP64_OFF64			     1
+#define _POSIX_V6_LPBIG_OFFBIG			     1
+#else
+#define _POSIX_V6_ILP32_OFFBIG			     1
+#define _POSIX_V6_LP64_OFF64			    -1
+#define _POSIX_V6_LPBIG_OFFBIG			    -1
+#endif
+#define _POSIX_V7_ILP32_OFF32			_POSIX_V6_ILP32_OFF32
+#define _POSIX_V7_ILP32_OFFBIG			_POSIX_V6_ILP32_OFFBIG
+#define _POSIX_V7_LP64_OFF64			_POSIX_V6_LP64_OFF64
+#define _POSIX_V7_LPBIG_OFFBIG			_POSIX_V6_LPBIG_OFFBIG
+#define _XBS5_ILP32_OFF32			_POSIX_V6_ILP32_OFF32
+#define _XBS5_ILP32_OFFBIG			_POSIX_V6_ILP32_OFFBIG
+#define _XBS5_LP64_OFF64			_POSIX_V6_LP64_OFF64
+#define _XBS5_LPBIG_OFFBIG			_POSIX_V6_LPBIG_OFFBIG
+
+#if __XSI_VISIBLE
+#define _XOPEN_CRYPT				     1
+#define _XOPEN_ENH_I18N				     1
+/* #define _XOPEN_LEGACY			    -1 */
+/* #define _XOPEN_REALTIME			    -1 */
+/* #define _XOPEN_REALTIME_THREADS		    -1 */
+#define _XOPEN_SHM				     1
+/* #define _XOPEN_STREAMS			    -1 */
+/* #define _XOPEN_UNIX				    -1 */
+#endif /* __XSI_VISIBLE */
+
+/*
+ * newlib's wide char conversion functions were updated on
+ *	2019-01-12
+ * to UNICODE version:
+ *	11.0.0 released 2018-06-05
+ */
+#define __STDC_ISO_10646__ 201806L
+
+#endif /* __CYGWIN__ */
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_FEATURES_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/fsreq.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/fsreq.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/fsreq.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/fsreq.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,256 @@
+#ifndef SYS_FSREQ_H
+#define SYS_FSREQ_H
+
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/dirent.h>
+#include <sys/stat.h>
+
+
+// TODO Move into newlib
+#define WSTAT_MODE  (1<<0)
+#define WSTAT_UID   (1<<1)
+#define WSTAT_GID   (1<<2)
+#define WSTAT_SIZE  (1<<3)
+#define WSTAT_ATIME (1<<4)
+#define WSTAT_MTIME (1<<5)
+#define WSTAT_CTIME (1<<6)
+
+
+/* @brief   VFS commands
+ */
+#define CMD_LOOKUP          0
+#define CMD_CLOSE           1
+#define CMD_READ            2
+#define CMD_WRITE           3
+#define CMD_READDIR         4
+#define CMD_UNLINK          5
+#define CMD_RMDIR           6
+#define CMD_MKDIR           7
+#define CMD_MKNOD           8
+#define CMD_RENAME          9
+#define CMD_STAT            10
+#define CMD_MKLINK          11
+#define CMD_CREATE          12
+#define CMD_TRUNCATE        13
+#define CMD_CHOWN           14
+#define CMD_CHMOD           15
+#define CMD_ISATTY          16
+#define CMD_TCGETATTR       17
+#define CMD_TCSETATTR       18
+#define CMD_SENDREC         19
+
+
+/* @brief   Common command header of VFS messages
+ */
+struct fsreq
+{
+    int cmd;    
+
+    union
+    {
+        struct {
+            uint32_t dir_inode_nr;
+            int name_sz;
+        } lookup;
+
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            uint32_t oflags;
+            mode_t mode;
+            int uid;
+            int gid;
+        } create;
+        
+        struct {
+            uint32_t inode_nr;
+        } close;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;
+        } read;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;            
+        } write;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;
+        } readdir;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            mode_t mode;
+            int uid;
+            int gid;
+        } mkdir;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } unlink;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } rmdir;
+        
+        struct {
+            uint32_t inode_nr;
+            int uid;
+            int gid;
+        } chown;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+        } chmod;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t size;
+        } truncate;
+
+        struct {
+            uint32_t inode_nr;
+        } stat;
+        
+        struct {
+           uint32_t src_dir_inode_nr;
+           uint32_t src_name_sz;
+           uint32_t dst_dir_inode_nr;
+           uint32_t dst_name_sz;
+        } rename;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            mode_t mode;
+            int uid;
+            int gid;
+        } mknod;
+
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            uint32_t link_sz;
+        } mklink;
+
+        struct {
+            uint32_t inode_nr;
+        } rdlink;
+        
+        struct {
+            uint32_t inode_nr;
+        } isatty;
+
+        struct
+        {
+          uint32_t inode_nr;
+        } tcgetattr;
+
+        struct
+        {
+          uint32_t inode_nr;
+        } tcsetattr;
+    } args;
+};
+
+
+/* @brief   Common reply header to VFS messages
+ */
+struct fsreply
+{
+    union
+    {
+        // The comments for each command indicate what the status value in
+        // replymsg indicates.
+        
+        // In most cases this is 0 for success, or negative errno value on failure.
+        // For transfers such as read, write and readdir the status indicates
+        // the number of bytes transferred or negative errno on failure.
+        
+        // lookup - int status
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+        } lookup;
+        
+        // create - int status
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+        } create;
+
+        // readdir - ssize_t nbytes_read        
+        struct {
+            off64_t offset;
+        } readdir;
+
+        // stat - int status
+        struct {
+            struct stat stat;
+        } stat;
+
+        // mknod - int status           
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+        } mknod;
+        
+        // mklink - int status
+        struct {
+            uint32_t inode_nr;
+        } mklink;   
+        
+        // rdlink - int status
+        struct {
+            uint32_t inode_nr;
+        } rdlink;
+                
+        // close - int status
+        // read - ssize_t nbytes_read (data follows fsreply)
+        // write - ssize_t nbytes_written
+        // unlink - int status
+        // mkdir - int status
+        // rmdir - int status
+        // chown - int status
+        // chmod - int status
+        // truncate - int status
+        // rename - int status
+        // isatty - int status, 0 if tty, -ENOTTY if not tty
+        // tcgetattr - int status (returns tcattr separately)        
+        // tcsetattr - int status        
+    } args;
+};
+
+
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/interrupts.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/interrupts.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/interrupts.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/interrupts.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,24 @@
+#ifndef _SYS_INTERRUPTS_H
+#define _SYS_INTERRUPTS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+struct InterruptAPI
+{
+  int (*MaskInterrupt)(int irq);
+  int (*UnmaskInterrupt)(int irq);
+  int (*EventNotifyFromISR)(struct InterruptAPI *api, int hint);
+
+  void *context;
+};
+
+
+#ifdef __cplusplus
+}
+#endif 
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/ioctl.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/ioctl.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/ioctl.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,21 @@
+#ifndef _SYS_IOCTL_H
+#define _SYS_IOCTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+#define  IOCTL_CON_SETMAP	0
+
+
+
+int ioctl (int fd, int request, ...);
+
+
+#ifdef __cplusplus
+}
+#endif 
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/lists.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/lists.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/lists.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/lists.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,503 @@
+#ifndef SYS_LISTS_H
+#define SYS_LISTS_H
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Double linked list with head and tail pointers in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define LIST_INITIALIZER                                                       \
+  { NULL, NULL }
+
+#define LIST_TYPE(type, headertype, entrytype)                                 \
+  typedef struct {                                                             \
+    struct type *head;                                                         \
+    struct type *tail;                                                         \
+  } headertype;                                                                \
+                                                                               \
+  typedef struct {                                                             \
+    struct type *next;                                                         \
+    struct type *prev;                                                         \
+  } entrytype
+
+#define LIST(type, header)                                                     \
+  struct {                                                                     \
+    struct type *head;                                                         \
+    struct type *tail;                                                         \
+  } header
+
+#define LIST_DECLARE(name, type)                                               \
+  struct name {                                                                \
+    struct type *head;                                                         \
+    struct type *tail;                                                         \
+  }
+
+#define LIST_DEFINE(name) struct name
+
+#define LIST_ENTRY(type, entry)                                                \
+  struct {                                                                     \
+    struct type *next;                                                         \
+    struct type *prev;                                                         \
+  } entry
+
+#define LIST_INIT(header)                                                      \
+  {                                                                            \
+    (header)->head = NULL;                                                     \
+    (header)->tail = NULL;                                                     \
+  }
+
+#define LIST_CONCAT(dest, src, field)                                          \
+  {                                                                            \
+    if ((src)->head != NULL) {                                                 \
+      if ((dest)->head != NULL) {                                              \
+        ((dest)->tail)->field.next = (src)->head;                              \
+        ((src)->head)->field.prev = (dest)->tail;                              \
+        (dest)->tail = (src)->tail;                                            \
+      } else {                                                                 \
+        ((src)->head)->field.prev = NULL;                                      \
+        (dest)->head = (src)->head;                                            \
+        (dest)->tail = (src)->tail;                                            \
+      }                                                                        \
+    }                                                                          \
+  }
+
+#define LIST_EMPTY(header) (((header)->head == NULL) ? 1 : 0)
+
+#define LIST_HEAD(header) ((header)->head)
+
+#define LIST_TAIL(header) ((header)->tail)
+
+#define LIST_NEXT(entry, field) ((entry)->field.next)
+
+#define LIST_PREV(entry, field) ((entry)->field.prev)
+
+#define LIST_ADD_HEAD(header, new_head, field)                                 \
+  {                                                                            \
+    (new_head)->field.next = (header)->head;                                   \
+    (new_head)->field.prev = NULL;                                             \
+                                                                               \
+    if ((header)->head != NULL)                                                \
+      (header)->head->field.prev = new_head;                                   \
+    else                                                                       \
+      (header)->tail = new_head;                                               \
+                                                                               \
+    (header)->head = new_head;                                                 \
+  }
+
+#define LIST_ADD_TAIL(header, new_tail, field)                                 \
+  {                                                                            \
+    (new_tail)->field.next = NULL;                                             \
+    (new_tail)->field.prev = (header)->tail;                                   \
+    if ((header)->tail != NULL)                                                \
+      (header)->tail->field.next = new_tail;                                   \
+    else                                                                       \
+      (header)->head = new_tail;                                               \
+    (header)->tail = new_tail;                                                 \
+  }
+
+#define LIST_REM_HEAD(header, field)                                           \
+  {                                                                            \
+    (header)->head = (header)->head->field.next;                               \
+    if ((header)->head != NULL)                                                \
+      (header)->head->field.prev = NULL;                                       \
+    else                                                                       \
+      (header)->tail = NULL;                                                   \
+  }
+
+#define LIST_REM_TAIL(header, field)                                           \
+  {                                                                            \
+    (header)->tail = (header)->tail->field.prev;                               \
+    if ((header)->tail != NULL)                                                \
+      (header)->tail->field.next = NULL;                                       \
+    else                                                                       \
+      (header)->head = NULL;                                                   \
+  }
+
+#define LIST_INSERT_AFTER(header, prev_entry, new_entry, field)                \
+  {                                                                            \
+    (new_entry)->field.next = (prev_entry)->field.next;                        \
+    (new_entry)->field.prev = prev_entry;                                      \
+    (prev_entry)->field.next = new_entry;                                      \
+    if ((new_entry)->field.next != NULL)                                       \
+      (new_entry)->field.next->field.prev = new_entry;                         \
+    else                                                                       \
+      (header)->tail = new_entry;                                              \
+  }
+
+#define LIST_INSERT_BEFORE(header, next_entry, new_entry, field)               \
+  {                                                                            \
+    (new_entry)->field.prev = (next_entry)->field.prev;                        \
+    (new_entry)->field.next = next_entry;                                      \
+    (next_entry)->field.prev = new_entry;                                      \
+    if (((new_entry)->field.prev) != NULL) {                                   \
+      (new_entry)->field.prev->field.next = new_entry;                         \
+    } else {                                                                   \
+      (header)->head = new_entry;                                              \
+    }                                                                          \
+  }
+
+#define LIST_REM_ENTRY(header, entry, field)                                   \
+  {                                                                            \
+    if ((entry)->field.prev != NULL)                                           \
+      (entry)->field.prev->field.next = (entry)->field.next;                   \
+    else                                                                       \
+      (header)->head = (entry)->field.next;                                    \
+    if ((entry)->field.next != NULL)                                           \
+      (entry)->field.next->field.prev = (entry)->field.prev;                   \
+    else                                                                       \
+      (header)->tail = (entry)->field.prev;                                    \
+  };
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Single linked queue with head and tail pointers in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define QUEUE_INITIALIZER                                                      \
+  { NULL, NULL }
+
+#define QUEUE_TYPE(type, headertype)                                           \
+  typedef struct {                                                             \
+    struct type *head;                                                         \
+    struct type *tail;                                                         \
+  } headertype
+
+#define QUEUE(type, header)                                                    \
+  struct {                                                                     \
+    struct type *head;                                                         \
+    struct type *tail;                                                         \
+  } header
+
+#define QUEUE_DECLARE(name, type)                                              \
+  struct name {                                                                \
+    struct type *head;                                                         \
+    struct type *tail;                                                         \
+  }
+
+#define QUEUE_DEFINE(name) struct name
+
+#define QUEUE_ENTRY(type, entry)                                               \
+  struct {                                                                     \
+    struct type *next;                                                         \
+  } entry
+
+#define QUEUE_INIT(header)                                                     \
+  {                                                                            \
+    (header)->head = NULL;                                                     \
+    (header)->tail = NULL;                                                     \
+  }
+
+#define QUEUE_EMPTY(header) (((header)->head == NULL) ? 1 : 0)
+
+#define QUEUE_HEAD(header) ((header)->head)
+
+#define QUEUE_TAIL(header) ((header)->tail)
+
+#define QUEUE_NEXT(entry, field) ((entry)->field.next)
+
+#define QUEUE_ADD_TAIL(header, new_tail, field)                                \
+  {                                                                            \
+    (new_tail)->field.next = NULL;                                             \
+    if ((header)->tail != NULL)                                                \
+      (header)->tail->field.next = new_tail;                                   \
+    else                                                                       \
+      (header)->head = new_tail;                                               \
+    (header)->tail = new_tail;                                                 \
+  }
+
+#define QUEUE_REM_HEAD(header, field)                                          \
+  {                                                                            \
+    (header)->head = (header)->head->field.next;                               \
+    if ((header)->head == NULL)                                                \
+      (header)->tail = NULL;                                                   \
+  }
+
+#define QUEUE_INSERT_AFTER(header, prec_entry, new_entry, field)               \
+  {                                                                            \
+    (new_entry)->field.next = (prev_entry)->field.next;                        \
+    (prev_entry)->field.next = new_entry;                                      \
+    if ((new_entry)->field.next == NULL)                                       \
+      (header)->tail = new_entry;                                              \
+  }
+
+#define QUEUE_REM_AFTER(header, prec_entry, rem_entry, field)                  \
+  {                                                                            \
+    if (prec_entry != NULL)                                                    \
+      (prec_entry)->field.next = (rem_entry)->field.next;                      \
+    else {                                                                     \
+      (header)->head = (header)->head->field.next;                             \
+      if ((header)->head == NULL)                                              \
+        (header)->tail = NULL;                                                 \
+    }                                                                          \
+  }
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Single linked list with only a head pointer in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define STACK_INITIALIZER                                                      \
+  { NULL }
+
+#define STACK_TYPE(type)                                                       \
+  typedef struct { struct type *head; }
+
+#define STACK(type)                                                            \
+  struct {                                                                     \
+    struct type *head;                                                         \
+  }
+
+#define STACK_DECLARE(name, type)                                              \
+  struct name {                                                                \
+    struct type *head;                                                         \
+  }
+
+#define STACK_DEFINE(name) struct name
+
+#define STACK_ENTRY(type)                                                      \
+  struct {                                                                     \
+    struct type *next;                                                         \
+  }
+
+#define STACK_INIT(header) (header)->head = NULL;
+
+#define STACK_EMPTY(header) (((header)->head == NULL) ? 1 : 0)
+
+#define STACK_HEAD(header) ((header)->head)
+
+#define STACK_NEXT(entry, field) ((entry)->field.next)
+
+#define STACK_ADD_HEAD(header, new_head, field)                                \
+  {                                                                            \
+    (new_head)->field.next = (header)->head;                                   \
+    (header)->head = new_head;                                                 \
+  }
+
+#define STACK_REM_HEAD(header, field)                                          \
+  (header)->head = (header)->head->field.next;
+
+#define STACK_INSERT_AFTER(header, prec_entry, new_entry, field)               \
+  {                                                                            \
+    (new_entry)->field.next = (prev_entry)->field.next;                        \
+    (prev_entry)->field.next = new_entry;                                      \
+  }
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Double linked list with only a head pointer in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define HEAP_INITIALIZER                                                       \
+  { NULL }
+
+#define HEAP_TYPE(type)                                                        \
+  typedef struct { struct type *head; }
+
+#define HEAP(type)                                                             \
+  struct {                                                                     \
+    struct type *head;                                                         \
+  }
+
+#define HEAP_DECLARE(name, type)                                               \
+  struct name {                                                                \
+    struct type *head;                                                         \
+  }
+
+#define HEAP_DEFINE(name) struct name
+
+#define HEAP_ENTRY(type)                                                       \
+  struct {                                                                     \
+    struct type *next;                                                         \
+    struct type *prev;                                                         \
+  }
+
+#define HEAP_INIT(header) (header)->head = NULL;
+
+#define HEAP_EMPTY(header) (((header)->head == NULL) ? 1 : 0)
+
+#define HEAP_HEAD(header) ((header)->head)
+
+#define HEAP_NEXT(entry, field) ((entry)->field.next)
+
+#define HEAP_PREV(entry, field) ((entry)->field.prev)
+
+#define HEAP_ADD_HEAD(header, new_head, field)                                 \
+  {                                                                            \
+    (new_head)->field.next = (header)->head;                                   \
+    (new_head)->field.prev = NULL;                                             \
+    if ((header)->head != NULL)                                                \
+      (header)->head->field.prev = new_head;                                   \
+    (header)->head = new_head;                                                 \
+  }
+
+#define HEAP_REM_HEAD(header, field)                                           \
+  {                                                                            \
+    (header)->head = (header)->head->field.next;                               \
+    if ((header)->head != NULL)                                                \
+      (header)->head->field.prev = NULL;                                       \
+  }
+
+#define HEAP_INSERT_AFTER(header, prev_entry, new_entry, field)                \
+  {                                                                            \
+    (new_entry)->field.next = (prev_entry)->field.next;                        \
+    (new_entry)->field.prev = prev_entry;                                      \
+    (prev_entry)->field.next = new_entry;                                      \
+    if ((new_entry)->field.next != NULL)                                       \
+      (new_entry)->field.next->field.prev = new_entry;                         \
+  }
+
+#define HEAP_INSERT_BEFORE(header, next_entry, new_entry, field)               \
+  {                                                                            \
+    (new_entry)->field.prev = (next_entry)->field.prev;                        \
+    (new_entry)->field.next = next_entry;                                      \
+    (next_entry)->field.prev = new_entry;                                      \
+    if ((new_entry)->field.prev != NULL)                                       \
+      (new_entry)->field.prev->field.next = new_entry;                         \
+    else                                                                       \
+      (header)->head = new_entry;                                              \
+  }
+
+#define HEAP_REM_ENTRY(header, entry, field)                                   \
+  {                                                                            \
+    if ((entry)->field.prev != NULL)                                           \
+      (entry)->field.prev->field.next = (entry)->field.next;                   \
+    else                                                                       \
+      (header)->head = entry->field.next;                                      \
+    if ((entry)->field.next != NULL)                                           \
+      (entry)->field.next->field.prev = (entry)->field.prev;                   \
+  }
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Circular queue with pointer to current head in header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define CIRCLEQ_INITIALIZER                                                    \
+  { NULL }
+
+#define CIRCLEQ_TYPE(type, headertype, entrytype)                              \
+  typedef struct {                                                             \
+    struct type *head;                                                         \
+  } headertype;                                                                \
+                                                                               \
+  typedef struct {                                                             \
+    struct type *next;                                                         \
+    struct type *prev;                                                         \
+  } entrytype
+
+#define CIRCLEQ(type, header)                                                  \
+  struct {                                                                     \
+    struct type *head;                                                         \
+  } heasder
+
+#define CIRCLEQ_DECLARE(name, type)                                            \
+  struct name {                                                                \
+    struct type *head;                                                         \
+  }
+
+#define CIRCLEQ_DEFINE(name) struct name
+
+#define CIRCLEQ_ENTRY(type, entry)                                             \
+  struct {                                                                     \
+    struct type *next;                                                         \
+    struct type *prev;                                                         \
+  } entry
+
+#define CIRCLEQ_INIT(header) (header)->head = NULL;
+
+#define CIRCLEQ_SET_HEAD(header, new_head) (header)->head = new_head;
+
+#define CIRCLEQ_EMPTY(header) (((header)->head == NULL) ? 1 : 0)
+
+#define CIRCLEQ_HEAD(header) ((header)->head)
+
+#define CIRCLEQ_TAIL(header, field)                                            \
+  (((header)->head != NULL) ? (header)->head->field.prev : NULL)
+
+#define CIRCLEQ_NEXT(entry, field) ((entry)->field.next)
+
+#define CIRCLEQ_PREV(entry, field) ((entry)->field.prev)
+
+#define CIRCLEQ_FORWARD(header, field)                                         \
+  { (header)->head = (header)->head->field.next; }
+
+#define CIRCLEQ_REVERSE(header, field)                                         \
+  {                                                                            \
+    if ((header)->head != NULL)                                                \
+      (header)->head = (header)->head->field.next;                             \
+  }
+
+#define CIRCLEQ_ADD_HEAD(header, new_head, field)                              \
+  {                                                                            \
+    if ((header)->head != NULL) {                                              \
+      (new_head)->field.next = (header)->head;                                 \
+      (new_head)->field.prev = (header)->head->field.prev;                     \
+      (header)->head->field.prev = (new_head);                                 \
+      (new_head)->field.prev->field.next = (new_head);                         \
+    } else {                                                                   \
+      (new_head)->field.next = (new_head);                                     \
+      (new_head)->field.prev = (new_head);                                     \
+    }                                                                          \
+    (header)->head = (new_head);                                               \
+  }
+
+#define CIRCLEQ_ADD_TAIL(header, new_tail, field)                              \
+  {                                                                            \
+    if ((header)->head != NULL) {                                              \
+      (new_tail)->field.next = (header)->head;                                 \
+      (new_tail)->field.prev = (header)->head->field.prev;                     \
+      (new_tail)->field.next->field.prev = (new_tail);                         \
+      (new_tail)->field.prev->field.next = (new_tail);                         \
+    } else {                                                                   \
+      (new_tail)->field.next = (new_tail);                                     \
+      (new_tail)->field.prev = (new_tail);                                     \
+      (header)->head = (new_tail);                                             \
+    }                                                                          \
+  }
+
+#define CIRCLEQ_REM_HEAD(header, field)                                        \
+  {                                                                            \
+    if ((header)->head->field.next != (header)->head) {                        \
+      (header)->head->field.next->field.prev = (header)->head->field.prev;     \
+      (header)->head->field.prev->field.next = (header)->head->field.next;     \
+      (header)->head = (header)->head->field.next;                             \
+    } else                                                                     \
+      (header)->head = NULL;                                                   \
+  }
+
+#define CIRCLEQ_REM_TAIL(header, field)                                        \
+  {                                                                            \
+    if ((header)->head->field.next != (header)->head) {                        \
+      (header)->head->field.prev->field.prev->field.next = (header)->head;     \
+      (header)->head->field.prev = (header)->head->field.prev->field.prev;     \
+    } else                                                                     \
+      (header)->head = NULL;                                                   \
+  }
+
+#define CIRCLEQ_REM_ENTRY(header, entry, field)                                \
+  {                                                                            \
+    if ((entry)->field.next != (entry)) {                                      \
+      (entry)->field.next->field.prev = (entry)->field.prev;                   \
+      (entry)->field.prev->field.next = (entry)->field.next;                   \
+      if ((header)->head == (entry))                                           \
+        (header)->head = (entry)->field.next;                                  \
+    } else                                                                     \
+      (header)->head = NULL;                                                   \
+  }
+
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/md5.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/md5.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/md5.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/md5.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,58 @@
+/*	$NetBSD: md5.h,v 1.9 2005/12/26 18:41:36 perry Exp $	*/
+
+/*
+ * This file is derived from the RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm and has been modified by Jason R. Thorpe <thorpej@NetBSD.org>
+ * for portability and formatting.
+ */
+
+/*
+ * Copyright (C) 1991-2, RSA Data Security, Inc. Created 1991. All
+ * rights reserved.
+ *
+ * License to copy and use this software is granted provided that it
+ * is identified as the "RSA Data Security, Inc. MD5 Message-Digest
+ * Algorithm" in all material mentioning or referencing this software
+ * or this function.
+ *
+ * License is also granted to make and use derivative works provided
+ * that such works are identified as "derived from the RSA Data
+ * Security, Inc. MD5 Message-Digest Algorithm" in all material
+ * mentioning or referencing the derived work.
+ *
+ * RSA Data Security, Inc. makes no representations concerning either
+ * the merchantability of this software or the suitability of this
+ * software for any particular purpose. It is provided "as is"
+ * without express or implied warranty of any kind.
+ *
+ * These notices must be retained in any copies of any part of this
+ * documentation and/or software.
+ */
+
+#ifndef _SYS_MD5_H_
+#define _SYS_MD5_H_
+
+#include <sys/types.h>
+
+#define MD5_DIGEST_LENGTH		16
+#define	MD5_DIGEST_STRING_LENGTH	33
+
+/* MD5 context. */
+typedef struct MD5Context {
+	uint32_t state[4];	/* state (ABCD) */
+	uint32_t count[2];	/* number of bits, modulo 2^64 (lsb first) */
+	unsigned char buffer[64]; /* input buffer */
+} MD5_CTX;
+
+__BEGIN_DECLS
+void	MD5Init(MD5_CTX *);
+void	MD5Update(MD5_CTX *, const unsigned char *, unsigned int);
+void	MD5Final(unsigned char[MD5_DIGEST_LENGTH], MD5_CTX *);
+#ifndef _KERNEL
+char	*MD5End(MD5_CTX *, char *);
+char	*MD5File(const char *, char *);
+char	*MD5Data(const unsigned char *, unsigned int, char *);
+#endif /* _KERNEL */
+__END_DECLS
+
+#endif /* _SYS_MD5_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/mount.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/mount.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/mount.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/mount.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,107 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+
+
+/*
+ * Major numbers
+ */
+#define MAJOR_ANON       0    /* Undefined major number */
+#define MAJOR_MEM        1    /* Special memory devices, e.g. dev/mem, dev/null or dev/zero */
+#define MAJOR_RAMDISK    2    /* RAM-disk devices with no physical backing */
+#define MAJOR_MMC        3    /* MMC/SD-Card block storage devices */                              
+#define MAJOR_ATA        4    /* SATA/PATA block devices */
+#define MAJOR_SCSI       5    /* SCSI devices */
+#define MAJOR_FD         6    /* Floppy disk */
+#define MAJOR_NET        7    /* Network interfaces */
+#define MAJOR_PTTY       8    /* Pseudo TTY */
+#define MAJOR_PTTY_SLV   9    /* Pseudo TTY slaves */
+#define MAJOR_TTY       10    /* TTY devices, virtual consoles */
+#define MAJOR_TTYS      11    /* Serial consoles, e.g. /dev/ttyS0 */
+#define MAJOR_LOOP      12    /* Block loopback devices, e.g. /dev/loop0 */
+#define MAJOR_KEYBOARD  13    /* Keyboards and Keypads */
+#define MAJOR_MOUSE     14    /* Mice */
+#define MAJOR_TOUCH     15    /* Touchscreens */
+#define MAJOR_TABLET    16    /* Tablets and pens */
+#define MAJOR_GFX       17    /* Graphics drivers */
+#define MAJOR_AUDIO     18    /* Audio */
+#define MAJOR_PRINTER   19    /* Printers */
+#define MAJOR_BOARD     20    /* Board-specific drivers */
+#define MAJOR_SERIAL    21    /* Serial ports (non-tty) */
+#define MAJOR_PARALLEL  22    /* Parallel ports */
+#define MAJOR_PCI       23    /* PCI bus */
+#define MAJOR_USB       24    /* USB bus */
+#define MAJOR_I2C       25    /* I2C bus */
+#define MAJRO_SPI       26    /* SPI bus */
+#define MAJOR_I2S       27    /* I2S bus */
+#define MAJOR_CAN       28    /* CAN bus */
+#define MAJOR_GPIO      29    /* GPIO pin control */
+#define MAJOR_MIDI      30    /* MIDI devices */
+#define MAJOR_MANAGER   31    /* Manager services, e.g. window and clipboard managers */
+#define MAJOR_DAEMON    32    /* Daemon background services */
+#define MAJOR_PROCFS    33    /* procfs filesystem */
+#define MAJOR_CAMERA    34    /* Cameras */
+
+
+/*
+ *
+ */
+#define MFSNAMELEN      15    /* length of fs type name, not inc. nul */
+#define MNAMELEN        90    /* length of buffer for returned name */
+
+
+/*
+ * Mount flags
+ */
+#define MNT_RDONLY      0x00000001    /* read only filesystem */
+#define MNT_SYNCHRONOUS 0x00000002    /* file system written synchronously */
+#define MNT_NOEXEC      0x00000004    /* can't exec from filesystem */
+#define MNT_NOSUID      0x00000008    /* don't honor setuid bits on fs */
+#define MNT_NODEV       0x00000010    /* don't interpret special files */
+#define MNT_UNION       0x00000020    /* union with underlying filesystem */
+#define MNT_ASYNC       0x00000040    /* file system written asynchronously */
+#define MNT_DONTBROWSE  0x00100000    /* file system is not ppropriate path to user data */
+#define MNT_IGNORE_OWNERSHIP 0x00200000 /* VFS will ignore ownership information on filesystem objects */
+#define MNT_AUTOMOUNTED 0x00400000    /* filesystem was mounted by automounter */
+#define MNT_JOURNALED   0x00800000    /* filesystem is journaled */
+#define MNT_NOUSERXATTR 0x01000000    /* Don't allow user extended attributes */
+#define MNT_DEFWRITE    0x02000000    /* filesystem should defer writes */
+#define MNT_NOCACHE     0x04000000    /* VFS does not cache files */
+#define MNT_NODNLC      0x08000000    /* VFS does not use DNLC, directory name lookup cache */
+#define MNT_NOWAIT      0x00000000
+#define MNT_WAIT        0x10000000
+
+
+/*
+ * fsid_t type
+ */
+typedef struct { long val[2]; } fsid_t;
+
+
+/*
+ * Prototypes
+ */
+int mknod2(char *path, uint32_t flags, struct stat *stat);
+int createmsgport(char *mount_path, uint32_t flags, struct stat *stat, int backlog);
+int unmount(int fd, bool force);
+int renamemsgport(char *new_path, char *old_path);
+int pivotroot(char *new_root, char *old_root);
+int getfsstat(struct statfs *buf, int bufsize, int flags);
+int getmntinfo(struct statfs **mntbufp, int flags);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/panic.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/panic.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/panic.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/panic.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,27 @@
+#ifndef _SYS_PANIC_H
+#define _SYS_PANIC_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+void debug_printf(const char *format, ...);
+
+
+#ifndef NDEBUG
+#define panic(fmt, args...)   { debug_printf(fmt, ##args); exit(EXIT_FAILURE); }
+#else
+#define panic(fmt, args...)   { exit(EXIT_FAILURE) }
+#endif
+
+
+
+#endif
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/param.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/param.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/param.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/param.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,241 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)param.h	8.3 (Berkeley) 4/4/95
+ * $Id: param.h,v 1.3 2004/05/07 20:29:24 jjohnstn Exp $
+ */
+
+#ifndef _SYS_PARAM_H_
+#define _SYS_PARAM_H_
+
+/* from newlib's <sys/param.h> */
+
+#include <sys/config.h>
+#include <machine/endian.h>
+
+# define HZ (60)
+# define PATHSIZE (1024)
+
+/* end of from newlib's <sys/param.h> */
+
+#include <unistd.h>
+
+#define	BSD	199506		/* System version (year & month). */
+#define BSD4_3	1
+#define BSD4_4	1
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef LOCORE
+#include <sys/types.h>
+#endif
+
+/*
+ * Machine-independent constants (some used in following include files).
+ * Redefined constants are from POSIX 1003.1 limits file.
+ *
+ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
+ * MAXLOGNAME should be >= UT_NAMESIZE (see <utmp.h>)
+ */
+#include <sys/syslimits.h>
+
+#define	MAXCOMLEN	16		/* max command name remembered */
+#define	MAXINTERP	32		/* max interpreter file name length */
+#define	MAXLOGNAME	12		/* max login name length */
+#define	MAXUPRC		CHILD_MAX	/* max simultaneous processes */
+#define	NCARGS		ARG_MAX		/* max bytes for an exec function */
+#define	NGROUPS		NGROUPS_MAX	/* max number groups */
+#define	NOFILE		OPEN_MAX	/* max open files per process */
+#define	NOGROUP		65535		/* marker for empty group set member */
+#define MAXHOSTNAMELEN	256		/* max hostname size */
+
+/* More types and definitions used throughout the kernel. */
+#ifdef KERNEL
+#include <sys/cdefs.h>
+#include <sys/errno.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/ucred.h>
+#include <sys/uio.h>
+#include <sys/rtprio.h>
+
+#ifndef FALSE
+#define	FALSE	0
+#endif
+#ifndef TRUE
+#define	TRUE	1
+#endif
+#endif
+
+/* Signals. */
+#include <sys/signal.h>
+
+/* Machine type dependent parameters. */
+#include <machine/param.h>
+#include <machine/limits.h>
+
+/*
+ * Priorities.  Note that with 32 run queues, differences less than 4 are
+ * insignificant.
+ */
+#define	PSWP	0
+#define	PVM	4
+#define	PINOD	8
+#define	PRIBIO	16
+#define	PVFS	20
+#define	PZERO	22		/* No longer magic, shouldn't be here.  XXX */
+#define	PSOCK	24
+#define	PWAIT	32
+#define	PLOCK	36
+#define	PPAUSE	40
+#define	PUSER	50
+#define	MAXPRI	127		/* Priorities range from 0 through MAXPRI. */
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
+
+#define	NZERO	0		/* default "nice" */
+
+#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
+
+#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
+#define	NODEV	(dev_t)(-1)	/* non-existent device */
+
+/*
+ * Clustering of hardware pages on machines with ridiculously small
+ * page sizes is done here.  The paging subsystem deals with units of
+ * CLSIZE pte's describing PAGE_SIZE (from machine/machparam.h) pages each.
+ */
+#if 0
+#define	CLBYTES		(CLSIZE*PAGE_SIZE)
+#endif
+
+#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
+#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
+				/* Data chars/clist. */
+#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
+#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
+
+/*
+ * File system parameters and macros.
+ *
+ * The file system is made out of blocks of at most MAXBSIZE units, with
+ * smaller units (fragments) only in the last direct block.  MAXBSIZE
+ * primarily determines the size of buffers in the buffer pool.  It may be
+ * made larger without any effect on existing file systems; however making
+ * it smaller make make some file systems unmountable.  Also, MAXBSIZE
+ * must be less than MAXPHYS!!!  DFLTBSIZE is the average amount of
+ * memory allocated by vfs_bio per nbuf.  BKVASIZE is the average amount
+ * of kernel virtual space allocated per nbuf.  BKVASIZE should be >=
+ * DFLTBSIZE.  If it is significantly bigger than DFLTBSIZE, then
+ * kva fragmentation causes fewer performance problems.
+ */
+#define	MAXBSIZE	65536
+#define BKVASIZE	8192
+#define DFLTBSIZE	4096
+#define MAXFRAG 	8
+
+/*
+ * MAXPATHLEN defines the longest permissible path length after expanding
+ * symbolic links. It is used to allocate a temporary buffer from the buffer
+ * pool in which to do the name expansion, hence should be a power of two,
+ * and must be less than or equal to MAXBSIZE.  MAXSYMLINKS defines the
+ * maximum number of symbolic links that may be expanded in a path name.
+ * It should be set high enough to allow all legitimate uses, but halt
+ * infinite loops reasonably quickly.
+ */
+#if !defined(__rtems__)
+#define	MAXPATHLEN	PATH_MAX
+#endif
+#define MAXSYMLINKS	32
+
+/* Bit map related macros. */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding. */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif
+#define	rounddown(x, y)	(((x)/(y))*(y))
+#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
+#define	roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#define powerof2(x)	((((x)-1)&(x))==0)
+
+/* Macros for min/max. */
+#ifndef KERNEL
+#define	MIN(a,b) (((a)<(b))?(a):(b))
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+#endif
+
+/*
+ * Constants for setting the parameters of the kernel memory allocator.
+ *
+ * 2 ** MINBUCKET is the smallest unit of memory that will be
+ * allocated. It must be at least large enough to hold a pointer.
+ *
+ * Units of memory less or equal to MAXALLOCSAVE will permanently
+ * allocate physical memory; requests for these size pieces of
+ * memory are quite fast. Allocations greater than MAXALLOCSAVE must
+ * always allocate and free physical memory; requests for these
+ * size allocations should be done infrequently as they will be slow.
+ *
+ * Constraints: PAGE_SIZE <= MAXALLOCSAVE <= 2 ** (MINBUCKET + 14), and
+ * MAXALLOCSIZE must be a power of two.
+ */
+#define MINBUCKET	4		/* 4 => min allocation of 16 bytes */
+#define MAXALLOCSAVE	(2 * PAGE_SIZE)
+
+/*
+ * Scale factor for scaled integers used to count %cpu time and load avgs.
+ *
+ * The number of CPU `tick's that map to a unique `%age' can be expressed
+ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+ * can be calculated (assuming 32 bits) can be closely approximated using
+ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
+ *
+ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
+ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
+ */
+#define	FSHIFT	11		/* bits to right of fixed binary point */
+#define FSCALE	(1<<FSHIFT)
+
+#endif	/* _SYS_PARAM_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/resource.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/resource.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/resource.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/resource.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,129 @@
+/*	$NetBSD: resource.h,v 1.33 2012/06/09 02:31:15 christos Exp $	*/
+
+/*
+ * Copyright (c) 1982, 1986, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)resource.h	8.4 (Berkeley) 1/9/95
+ */
+
+#ifndef _SYS_RESOURCE_H_
+#define	_SYS_RESOURCE_H_
+
+#include <sys/time.h>
+
+/*
+ * Process priority specifications to get/setpriority.
+ */
+#define	PRIO_MIN	-20
+#define	PRIO_MAX	20
+
+#define	PRIO_PROCESS	0
+#define	PRIO_PGRP	1
+#define	PRIO_USER	2
+
+/*
+ * Resource utilization information.
+ */
+
+#define	RUSAGE_SELF	0
+#define	RUSAGE_CHILDREN	-1
+
+struct	rusage {
+	struct timeval ru_utime;	/* user time used */
+	struct timeval ru_stime;	/* system time used */
+	long	ru_maxrss;		/* max resident set size */
+#define	ru_first	ru_ixrss
+	long	ru_ixrss;		/* integral shared memory size */
+	long	ru_idrss;		/* integral unshared data " */
+	long	ru_isrss;		/* integral unshared stack " */
+	long	ru_minflt;		/* page reclaims */
+	long	ru_majflt;		/* page faults */
+	long	ru_nswap;		/* swaps */
+	long	ru_inblock;		/* block input operations */
+	long	ru_oublock;		/* block output operations */
+	long	ru_msgsnd;		/* messages sent */
+	long	ru_msgrcv;		/* messages received */
+	long	ru_nsignals;		/* signals received */
+	long	ru_nvcsw;		/* voluntary context switches */
+	long	ru_nivcsw;		/* involuntary " */
+#define	ru_last		ru_nivcsw
+};
+
+/*
+ * Resource limits
+ */
+#define	RLIMIT_CPU	0		/* cpu time in milliseconds */
+#define	RLIMIT_FSIZE	1		/* maximum file size */
+#define	RLIMIT_DATA	2		/* data size */
+#define	RLIMIT_STACK	3		/* stack size */
+#define	RLIMIT_CORE	4		/* core file size */
+#define	RLIMIT_RSS	5		/* resident set size */
+#define	RLIMIT_MEMLOCK	6		/* locked-in-memory address space */
+#define	RLIMIT_NPROC	7		/* number of processes */
+#define	RLIMIT_NOFILE	8		/* number of open files */
+#define	RLIMIT_SBSIZE	9		/* maximum size of all socket buffers */
+#define	RLIMIT_AS	10		/* virtual process size (inclusive of mmap) */
+#define	RLIMIT_VMEM	RLIMIT_AS	/* common alias */
+#define	RLIMIT_NTHR	11		/* number of threads */
+
+#if defined(_NETBSD_SOURCE)
+#define	RLIM_NLIMITS	12		/* number of resource limits */
+#endif
+
+#define	RLIM_INFINITY	(0xFFFFFFFFU)	/* no limit */
+#define	RLIM_SAVED_MAX	RLIM_INFINITY	/* unrepresentable hard limit */
+#define	RLIM_SAVED_CUR	RLIM_INFINITY	/* unrepresentable soft limit */
+
+typedef unsigned long rlim_t;
+
+struct rlimit {
+	rlim_t	rlim_cur;		/* current (soft) limit */
+	rlim_t	rlim_max;		/* maximum value for rlim_cur */
+};
+
+#if defined(_NETBSD_SOURCE)
+/* Load average structure. */
+struct loadavg {
+	fixpt_t	ldavg[3];
+	long	fscale;
+};
+#endif
+
+#include <sys/cdefs.h>
+
+__BEGIN_DECLS
+int	getpriority(int which, id_t who);
+int	getrlimit(int resource, struct rlimit *rlim);
+#ifndef __LIBC12_SOURCE__
+int	getrusage(int resource, struct rusage *);
+#endif
+int	setpriority(int which, id_t who, int prio);
+int	setrlimit(int resource, const struct rlimit *rlim);
+__END_DECLS
+
+#endif	/* !_SYS_RESOURCE_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/sha1.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/sha1.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/sha1.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/sha1.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,37 @@
+/*	$NetBSD: sha1.h,v 1.14 2009/11/06 20:31:19 joerg Exp $	*/
+
+/*
+ * SHA-1 in C
+ * By Steve Reid <steve@edmweb.com>
+ * 100% Public Domain
+ */
+
+#ifndef _SYS_SHA1_H_
+#define	_SYS_SHA1_H_
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#define SHA1_DIGEST_LENGTH		20
+#define SHA1_DIGEST_STRING_LENGTH	41
+
+typedef struct {
+	uint32_t state[5];
+	uint32_t count[2];
+	uint8_t buffer[64];
+} SHA1_CTX;
+
+__BEGIN_DECLS
+void	SHA1Transform(uint32_t[5], const uint8_t[64]);
+void	SHA1Init(SHA1_CTX *);
+void	SHA1Update(SHA1_CTX *, const uint8_t *, unsigned int);
+void	SHA1Final(uint8_t[SHA1_DIGEST_LENGTH], SHA1_CTX *);
+#ifndef _KERNEL
+char	*SHA1End(SHA1_CTX *, char *);
+char	*SHA1FileChunk(const char *, char *, off_t, off_t);
+char	*SHA1File(const char *, char *);
+char	*SHA1Data(const uint8_t *, size_t, char *);
+#endif /* _KERNEL */
+__END_DECLS
+
+#endif /* _SYS_SHA1_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/signal.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/signal.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/signal.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,333 @@
+/* sys/signal.h */
+
+#ifndef _SYS_SIGNAL_H
+#define _SYS_SIGNAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "_ansi.h"
+#include <sys/cdefs.h>
+#include <sys/features.h>
+#include <sys/types.h>
+#include <sys/_sigset.h>
+#include <sys/_timespec.h>
+
+#if !defined(_SIGSET_T_DECLARED)
+#define	_SIGSET_T_DECLARED
+typedef	__sigset_t	sigset_t;
+#endif
+
+#if defined(__CYGWIN__)
+#include <cygwin/signal.h>
+#else
+
+/* sigev_notify values
+   NOTE: P1003.1c/D10, p. 34 adds SIGEV_THREAD.  */
+
+#define SIGEV_NONE   1  /* No asynchronous notification shall be delivered */
+                        /*   when the event of interest occurs. */
+#define SIGEV_SIGNAL 2  /* A queued signal, with an application defined */
+                        /*  value, shall be delivered when the event of */
+                        /*  interest occurs. */
+#define SIGEV_THREAD 3  /* A notification function shall be called to */
+                        /*   perform notification. */
+
+/*  Signal Generation and Delivery, P1003.1b-1993, p. 63
+    NOTE: P1003.1c/D10, p. 34 adds sigev_notify_function and
+          sigev_notify_attributes to the sigevent structure.  */
+
+union sigval {
+  int    sival_int;    /* Integer signal value */
+  void  *sival_ptr;    /* Pointer signal value */
+};
+
+struct sigevent {
+  int              sigev_notify;               /* Notification type */
+  int              sigev_signo;                /* Signal number */
+  union sigval     sigev_value;                /* Signal value */
+
+#if defined(_POSIX_THREADS)
+  void           (*sigev_notify_function)( union sigval );
+                                               /* Notification function */
+  pthread_attr_t  *sigev_notify_attributes;    /* Notification Attributes */
+#endif
+};
+
+/* Signal Actions, P1003.1b-1993, p. 64 */
+/* si_code values, p. 66 */
+
+#define SI_USER    1    /* Sent by a user. kill(), abort(), etc */
+#define SI_QUEUE   2    /* Sent by sigqueue() */
+#define SI_TIMER   3    /* Sent by expiration of a timer_settime() timer */
+#define SI_ASYNCIO 4    /* Indicates completion of asycnhronous IO */
+#define SI_MESGQ   5    /* Indicates arrival of a message at an empty queue */
+
+typedef struct {
+  int          si_signo;    /* Signal number */
+  int          si_code;     /* Cause of the signal */
+  union sigval si_value;    /* Signal value */
+} siginfo_t;
+
+#define SA_NOCLDSTOP      (1<<0)
+#define SA_RESETHAND      (1<<1)
+#define SA_SIGINFO        (1<<2)
+#define SA_NODEFER        (1<<3)
+#define SA_RESTORER       (1<<4)
+
+typedef void (*_sig_func_ptr)(int);
+
+struct sigaction 
+{
+	void (* sa_restorer)(void);
+	sigset_t sa_mask;
+	int sa_flags;
+
+  union {
+    _sig_func_ptr _handler;  /* SIG_DFL, SIG_IGN, or pointer to a function */
+    void        (*_sigaction)( int, siginfo_t *, void * );
+  } _signal_handlers;
+};
+
+#define sa_handler    _signal_handlers._handler
+#define sa_sigaction  _signal_handlers._sigaction
+
+#endif /* defined(__CYGWIN__) */
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+/*
+ * Minimum and default signal stack constants. Allow for target overrides
+ * from <sys/features.h>.
+ */
+#ifndef	MINSIGSTKSZ
+#define	MINSIGSTKSZ	2048
+#endif
+#ifndef	SIGSTKSZ
+#define	SIGSTKSZ	8192
+#endif
+
+/*
+ * Possible values for ss_flags in stack_t below.
+ */
+#define	SS_ONSTACK	0x1
+#define	SS_DISABLE	0x2
+
+#endif
+
+/*
+ * Structure used in sigaltstack call.
+ */
+typedef struct sigaltstack {
+  void     *ss_sp;    /* Stack base or pointer.  */
+  int       ss_flags; /* Flags.  */
+  size_t    ss_size;  /* Stack size.  */
+} stack_t;
+
+#define SIG_SETMASK 0	/* set mask with sigprocmask() */
+#define SIG_BLOCK 1	/* set of signals to block */
+#define SIG_UNBLOCK 2	/* set of signals to, well, unblock */
+
+int sigprocmask (int, const sigset_t *, sigset_t *);
+
+#if __POSIX_VISIBLE >= 199506
+int pthread_sigmask (int, const sigset_t *, sigset_t *);
+#endif
+
+#ifdef _COMPILING_NEWLIB
+int _kill (pid_t, int);
+#endif /* _COMPILING_NEWLIB */
+
+int kill (pid_t, int);
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4
+int killpg (pid_t, int);
+#endif
+
+int sigaction (int, const struct sigaction *, struct sigaction *);
+int sigaddset (sigset_t *, const int);
+int sigdelset (sigset_t *, const int);
+int sigismember (const sigset_t *, int);
+int sigfillset (sigset_t *);
+int sigemptyset (sigset_t *);
+int sigpending (sigset_t *);
+int sigsuspend (const sigset_t *);
+int sigwait (const sigset_t *, int *);
+
+#if !defined(__CYGWIN__) && !defined(__rtems__)
+/* These depend upon the type of sigset_t, which right now 
+   is always a long.. They're in the POSIX namespace, but
+   are not ANSI. */
+#define sigaddset(what,sig) (*(what) |= (1<<(sig)), 0)
+#define sigdelset(what,sig) (*(what) &= ~(1<<(sig)), 0)
+#define sigemptyset(what)   (*(what) = 0, 0)
+#define sigfillset(what)    (*(what) = ~(0), 0)
+#define sigismember(what,sig) (((*(what)) & (1<<(sig))) != 0)
+#endif /* !__CYGWIN__ && !__rtems__ */
+
+/* There are two common sigpause variants, both of which take an int argument.
+   If you request _XOPEN_SOURCE or _GNU_SOURCE, you get the System V version,
+   which removes the given signal from the process's signal mask; otherwise
+   you get the BSD version, which sets the process's signal mask to the given
+   value. */
+#if __XSI_VISIBLE && !defined(__INSIDE_CYGWIN__)
+# ifdef __GNUC__
+int sigpause (int) __asm__ (__ASMNAME ("__xpg_sigpause"));
+# else
+int __xpg_sigpause (int);
+#  define sigpause __xpg_sigpause
+# endif
+#elif __BSD_VISIBLE
+int sigpause (int);
+#endif
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int sigaltstack (const stack_t *__restrict, stack_t *__restrict);
+#endif
+
+#if __POSIX_VISIBLE >= 199506
+int pthread_kill (pthread_t, int);
+#endif
+
+#if __POSIX_VISIBLE >= 199309
+
+/*  3.3.8 Synchronously Accept a Signal, P1003.1b-1993, p. 76
+    NOTE: P1003.1c/D10, p. 39 adds sigwait().  */
+
+int sigwaitinfo (const sigset_t *, siginfo_t *);
+int sigtimedwait (const sigset_t *, siginfo_t *, const struct timespec *);
+/*  3.3.9 Queue a Signal to a Process, P1003.1b-1993, p. 78 */
+int sigqueue (pid_t, int, const union sigval);
+
+#endif /* __POSIX_VISIBLE >= 199309 */
+
+#if defined(___AM29K__)
+/* These all need to be defined for ANSI C, but I don't think they are
+   meaningful.  */
+#define SIGABRT 1
+#define SIGFPE 1
+#define SIGILL 1
+#define SIGINT 1
+#define SIGSEGV 1
+#define SIGTERM 1
+/* These need to be defined for POSIX, and some others do too.  */
+#define SIGHUP 1
+#define SIGQUIT 1
+#define NSIG 2
+#elif defined(__GO32__)
+#define SIGINT  1
+#define SIGKILL 2
+#define SIGPIPE 3
+#define SIGFPE  4
+#define SIGHUP  5
+#define SIGTERM 6
+#define SIGSEGV 7
+#define SIGTSTP 8
+#define SIGQUIT 9
+#define SIGTRAP 10
+#define SIGILL  11
+#define SIGEMT  12
+#define SIGALRM 13
+#define SIGBUS  14
+#define SIGLOST 15
+#define SIGSTOP 16
+#define SIGABRT 17
+#define SIGUSR1	18
+#define SIGUSR2	19
+#define NSIG    20
+#elif !defined(SIGTRAP)
+#define	SIGHUP	1	/* hangup */
+#define	SIGINT	2	/* interrupt */
+#define	SIGQUIT	3	/* quit */
+#define	SIGILL	4	/* illegal instruction (not reset when caught) */
+#define	SIGTRAP	5	/* trace trap (not reset when caught) */
+#define	SIGIOT	6	/* IOT instruction */
+#define	SIGABRT 6	/* used by abort, replace SIGIOT in the future */
+#define	SIGEMT	7	/* EMT instruction */
+#define	SIGFPE	8	/* floating point exception */
+#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
+#define	SIGBUS	10	/* bus error */
+#define	SIGSEGV	11	/* segmentation violation */
+#define	SIGSYS	12	/* bad argument to system call */
+#define	SIGPIPE	13	/* write on a pipe with no one to read it */
+#define	SIGALRM	14	/* alarm clock */
+#define	SIGTERM	15	/* software termination signal from kill */
+
+#if defined(__rtems__)
+#define	SIGURG	16	/* urgent condition on IO channel */
+#define	SIGSTOP	17	/* sendable stop signal not from tty */
+#define	SIGTSTP	18	/* stop signal from tty */
+#define	SIGCONT	19	/* continue a stopped process */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define	SIGCLD	20	/* System V name for SIGCHLD */
+#define	SIGTTIN	21	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define	SIGIO	23	/* input/output possible signal */
+#define	SIGPOLL	SIGIO	/* System V name for SIGIO */
+#define	SIGWINCH 24	/* window changed */
+#define	SIGUSR1 25	/* user defined signal 1 */
+#define	SIGUSR2 26	/* user defined signal 2 */
+
+/* Real-Time Signals Range, P1003.1b-1993, p. 61
+   NOTE: By P1003.1b-1993, this should be at least RTSIG_MAX
+         (which is a minimum of 8) signals.
+ */
+#define SIGRTMIN 27
+#define SIGRTMAX 31
+#define __SIGFIRSTNOTRT SIGHUP
+#define __SIGLASTNOTRT  SIGUSR2
+
+#define NSIG	32      /* signal 0 implied */
+
+#elif defined(__svr4__)
+/* svr4 specifics. different signals above 15, and sigaction. */
+#define	SIGUSR1	16
+#define SIGUSR2	17
+#define SIGCLD	18
+#define	SIGPWR	19
+#define SIGWINCH 20
+#define	SIGPOLL	22	/* 20 for x.out binaries!!!! */
+#define	SIGSTOP	23	/* sendable stop signal not from tty */
+#define	SIGTSTP	24	/* stop signal from tty */
+#define	SIGCONT	25	/* continue a stopped process */
+#define	SIGTTIN	26	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	27	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define NSIG	28	
+#else
+#define	SIGURG	16	/* urgent condition on IO channel */
+#define	SIGSTOP	17	/* sendable stop signal not from tty */
+#define	SIGTSTP	18	/* stop signal from tty */
+#define	SIGCONT	19	/* continue a stopped process */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define	SIGCLD	20	/* System V name for SIGCHLD */
+#define	SIGTTIN	21	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define	SIGIO	23	/* input/output possible signal */
+#define	SIGPOLL	SIGIO	/* System V name for SIGIO */
+#define	SIGXCPU	24	/* exceeded CPU time limit */
+#define	SIGXFSZ	25	/* exceeded file size limit */
+#define	SIGVTALRM 26	/* virtual time alarm */
+#define	SIGPROF	27	/* profiling time alarm */
+#define	SIGWINCH 28	/* window changed */
+#define	SIGLOST 29	/* resource lost (eg, record-lock lost) */
+#define	SIGUSR1 30	/* user defined signal 1 */
+#define	SIGUSR2 31	/* user defined signal 2 */
+#define NSIG	32      /* signal 0 implied */
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(__CYGWIN__)
+#if __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+#include <sys/ucontext.h>
+#endif
+#endif
+
+#ifndef _SIGNAL_H_
+/* Some applications take advantage of the fact that <sys/signal.h>
+ * and <signal.h> are equivalent in glibc.  Allow for that here.  */
+#include <signal.h>
+#endif
+#endif /* _SYS_SIGNAL_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/stat.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/stat.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/stat.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/stat.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,189 @@
+#ifndef	_SYS_STAT_H
+#define	_SYS_STAT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <time.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/_timespec.h>
+
+/* dj's stat defines _STAT_H_ */
+#ifndef _STAT_H_
+
+/* It is intended that the layout of this structure not change when the
+   sizes of any of the basic types change (short, int, long) [via a compile
+   time option].  */
+
+#ifdef __CYGWIN__
+#include <cygwin/stat.h>
+#ifdef _COMPILING_NEWLIB
+#define stat64 stat
+#endif
+#else
+struct	stat 
+{
+  dev_t		st_dev;
+  ino_t		st_ino;
+  mode_t	st_mode;
+  nlink_t	st_nlink;
+  uid_t		st_uid;
+  gid_t		st_gid;
+  dev_t		st_rdev;
+  off_t		st_size;
+#if defined(__svr4__) && !defined(__PPC__) && !defined(__sun__)
+  time_t	st_atime;
+  time_t	st_mtime;
+  time_t	st_ctime;
+#else
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+  blksize_t     st_blksize;
+  blkcnt_t	st_blocks;
+#if !defined(__rtems__)
+  long		st_spare4[2];
+#endif
+#endif
+};
+
+#if !(defined(__svr4__) && !defined(__PPC__) && !defined(__sun__)) && !defined(__cris__)
+#define st_atime st_atim.tv_sec
+#define st_ctime st_ctim.tv_sec
+#define st_mtime st_mtim.tv_sec
+#endif
+
+#endif
+
+#define	  _IFMT		0170000	/* type of file */
+
+#define		_IFDIR	0040000	/* directory */
+#define		_IFCHR	0020000	/* character special */
+#define		_IFBLK	0060000	/* block special */
+#define		_IFREG	0100000	/* regular */
+#define		_IFLNK	0120000	/* symbolic link */
+#define		_IFSOCK	0140000	/* socket */
+#define		_IFIFO	0010000	/* fifo */
+
+// Unique file handle types for Cheviot OS  (Remove, prevent stating of mount and isr)
+#define		_IFMNT	0160000	/* filesystem mount */
+#define		_IFIRQ	0170000	/* interrupt */
+
+
+
+#define 	S_BLKSIZE  1024 /* size of a block */
+
+#define	S_ISUID		0004000	/* set user id on execution */
+#define	S_ISGID		0002000	/* set group id on execution */
+#define	S_ISVTX		0001000	/* save swapped text even after use */
+#if __BSD_VISIBLE
+#define	S_IREAD		0000400	/* read permission, owner */
+#define	S_IWRITE 	0000200	/* write permission, owner */
+#define	S_IEXEC		0000100	/* execute/search permission, owner */
+#define	S_ENFMT 	0002000	/* enforcement-mode locking */
+#endif	/* !_BSD_VISIBLE */
+
+#define	S_IFMT		_IFMT
+#define	S_IFDIR		_IFDIR
+#define	S_IFCHR		_IFCHR
+#define	S_IFBLK		_IFBLK
+#define	S_IFREG		_IFREG
+#define	S_IFLNK		_IFLNK
+#define	S_IFSOCK	_IFSOCK
+#define	S_IFIFO		_IFIFO
+
+
+#ifdef _WIN32
+/* The Windows header files define _S_ forms of these, so we do too
+   for easier portability.  */
+#define _S_IFMT		_IFMT
+#define _S_IFDIR	_IFDIR
+#define _S_IFCHR	_IFCHR
+#define _S_IFIFO	_IFIFO
+#define _S_IFREG	_IFREG
+#define _S_IREAD	0000400
+#define _S_IWRITE	0000200
+#define _S_IEXEC	0000100
+#endif
+
+#define	S_IRWXU 	(S_IRUSR | S_IWUSR | S_IXUSR)
+#define		S_IRUSR	0000400	/* read permission, owner */
+#define		S_IWUSR	0000200	/* write permission, owner */
+#define		S_IXUSR 0000100/* execute/search permission, owner */
+#define	S_IRWXG		(S_IRGRP | S_IWGRP | S_IXGRP)
+#define		S_IRGRP	0000040	/* read permission, group */
+#define		S_IWGRP	0000020	/* write permission, grougroup */
+#define		S_IXGRP 0000010/* execute/search permission, group */
+#define	S_IRWXO		(S_IROTH | S_IWOTH | S_IXOTH)
+#define		S_IROTH	0000004	/* read permission, other */
+#define		S_IWOTH	0000002	/* write permission, other */
+#define		S_IXOTH 0000001/* execute/search permission, other */
+
+#if __BSD_VISIBLE
+#define ACCESSPERMS (S_IRWXU | S_IRWXG | S_IRWXO) /* 0777 */
+#define ALLPERMS (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO) /* 07777 */
+#define DEFFILEMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) /* 0666 */
+#endif
+
+#define	S_ISBLK(m)	(((m)&_IFMT) == _IFBLK)
+#define	S_ISCHR(m)	(((m)&_IFMT) == _IFCHR)
+#define	S_ISDIR(m)	(((m)&_IFMT) == _IFDIR)
+#define	S_ISFIFO(m)	(((m)&_IFMT) == _IFIFO)
+#define	S_ISREG(m)	(((m)&_IFMT) == _IFREG)
+#define	S_ISLNK(m)	(((m)&_IFMT) == _IFLNK)
+#define	S_ISSOCK(m)	(((m)&_IFMT) == _IFSOCK)
+
+
+#if defined(__CYGWIN__)
+/* Special tv_nsec values for futimens(2) and utimensat(2). */
+#define UTIME_NOW	-2L
+#define UTIME_OMIT	-1L
+#endif
+
+int	chmod (const char *__path, mode_t __mode );
+int     fchmod (int __fd, mode_t __mode);
+int	fstat (int __fd, struct stat *__sbuf );
+int	mkdir (const char *_path, mode_t __mode );
+int	mkfifo (const char *__path, mode_t __mode );
+int	stat (const char *__restrict __path, struct stat *__restrict __sbuf );
+mode_t	umask (mode_t __mask );
+int mknod2 (char *path, uint32_t flags, struct stat *stat);
+
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
+int	lstat (const char *__restrict __path, struct stat *__restrict __buf );
+int	mknod (const char *__path, mode_t __mode, dev_t __dev );
+#endif
+
+#if __ATFILE_VISIBLE && !defined(__INSIDE_CYGWIN__)
+int	fchmodat (int, const char *, mode_t, int);
+int	fstatat (int, const char *__restrict , struct stat *__restrict, int);
+int	mkdirat (int, const char *, mode_t);
+int	mkfifoat (int, const char *, mode_t);
+int	mknodat (int, const char *, mode_t, dev_t);
+int	utimensat (int, const char *, const struct timespec *, int);
+#endif
+#if __POSIX_VISIBLE >= 200809 && !defined(__INSIDE_CYGWIN__)
+int	futimens (int, const struct timespec *);
+#endif
+
+/* Provide prototypes for most of the _<systemcall> names that are
+   provided in newlib for some compilers.  */
+#ifdef _COMPILING_NEWLIB
+int	_fstat (int __fd, struct stat *__sbuf );
+int	_stat (const char *__restrict __path, struct stat *__restrict __sbuf );
+int	_mkdir (const char *_path, mode_t __mode );
+#ifdef __LARGE64_FILES
+struct stat64;
+int	_stat64 (const char *__restrict __path, struct stat64 *__restrict __sbuf );
+int	_fstat64 (int __fd, struct stat64 *__sbuf );
+#endif
+#endif
+
+#endif /* !_STAT_H_ */
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STAT_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/statvfs.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/statvfs.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/statvfs.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/statvfs.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,56 @@
+#ifndef	_SYS_STATVFS_H
+#define	_SYS_STATVFS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <time.h>
+#include <sys/types.h>
+
+
+struct statvfs 
+{
+  int f_type;
+  char *f_mntfromname;
+  char *f_mntonname;  
+	unsigned long f_bsize;    /* File system block size */
+	unsigned long f_frsize;   /* Fundamental file system block size */
+	fsblkcnt_t    f_blocks;   /* Num blocks in units of f_frsize */
+	fsblkcnt_t    f_bfree;    /* Num free blocks */
+	fsblkcnt_t    f_bavail;   /* Num free blocks for non-privileged process */
+	fsfilcnt_t    f_files;    /* Total number of file serial numbers */ 
+	fsfilcnt_t    f_ffree;    /* Total number of free file serial numbers */ 
+	fsfilcnt_t    f_favail;   /* ... for non-privileged process */ 
+	unsigned long f_fsid;     /* File system ID */ 
+	unsigned long f_flag;     /* Bit mask of f_flag values */  
+	unsigned long f_namemax ; /* Maximum filename length */ 
+};
+
+
+struct statfs 
+{
+  int f_type;
+  char *f_mntfromname;
+  char *f_mntonname;  
+	unsigned long f_bsize;    /* File system block size */
+	unsigned long f_frsize;   /* Fundamental file system block size */
+	fsblkcnt_t    f_blocks;   /* Num blocks in units of f_frsize */
+	fsblkcnt_t    f_bfree;    /* Num free blocks */
+	fsblkcnt_t    f_bavail;   /* Num free blocks for non-privileged process */
+	fsfilcnt_t    f_files;    /* Total number of file serial numbers */ 
+	fsfilcnt_t    f_ffree;    /* Total number of free file serial numbers */ 
+	fsfilcnt_t    f_favail;   /* ... for non-privileged process */ 
+	unsigned long f_fsid;     /* File system ID */ 
+	unsigned long f_flag;     /* Bit mask of f_flag values */  
+	unsigned long f_namemax ; /* Maximum filename length */ 
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STATVFS_H */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/syscalls.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/syscalls.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/syscalls.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/syscalls.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,261 @@
+#ifndef _SYS_KSYSCALLS_H
+#define _SYS_KSYSCALLS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/mount.h>
+#include <sys/stat.h>
+#include <sys/execargs.h>
+#include <sys/signal.h>
+#include <sys/event.h>
+#include <poll.h>
+#include <time.h>
+#include <sys/time.h>
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/resource.h>
+#include <sys/types.h>
+
+
+// Types
+typedef signed char 		    int8;
+typedef unsigned char 		  uint8;
+typedef signed short		    int16;
+typedef unsigned short		  uint16;
+typedef signed long			    int32;
+typedef unsigned long		    uint32;
+typedef signed long long 	  int64;
+typedef unsigned long long 	uint64;
+typedef signed long			    err32;
+typedef uint32_t				    vm_offset;
+typedef uint32_t				    vm_size;
+typedef unsigned char		    bits8_t;
+typedef unsigned short		  bits16_t;
+typedef unsigned long		    bits32_t;
+typedef long long			      uuid_t;
+
+typedef uint32_t            msgid_t;
+
+/*
+ * Exit()/Join() Status
+ */
+#define EXIT_OK                 0
+#define EXIT_ERROR              1
+#define EXIT_FATAL              2
+#define EXIT_KILLED             3
+
+
+
+/*
+ * Multi-part messages
+ */
+struct IOV
+{
+  void *addr;
+  size_t size;
+  uint32_t flags;						// TODO: Use iov flags to control zero-copy
+};
+
+
+/*
+ * Time related structures
+ */
+struct TimeVal
+{
+	long long seconds;
+	long microseconds;
+};
+
+
+struct InterruptAPI;
+
+
+/*
+ * Timer types
+ */
+#define TIMER_TYPE_RELATIVE     0
+#define TIMER_TYPE_ABSOLUTE     1
+
+
+/*
+ * VirtualAlloc() protections
+ */
+#define PROT_NONE			        0
+#define PROT_READ			        (1<<0)
+#define PROT_WRITE			      (1<<1)
+#define PROT_EXEC			        (1<<2)
+#define PROT_ALL			        (PROT_READ | PROT_WRITE | PROT_EXEC)
+#define PROT_READWRITE 		    (PROT_READ | PROT_WRITE)
+#define PROT_READEXEC		      (PROT_READ | PROT_EXEC)
+
+#define MAP_FIXED				      (1<<3)
+#define MAP_WIRED				      (1<<4)
+#define MAP_NOX64				      (1<<5)
+#define MAP_BELOW16M			    (1<<6)
+#define MAP_BELOW4G				    (1<<7)
+
+#define CACHE_DEFAULT	 		    (0<<8)
+#define CACHE_WRITEBACK	 		  (1<<8)
+#define CACHE_WRITETHRU	 		  (2<<8)
+#define CACHE_WRITECOMBINE 		(3<<8)
+#define CACHE_UNCACHEABLE  		(4<<8)
+#define CACHE_WEAKUNCACHEABLE	(5<<8)
+#define CACHE_WRITEPROTECT		(6<<8)
+
+#define PROT_MASK				  0x00000007
+#define CACHE_MASK   		  0x00000f00
+
+
+/*
+ * System call prototypes
+ */
+
+void _swi_debug (char *str);
+
+int _swi_fork (void);
+int _swi_exec (const char *filename, struct execargs *args);
+void _swi_exit (int status);
+int _swi_waitpid (int pid, int *loc_stat, int options);
+int _swi_kill (int pid, int sig);
+int _swi_setschedparams (int policy, int priority);
+
+void *_swi_virtualalloc (void *addr, size_t size, bits32_t flags);
+void *_swi_virtualallocphys (void *addr, size_t size, bits32_t flags, void *phys_addr);
+int _swi_virtualfree (void *addr, size_t sz);
+int _swi_virtualprotect (void *addr, size_t sz, bits32_t flags);
+void *_swi_virtualtophysaddr(void *addr);
+
+int _swi_open (char *name, int oflags, mode_t mode);
+int _swi_close (int handle);
+
+ssize_t _swi_read (int fd, void *buf, size_t nbyte);
+ssize_t _swi_write (int fd, void *buf, size_t nbyte);
+
+int _swi_dup(int fd); 
+int _swi_dup2(int fd1, int fd2);
+
+int _swi_rename (const char *oldname, const char *newname);
+
+int _swi_pipe (int fdp[2]);
+
+int _swi_createinterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api));
+int _swi_maskinterrupt (int irq);
+int _swi_unmaskinterrupt (int irq);
+
+int _swi_sleep(int seconds);
+int _swi_alarm(int seconds);
+int _swi_nanosleep(struct timespec *req, struct timespec *rem);
+
+int _swi_opendir(const char *path);
+ssize_t _swi_readdir (int fd, void *buf, size_t buf_sz);
+int _swi_rewinddir (int fd);
+
+off_t _swi_lseek(int fd, off_t offs, int whence);
+off64_t _swi_lseek64(int fd, off64_t *offs, int whence);
+
+int _swi_mknod2(const char *path, uint32_t flags, struct stat *stat);
+int _swi_createmsgport(const char *path, uint32_t flags, struct stat *stat, int backlog);
+int _swi_unmount(int fd, bool force);
+int _swi_renamemsgport(const char *new_path, const char *old_path);
+int _swi_pivotroot(const char *new_root, const char *old_root);
+
+int _swi_sendrec(int fd, int siov_cnt, struct IOV *siov, int riov_cnt, struct IOV *riov);
+int _swi_getmsg(int portid, msgid_t *msgid, void *buf, size_t buf_sz);
+int _swi_replymsg(int portid, msgid_t msgid, int status, void *buf, size_t buf_sz);
+int _swi_readmsg(int portid, msgid_t msgid, void *buf, size_t buf_sz, off_t offset);
+int _swi_writemsg(int portid, msgid_t msgid, void *buf, size_t buf_sz, off_t offset);
+
+int _swi_stat(char *path, struct stat *stat);
+int _swi_fstat(int fd, struct stat *stat);
+
+int _swi_poll(struct pollfd *pfds, nfds_t nfds, int timeout);
+
+int _swi_signalnotify(int fd, int ino, int signal);
+int _swi_pollnotify(int fd, int ino, short events);
+
+int _swi_chdir(char *path);
+int _swi_fchdir(int fd);
+
+int _swi_fcntl(int fd, int cmd, int arg);
+int _swi_isatty(int fd);
+
+int _swi_fsync(int fd);
+int _swi_sync(void);
+int _swi_chmod(char *_path, mode_t mode);
+int _swi_chown(char *_path, uid_t uid, gid_t gid);
+int _swi_fchmod(int fd, mode_t mode);
+int _swi_fchown(int fd, uid_t uid, gid_t gid);
+
+int _swi_symlink(char *_path, char *_link);
+int _swi_readlink(char *_path, char *_link, size_t link_size);
+
+int _swi_ioctl(int fd, int cmd, void *arg);
+
+int _swi_sigprocmask(int how, const sigset_t *set, sigset_t *oset);
+int _swi_sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
+int _swi_sigpending(sigset_t *set);
+int _swi_sigsuspend(const sigset_t *set);
+
+int _swi_mknod(char *_path, uint32_t flags, struct stat *stat);
+
+int _swi_kqueue(void);
+int _swi_kevent(int kq, const struct kevent *changelist, int nchanges,
+	                struct kevent *eventlist, int nevents,
+	                const struct timespec *timeout);
+
+int _swi_setegid(gid_t gid);
+int _swi_seteuid(uid_t uid);
+int _swi_issetugid(void);
+int	_swi_setgroups(int ngroups, const gid_t *grouplist);
+int _swi_getgroups(int gidsetsize, gid_t grouplist[]);
+
+int _swi_get_priority(id_t who, int *prio);
+int _swi_setpriority(id_t who, int prio);
+
+
+/*
+ * unistd.h 64-bit syscalls.
+ */
+ 
+off64_t lseek64(int fd, off64_t offset, int whence);
+
+/*
+ *
+ */
+void *virtualalloc (void *addr, size_t size, bits32_t flags);
+void *virtualallocphys (void *addr, size_t size, bits32_t flags, void *phys_addr);
+int virtualfree (void *addr, size_t sz);
+int virtualprotect (void *addr, size_t sz, bits32_t flags);
+void *virtualtophysaddr(void *addr);
+
+/*
+ *
+ */
+int sendrec(int fd, int siov_cnt, struct IOV *siov, int riov_cnt, struct IOV *riov);
+int getmsg(int portid, msgid_t *msgid, void *buf, size_t buf_sz);
+int replymsg(int portid, msgid_t msgid, int status, void *buf, size_t buf_sz);
+int readmsg(int portid, msgid_t msgid, void *buf, size_t buf_sz, off_t offset);
+int writemsg(int portid, msgid_t msgid, void *buf, size_t buf_sz, off_t offset);
+
+
+/*
+ *
+ */
+int createinterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api));
+int maskinterrupt (int irq);
+int unmaskinterrupt (int irq);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/syslimits.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/syslimits.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/syslimits.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/syslimits.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,47 @@
+/* "sys/syslimits.h"
+ * 
+ * Values in this file should match those in "limits.h"
+ */
+ 
+#ifndef _SYS_SYSLIMITS_H_
+#define _SYS_SYSLIMITS_H_
+
+
+
+
+/*
+ * Might be useful to make them match limits.h
+ */
+
+#define	ARG_MAX			 4096
+
+#ifndef CHILD_MAX
+#define	CHILD_MAX		    6
+#endif
+
+#define	LINK_MAX		    8
+#define	MAX_CANON		  255
+#define	MAX_INPUT		  255
+#define	NAME_MAX		  255
+#define	NGROUPS_MAX		   16
+
+#ifndef OPEN_MAX
+#define	OPEN_MAX		   64
+#endif
+
+#define	PATH_MAX		 1024
+#define	PIPE_BUF		  512
+#define	IOV_MAX			 1024
+#define	BC_BASE_MAX		   99
+#define	BC_DIM_MAX		 2048
+#define	BC_SCALE_MAX	   99
+#define	BC_STRING_MAX	 1000
+#define	COLL_WEIGHTS_MAX    0
+#define	EXPR_NEST_MAX	   32
+#define	LINE_MAX		 2048
+#define	RE_DUP_MAX		  255
+
+#define	UID_MAX		   2147483647U
+#define	GID_MAX		   2147483647U
+
+#endif /* !_SYS_SYSLIMITS_H_ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/termios.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/termios.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/termios.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,245 @@
+/* termios.h
+ *
+ * termios.h is identical to /sys/termios.h.  Some applications appear to use
+ * different source directories, so this file exists in both directories.
+ */
+
+#ifndef _SYS_TERMIOS_H_
+#define _SYS_TERMIOS_H_
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+
+
+
+
+/*
+ * Control Characters in termios.c_cc[]
+ */
+ 
+#define	VEOF		0
+#define	VEOL		1
+#define	VEOL2		2
+#define	VERASE		3
+#define VWERASE 	4
+#define VKILL		5
+#define	VREPRINT 	6
+#define VINTR		8
+#define VQUIT		9
+#define VSUSP		10
+#define VDSUSP		11
+#define VSTART		12
+#define VSTOP		13
+#define	VLNEXT		14
+#define	VDISCARD	15
+#define VMIN		16
+#define VTIME		17
+#define VSTATUS		18
+#define	NCCS		20
+
+
+
+
+/*
+ * Input flags
+ */
+
+#define	IGNBRK		0x00000001
+#define	BRKINT		0x00000002
+#define	IGNPAR		0x00000004
+#define	PARMRK		0x00000008
+#define	INPCK		0x00000010
+#define	ISTRIP		0x00000020
+#define	INLCR		0x00000040
+#define	IGNCR		0x00000080
+#define	ICRNL		0x00000100
+#define	IXON		0x00000200
+#define	IXOFF		0x00000400
+#define	IXANY		0x00000800
+#define IMAXBEL		0x00002000
+
+
+
+
+/*
+ * Output flags
+ */
+
+#define	OPOST		0x00000001
+#define ONLCR		0x00000002
+#define OXTABS		0x00000004
+#define ONOEOT		0x00000008
+#define OCRNL		0x00000010
+#define ONOCR		0x00000020
+#define ONLRET		0x00000040
+
+
+
+
+/*
+ * Control flags - hardware control of terminal
+ */
+
+#define	CIGNORE		0x00000001
+#define CSIZE		0x00000300
+#define CS5		    0x00000000
+#define CS6		    0x00000100
+#define CS7		    0x00000200
+#define CS8		    0x00000300
+#define CSTOPB		0x00000400
+#define CREAD		0x00000800
+#define PARENB		0x00001000
+#define PARODD		0x00002000
+#define HUPCL		0x00004000
+#define CLOCAL		0x00008000
+#define	CRTSCTS		0x00010000
+#define	CRTS_IFLOW	CRTSCTS
+#define	CCTS_OFLOW	CRTSCTS
+#define	CDTRCTS		0x00020000
+#define	MDMBUF		0x00100000
+#define	CHWFLOW		(MDMBUF|CRTSCTS|CDTRCTS)
+
+
+
+
+/*
+ * Local flags 
+ */
+
+#define	ECHOKE		0x00000001
+#define	ECHOE		0x00000002
+#define	ECHOK		0x00000004
+#define ECHO		0x00000008
+#define	ECHONL		0x00000010
+#define	ECHOPRT		0x00000020
+#define ECHOCTL  	0x00000040
+#define	ISIG		0x00000080
+#define	ICANON		0x00000100
+#define ALTWERASE	0x00000200
+#define	IEXTEN		0x00000400
+#define EXTPROC     0x00000800
+#define TOSTOP		0x00400000
+#define FLUSHO		0x00800000
+#define	NOKERNINFO	0x02000000
+#define PENDIN		0x20000000
+#define	NOFLSH		0x80000000
+
+
+
+
+/*
+ * struct termios and types
+ */
+
+typedef unsigned int	tcflag_t;
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+
+struct termios
+{
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t     c_cc[NCCS];
+	int      c_ispeed;
+	int      c_ospeed;
+};
+
+
+
+
+/*
+ * tcsetattr() action commands
+ */
+ 
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+#define TCSASOFT	0x10
+
+
+
+
+/*
+ * Standard speeds
+ */
+
+#define B0	0
+#define B50	50
+#define B75	75
+#define B110	110
+#define B134	134
+#define B150	150
+#define B200	200
+#define B300	300
+#define B600	600
+#define B1200	1200
+#define	B1800	1800
+#define B2400	2400
+#define B4800	4800
+#define B9600	9600
+#define B19200	19200
+#define B38400	38400
+#define B7200	7200
+#define B14400	14400
+#define B28800	28800
+#define B57600	57600
+#define B76800	76800
+#define B115200	115200
+#define B230400	230400
+#define EXTA	19200
+#define EXTB	38400
+
+
+/*
+ * Line Control
+ */
+
+#define	TCIFLUSH	1
+#define	TCOFLUSH	2
+#define TCIOFLUSH	3
+#define	TCOOFF		1
+#define	TCOON		2
+#define TCIOFF		3
+#define TCION		4
+
+
+/*
+ * Ioctls
+ */
+ 
+#define TCSETS      (('T'<<8) | 1)
+#define TCSETSW     (('T'<<8) | 2)
+#define TCSETSF     (('T'<<8) | 3)
+#define TCGETS      (('T'<<8) | 4)
+
+#define TIOCGPGRP   (('T'<<8) | 5)
+#define TIOCSPGRP   (('T'<<8) | 6)
+#define TCXONC      (('T'<<8) | 7)
+#define TCFLSH      (('T'<<8) | 8)
+
+
+/*
+ * Prototypes
+ */
+
+int	cfsetispeed (struct termios *termios_p, speed_t speed);
+int	cfsetospeed (struct termios *termios_p, speed_t speed);
+int	tcgetattr (int fd, struct termios *termios_p);
+int	tcsetattr (int fd, int actions, const struct termios *termios_p);
+int	tcdrain (int fd);
+int	tcflow (int fd, int actions);
+int	tcflush (int fd, int queue_sel);
+int	tcsendbreak (int fd, int duration);
+pid_t tcgetsid (int fd);
+speed_t	cfgetispeed (const struct termios *termios_p);
+speed_t	cfgetospeed (const struct termios *termios_p);
+void cfmakeraw (struct termios *termios_p);
+int	cfsetspeed (struct termios *termios_p, speed_t speed);
+
+
+
+
+#endif /* !_SYS_TERMIOS_H_ */
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/_types.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/_types.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/_types.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/_types.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,219 @@
+/* ANSI C namespace clean utility typedefs */
+
+/* This file defines various typedefs needed by the system calls that support
+   the C library.  Basically, they're just the POSIX versions with an '_'
+   prepended.  Targets shall use <machine/_types.h> to define their own
+   internal types if desired.
+
+   There are three define patterns used for type definitions.  Lets assume
+   xyz_t is a user type.
+
+   The internal type definition uses __machine_xyz_t_defined.  It is defined by
+   <machine/_types.h> to disable a default definition in <sys/_types.h>. It
+   must not be used in other files.
+
+   User type definitions are guarded by __xyz_t_defined in glibc and
+   _XYZ_T_DECLARED in BSD compatible systems.
+*/
+
+#ifndef	_SYS__TYPES_H
+#define _SYS__TYPES_H
+
+#define __need_size_t
+#define __need_wint_t
+#include <stddef.h>
+#include <newlib.h>
+#include <sys/config.h>
+#include <machine/_types.h>
+
+#ifndef __machine_blkcnt_t_defined
+typedef long __blkcnt_t;
+#endif
+
+#ifndef __machine_blksize_t_defined
+typedef long __blksize_t;
+#endif
+
+#ifndef __machine_fsblkcnt_t_defined
+typedef __uint64_t __fsblkcnt_t;
+#endif
+
+#ifndef __machine_fsfilcnt_t_defined
+typedef __uint32_t __fsfilcnt_t;
+#endif
+
+#ifndef __machine_off_t_defined
+typedef long _off_t;
+#endif
+
+#if defined(__XMK__)
+typedef signed char __pid_t;
+#else
+typedef int __pid_t;
+#endif
+
+#ifndef __machine_dev_t_defined
+typedef short __dev_t;
+#endif
+
+#ifndef __machine_uid_t_defined
+typedef unsigned short __uid_t;
+#endif
+#ifndef __machine_gid_t_defined
+typedef unsigned short __gid_t;
+#endif
+
+#ifndef __machine_id_t_defined
+typedef __uint32_t __id_t;
+#endif
+
+#ifndef __machine_ino_t_defined
+typedef unsigned long __ino_t;
+#endif
+
+#ifndef __machine_mode_t_defined
+#if defined(__i386__) && (defined(GO32) || defined(__MSDOS__))
+typedef int __mode_t;
+#else
+#if defined(__sparc__) && !defined(__sparc_v9__)
+#ifdef __svr4__
+typedef unsigned long __mode_t;
+#else
+typedef unsigned short __mode_t;
+#endif
+#else
+typedef __uint32_t __mode_t;
+#endif
+#endif
+#endif
+
+#ifndef __machine_off64_t_defined
+__extension__ typedef long long _off64_t;
+#endif
+
+#if defined(__CYGWIN__) && !defined(__LP64__)
+typedef _off64_t __off_t;
+#else
+typedef _off_t __off_t;
+#endif
+
+typedef _off64_t __loff_t;
+
+#ifndef __machine_key_t_defined
+typedef long __key_t;
+#endif
+
+/*
+ * We need fpos_t for the following, but it doesn't have a leading "_",
+ * so we use _fpos_t instead.
+ */
+#ifndef __machine_fpos_t_defined
+typedef long _fpos_t;		/* XXX must match off_t in <sys/types.h> */
+				/* (and must be `long' for now) */
+#endif
+
+#ifdef __LARGE64_FILES
+#ifndef __machine_fpos64_t_defined
+typedef _off64_t _fpos64_t;
+#endif
+#endif
+
+/* Defined by GCC provided <stddef.h> */
+#undef __size_t
+
+#ifndef __machine_size_t_defined
+#ifdef __SIZE_TYPE__
+typedef __SIZE_TYPE__ __size_t;
+#else
+#if defined(__INT_MAX__) && __INT_MAX__ == 2147483647
+typedef unsigned int __size_t;
+#else
+typedef unsigned long __size_t;
+#endif
+#endif
+#endif
+
+#ifndef __machine_ssize_t_defined
+#ifdef __SIZE_TYPE__
+/* If __SIZE_TYPE__ is defined (gcc) we define ssize_t based on size_t.
+   We simply change "unsigned" to "signed" for this single definition
+   to make sure ssize_t and size_t only differ by their signedness. */
+#define unsigned signed
+typedef __SIZE_TYPE__ _ssize_t;
+#undef unsigned
+#else
+#if defined(__INT_MAX__) && __INT_MAX__ == 2147483647
+typedef int _ssize_t;
+#else
+typedef long _ssize_t;
+#endif
+#endif
+#endif
+
+typedef _ssize_t __ssize_t;
+
+#ifndef __machine_mbstate_t_defined
+/* Conversion state information.  */
+typedef struct
+{
+  int __count;
+  union
+  {
+    wint_t __wch;
+    unsigned char __wchb[4];
+  } __value;		/* Value so far.  */
+} _mbstate_t;
+#endif
+
+#ifndef __machine_iconv_t_defined
+/* Iconv descriptor type */
+typedef void *_iconv_t;
+#endif
+
+#ifndef __machine_clock_t_defined
+#define	_CLOCK_T_	unsigned long	/* clock() */
+#endif
+
+typedef	_CLOCK_T_	__clock_t;
+
+#if defined(_USE_LONG_TIME_T) || __LONG_MAX__ > 0x7fffffffL
+#define	_TIME_T_ long
+#else
+#define	_TIME_T_ __int_least64_t
+#endif
+typedef	_TIME_T_	__time_t;
+
+#ifndef __machine_clockid_t_defined
+#define	_CLOCKID_T_ 	unsigned long
+#endif
+
+typedef	_CLOCKID_T_	__clockid_t;
+
+#define	_TIMER_T_	unsigned long
+typedef	_TIMER_T_	__timer_t;
+
+#ifndef __machine_sa_family_t_defined
+typedef	__uint8_t	__sa_family_t;
+#endif
+
+#ifndef __machine_socklen_t_defined
+typedef	__uint32_t	__socklen_t;
+#endif
+
+typedef	int		__nl_item;
+typedef	unsigned short	__nlink_t;
+typedef	long		__suseconds_t;	/* microseconds (signed) */
+typedef	unsigned long	__useconds_t;	/* microseconds (unsigned) */
+
+/*
+ * Must be identical to the __GNUCLIKE_BUILTIN_VAALIST definition in
+ * <sys/cdefs.h>.  The <sys/cdefs.h> must not be included here to avoid cyclic
+ * header dependencies.
+ */
+#if __GNUC_MINOR__ > 95 || __GNUC__ >= 3
+typedef	__builtin_va_list	__va_list;
+#else
+typedef	char *			__va_list;
+#endif
+
+#endif	/* _SYS__TYPES_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/types.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/types.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/types.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/types.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,232 @@
+/* unified sys/types.h: 
+   start with sef's sysvi386 version.
+   merge go32 version -- a few ifdefs.
+   h8300hms, h8300xray, and sysvnecv70 disagree on the following types:
+
+   typedef int gid_t;
+   typedef int uid_t;
+   typedef int dev_t;
+   typedef int ino_t;
+   typedef int mode_t;
+   typedef int caddr_t;
+
+   however, these aren't "reasonable" values, the sysvi386 ones make far 
+   more sense, and should work sufficiently well (in particular, h8300 
+   doesn't have a stat, and the necv70 doesn't matter.) -- eichin
+ */
+
+#ifndef _SYS_TYPES_H
+
+#include <_ansi.h>
+#include <sys/cdefs.h>
+#include <machine/_types.h>
+
+/* BSD types permitted by POSIX and always exposed as in Glibc.  Only provided
+   for backward compatibility with BSD code.  The uintN_t standard types should
+   be preferred in new code. */
+#if ___int8_t_defined
+typedef __uint8_t	u_int8_t;
+#endif
+#if ___int16_t_defined
+typedef __uint16_t	u_int16_t;
+#endif 
+#if ___int32_t_defined
+typedef __uint32_t	u_int32_t;
+#endif
+#if ___int64_t_defined
+typedef __uint64_t	u_int64_t;
+#endif
+typedef __intptr_t register_t;
+#define __BIT_TYPES_DEFINED__ 1
+
+#ifndef __need_inttypes
+
+#define _SYS_TYPES_H
+#include <sys/_types.h>
+#include <sys/_stdint.h>
+
+#if __BSD_VISIBLE
+#include <machine/endian.h>
+#include <sys/select.h>
+#  define	physadr		physadr_t
+#  define	quad		quad_t
+
+#ifndef _IN_ADDR_T_DECLARED
+typedef	__uint32_t	in_addr_t;	/* base type for internet address */
+#define	_IN_ADDR_T_DECLARED
+#endif
+
+#ifndef _IN_PORT_T_DECLARED
+typedef	__uint16_t	in_port_t;
+#define	_IN_PORT_T_DECLARED
+#endif
+
+typedef	__uintptr_t	u_register_t;
+#endif /* __BSD_VISIBLE */
+
+#define NBBY	8									/* Number of Bits per Byte */
+
+#if __MISC_VISIBLE
+#ifndef _BSDTYPES_DEFINED
+/* also defined in mingw/gmon.h and in w32api/winsock[2].h */
+#ifndef __u_char_defined
+typedef	unsigned char	u_char;
+#define __u_char_defined
+#endif
+#ifndef __u_short_defined
+typedef	unsigned short	u_short;
+#define __u_short_defined
+#endif
+#ifndef __u_int_defined
+typedef	unsigned int	u_int;
+#define __u_int_defined
+#endif
+#ifndef __u_long_defined
+typedef	unsigned long	u_long;
+#define __u_long_defined
+#endif
+#define _BSDTYPES_DEFINED
+#endif
+#endif /* __MISC_VISIBLE */
+
+#if __MISC_VISIBLE
+typedef	unsigned short	ushort;		/* System V compatibility */
+typedef	unsigned int	uint;		/* System V compatibility */
+typedef	unsigned long	ulong;		/* System V compatibility */
+#endif
+
+#ifndef _BLKCNT_T_DECLARED
+typedef	__blkcnt_t	blkcnt_t;
+#define	_BLKCNT_T_DECLARED
+#endif
+
+#ifndef _BLKSIZE_T_DECLARED
+typedef	__blksize_t	blksize_t;
+#define	_BLKSIZE_T_DECLARED
+#endif
+
+#if !defined(__clock_t_defined) && !defined(_CLOCK_T_DECLARED)
+typedef	_CLOCK_T_	clock_t;
+#define	__clock_t_defined
+#define	_CLOCK_T_DECLARED
+#endif
+
+#if !defined(__time_t_defined) && !defined(_TIME_T_DECLARED)
+typedef	_TIME_T_	time_t;
+#define	__time_t_defined
+#define	_TIME_T_DECLARED
+#endif
+
+#ifndef __daddr_t_defined
+typedef	long	daddr_t;
+#define __daddr_t_defined
+#endif
+#ifndef __caddr_t_defined
+typedef	char *	caddr_t;
+#define __caddr_t_defined
+#endif
+
+#ifndef _FSBLKCNT_T_DECLARED		/* for statvfs() */
+typedef	__fsblkcnt_t	fsblkcnt_t;
+typedef	__fsfilcnt_t	fsfilcnt_t;
+#define	_FSBLKCNT_T_DECLARED
+#endif
+
+#ifndef _ID_T_DECLARED
+typedef	__id_t		id_t;		/* can hold a uid_t or pid_t */
+#define	_ID_T_DECLARED
+#endif
+
+#ifndef _INO_T_DECLARED
+typedef	__ino_t		ino_t;		/* inode number */
+#define	_INO_T_DECLARED
+#endif
+
+#if defined(__i386__) && (defined(GO32) || defined(__MSDOS__))
+typedef	char *		addr_t;
+typedef unsigned long vm_offset_t;
+typedef unsigned long vm_size_t;
+#endif /* __i386__ && (GO32 || __MSDOS__) */
+
+/*
+ * All these should be machine specific - right now they are all broken.
+ * However, for all of Cygnus' embedded targets, we want them to all be
+ * the same.  Otherwise things like sizeof (struct stat) might depend on
+ * how the file was compiled (e.g. -mint16 vs -mint32, etc.).
+ */
+
+#ifndef _OFF_T_DECLARED
+typedef	__off_t		off_t;		/* file offset */
+#define	_OFF_T_DECLARED
+#endif
+#ifndef _DEV_T_DECLARED
+typedef	__dev_t		dev_t;		/* device number or struct cdev */
+#define	_DEV_T_DECLARED
+#endif
+#ifndef _UID_T_DECLARED
+typedef	__uid_t		uid_t;		/* user id */
+#define	_UID_T_DECLARED
+#endif
+#ifndef _GID_T_DECLARED
+typedef	__gid_t		gid_t;		/* group id */
+#define	_GID_T_DECLARED
+#endif
+
+#ifndef _PID_T_DECLARED
+typedef	__pid_t		pid_t;		/* process id */
+#define	_PID_T_DECLARED
+#endif
+
+#ifndef _KEY_T_DECLARED
+typedef	__key_t		key_t;		/* IPC key */
+#define	_KEY_T_DECLARED
+#endif
+
+#ifndef _SSIZE_T_DECLARED
+typedef _ssize_t ssize_t;
+#define	_SSIZE_T_DECLARED
+#endif
+
+#ifndef _MODE_T_DECLARED
+typedef	__mode_t	mode_t;		/* permissions */
+#define	_MODE_T_DECLARED
+#endif
+
+#ifndef _NLINK_T_DECLARED
+typedef	__nlink_t	nlink_t;	/* link count */
+#define	_NLINK_T_DECLARED
+#endif
+
+#if !defined(__clockid_t_defined) && !defined(_CLOCKID_T_DECLARED)
+typedef	__clockid_t	clockid_t;
+#define	__clockid_t_defined
+#define	_CLOCKID_T_DECLARED
+#endif
+
+#if !defined(__timer_t_defined) && !defined(_TIMER_T_DECLARED)
+typedef	__timer_t	timer_t;
+#define	__timer_t_defined
+#define	_TIMER_T_DECLARED
+#endif
+
+#ifndef _USECONDS_T_DECLARED
+typedef	__useconds_t	useconds_t;	/* microseconds (unsigned) */
+#define	_USECONDS_T_DECLARED
+#endif
+
+#ifndef _SUSECONDS_T_DECLARED
+typedef	__suseconds_t	suseconds_t;
+#define	_SUSECONDS_T_DECLARED
+#endif
+
+typedef	__int64_t	sbintime_t;
+
+#include <sys/features.h>
+#include <sys/_pthreadtypes.h>
+#include <machine/types.h>
+
+#endif  /* !__need_inttypes */
+
+#undef __need_inttypes
+
+#endif	/* _SYS_TYPES_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/uio.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/uio.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/uio.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/uio.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,18 @@
+#ifndef _SYS_UIO_H
+#define _SYS_UIO_H
+
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#define UIO_MAXIOV 64
+
+struct iovec {
+	void *iov_base;
+	size_t iov_len;
+};
+
+ssize_t readv(int fd, const struct iovec *iov, int iovcnt);
+ssize_t writev(int fd, const struct iovec *iov, int iovcnt);
+
+#endif
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/unistd.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/unistd.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/unistd.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/unistd.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,604 @@
+#ifndef _SYS_UNISTD_H
+#define _SYS_UNISTD_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#define __need_size_t
+#define __need_ptrdiff_t
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/_types.h>
+#include <stddef.h>
+
+extern char **environ;
+
+void	_exit (int __status) _ATTRIBUTE ((__noreturn__));
+
+int	access (const char *__path, int __amode);
+unsigned  alarm (unsigned __secs);
+int     chdir (const char *__path);
+int     chmod (const char *__path, mode_t __mode);
+#if !defined(__INSIDE_CYGWIN__)
+int     chown (const char *__path, uid_t __owner, gid_t __group);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200112)
+int     chroot (const char *__path);
+#endif
+int     close (int __fildes);
+#if __POSIX_VISIBLE >= 199209
+size_t	confstr (int __name, char *__buf, size_t __len);
+#endif
+#if __XSI_VISIBLE
+char *  crypt (const char *__key, const char *__salt);
+#endif
+#if __XSI_VISIBLE && __XSI_VISIBLE < 700
+char *  ctermid (char *__s);
+#endif
+#if __XSI_VISIBLE && __XSI_VISIBLE < 600
+char *  cuserid (char *__s);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+int	daemon (int nochdir, int noclose);
+#endif
+int     dup (int __fildes);
+int     dup2 (int __fildes, int __fildes2);
+#if __GNU_VISIBLE
+int     dup3 (int __fildes, int __fildes2, int flags);
+int	eaccess (const char *__path, int __mode);
+#endif
+#if __XSI_VISIBLE
+void	encrypt (char *__block, int __edflag);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+void	endusershell (void);
+#endif
+#if __GNU_VISIBLE
+int	euidaccess (const char *__path, int __mode);
+#endif
+int     execl (const char *__path, const char *, ...);
+int     execle (const char *__path, const char *, ...);
+int     execlp (const char *__file, const char *, ...);
+#if __MISC_VISIBLE
+int     execlpe (const char *__file, const char *, ...);
+#endif
+int     execv (const char *__path, char * const __argv[]);
+int     execve (const char *__path, char * const __argv[], char * const __envp[]);
+int     execvp (const char *__file, char * const __argv[]);
+#if __GNU_VISIBLE
+int     execvpe (const char *__file, char * const __argv[], char * const __envp[]);
+#endif
+#if __ATFILE_VISIBLE
+int	faccessat (int __dirfd, const char *__path, int __mode, int __flags);
+#endif
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int     fchdir (int __fildes);
+#endif
+#if __POSIX_VISIBLE >= 199309
+int     fchmod (int __fildes, mode_t __mode);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int     fchown (int __fildes, uid_t __owner, gid_t __group);
+#endif
+#endif
+#if __ATFILE_VISIBLE
+int	fchownat (int __dirfd, const char *__path, uid_t __owner, gid_t __group, int __flags);
+#endif
+#if __POSIX_VISIBLE >= 200809
+int	fexecve (int __fd, char * const __argv[], char * const __envp[]);
+#endif
+pid_t   fork (void);
+long    fpathconf (int __fd, int __name);
+int     fsync (int __fd);
+#if __POSIX_VISIBLE >= 199309
+int     fdatasync (int __fd);
+#endif
+#if __GNU_VISIBLE
+char *  get_current_dir_name (void);
+#endif
+char *  getcwd (char *__buf, size_t __size);
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+int	getdomainname  (char *__name, size_t __len);
+#endif
+#if __BSD_VISIBLE
+int     getentropy (void *, size_t);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+gid_t   getegid (void);
+uid_t   geteuid (void);
+gid_t   getgid (void);
+#endif
+int     getgroups (int __gidsetsize, gid_t __grouplist[]);
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4
+long    gethostid (void);
+#endif
+char *  getlogin (void);
+#if defined(_POSIX_THREAD_SAFE_FUNCTIONS)
+int getlogin_r (char *name, size_t namesize) ;
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __POSIX_VISIBLE < 200112)
+char *  getpass (const char *__prompt);
+int	getpagesize (void);
+#endif
+#if __BSD_VISIBLE
+int    getpeereid (int, uid_t *, gid_t *);
+#endif
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 4
+pid_t   getpgid (pid_t);
+#endif
+pid_t   getpgrp (void);
+pid_t   getpid (void);
+pid_t   getppid (void);
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 4
+pid_t   getsid (pid_t);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+uid_t   getuid (void);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+char *	getusershell (void);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200809)
+char *  getwd (char *__buf);
+#endif
+#if __BSD_VISIBLE
+int	iruserok (unsigned long raddr, int superuser, const char *ruser, const char *luser);
+#endif
+int     isatty (int __fildes);
+#if __BSD_VISIBLE
+int        issetugid (void);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int     lchown (const char *__path, uid_t __owner, gid_t __group);
+#endif
+#endif
+int     link (const char *__path1, const char *__path2);
+#if __ATFILE_VISIBLE
+int     linkat (int __dirfd1, const char *__path1, int __dirfd2, const char *__path2, int __flags);
+#endif
+#if __MISC_VISIBLE || __XSI_VISIBLE
+int	nice (int __nice_value);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+off_t   lseek (int __fildes, off_t __offset, int __whence);
+#endif
+#if __MISC_VISIBLE || __XSI_VISIBLE >= 4
+#define F_ULOCK	0
+#define F_LOCK	1
+#define F_TLOCK	2
+#define F_TEST	3
+int     lockf (int __fd, int __cmd, off_t __len);
+#endif
+long    pathconf (const char *__path, int __name);
+int     pause (void);
+#if __POSIX_VISIBLE >= 199506
+int	pthread_atfork (void (*)(void), void (*)(void), void (*)(void));
+#endif
+int     pipe (int __fildes[2]);
+#if __GNU_VISIBLE
+int     pipe2 (int __fildes[2], int flags);
+#endif
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
+ssize_t pread (int __fd, void *__buf, size_t __nbytes, off_t __offset);
+ssize_t pwrite (int __fd, const void *__buf, size_t __nbytes, off_t __offset);
+#endif
+_READ_WRITE_RETURN_TYPE read (int __fd, void *__buf, size_t __nbyte);
+#if __BSD_VISIBLE
+int	rresvport (int *__alport);
+int	revoke (char *__path);
+#endif
+int     rmdir (const char *__path);
+#if __BSD_VISIBLE
+int	ruserok (const char *rhost, int superuser, const char *ruser, const char *luser);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200112)
+void *  sbrk (ptrdiff_t __incr);
+#endif
+#if !defined(__INSIDE_CYGWIN__)
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200112
+int     setegid (gid_t __gid);
+int     seteuid (uid_t __uid);
+#endif
+int     setgid (gid_t __gid);
+#endif
+#if __BSD_VISIBLE
+int	setgroups (int ngroups, const gid_t *grouplist);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+int	sethostname (const char *, size_t);
+#endif
+int     setpgid (pid_t __pid, pid_t __pgid);
+#if __SVID_VISIBLE || __XSI_VISIBLE >= 500
+int     setpgrp (void);
+#endif
+#if (__BSD_VISIBLE || __XSI_VISIBLE >= 4) && !defined(__INSIDE_CYGWIN__)
+int	setregid (gid_t __rgid, gid_t __egid);
+int	setreuid (uid_t __ruid, uid_t __euid);
+#endif
+pid_t   setsid (void);
+#if !defined(__INSIDE_CYGWIN__)
+int     setuid (uid_t __uid);
+#endif
+#if __BSD_VISIBLE || (__XSI_VISIBLE && __XSI_VISIBLE < 500)
+void	setusershell (void);
+#endif
+unsigned sleep (unsigned int __seconds);
+#if __XSI_VISIBLE
+void    swab (const void *__restrict, void *__restrict, ssize_t);
+#endif
+long    sysconf (int __name);
+pid_t   tcgetpgrp (int __fildes);
+int     tcsetpgrp (int __fildes, pid_t __pgrp_id);
+char *  ttyname (int __fildes);
+int     ttyname_r (int, char *, size_t);
+int     unlink (const char *__path);
+#if __XSI_VISIBLE >= 500 && __POSIX_VISIBLE < 200809 || __BSD_VISIBLE
+int 	usleep (useconds_t __useconds);
+#endif
+#if __BSD_VISIBLE
+int     vhangup (void);
+#endif
+_READ_WRITE_RETURN_TYPE write (int __fd, const void *__buf, size_t __nbyte);
+
+#ifdef __CYGWIN__
+# define __UNISTD_GETOPT__
+# include <getopt.h>
+# undef __UNISTD_GETOPT__
+#else
+extern char *optarg;			/* getopt(3) external variables */
+extern int optind, opterr, optopt;
+int	 getopt(int, char * const [], const char *);
+extern int optreset;			/* getopt(3) external variable */
+#endif
+
+#if __BSD_VISIBLE || (__XSI_VISIBLE >= 4 && __POSIX_VISIBLE < 200809)
+pid_t   vfork (void);
+#endif
+
+#ifdef _COMPILING_NEWLIB
+/* Provide prototypes for most of the _<systemcall> names that are
+   provided in newlib for some compilers.  */
+int     _close (int __fildes);
+pid_t   _fork (void);
+pid_t   _getpid (void);
+int	_isatty (int __fildes);
+int     _link (const char *__path1, const char *__path2);
+_off_t   _lseek (int __fildes, _off_t __offset, int __whence);
+#ifdef __LARGE64_FILES
+_off64_t _lseek64 (int __filedes, _off64_t __offset, int __whence);
+#endif
+_READ_WRITE_RETURN_TYPE _read (int __fd, void *__buf, size_t __nbyte);
+void *  _sbrk (ptrdiff_t __incr);
+int     _unlink (const char *__path);
+_READ_WRITE_RETURN_TYPE _write (int __fd, const void *__buf, size_t __nbyte);
+int     _execve (const char *__path, char * const __argv[], char * const __envp[]);
+#endif
+
+#if !defined(__INSIDE_CYGWIN__)
+#if __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 500
+int     ftruncate (int __fd, off_t __length);
+#endif
+#if __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
+int     truncate (const char *, off_t __length);
+#endif
+#endif
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE < 200112
+int	getdtablesize (void);
+#endif
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200809 || __XSI_VISIBLE >= 500
+useconds_t ualarm (useconds_t __useconds, useconds_t __interval);
+#endif
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 500
+#if !(defined  (_WINSOCK_H) || defined (_WINSOCKAPI_) || defined (__USE_W32_SOCKETS))
+/* winsock[2].h defines as __stdcall, and with int as 2nd arg */
+ int	gethostname (char *__name, size_t __len);
+#endif
+#endif
+
+#if __MISC_VISIBLE
+int	setdtablesize (int);
+#endif
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 500
+void    sync (void);
+#endif
+
+#if __BSD_VISIBLE || __POSIX_VISIBLE >= 200112 || __XSI_VISIBLE >= 4
+ssize_t readlink (const char *__restrict __path,
+                          char *__restrict __buf, size_t __buflen);
+int     symlink (const char *__name1, const char *__name2);
+#endif
+#if __ATFILE_VISIBLE
+ssize_t        readlinkat (int __dirfd1, const char *__restrict __path,
+                            char *__restrict __buf, size_t __buflen);
+int	symlinkat (const char *, int, const char *);
+int	unlinkat (int, const char *, int);
+#endif
+
+#define	F_OK	0
+#define	R_OK	4
+#define	W_OK	2
+#define	X_OK	1
+
+# define	SEEK_SET	0
+# define	SEEK_CUR	1
+# define	SEEK_END	2
+
+#include <sys/features.h>
+
+#define STDIN_FILENO    0       /* standard input file descriptor */
+#define STDOUT_FILENO   1       /* standard output file descriptor */
+#define STDERR_FILENO   2       /* standard error file descriptor */
+
+/*
+ *  sysconf values per IEEE Std 1003.1, 2008 Edition
+ */
+
+#define _SC_ARG_MAX                       0
+#define _SC_CHILD_MAX                     1
+#define _SC_CLK_TCK                       2
+#define _SC_NGROUPS_MAX                   3
+#define _SC_OPEN_MAX                      4
+#define _SC_JOB_CONTROL                   5
+#define _SC_SAVED_IDS                     6
+#define _SC_VERSION                       7
+#define _SC_PAGESIZE                      8
+#define _SC_PAGE_SIZE                     _SC_PAGESIZE
+/* These are non-POSIX values we accidentally introduced in 2000 without
+   guarding them.  Keeping them unguarded for backward compatibility. */
+#define _SC_NPROCESSORS_CONF              9
+#define _SC_NPROCESSORS_ONLN             10
+#define _SC_PHYS_PAGES                   11
+#define _SC_AVPHYS_PAGES                 12
+/* End of non-POSIX values. */
+#define _SC_MQ_OPEN_MAX                  13
+#define _SC_MQ_PRIO_MAX                  14
+#define _SC_RTSIG_MAX                    15
+#define _SC_SEM_NSEMS_MAX                16
+#define _SC_SEM_VALUE_MAX                17
+#define _SC_SIGQUEUE_MAX                 18
+#define _SC_TIMER_MAX                    19
+#define _SC_TZNAME_MAX                   20
+#define _SC_ASYNCHRONOUS_IO              21
+#define _SC_FSYNC                        22
+#define _SC_MAPPED_FILES                 23
+#define _SC_MEMLOCK                      24
+#define _SC_MEMLOCK_RANGE                25
+#define _SC_MEMORY_PROTECTION            26
+#define _SC_MESSAGE_PASSING              27
+#define _SC_PRIORITIZED_IO               28
+#define _SC_REALTIME_SIGNALS             29
+#define _SC_SEMAPHORES                   30
+#define _SC_SHARED_MEMORY_OBJECTS        31
+#define _SC_SYNCHRONIZED_IO              32
+#define _SC_TIMERS                       33
+#define _SC_AIO_LISTIO_MAX               34
+#define _SC_AIO_MAX                      35
+#define _SC_AIO_PRIO_DELTA_MAX           36
+#define _SC_DELAYTIMER_MAX               37
+#define _SC_THREAD_KEYS_MAX              38
+#define _SC_THREAD_STACK_MIN             39
+#define _SC_THREAD_THREADS_MAX           40
+#define _SC_TTY_NAME_MAX                 41
+#define _SC_THREADS                      42
+#define _SC_THREAD_ATTR_STACKADDR        43
+#define _SC_THREAD_ATTR_STACKSIZE        44
+#define _SC_THREAD_PRIORITY_SCHEDULING   45
+#define _SC_THREAD_PRIO_INHERIT          46
+/* _SC_THREAD_PRIO_PROTECT was _SC_THREAD_PRIO_CEILING in early drafts */
+#define _SC_THREAD_PRIO_PROTECT          47
+#define _SC_THREAD_PRIO_CEILING          _SC_THREAD_PRIO_PROTECT
+#define _SC_THREAD_PROCESS_SHARED        48
+#define _SC_THREAD_SAFE_FUNCTIONS        49
+#define _SC_GETGR_R_SIZE_MAX             50
+#define _SC_GETPW_R_SIZE_MAX             51
+#define _SC_LOGIN_NAME_MAX               52
+#define _SC_THREAD_DESTRUCTOR_ITERATIONS 53
+#define _SC_ADVISORY_INFO                54
+#define _SC_ATEXIT_MAX                   55
+#define _SC_BARRIERS                     56
+#define _SC_BC_BASE_MAX                  57
+#define _SC_BC_DIM_MAX                   58
+#define _SC_BC_SCALE_MAX                 59
+#define _SC_BC_STRING_MAX                60
+#define _SC_CLOCK_SELECTION              61
+#define _SC_COLL_WEIGHTS_MAX             62
+#define _SC_CPUTIME                      63
+#define _SC_EXPR_NEST_MAX                64
+#define _SC_HOST_NAME_MAX                65
+#define _SC_IOV_MAX                      66
+#define _SC_IPV6                         67
+#define _SC_LINE_MAX                     68
+#define _SC_MONOTONIC_CLOCK              69
+#define _SC_RAW_SOCKETS                  70
+#define _SC_READER_WRITER_LOCKS          71
+#define _SC_REGEXP                       72
+#define _SC_RE_DUP_MAX                   73
+#define _SC_SHELL                        74
+#define _SC_SPAWN                        75
+#define _SC_SPIN_LOCKS                   76
+#define _SC_SPORADIC_SERVER              77
+#define _SC_SS_REPL_MAX                  78
+#define _SC_SYMLOOP_MAX                  79
+#define _SC_THREAD_CPUTIME               80
+#define _SC_THREAD_SPORADIC_SERVER       81
+#define _SC_TIMEOUTS                     82
+#define _SC_TRACE                        83
+#define _SC_TRACE_EVENT_FILTER           84
+#define _SC_TRACE_EVENT_NAME_MAX         85
+#define _SC_TRACE_INHERIT                86
+#define _SC_TRACE_LOG                    87
+#define _SC_TRACE_NAME_MAX               88
+#define _SC_TRACE_SYS_MAX                89
+#define _SC_TRACE_USER_EVENT_MAX         90
+#define _SC_TYPED_MEMORY_OBJECTS         91
+#define _SC_V7_ILP32_OFF32               92
+#define _SC_V6_ILP32_OFF32               _SC_V7_ILP32_OFF32
+#define _SC_XBS5_ILP32_OFF32             _SC_V7_ILP32_OFF32
+#define _SC_V7_ILP32_OFFBIG              93
+#define _SC_V6_ILP32_OFFBIG              _SC_V7_ILP32_OFFBIG
+#define _SC_XBS5_ILP32_OFFBIG            _SC_V7_ILP32_OFFBIG
+#define _SC_V7_LP64_OFF64                94
+#define _SC_V6_LP64_OFF64                _SC_V7_LP64_OFF64
+#define _SC_XBS5_LP64_OFF64              _SC_V7_LP64_OFF64
+#define _SC_V7_LPBIG_OFFBIG              95
+#define _SC_V6_LPBIG_OFFBIG              _SC_V7_LPBIG_OFFBIG
+#define _SC_XBS5_LPBIG_OFFBIG            _SC_V7_LPBIG_OFFBIG
+#define _SC_XOPEN_CRYPT                  96
+#define _SC_XOPEN_ENH_I18N               97
+#define _SC_XOPEN_LEGACY                 98
+#define _SC_XOPEN_REALTIME               99
+#define _SC_STREAM_MAX                  100
+#define _SC_PRIORITY_SCHEDULING         101
+#define _SC_XOPEN_REALTIME_THREADS      102
+#define _SC_XOPEN_SHM                   103
+#define _SC_XOPEN_STREAMS               104
+#define _SC_XOPEN_UNIX                  105
+#define _SC_XOPEN_VERSION               106
+#define _SC_2_CHAR_TERM                 107
+#define _SC_2_C_BIND                    108
+#define _SC_2_C_DEV                     109
+#define _SC_2_FORT_DEV                  110
+#define _SC_2_FORT_RUN                  111
+#define _SC_2_LOCALEDEF                 112
+#define _SC_2_PBS                       113
+#define _SC_2_PBS_ACCOUNTING            114
+#define _SC_2_PBS_CHECKPOINT            115
+#define _SC_2_PBS_LOCATE                116
+#define _SC_2_PBS_MESSAGE               117
+#define _SC_2_PBS_TRACK                 118
+#define _SC_2_SW_DEV                    119
+#define _SC_2_UPE                       120
+#define _SC_2_VERSION                   121
+#define _SC_THREAD_ROBUST_PRIO_INHERIT  122
+#define _SC_THREAD_ROBUST_PRIO_PROTECT  123
+#define _SC_XOPEN_UUCP                  124
+#define _SC_LEVEL1_ICACHE_SIZE          125
+#define _SC_LEVEL1_ICACHE_ASSOC         126
+#define _SC_LEVEL1_ICACHE_LINESIZE      127
+#define _SC_LEVEL1_DCACHE_SIZE          128
+#define _SC_LEVEL1_DCACHE_ASSOC         129
+#define _SC_LEVEL1_DCACHE_LINESIZE      130
+#define _SC_LEVEL2_CACHE_SIZE           131
+#define _SC_LEVEL2_CACHE_ASSOC          132
+#define _SC_LEVEL2_CACHE_LINESIZE       133
+#define _SC_LEVEL3_CACHE_SIZE           134
+#define _SC_LEVEL3_CACHE_ASSOC          135
+#define _SC_LEVEL3_CACHE_LINESIZE       136
+#define _SC_LEVEL4_CACHE_SIZE           137
+#define _SC_LEVEL4_CACHE_ASSOC          138
+#define _SC_LEVEL4_CACHE_LINESIZE       139
+#define _SC_POSIX_26_VERSION            140
+
+
+
+
+
+/*
+ *  pathconf values per IEEE Std 1003.1, 2008 Edition
+ */
+
+#define _PC_LINK_MAX                      0
+#define _PC_MAX_CANON                     1
+#define _PC_MAX_INPUT                     2
+#define _PC_NAME_MAX                      3
+#define _PC_PATH_MAX                      4
+#define _PC_PIPE_BUF                      5
+#define _PC_CHOWN_RESTRICTED              6
+#define _PC_NO_TRUNC                      7
+#define _PC_VDISABLE                      8
+#define _PC_ASYNC_IO                      9
+#define _PC_PRIO_IO                      10
+#define _PC_SYNC_IO                      11
+#define _PC_FILESIZEBITS                 12
+#define _PC_2_SYMLINKS                   13
+#define _PC_SYMLINK_MAX                  14
+#define _PC_ALLOC_SIZE_MIN               15
+#define _PC_REC_INCR_XFER_SIZE           16
+#define _PC_REC_MAX_XFER_SIZE            17
+#define _PC_REC_MIN_XFER_SIZE            18
+#define _PC_REC_XFER_ALIGN               19
+#define _PC_TIMESTAMP_RESOLUTION         20
+#ifdef __CYGWIN__
+/* Ask for POSIX permission bits support. */
+#define _PC_POSIX_PERMISSIONS            90
+/* Ask for full POSIX permission support including uid/gid settings. */
+#define _PC_POSIX_SECURITY               91
+#define _PC_CASE_INSENSITIVE             92
+#endif
+
+/*
+ *  confstr values per IEEE Std 1003.1, 2004 Edition
+ */
+
+/* Only defined on Cygwin and RTEMS for now. */
+#if defined (__CYGWIN__) || defined(__rtems__)
+#define _CS_PATH                               0
+#define _CS_POSIX_V7_ILP32_OFF32_CFLAGS        1
+#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS       _CS_POSIX_V7_ILP32_OFF32_CFLAGS
+#define _CS_XBS5_ILP32_OFF32_CFLAGS           _CS_POSIX_V7_ILP32_OFF32_CFLAGS
+#define _CS_POSIX_V7_ILP32_OFF32_LDFLAGS       2
+#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS      _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
+#define _CS_XBS5_ILP32_OFF32_LDFLAGS          _CS_POSIX_V7_ILP32_OFF32_LDFLAGS
+#define _CS_POSIX_V7_ILP32_OFF32_LIBS          3
+#define _CS_POSIX_V6_ILP32_OFF32_LIBS         _CS_POSIX_V7_ILP32_OFF32_LIBS
+#define _CS_XBS5_ILP32_OFF32_LIBS             _CS_POSIX_V7_ILP32_OFF32_LIBS
+#define _CS_XBS5_ILP32_OFF32_LINTFLAGS         4
+#define _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS       5
+#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS      _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_CFLAGS          _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS
+#define _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS      6
+#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS     _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
+#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS         _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS
+#define _CS_POSIX_V7_ILP32_OFFBIG_LIBS         7
+#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS        _CS_POSIX_V7_ILP32_OFFBIG_LIBS
+#define _CS_XBS5_ILP32_OFFBIG_LIBS            _CS_POSIX_V7_ILP32_OFFBIG_LIBS
+#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS        8
+#define _CS_POSIX_V7_LP64_OFF64_CFLAGS         9
+#define _CS_POSIX_V6_LP64_OFF64_CFLAGS        _CS_POSIX_V7_LP64_OFF64_CFLAGS
+#define _CS_XBS5_LP64_OFF64_CFLAGS            _CS_POSIX_V7_LP64_OFF64_CFLAGS
+#define _CS_POSIX_V7_LP64_OFF64_LDFLAGS       10
+#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS       _CS_POSIX_V7_LP64_OFF64_LDFLAGS
+#define _CS_XBS5_LP64_OFF64_LDFLAGS           _CS_POSIX_V7_LP64_OFF64_LDFLAGS
+#define _CS_POSIX_V7_LP64_OFF64_LIBS          11
+#define _CS_POSIX_V6_LP64_OFF64_LIBS          _CS_POSIX_V7_LP64_OFF64_LIBS
+#define _CS_XBS5_LP64_OFF64_LIBS              _CS_POSIX_V7_LP64_OFF64_LIBS
+#define _CS_XBS5_LP64_OFF64_LINTFLAGS         12
+#define _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS      13
+#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS      _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
+#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS          _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS     14
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS     _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
+#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS         _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS
+#define _CS_POSIX_V7_LPBIG_OFFBIG_LIBS        15
+#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS        _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
+#define _CS_XBS5_LPBIG_OFFBIG_LIBS            _CS_POSIX_V7_LPBIG_OFFBIG_LIBS
+#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS       16
+#define _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS    17
+#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS    _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
+#define _CS_XBS5_WIDTH_RESTRICTED_ENVS        _CS_POSIX_V7_WIDTH_RESTRICTED_ENVS
+#define _CS_POSIX_V7_THREADS_CFLAGS           18
+#define _CS_POSIX_V7_THREADS_LDFLAGS          19
+#define _CS_V7_ENV                            20
+#define _CS_V6_ENV                            _CS_V7_ENV
+#define _CS_LFS_CFLAGS                        21
+#define _CS_LFS_LDFLAGS                       22
+#define _CS_LFS_LIBS                          23
+#define _CS_LFS_LINTFLAGS                     24
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#if __SSP_FORTIFY_LEVEL > 0
+#include <ssp/unistd.h>
+#endif
+
+#endif /* _SYS_UNISTD_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/utime.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/utime.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/utime.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/utime.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,32 @@
+/*
+ *  $Id: utime.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef __UTIME_h__
+#define __UTIME_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *  POSIX 1003.1b 5.6.6 Set File Access and Modification Times
+ */
+
+struct utimbuf {
+  time_t  actime;   /* Access time */
+  time_t  modtime;  /* Modification time */
+};
+
+/* Functions */
+
+int utime(
+  const char           *path,
+  const struct utimbuf *times
+);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _SYS_UTIME_H */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/utmp.h third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/utmp.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sys/utmp.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sys/utmp.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,47 @@
+/* Written 2000 by Werner Almesberger */
+/* Some things copied from glibc's /usr/include/bits/utmp.h */
+
+#ifndef _SYS_UTMP_H
+#define _SYS_UTMP_H
+
+#include <sys/types.h>
+#include <time.h>
+
+#define UTMP_FILE		"/var/run/utmp"
+
+#define UT_LINESIZE		32
+#define UT_NAMESIZE		32
+#define UT_HOSTSIZE		256
+
+struct utmp {
+	short int ut_type;
+	pid_t ut_pid;
+	char ut_line[UT_LINESIZE];
+	char ut_id[4];
+	char ut_user[UT_NAMESIZE];
+	char ut_host[UT_HOSTSIZE];
+	char __filler[52];
+	time_t	ut_time;
+};
+
+#define ut_name ut_user
+
+#define RUN_LVL			1
+#define BOOT_TIME		2
+#define NEW_TIME		3
+#define OLD_TIME		4
+#define INIT_PROCESS	5
+#define LOGIN_PROCESS	6
+#define USER_PROCESS	7
+#define DEAD_PROCESS	8
+
+struct utmp *_getutline(struct utmp *ut);
+struct utmp *getutent();
+struct utmp *getutid(struct utmp *ut);
+struct utmp *getutline(struct utmp *ut);
+void endutent();
+void pututline(struct utmp *ut);
+void setutent();
+void utmpname(const char *file);
+
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/syscall.S third_party/newlib-4.1.0/newlib/libc/sys/arm/syscall.S
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/syscall.S	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/syscall.S	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,176 @@
+.extern __real_set_errno
+
+.text
+
+#define SYSCALL_SWI(name, idx)  \
+.global name;                   \
+name:;                          \
+    swi idx;                    \
+    bx lr;
+
+#define SYSCALL_SWI5(name, idx)     \
+.global name;                       \
+name:;                              \
+    sub sp, #8;                     \
+  	str	r4, [sp, #0];               \
+    ldr r4, [sp, #8];               \
+    swi idx;                        \
+    ldr	r4, [sp, #0];               \
+    add sp, #8;                     \
+    bx lr;
+
+#define SYSCALL_SWI6(name, idx)     \
+.global name;                       \
+name:;                              \
+    sub sp, #8;                     \
+  	str	r4, [sp, #0];               \
+  	str	r5, [sp, #4];               \
+    ldr r4, [sp, #8];               \
+    ldr r5, [sp, #12];              \
+    swi idx;                        \
+    ldr	r4, [sp, #0];               \
+  	ldr	r5, [sp, #4];               \
+    add sp, #8;                     \
+    bx lr;
+
+
+
+#define SYSCALL0 SYSCALL_SWI
+#define SYSCALL1 SYSCALL_SWI
+#define SYSCALL2 SYSCALL_SWI
+#define SYSCALL3 SYSCALL_SWI
+#define SYSCALL4 SYSCALL_SWI
+#define SYSCALL5 SYSCALL_SWI5
+#define SYSCALL6 SYSCALL_SWI6
+
+SYSCALL1( _swi_debug, 1)
+SYSCALL1( _swi_fork, 2)
+SYSCALL1( _swi_exit, 3)
+SYSCALL3( _swi_waitpid, 4)
+SYSCALL0( _swi_kill, 5)
+SYSCALL2( _swi_setschedparams, 6)
+
+SYSCALL1( _swi_sleep, 7)
+SYSCALL1( _swi_alarm, 8)
+SYSCALL2( _swi_nanosleep, 9)
+SYSCALL0( _swi_gettimeofday, 10)
+SYSCALL1( _swi_settimeofday, 11)
+
+SYSCALL3( _swi_virtualalloc, 12)
+SYSCALL4( _swi_virtualallocphys, 13)
+SYSCALL2( _swi_virtualfree, 14)
+SYSCALL2( _swi_virtualprotect, 15)
+
+SYSCALL1( _swi_createinterrupt, 16)
+SYSCALL1( _swi_maskinterrupt, 17)
+SYSCALL1( _swi_unmaskinterrupt, 18)
+
+SYSCALL3( _swi_poll, 19)
+
+SYSCALL2( _swi_exec, 20)
+
+SYSCALL4( _swi_mount, 21)
+SYSCALL2( _swi_unmount, 22)
+
+SYSCALL5( _swi_sendrec, 24)
+SYSCALL4( _swi_getmsg, 24)
+SYSCALL5( _swi_replymsg, 25)
+SYSCALL5( _swi_readmsg, 26)
+SYSCALL5( _swi_writemsg, 27)
+
+SYSCALL3( _swi_open, 28)
+SYSCALL1( _swi_close, 29)
+SYSCALL1( _swi_dup, 30)
+SYSCALL1( _swi_dup2, 31)
+
+SYSCALL3( _swi_read, 32)
+SYSCALL3( _swi_write, 33)
+SYSCALL3( _swi_lseek, 34)
+SYSCALL3( _swi_lseek64, 35)
+
+SYSCALL2( _swi_truncate, 36)
+SYSCALL1( _swi_unlink, 37)
+
+SYSCALL2( _swi_mkdir, 38)
+SYSCALL1( _swi_opendir, 39)
+SYSCALL3( _swi_readdir, 40)
+SYSCALL1( _swi_rewinddir, 41)
+SYSCALL1( _swi_rmdir, 42)
+
+SYSCALL2( _swi_rename, 43)
+
+SYSCALL1( _swi_pipe, 44)
+SYSCALL1( _swi_socketpair, 45)
+
+SYSCALL1( _swi_chdir, 46)
+SYSCALL1( _swi_fchdir, 47)
+
+SYSCALL2( _swi_stat, 48)
+SYSCALL2( _swi_fstat, 49)
+    
+SYSCALL2( _swi_symlink, 50)
+SYSCALL2( _swi_readlink, 51)
+
+SYSCALL2( _swi_chmod, 52)
+SYSCALL2( _swi_chown, 53)
+SYSCALL2( _swi_access, 54)
+SYSCALL1( _swi_umask, 55)
+
+SYSCALL0( _swi_getpid, 56)
+SYSCALL0( _swi_getppid, 57)
+SYSCALL0( _swi_getuid, 58)
+SYSCALL0( _swi_getgid, 59)
+SYSCALL0( _swi_geteuid, 60)
+SYSCALL0( _swi_getegid, 61)
+SYSCALL1( _swi_setuid, 62)
+SYSCALL1( _swi_setgid, 63)
+
+SYSCALL0( _swi_setpgrp, 64)
+SYSCALL0( _swi_getpgrp, 65)
+
+SYSCALL1( _swi_virtualtophysaddr, 66)
+
+SYSCALL3( _swi_signalnotify, 67)
+
+SYSCALL3( _swi_pollnotify, 68)
+
+SYSCALL2( _swi_pivotroot, 69)
+
+SYSCALL3( _swi_fcntl, 70)
+SYSCALL1( _swi_isatty, 71)
+SYSCALL3( _swi_ioctl, 72)
+
+SYSCALL0( _swi_sync, 73)
+SYSCALL1( _swi_fsync, 74)
+
+SYSCALL3( _swi_sigaction, 75)
+SYSCALL3( _swi_sigprocmask, 76)
+SYSCALL1( _swi_sigpending, 77)
+SYSCALL1( _swi_sigsuspend, 78)
+SYSCALL3( _swi_mknod, 79)
+
+SYSCALL2( _swi_renamemsgport, 80)
+SYSCALL1( _swi_chroot, 81)
+
+SYSCALL0( _swi_kqueue, 82)
+
+SYSCALL6( _swi_kevent, 83)
+
+SYSCALL1( _swi_setegid, 84)
+SYSCALL1( _swi_seteuid, 85)
+SYSCALL0( _swi_issetugid, 86)
+SYSCALL2( _swi_setgroups, 87)
+SYSCALL2( _swi_getgroups, 88)
+
+SYSCALL2( _swi_get_priority, 89)
+SYSCALL2( _swi_setpriority, 90)
+
+
+SYSCALL2( _swi_fchmod, 92)
+SYSCALL3( _swi_fchown, 93)
+
+SYSCALL2( _swi_clock_gettime, 94)
+
+SYSCALL2( _swi_clock_settime, 98)
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/syscalls.c third_party/newlib-4.1.0/newlib/libc/sys/arm/syscalls.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/syscalls.c	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/syscalls.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,716 +0,0 @@
-/* Support files for GNU libc.  Files in the system namespace go here.
-   Files in the C namespace (ie those that do not start with an
-   underscore) go in .c.  */
-
-#include <_ansi.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/fcntl.h>
-#include <stdio.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/times.h>
-#include <errno.h>
-#include <reent.h>
-#include <signal.h>
-#include <unistd.h>
-#include <sys/wait.h>
-#include "swi.h"
-
-/* Forward prototypes.  */
-int	_system		(const char *);
-int	_rename		(const char *, const char *);
-int	_isatty		(int);
-clock_t _times		(struct tms *);
-int	_gettimeofday	(struct timeval *, void *);
-void	_raise		(void);
-int	_unlink		(const char *);
-int	_link		(const char *, const char *);
-int	_stat		(const char *, struct stat *);
-int	_fstat		(int, struct stat *);
-void *	_sbrk		(ptrdiff_t);
-pid_t	_getpid		(void);
-int	_kill		(int, int);
-void	_exit		(int);
-int	_close		(int);
-int	_swiclose	(int);
-int	_open		(const char *, int, ...);
-int	_swiopen	(const char *, int);
-int	_write		(int, const void *, size_t);
-int	_swiwrite	(int, const void *, size_t);
-_off_t	_lseek		(int, _off_t, int);
-_off_t	_swilseek	(int, _off_t, int);
-int	_read		(int, void *, size_t);
-int	_swiread	(int, void *, size_t);
-void	initialise_monitor_handles (void);
-
-static int	wrap		(int);
-static int	error		(int);
-static int	get_errno	(void);
-static int	remap_handle	(int);
-static int	findslot	(int);
-static int	_kill_shared	(int, int, int) __attribute__((__noreturn__));
-
-/* Register name faking - works in collusion with the linker.  */
-register char * stack_ptr asm ("sp");
-
-
-/* following is copied from libc/stdio/local.h to check std streams */
-extern void   __sinit (struct _reent *);
-#define CHECK_INIT(ptr) \
-  do						\
-    {						\
-      if ((ptr) && !(ptr)->__sdidinit)		\
-	__sinit (ptr);				\
-    }						\
-  while (0)
-
-/* Adjust our internal handles to stay away from std* handles.  */
-#define FILE_HANDLE_OFFSET (0x20)
-
-static int monitor_stdin;
-static int monitor_stdout;
-static int monitor_stderr;
-
-/* Struct used to keep track of the file position, just so we
-   can implement fseek(fh,x,SEEK_CUR).  */
-typedef struct
-{
-  int handle;
-  off_t pos;
-}
-poslog;
-
-#define MAX_OPEN_FILES 20
-static poslog openfiles [MAX_OPEN_FILES];
-
-static int
-findslot (int fh)
-{
-  int i;
-  for (i = 0; i < MAX_OPEN_FILES; i ++)
-    if (openfiles[i].handle == fh)
-      break;
-  return i;
-}
-
-/* Function to convert std(in|out|err) handles to internal versions.  */
-static int
-remap_handle (int fh)
-{
-  CHECK_INIT(_REENT);
-
-  if (fh == STDIN_FILENO)
-    return monitor_stdin;
-  if (fh == STDOUT_FILENO)
-    return monitor_stdout;
-  if (fh == STDERR_FILENO)
-    return monitor_stderr;
-
-  return fh - FILE_HANDLE_OFFSET;
-}
-
-void
-initialise_monitor_handles (void)
-{
-  int i;
-  
-  /* Open the standard file descriptors by opening the special
-   * teletype device, ":tt", read-only to obtain a descriptor for
-   * standard input and write-only to obtain a descriptor for standard
-   * output. Finally, open ":tt" in append mode to obtain a descriptor
-   * for standard error. Since this is a write mode, most kernels will
-   * probably return the same value as for standard output, but the
-   * kernel can differentiate the two using the mode flag and return a
-   * different descriptor for standard error.
-   */
-
-#ifdef ARM_RDI_MONITOR
-  int volatile block[3];
-
-  block[0] = (int) ":tt";
-  block[2] = 3;     /* length of filename */
-  block[1] = 0;     /* mode "r" */
-  monitor_stdin = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
-
-  block[0] = (int) ":tt";
-  block[2] = 3;     /* length of filename */
-  block[1] = 4;     /* mode "w" */
-  monitor_stdout = monitor_stderr
-    = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
-#else
-  int fh;
-  const char * name;
-
-  name = ":tt";
-  asm ("mov r0,%2; mov r1, #0; swi %a1; mov %0, r0"
-       : "=r"(fh)
-       : "i" (SWI_Open),"r"(name)
-       : "r0","r1");
-  monitor_stdin = fh;
-
-  name = ":tt";
-  asm ("mov r0,%2; mov r1, #4; swi %a1; mov %0, r0"
-       : "=r"(fh)
-       : "i" (SWI_Open),"r"(name)
-       : "r0","r1");
-  monitor_stdout = monitor_stderr = fh;
-#endif
-
-  for (i = 0; i < MAX_OPEN_FILES; i ++)
-    openfiles[i].handle = -1;
-
-  openfiles[0].handle = monitor_stdin;
-  openfiles[0].pos = 0;
-  openfiles[1].handle = monitor_stdout;
-  openfiles[1].pos = 0;
-}
-
-static int
-get_errno (void)
-{
-#ifdef ARM_RDI_MONITOR
-  return do_AngelSWI (AngelSWI_Reason_Errno, NULL);
-#else
-  register int r0 asm("r0");
-  asm ("swi %a1" : "=r"(r0) : "i" (SWI_GetErrno));
-  return r0;
-#endif
-}
-
-/* Set errno and return result. */
-static int
-error (int result)
-{
-  errno = get_errno ();
-  return result;
-}
-
-static int
-wrap (int result)
-{
-  if (result == -1)
-    return error (-1);
-  return result;
-}
-
-/* file, is a valid user file handle.
-   ptr, is a null terminated string.
-   len, is the length in bytes to read. 
-   Returns the number of bytes *not* written. */
-int
-_swiread (int file, void * ptr, size_t len)
-{
-  int fh = remap_handle (file);
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-
-  block[0] = fh;
-  block[1] = (int) ptr;
-  block[2] = (int) len;
-
-  return do_AngelSWI (AngelSWI_Reason_Read, block);
-#else
-  register int r0 asm("r0") = fh;
-  register int r1 asm("r1") = (int) ptr;
-  register int r2 asm("r2") = (int) len;
-  asm ("swi %a4"
-       : "=r" (r0)
-       : "0"(r0), "r"(r1), "r"(r2), "i"(SWI_Read));
-  return r0;
-#endif
-}
-
-/* file, is a valid user file handle.
-   Translates the return of _swiread into
-   bytes read. */
-int __attribute__((weak))
-_read (int file, void * ptr, size_t len)
-{
-  int slot = findslot (remap_handle (file));
-  int x = _swiread (file, ptr, len);
-
-  if (x < 0)
-    return error (-1);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles [slot].pos += len - x;
-
-  /* x == len is not an error, at least if we want feof() to work.  */
-  return len - x;
-}
-
-/* file, is a user file descriptor. */
-off_t
-_swilseek (int file, off_t ptr, int dir)
-{
-  _off_t res;
-  int fh = remap_handle (file);
-  int slot = findslot (fh);
-
-  if (dir == SEEK_CUR)
-    {
-      off_t pos;
-      if (slot == MAX_OPEN_FILES)
-	return -1;
-      pos = openfiles[slot].pos;
-
-      /* Avoid SWI SEEK command when just querying file position. */
-      if (ptr == 0)
-	return pos;
-
-      ptr += pos;
-      dir = SEEK_SET;
-    }
-
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  if (dir == SEEK_END)
-    {
-      block[0] = fh;
-      ptr += do_AngelSWI (AngelSWI_Reason_FLen, block);
-    }
-
-  /* This code only does absolute seeks.  */
-  block[0] = remap_handle (file);
-  block[1] = ptr;
-  res = do_AngelSWI (AngelSWI_Reason_Seek, block);
-#else
-  register int r0 asm("r0");
-  register int r1 asm("r1");
-  if (dir == SEEK_END)
-    {
-      r0 = (int) fh;
-      asm ("swi %a2"
-	   : "=r" (r0)
-	   : "0"(r0), "i" (SWI_Flen));
-      res = r0;
-      ptr += res;
-    }
-
-  /* This code only does absolute seeks.  */
-  r0 = (int) fh;
-  r1 = (int) ptr;
-  asm ("swi %a3"
-       : "=r" (r0)
-       : "0"(r0), "r"(r1), "i" (SWI_Seek));
-  res = r0;
-#endif
-
-  if (slot != MAX_OPEN_FILES && res == 0)
-    openfiles[slot].pos = ptr;
-
-  /* This is expected to return the position in the file.  */
-  return res == 0 ? ptr : -1;
-}
-
-off_t
-_lseek (int file, off_t ptr, int dir)
-{
-  return wrap (_swilseek (file, ptr, dir));
-}
-
-/* file, is a valid internal file handle.
-   Returns the number of bytes *not* written. */
-int
-_swiwrite (int file, const void * ptr, size_t len)
-{
-  int fh = remap_handle (file);
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-
-  block[0] = fh;
-  block[1] = (int) ptr;
-  block[2] = (int) len;
-
-  return do_AngelSWI (AngelSWI_Reason_Write, block);
-#else
-  register int r0 asm("r0") = fh;
-  register int r1 asm("r1") = (int) ptr;
-  register int r2 asm("r2") = (int) len;
-
-  asm ("swi %a4"
-       : "=r" (r0)
-       : "0"(fh), "r"(r1), "r"(r2), "i"(SWI_Write));
-  return r0;
-#endif
-}
-
-/* file, is a user file descriptor. */
-int __attribute__((weak))
-_write (int file, const void * ptr, size_t len)
-{
-  int slot = findslot (remap_handle (file));
-  int x = _swiwrite (file, ptr, len);
-
-  if (x == -1 || x == len)
-    return error (-1);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles[slot].pos += len - x;
-
-  return len - x;
-}
-
-extern int strlen (const char *);
-
-int
-_swiopen (const char * path, int flags)
-{
-  int aflags = 0, fh;
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-#endif
-
-  int i = findslot (-1);
-
-  if (i == MAX_OPEN_FILES)
-    return -1;
-
-  /* The flags are Unix-style, so we need to convert them.  */
-#ifdef O_BINARY
-  if (flags & O_BINARY)
-    aflags |= 1;
-#endif
-
-  if (flags & O_RDWR)
-    aflags |= 2;
-
-  if (flags & O_CREAT)
-    aflags |= 4;
-
-  if (flags & O_TRUNC)
-    aflags |= 4;
-
-  if (flags & O_APPEND)
-    {
-      aflags &= ~4; /* Can't ask for w AND a; means just 'a'.  */
-      aflags |= 8;
-    }
-
-#ifdef ARM_RDI_MONITOR
-  block[0] = (int) path;
-  block[2] = strlen (path);
-  block[1] = aflags;
-
-  fh = do_AngelSWI (AngelSWI_Reason_Open, block);
-
-#else
-  register int r0 asm("r0") = (int) path;
-  register int r1 asm("r1") = (int) aflags;;
-  asm ("swi %a3"
-       : "=r"(r0)
-       : "0"(r0), "r"(r1), "i" (SWI_Open));
-  fh = r0;
-#endif
-
-  if (fh >= 0)
-    {
-      openfiles[i].handle = fh;
-      openfiles[i].pos = 0;
-    }
-
-  return fh >= 0 ? fh + FILE_HANDLE_OFFSET : error (fh);
-}
-
-int
-_open (const char * path, int flags, ...)
-{
-  return wrap (_swiopen (path, flags));
-}
-
-int
-_swiclose (int file)
-{
-  int myhan = remap_handle (file);
-  int slot = findslot (myhan);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles[slot].handle = -1;
-
-#ifdef ARM_RDI_MONITOR
-  return do_AngelSWI (AngelSWI_Reason_Close, & myhan);
-#else
-  register int r0 asm("r0") = myhan;
-  asm ("swi %a2" : "=r"(r0): "0"(r0), "i" (SWI_Close));
-  return r0;
-#endif
-}
-
-int
-_close (int file)
-{
-  return wrap (_swiclose (file));
-}
-
-static int
-_kill_shared (int pid, int sig, int reason)
-{
-  (void) pid; (void) sig;
-#ifdef ARM_RDI_MONITOR
-  /* Note: The pid argument is thrown away.  */
-  int block[2];
-  block[1] = sig;
-  block[0] = reason;
-  int insn;
-
-#if SEMIHOST_V2
-  if (_has_ext_exit_extended ())
-    {
-      insn = AngelSWI_Reason_ReportExceptionExtended;
-    }
-  else
-#endif
-    {
-      insn = AngelSWI_Reason_ReportException;
-    }
-
-#if SEMIHOST_V2
-if (_has_ext_exit_extended ())
-  do_AngelSWI (insn, block);
-else
-#endif
-  do_AngelSWI (insn, (void*)block[0]);
-
-#else
-  asm ("swi %a0" :: "i" (SWI_Exit));
-#endif
-
-  __builtin_unreachable();
-}
-
-int
-_kill (int pid, int sig)
-{
-  if (sig == SIGABRT)
-    _kill_shared (pid, sig, ADP_Stopped_RunTimeError);
-  else
-    _kill_shared (pid, sig, ADP_Stopped_ApplicationExit);
-}
-
-void
-_exit (int status)
-{
-  /* The same SWI is used for both _exit and _kill.
-     For _exit, call the SWI with "reason" set to ADP_Stopped_ApplicationExit
-     to mark a standard exit.
-     Note: The RDI implementation of _kill_shared throws away all its
-     arguments and all implementations ignore the first argument.  */
-  _kill_shared (-1, status, ADP_Stopped_ApplicationExit);
-}
-
-pid_t
-_getpid (void)
-{
-  return (pid_t)1;
-}
-
-/* Heap limit returned from SYS_HEAPINFO Angel semihost call.  */
-uint __heap_limit = 0xcafedead;
-
-void * __attribute__((weak))
-_sbrk (ptrdiff_t incr)
-{
-  extern char   end asm ("end"); /* Defined by the linker.  */
-  static char * heap_end;
-  char *        prev_heap_end;
-
-  if (heap_end == NULL)
-    heap_end = & end;
-
-  prev_heap_end = heap_end;
-
-  if ((heap_end + incr > stack_ptr)
-      /* Honour heap limit if it's valid.  */
-      || (__heap_limit != 0xcafedead && heap_end + incr > (char *)__heap_limit))
-    {
-      /* Some of the libstdc++-v3 tests rely upon detecting
-	 out of memory errors, so do not abort here.  */
-#if 0
-      extern void abort (void);
-
-      _write (1, "_sbrk: Heap and stack collision\n", 32);
-
-      abort ();
-#else
-      errno = ENOMEM;
-      return (void *) -1;
-#endif
-    }
-
-  heap_end += incr;
-
-  return (void *) prev_heap_end;
-}
-
-extern void memset (struct stat *, int, unsigned int);
-
-int __attribute__((weak))
-_fstat (int file, struct stat * st)
-{
-  memset (st, 0, sizeof (* st));
-  st->st_mode = S_IFCHR;
-  st->st_blksize = 1024;
-  return 0;
-  file = file;
-}
-
-int __attribute__((weak))
-_stat (const char *fname, struct stat *st)
-{
-  int file;
-
-  /* The best we can do is try to open the file readonly.  If it exists,
-     then we can guess a few things about it.  */
-  if ((file = _open (fname, O_RDONLY)) < 0)
-    return -1;
-
-  memset (st, 0, sizeof (* st));
-  st->st_mode = S_IFREG | S_IREAD;
-  st->st_blksize = 1024;
-  _swiclose (file); /* Not interested in the error.  */
-  return 0;
-}
-
-int __attribute__((weak))
-_link (const char *__path1 __attribute__ ((unused)), const char *__path2 __attribute__ ((unused)))
-{
-  errno = ENOSYS;
-  return -1;
-}
-
-int
-_unlink (const char *path)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  block[0] = (int)path;
-  block[1] = strlen(path);
-  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-void
-_raise (void)
-{
-  return;
-}
-
-int
-_gettimeofday (struct timeval * tp, void * tzvp)
-{
-  struct timezone *tzp = tzvp;
-  if (tp)
-    {
-    /* Ask the host for the seconds since the Unix epoch.  */
-#ifdef ARM_RDI_MONITOR
-      tp->tv_sec = do_AngelSWI (AngelSWI_Reason_Time,NULL);
-#else
-      {
-	register int r0 asm("r0");
-	asm ("swi %a1" : "=r" (r0): "i" (SWI_Time));
-	tp->tv_sec = r0;
-      }
-#endif
-      tp->tv_usec = 0;
-    }
-
-  /* Return fixed data for the timezone.  */
-  if (tzp)
-    {
-      tzp->tz_minuteswest = 0;
-      tzp->tz_dsttime = 0;
-    }
-
-  return 0;
-}
-
-/* Return a clock that ticks at 100Hz.  */
-clock_t
-_times (struct tms * tp)
-{
-  clock_t timeval;
-
-#ifdef ARM_RDI_MONITOR
-  timeval = do_AngelSWI (AngelSWI_Reason_Clock, NULL);
-#else
-  register int r0 asm("r0");
-  asm ("swi %a1" : "=r" (r0): "i" (SWI_Clock));
-  timeval = (clock_t) r0;
-#endif
-
-  if (tp)
-    {
-      tp->tms_utime  = timeval;	/* user time */
-      tp->tms_stime  = 0;	/* system time */
-      tp->tms_cutime = 0;	/* user time, children */
-      tp->tms_cstime = 0;	/* system time, children */
-    }
-
-  return timeval;
-};
-
-
-int
-_isatty (int fd)
-{
-#ifdef ARM_RDI_MONITOR
-  int fh = remap_handle (fd);
-  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
-#else
-  return (fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
-#endif
-}
-
-int
-_system (const char *s)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  int e;
-
-  /* Hmmm.  The ARM debug interface specification doesn't say whether
-     SYS_SYSTEM does the right thing with a null argument, or assign any
-     meaning to its return value.  Try to do something reasonable....  */
-  if (!s)
-    return 1;  /* maybe there is a shell available? we can hope. :-P */
-  block[0] = (int)s;
-  block[1] = strlen (s);
-  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
-  if ((e >= 0) && (e < 256))
-    {
-      /* We have to convert e, an exit status to the encoded status of
-         the command.  To avoid hard coding the exit status, we simply
-	 loop until we find the right position.  */
-      int exit_code;
-
-      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
-	continue;
-    }
-  return e;
-#else
-  if (s == NULL)
-    return 0;
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-int
-_rename (const char * oldpath, const char * newpath)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[4];
-  block[0] = (int) oldpath;
-  block[1] = strlen(oldpath);
-  block[2] = (int) newpath;
-  block[3] = strlen(newpath);
-  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sysconf.c third_party/newlib-4.1.0/newlib/libc/sys/arm/sysconf.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/sysconf.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/sysconf.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,24 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+long sysconf(int name)
+{
+	errno = -ENOSYS;
+	return -1;
+}
+
+
+/*
+ *
+ */
+int getdtablesize(void)
+{
+	return 512;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/termios.c third_party/newlib-4.1.0/newlib/libc/sys/arm/termios.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/termios.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/termios.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,140 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+#include <termios.h>
+#include <sys/termios.h>
+
+
+/*
+ *
+ */
+int isatty(int fd)
+{   
+    int sc;
+    sc = _swi_isatty(fd);  
+
+    if (sc < 0)
+    {
+        errno = -sc;
+        return 0;
+    }
+    
+    return sc;
+}
+
+/*
+ *
+ */
+int tcgetattr(int fd,struct termios *termios_p)
+{
+    return ioctl(fd, TCGETS, termios_p);
+}
+
+/*
+ *
+ */
+int tcsetattr(int fd,int optional_actions, const struct termios *termios_p)
+{
+    int cmd;
+
+    switch (optional_actions) {
+        case TCSANOW:
+            cmd = TCSETS;
+            break;
+        case TCSADRAIN:
+            cmd = TCSETSW;
+            break;
+        case TCSAFLUSH:
+            cmd = TCSETSF;
+            break;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+
+    return ioctl(fd, cmd, termios_p);
+}
+
+/*
+ *
+ */
+pid_t tcgetpgrp(int fd)
+{
+    int p;
+
+    if (ioctl(fd,TIOCGPGRP,&p) < 0) {
+        return (pid_t)-1;
+    }
+
+    return (pid_t)p;
+}
+
+/*
+ *
+ */
+int tcsetpgrp(int fd, pid_t pid)
+{
+    int p = (int)pid;
+    return ioctl(fd,TIOCSPGRP, &p);
+}
+
+/*
+ *
+ */
+int tcflow (int fd, int action)
+{
+    return ioctl(fd, TCXONC, action);
+}
+
+/*
+ *
+ */
+int tcflush (int fd, int queue_selector)
+{
+    return ioctl(fd, TCFLSH, queue_selector);
+}
+
+/*
+ *
+ */
+int cfsetispeed (struct termios *termios_p, speed_t speed)
+{
+	  termios_p->c_ispeed = speed;
+	  return 0;
+}
+
+/*
+ *
+ */
+int cfsetospeed (struct termios *termios_p, speed_t speed)
+{
+	  termios_p->c_ospeed = speed;
+	  return 0;
+}
+
+/*
+ *
+ */
+speed_t cfgetispeed (const struct termios *termios_p)
+{
+  	return termios_p->c_ispeed;
+}
+
+/*
+ *
+ */
+speed_t cfgetospeed (const struct termios *termios_p)
+{
+  	return termios_p->c_ospeed;
+}
+
+/*
+ *
+ */
+char *ttyname(int fildes)
+{
+  	return "/dev/tty";
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/time.c third_party/newlib-4.1.0/newlib/libc/sys/arm/time.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/time.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/time.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,106 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <utime.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+time_t time (time_t *tloc)
+{
+	struct timeval tv;
+	
+	gettimeofday(&tv, NULL);
+	
+	return tv.tv_sec;
+}
+
+
+/* @brief		TODO: Set the timestamp of a file
+ *
+ */
+int utime(const char *path, const struct utimbuf *times)
+{
+	return 0;
+}
+
+
+/*
+ *
+ */
+int clock_gettime(clockid_t clk_id, struct timespec *tp)
+{
+  int sc;
+  
+  sc = _swi_clock_settime(clk_id, tp);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+
+  return sc;
+}
+
+
+/*
+ *
+ */
+int clock_settime(clockid_t clk_id, const struct timespec *tp)
+{
+  int sc;
+  
+  sc = _swi_clock_settime(clk_id, tp);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+
+  return sc;
+}
+
+
+/* @brief		Helper function to subtract time t1 from time t2
+ *
+ * @return	1 if t1 is after t2, else return 0.
+ */
+int diff_timespec(struct timespec *result, struct timespec *t2, struct timespec *t1)
+{
+  if (t2->tv_nsec < t1->tv_nsec) {
+    int nsec = (t1->tv_nsec - t2->tv_nsec) / 1000000 + 1;
+    t1->tv_nsec -= 1000000 * nsec;
+    t1->tv_sec += nsec;
+  }
+  if (t2->tv_nsec - t1->tv_nsec > 1000000) {
+    int nsec = (t2->tv_nsec - t1->tv_nsec) / 1000000;
+    t1->tv_nsec += 1000000 * nsec;
+    t1->tv_sec -= nsec;
+  }
+
+  result->tv_sec = t2->tv_sec - t1->tv_sec;
+  result->tv_nsec = t2->tv_nsec - t1->tv_nsec;
+
+  return (t1->tv_sec > t2->tv_sec) ? 1 : 0;
+}
+
+
+/* @brief		Helper function to add t2 to t1
+ *
+ */
+void add_timespec(struct timespec *result, struct timespec *t2, struct timespec *t1)
+{
+  result->tv_sec = t2->tv_sec + t1->tv_sec;
+  result->tv_nsec = t2->tv_nsec + t1->tv_nsec;
+  
+  if (result->tv_nsec > 1000000000) {
+    result->tv_nsec -= 1000000000;
+    result->tv_sec++;
+  }
+}
+
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/times.c third_party/newlib-4.1.0/newlib/libc/sys/arm/times.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/times.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/times.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,16 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+clock_t times(struct tms *buf)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/trap.S third_party/newlib-4.1.0/newlib/libc/sys/arm/trap.S
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/trap.S	2020-12-18 23:50:49.000000000 +0000
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/trap.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-        /* Run-time exception support */
-#ifndef __ARM_EABI__
-#include "swi.h"
-
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-        .align 0
-        .global __rt_stkovf_split_big
-        .global __rt_stkovf_split_small
-
-/* The following functions are provided for software stack checking.
-   If hardware stack-checking is being used then the code can be
-   compiled without the PCS entry checks, and simply rely on VM
-   management to extend the stack for a thread.
-
-   The stack extension event occurs when the PCS function entry code
-   would result in a stack-pointer beneath the stack-limit register
-   value.  The system relies on the following map:
-
-        +-----------------------------------+ <-- end of stack block
-        | ...                               |
-        | ...                               |
-        | active stack                      |
-        | ...                               | <-- sp (stack-pointer) somewhere in here
-        | ...                               |
-        +-----------------------------------+ <-- sl (stack-limit)
-        | stack-extension handler workspace |
-        +-----------------------------------+ <-- base of stack block
-
-   The "stack-extension handler workspace" is an amount of memory in
-   which the stack overflow support code must execute.  It must be
-   large enough to deal with the worst case path through the extension
-   code.  At the moment the compiler expects this to be AT LEAST
-   256bytes.  It uses this fact to code functions with small local
-   data usage within the overflow space.
-
-   In a true target environment We may need to increase the space
-   between sl and the true limit to allow for the stack extension
-   code, SWI handlers and for undefined instruction handlers of the
-   target environment.  */
-
-__rt_stkovf_split_small:
-        mov     ip,sp   @ Ensure we can calculate the stack required
-        @ and fall through to...
-__rt_stkovf_split_big:
-        @ in:   sp = current stack-pointer (beneath stack-limit)
-        @       sl = current stack-limit
-        @       ip = low stack point we require for the current function
-        @       lr = return address into the current function
-        @       fp = frame-pointer
-        @               original sp --> +----------------------------------+
-        @                               | pc (12 ahead of PCS entry store) |
-        @               current fp ---> +----------------------------------+
-        @                               | lr (on entry) pc (on exit)       |
-        @                               +----------------------------------+
-        @                               | sp ("original sp" on entry)      |
-        @                               +----------------------------------+
-        @                               | fp (on entry to function)        |
-        @                               +----------------------------------+
-        @                               |                                  |
-        @                               | ..argument and work registers..  |
-        @                               |                                  |
-        @               current sp ---> +----------------------------------+
-        @
-        @ The "current sl" is somewhere between "original sp" and "current sp"
-        @ but above "true sl". The "current sl" should be at least 256bytes
-        @ above the "true sl". The 256byte stack guard should be large enough
-        @ to deal with the worst case function entry stacking (160bytes) plus
-        @ the stack overflow handler stacking requirements, plus the stack
-        @ required for the memory allocation routines.
-        @
-        @ Normal PCS entry (before stack overflow check) can stack 16
-        @ standard registers (64bytes) and 8 floating point registers
-        @ (96bytes). This gives a minimum stack guard of 160bytes (excluding
-        @ the stack required for the code). (Actually only a maximum of
-        @ 14standard registers are ever stacked on entry to a function).
-        @
-        @ NOTE: Structure returns are performed by the caller allocating a
-        @       dummy space on the stack and passing in a "phantom" arg1 into
-        @       the function. This means that we do not need to worry about
-        @       preserving the stack under "sp" even on function return.
-        @ 
-        @        Code should never poke values beneath sp. The sp register
-        @        should always be "dropped" first to cover the data. This
-        @        protects the data against any events that may try and use
-        @        the stack.
-
-        SUB     ip, sp, ip      @ extra stack required for function
-        @ Add stack extension code here.  If desired a new stack chunk
-        @ can be allocated, and the register state updated suitably.
-
-        @ We now know how much extra stack the function requires.
-        @ Terminate the program for the moment:
-        swi     SWI_Exit
-#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/truncate.c third_party/newlib-4.1.0/newlib/libc/sys/arm/truncate.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/truncate.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/truncate.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,53 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+
+
+/* @brief Truncate an already open file
+ *
+ */
+int ftruncate (int fd, off_t size)
+{
+    int sc;
+    
+    sc = _swi_truncate(fd, size);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/* @brief Truncate a file
+ *
+ */
+int truncate (const char *path, off_t size)
+{
+    int fd;
+    int sc;
+    
+    fd = open(path, O_WRONLY);
+    
+    if (fd < 0) {
+      errno = -fd;
+      return -1;
+    }
+        
+    sc = _swi_truncate(fd, size);
+    close(fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/ttyaction.c third_party/newlib-4.1.0/newlib/libc/sys/arm/ttyaction.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/ttyaction.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/ttyaction.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,160 @@
+/*	$NetBSD: ttyaction.c,v 1.19 2008/04/28 20:23:03 martin Exp $	*/
+
+/*-
+ * Copyright (c) 1996 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Gordon W. Ross.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ * For each matching "tty" and "action" run the "command."
+ * See fnmatch() for matching the tty name.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: ttyaction.c,v 1.19 2008/04/28 20:23:03 martin Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/types.h>
+#include <sys/wait.h>
+
+#include <assert.h>
+#include <err.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <fnmatch.h>
+#include <paths.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "util.h"
+
+#ifndef _PATH_TTYACTION
+#define _PATH_TTYACTION "/etc/ttyaction"
+#endif
+
+static const char *actfile = _PATH_TTYACTION;
+static const char *pathenv = "PATH=" _PATH_STDPATH;
+
+int
+ttyaction(const char *tty, const char *act, const char *user)
+{
+	FILE *fp;
+	char *p1, *p2;
+	const char *argv[4];
+	const char *envp[8];
+	char *lastp;
+	char line[1024];
+	char env_tty[64];
+	char env_act[64];
+	char env_user[256];
+	int error, linenum, status;
+	pid_t pid;
+
+	_DIAGASSERT(tty != NULL);
+	_DIAGASSERT(act != NULL);
+	_DIAGASSERT(user != NULL);
+
+	fp = fopen(actfile, "r");
+	if (fp == NULL)
+		return 0;
+
+	/* Skip the "/dev/" part of the first arg. */
+	if (!strncmp(tty, "/dev/", (size_t)5))
+		tty += 5;
+
+	/* Args will be: "sh -c ..." */
+	argv[0] = _PATH_BSHELL;
+	argv[1] = "-c";
+	argv[2] = NULL;	/* see below */
+	argv[3] = NULL;
+
+	/*
+	 * Environment needs: TTY, ACT, USER
+	 */
+	snprintf(env_tty, sizeof(env_tty), "TTY=%s", tty);
+	snprintf(env_act, sizeof(env_act), "ACT=%s", act);
+	snprintf(env_user, sizeof(env_user), "USER=%s", user);
+	envp[0] = pathenv;
+	envp[1] = env_tty;
+	envp[2] = env_act;
+	envp[3] = env_user;
+	envp[4] = NULL;
+
+	linenum = 0;
+	status = 0;
+	while (fgets(line, (int)sizeof(line), fp)) {
+		linenum++;
+
+		/* Allow comment lines. */
+		if (line[0] == '#')
+			continue;
+
+		p1 = strtok_r(line, " \t", &lastp);
+		p2 = strtok_r(NULL, " \t", &lastp);
+		/* This arg goes to end of line. */
+		argv[2] = strtok_r(NULL, "\n", &lastp);
+		if (!p1 || !p2 || !argv[2]) {
+			warnx("%s: line %d format error", actfile, linenum);
+			continue;
+		}
+		if (fnmatch(p1, tty, 0) || fnmatch(p2, act, 0))
+			continue;
+		/* OK, this is a match.  Run the command. */
+		pid = fork();
+		if (pid == -1) {
+			warnx("fork failed: %s", strerror(errno));
+			continue;
+		}
+		if (pid == 0) {
+			/* This is the child. */
+			error = execve(argv[0], 
+			    (char *const *)__UNCONST(argv),
+			    (char *const *)__UNCONST(envp));
+			/* If we get here, it is an error. */
+			warnx("%s: line %d: exec failed: %s",
+				  actfile, linenum, strerror(errno));
+			_exit(1);
+		}
+		/* This is the parent. */
+		error = waitpid(pid, &status, 0);
+		if (error == -1) {
+			warnx("%s: line %d: wait failed: %s",
+				  actfile, linenum, strerror(errno));
+			continue;
+		}
+		if (WTERMSIG(status)) {
+			warnx("%s: line %d: child died with signal %d",
+				  actfile, linenum, WTERMSIG(status));
+			continue;
+		}
+	}
+	fclose(fp);
+	return status;
+}
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/uio.c third_party/newlib-4.1.0/newlib/libc/sys/arm/uio.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/uio.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/uio.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,57 @@
+#include <stdint.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/uio.h>
+
+
+/*
+ *
+ */
+ssize_t readv(int fd, const struct iovec *iov, int iov_cnt)
+{
+	ssize_t total;
+	ssize_t xfered;
+	
+	for (int t=0; t<iov_cnt; t++) {
+		xfered = read(fd, iov[t].iov_base, iov[t].iov_len);
+		
+		if (xfered < 0) {
+			return xfered;
+		}
+
+		total += xfered;
+		
+		if (xfered != iov[t].iov_len) {
+			break;
+		}		
+	}
+	
+	return total;
+}
+	
+
+/*
+ *
+ */
+ssize_t writev(int fd, const struct iovec *iov, int iov_cnt)
+{
+	ssize_t total;
+	ssize_t xfered;
+	
+	for (int t=0; t<iov_cnt; t++) {
+		xfered = write(fd, iov[t].iov_base, iov[t].iov_len);
+		
+		if (xfered < 0) {
+			return xfered;
+		}
+
+		total += xfered;
+		
+		if (xfered != iov[t].iov_len) {
+			break;
+		}		
+	}
+	
+	return total;
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/unlink.c third_party/newlib-4.1.0/newlib/libc/sys/arm/unlink.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/unlink.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/unlink.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/* @brief Remove a file
+ *
+ */
+int unlink (char *path)
+{
+    int sc;
+    
+  	sc = _swi_unlink(path);
+  	
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/update.sh third_party/newlib-4.1.0/newlib/libc/sys/arm/update.sh
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/update.sh	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/update.sh	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,7 @@
+# When adding files to this directory, add the name
+# of the object file to makefile.am then run the following
+# script in this directory.
+
+aclocal -I ../../..
+autoconf
+automake --cygnus Makefile
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/user_strerror.c third_party/newlib-4.1.0/newlib/libc/sys/arm/user_strerror.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/user_strerror.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/user_strerror.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,20 @@
+#include <_ansi.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+
+
+
+char * _user_strerror (int errnum)
+{
+    char *error;
+
+    switch (errnum) {
+        default:
+        error = NULL;
+    }
+
+    return error;		
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/verrx.c third_party/newlib-4.1.0/newlib/libc/sys/arm/verrx.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/verrx.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/verrx.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,65 @@
+/*	$NetBSD: verrx.c,v 1.15 2011/07/17 20:54:34 joerg Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: verrx.c,v 1.15 2011/07/17 20:54:34 joerg Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef __weak_alias
+__weak_alias(verrx, _verrx)
+#endif
+
+#if !HAVE_ERR_H
+__dead void
+verrx(int eval, const char *fmt, va_list ap)
+{
+	(void)fprintf(stderr, "%s: ", getprogname());
+	if (fmt != NULL)
+		(void)vfprintf(stderr, fmt, ap);
+	(void)fprintf(stderr, "\n");
+	exit(eval);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/virtualalloc.c third_party/newlib-4.1.0/newlib/libc/sys/arm/virtualalloc.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/virtualalloc.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/virtualalloc.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,69 @@
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+void *virtualalloc (void *addr, size_t size, bits32_t flags)
+{
+    return _swi_virtualalloc(addr, size, flags);
+}
+
+
+/*
+ *
+ */
+void *virtualallocphys (void *addr, size_t size, bits32_t flags, void *phys_addr)
+{
+    return _swi_virtualallocphys(addr, size, flags, phys_addr);
+}
+
+
+/*
+ *
+ */
+int virtualfree (void *addr, size_t size)
+{
+    int sc;
+      
+    sc = _swi_virtualfree(addr, size);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int virtualprotect (void *addr, size_t sz, bits32_t flags)
+{
+    int sc;
+      
+    sc = _swi_virtualprotect(addr, sz, flags);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+void *virtualtophysaddr(void *addr)
+{
+    return _swi_virtualtophysaddr(addr);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vis.c third_party/newlib-4.1.0/newlib/libc/sys/arm/vis.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vis.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/vis.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,742 @@
+/*	$NetBSD: vis.c,v 1.74 2017/11/27 16:37:21 christos Exp $	*/
+
+/*-
+ * Copyright (c) 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/*-
+ * Copyright (c) 1999, 2005 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: vis.c,v 1.74 2017/11/27 16:37:21 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include <sys/types.h>
+#include <sys/param.h>
+
+#include <assert.h>
+#include <vis.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <wchar.h>
+#include <wctype.h>
+#include <limits.h>
+
+#ifdef __weak_alias
+__weak_alias(strvisx,_strvisx)
+#endif
+
+#if !HAVE_VIS || !HAVE_SVIS
+#include <ctype.h>
+#include <stdio.h>
+#include <string.h>
+
+/*
+ * The reason for going through the trouble to deal with character encodings
+ * in vis(3), is that we use this to safe encode output of commands. This
+ * safe encoding varies depending on the character set. For example if we
+ * display ps output in French, we don't want to display French characters
+ * as M-foo.
+ */
+
+static wchar_t *do_svis(wchar_t *, wint_t, int, wint_t, const wchar_t *);
+
+#undef BELL
+#define BELL L'\a'
+ 
+#if defined(LC_C_LOCALE)
+#define iscgraph(c)      isgraph_l(c, LC_C_LOCALE)
+#else
+/* Keep it simple for now, no locale stuff */
+#define iscgraph(c)	isgraph(c)
+#ifdef notyet
+#include <locale.h>
+static int
+iscgraph(int c) {
+	int rv;
+	char *ol;
+
+	ol = setlocale(LC_CTYPE, "C");
+	rv = isgraph(c);
+	if (ol)
+		setlocale(LC_CTYPE, ol);
+	return rv;
+}
+#endif
+#endif
+
+#define ISGRAPH(flags, c) \
+    (((flags) & VIS_NOLOCALE) ? iscgraph(c) : iswgraph(c))
+
+#define iswoctal(c)	(((u_char)(c)) >= L'0' && ((u_char)(c)) <= L'7')
+#define iswwhite(c)	(c == L' ' || c == L'\t' || c == L'\n')
+#define iswsafe(c)	(c == L'\b' || c == BELL || c == L'\r')
+#define xtoa(c)		L"0123456789abcdef"[c]
+#define XTOA(c)		L"0123456789ABCDEF"[c]
+
+#define MAXEXTRAS	30
+
+static const wchar_t char_shell[] = L"'`\";&<>()|{}]\\$!^~";
+static const wchar_t char_glob[] = L"*?[#";
+
+/*
+ * This is do_hvis, for HTTP style (RFC 1808)
+ */
+static wchar_t *
+do_hvis(wchar_t *dst, wint_t c, int flags, wint_t nextc, const wchar_t *extra)
+{
+	if (iswalnum(c)
+	    /* safe */
+	    || c == L'$' || c == L'-' || c == L'_' || c == L'.' || c == L'+'
+	    /* extra */
+	    || c == L'!' || c == L'*' || c == L'\'' || c == L'(' || c == L')'
+	    || c == L',')
+		dst = do_svis(dst, c, flags, nextc, extra);
+	else {
+		*dst++ = L'%';
+		*dst++ = xtoa(((unsigned int)c >> 4) & 0xf);
+		*dst++ = xtoa((unsigned int)c & 0xf);
+	}
+
+	return dst;
+}
+
+/*
+ * This is do_mvis, for Quoted-Printable MIME (RFC 2045)
+ * NB: No handling of long lines or CRLF.
+ */
+static wchar_t *
+do_mvis(wchar_t *dst, wint_t c, int flags, wint_t nextc, const wchar_t *extra)
+{
+	if ((c != L'\n') &&
+	    /* Space at the end of the line */
+	    ((iswspace(c) && (nextc == L'\r' || nextc == L'\n')) ||
+	    /* Out of range */
+	    (!iswspace(c) && (c < 33 || (c > 60 && c < 62) || c > 126)) ||
+	    /* Specific char to be escaped */
+	    wcschr(L"#$@[\\]^`{|}~", c) != NULL)) {
+		*dst++ = L'=';
+		*dst++ = XTOA(((unsigned int)c >> 4) & 0xf);
+		*dst++ = XTOA((unsigned int)c & 0xf);
+	} else
+		dst = do_svis(dst, c, flags, nextc, extra);
+	return dst;
+}
+
+/*
+ * Output single byte of multibyte character.
+ */
+static wchar_t *
+do_mbyte(wchar_t *dst, wint_t c, int flags, wint_t nextc, int iswextra)
+{
+	if (flags & VIS_CSTYLE) {
+		switch (c) {
+		case L'\n':
+			*dst++ = L'\\'; *dst++ = L'n';
+			return dst;
+		case L'\r':
+			*dst++ = L'\\'; *dst++ = L'r';
+			return dst;
+		case L'\b':
+			*dst++ = L'\\'; *dst++ = L'b';
+			return dst;
+		case BELL:
+			*dst++ = L'\\'; *dst++ = L'a';
+			return dst;
+		case L'\v':
+			*dst++ = L'\\'; *dst++ = L'v';
+			return dst;
+		case L'\t':
+			*dst++ = L'\\'; *dst++ = L't';
+			return dst;
+		case L'\f':
+			*dst++ = L'\\'; *dst++ = L'f';
+			return dst;
+		case L' ':
+			*dst++ = L'\\'; *dst++ = L's';
+			return dst;
+		case L'\0':
+			*dst++ = L'\\'; *dst++ = L'0';
+			if (iswoctal(nextc)) {
+				*dst++ = L'0';
+				*dst++ = L'0';
+			}
+			return dst;
+		/* We cannot encode these characters in VIS_CSTYLE
+		 * because they special meaning */
+		case L'n':
+		case L'r':
+		case L'b':
+		case L'a':
+		case L'v':
+		case L't':
+		case L'f':
+		case L's':
+		case L'0':
+		case L'M':
+		case L'^':
+		case L'$': /* vis(1) -l */
+			break;
+		default:
+			if (ISGRAPH(flags, c) && !iswoctal(c)) {
+				*dst++ = L'\\';
+				*dst++ = c;
+				return dst;
+			}
+		}
+	}
+	if (iswextra || ((c & 0177) == L' ') || (flags & VIS_OCTAL)) {
+		*dst++ = L'\\';
+		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 6) & 03) + L'0';
+		*dst++ = (u_char)(((u_int32_t)(u_char)c >> 3) & 07) + L'0';
+		*dst++ =			     (c	      & 07) + L'0';
+	} else {
+		if ((flags & VIS_NOSLASH) == 0)
+			*dst++ = L'\\';
+
+		if (c & 0200) {
+			c &= 0177;
+			*dst++ = L'M';
+		}
+
+		if (iswcntrl(c)) {
+			*dst++ = L'^';
+			if (c == 0177)
+				*dst++ = L'?';
+			else
+				*dst++ = c + L'@';
+		} else {
+			*dst++ = L'-';
+			*dst++ = c;
+		}
+	}
+
+	return dst;
+}
+
+/*
+ * This is do_vis, the central code of vis.
+ * dst:	      Pointer to the destination buffer
+ * c:	      Character to encode
+ * flags:     Flags word
+ * nextc:     The character following 'c'
+ * extra:     Pointer to the list of extra characters to be
+ *	      backslash-protected.
+ */
+static wchar_t *
+do_svis(wchar_t *dst, wint_t c, int flags, wint_t nextc, const wchar_t *extra)
+{
+	int iswextra, i, shft;
+	u_int64_t bmsk, wmsk;
+
+	iswextra = wcschr(extra, c) != NULL;
+	if (!iswextra && (ISGRAPH(flags, c) || iswwhite(c) ||
+	    ((flags & VIS_SAFE) && iswsafe(c)))) {
+		*dst++ = c;
+		return dst;
+	}
+
+	/* See comment in istrsenvisx() output loop, below. */
+	wmsk = 0;
+	for (i = sizeof(wmsk) - 1; i >= 0; i--) {
+		shft = i * NBBY;
+		bmsk = (u_int64_t)0xffLL << shft;
+		wmsk |= bmsk;
+		if ((c & wmsk) || i == 0)
+			dst = do_mbyte(dst, (wint_t)(
+			    (u_int64_t)(c & bmsk) >> shft),
+			    flags, nextc, iswextra);
+	}
+
+	return dst;
+}
+
+typedef wchar_t *(*visfun_t)(wchar_t *, wint_t, int, wint_t, const wchar_t *);
+
+/*
+ * Return the appropriate encoding function depending on the flags given.
+ */
+static visfun_t
+getvisfun(int flags)
+{
+	if (flags & VIS_HTTPSTYLE)
+		return do_hvis;
+	if (flags & VIS_MIMESTYLE)
+		return do_mvis;
+	return do_svis;
+}
+
+/*
+ * Expand list of extra characters to not visually encode.
+ */
+static wchar_t *
+makeextralist(int flags, const char *src)
+{
+	wchar_t *dst, *d;
+	size_t len;
+	const wchar_t *s;
+	mbstate_t mbstate;
+
+	bzero(&mbstate, sizeof(mbstate));
+	len = strlen(src);
+	if ((dst = calloc(len + MAXEXTRAS, sizeof(*dst))) == NULL)
+		return NULL;
+
+	if ((flags & VIS_NOLOCALE) || mbsrtowcs(dst, &src, len, &mbstate) == (size_t)-1) {
+		size_t i;
+		for (i = 0; i < len; i++)
+			dst[i] = (wchar_t)(u_char)src[i];
+		d = dst + len;
+	} else
+		d = dst + wcslen(dst);
+
+	if (flags & VIS_GLOB)
+		for (s = char_glob; *s; *d++ = *s++)
+			continue;
+
+	if (flags & VIS_SHELL)
+		for (s = char_shell; *s; *d++ = *s++)
+			continue;
+
+	if (flags & VIS_SP) *d++ = L' ';
+	if (flags & VIS_TAB) *d++ = L'\t';
+	if (flags & VIS_NL) *d++ = L'\n';
+	if (flags & VIS_DQ) *d++ = L'"';
+	if ((flags & VIS_NOSLASH) == 0) *d++ = L'\\';
+	*d = L'\0';
+
+	return dst;
+}
+
+/*
+ * istrsenvisx()
+ * 	The main internal function.
+ *	All user-visible functions call this one.
+ */
+static int
+istrsenvisx(char **mbdstp, size_t *dlen, const char *mbsrc, size_t mblength,
+    int flags, const char *mbextra, int *cerr_ptr)
+{
+	wchar_t *dst, *src, *pdst, *psrc, *start, *extra;
+	size_t len, olen;
+	u_int64_t bmsk, wmsk;
+	wint_t c;
+	visfun_t f;
+	int clen = 0, cerr, error = -1, i, shft;
+	char *mbdst, *mdst;
+	ssize_t mbslength, maxolen;
+	mbstate_t mbstate;
+
+	_DIAGASSERT(mbdstp != NULL);
+	_DIAGASSERT(mbsrc != NULL || mblength == 0);
+	_DIAGASSERT(mbextra != NULL);
+
+	mbslength = (ssize_t)mblength;
+	/*
+	 * When inputing a single character, must also read in the
+	 * next character for nextc, the look-ahead character.
+	 */
+	if (mbslength == 1)
+		mbslength++;
+
+	/*
+	 * Input (mbsrc) is a char string considered to be multibyte
+	 * characters.  The input loop will read this string pulling
+	 * one character, possibly multiple bytes, from mbsrc and
+	 * converting each to wchar_t in src.
+	 *
+	 * The vis conversion will be done using the wide char
+	 * wchar_t string.
+	 *
+	 * This will then be converted back to a multibyte string to
+	 * return to the caller.
+	 */
+
+	/* Allocate space for the wide char strings */
+	psrc = pdst = extra = NULL;
+	mdst = NULL;
+	if ((psrc = calloc(mbslength + 1, sizeof(*psrc))) == NULL)
+		return -1;
+	if ((pdst = calloc((16 * mbslength) + 1, sizeof(*pdst))) == NULL)
+		goto out;
+	if (*mbdstp == NULL) {
+		if ((mdst = calloc((16 * mbslength) + 1, sizeof(*mdst))) == NULL)
+			goto out;
+		*mbdstp = mdst;
+	}
+
+	mbdst = *mbdstp;
+	dst = pdst;
+	src = psrc;
+
+	if (flags & VIS_NOLOCALE) {
+		/* Do one byte at a time conversion */
+		cerr = 1;
+	} else {
+		/* Use caller's multibyte conversion error flag. */
+		cerr = cerr_ptr ? *cerr_ptr : 0;
+	}
+
+	/*
+	 * Input loop.
+	 * Handle up to mblength characters (not bytes).  We do not
+	 * stop at NULs because we may be processing a block of data
+	 * that includes NULs.
+	 */
+	bzero(&mbstate, sizeof(mbstate));
+	while (mbslength > 0) {
+		/* Convert one multibyte character to wchar_t. */
+		if (!cerr)
+			clen = mbrtowc(src, mbsrc, MIN(mbslength, MB_LEN_MAX),
+			    &mbstate);
+		if (cerr || clen < 0) {
+			/* Conversion error, process as a byte instead. */
+			*src = (wint_t)(u_char)*mbsrc;
+			clen = 1;
+			cerr = 1;
+		}
+		if (clen == 0) {
+			/*
+			 * NUL in input gives 0 return value. process
+			 * as single NUL byte and keep going.
+			 */
+			clen = 1;
+		}
+		/* Advance buffer character pointer. */
+		src++;
+		/* Advance input pointer by number of bytes read. */
+		mbsrc += clen;
+		/* Decrement input byte count. */
+		mbslength -= clen;
+	}
+	len = src - psrc;
+	src = psrc;
+
+	/*
+	 * In the single character input case, we will have actually
+	 * processed two characters, c and nextc.  Reset len back to
+	 * just a single character.
+	 */
+	if (mblength < len)
+		len = mblength;
+
+	/* Convert extra argument to list of characters for this mode. */
+	extra = makeextralist(flags, mbextra);
+	if (!extra) {
+		if (dlen && *dlen == 0) {
+			errno = ENOSPC;
+			goto out;
+		}
+		*mbdst = '\0';	/* can't create extra, return "" */
+		error = 0;
+		goto out;
+	}
+
+	/* Look up which processing function to call. */
+	f = getvisfun(flags);
+
+	/*
+	 * Main processing loop.
+	 * Call do_Xvis processing function one character at a time
+	 * with next character available for look-ahead.
+	 */
+	for (start = dst; len > 0; len--) {
+		c = *src++;
+		dst = (*f)(dst, c, flags, len >= 1 ? *src : L'\0', extra);
+		if (dst == NULL) {
+			errno = ENOSPC;
+			goto out;
+		}
+	}
+
+	/* Terminate the string in the buffer. */
+	*dst = L'\0';
+
+	/*
+	 * Output loop.
+	 * Convert wchar_t string back to multibyte output string.
+	 * If we have hit a multi-byte conversion error on input,
+	 * output byte-by-byte here.  Else use wctomb().
+	 */
+	len = wcslen(start);
+	maxolen = dlen ? *dlen : (wcslen(start) * MB_LEN_MAX + 1);
+	olen = 0;
+	bzero(&mbstate, sizeof(mbstate));
+	for (dst = start; len > 0; len--) {
+		if (!cerr)
+			clen = wcrtomb(mbdst, *dst, &mbstate);
+		if (cerr || clen < 0) {
+			/*
+			 * Conversion error, process as a byte(s) instead.
+			 * Examine each byte and higher-order bytes for
+			 * data.  E.g.,
+			 *	0x000000000000a264 -> a2 64
+			 *	0x000000001f00a264 -> 1f 00 a2 64
+			 */
+			clen = 0;
+			wmsk = 0;
+			for (i = sizeof(wmsk) - 1; i >= 0; i--) {
+				shft = i * NBBY;
+				bmsk = (u_int64_t)0xffLL << shft;
+				wmsk |= bmsk;
+				if ((*dst & wmsk) || i == 0)
+					mbdst[clen++] = (char)(
+					    (u_int64_t)(*dst & bmsk) >>
+					    shft);
+			}
+			cerr = 1;
+		}
+		/* If this character would exceed our output limit, stop. */
+		if (olen + clen > (size_t)maxolen)
+			break;
+		/* Advance output pointer by number of bytes written. */
+		mbdst += clen;
+		/* Advance buffer character pointer. */
+		dst++;
+		/* Incrment output character count. */
+		olen += clen;
+	}
+
+	/* Terminate the output string. */
+	*mbdst = '\0';
+
+	if (flags & VIS_NOLOCALE) {
+		/* Pass conversion error flag out. */
+		if (cerr_ptr)
+			*cerr_ptr = cerr;
+	}
+
+	free(extra);
+	free(pdst);
+	free(psrc);
+
+	return (int)olen;
+out:
+	free(extra);
+	free(pdst);
+	free(psrc);
+	free(mdst);
+	return error;
+}
+
+static int
+istrsenvisxl(char **mbdstp, size_t *dlen, const char *mbsrc,
+    int flags, const char *mbextra, int *cerr_ptr)
+{
+	return istrsenvisx(mbdstp, dlen, mbsrc,
+	    mbsrc != NULL ? strlen(mbsrc) : 0, flags, mbextra, cerr_ptr);
+}
+
+#endif
+
+#if !HAVE_SVIS
+/*
+ *	The "svis" variants all take an "extra" arg that is a pointer
+ *	to a NUL-terminated list of characters to be encoded, too.
+ *	These functions are useful e. g. to encode strings in such a
+ *	way so that they are not interpreted by a shell.
+ */
+
+char *
+svis(char *mbdst, int c, int flags, int nextc, const char *mbextra)
+{
+	char cc[2];
+	int ret;
+
+	cc[0] = c;
+	cc[1] = nextc;
+
+	ret = istrsenvisx(&mbdst, NULL, cc, 1, flags, mbextra, NULL);
+	if (ret < 0)
+		return NULL;
+	return mbdst + ret;
+}
+
+char *
+snvis(char *mbdst, size_t dlen, int c, int flags, int nextc, const char *mbextra)
+{
+	char cc[2];
+	int ret;
+
+	cc[0] = c;
+	cc[1] = nextc;
+
+	ret = istrsenvisx(&mbdst, &dlen, cc, 1, flags, mbextra, NULL);
+	if (ret < 0)
+		return NULL;
+	return mbdst + ret;
+}
+
+int
+strsvis(char *mbdst, const char *mbsrc, int flags, const char *mbextra)
+{
+	return istrsenvisxl(&mbdst, NULL, mbsrc, flags, mbextra, NULL);
+}
+
+int
+strsnvis(char *mbdst, size_t dlen, const char *mbsrc, int flags, const char *mbextra)
+{
+	return istrsenvisxl(&mbdst, &dlen, mbsrc, flags, mbextra, NULL);
+}
+
+int
+strsvisx(char *mbdst, const char *mbsrc, size_t len, int flags, const char *mbextra)
+{
+	return istrsenvisx(&mbdst, NULL, mbsrc, len, flags, mbextra, NULL);
+}
+
+int
+strsnvisx(char *mbdst, size_t dlen, const char *mbsrc, size_t len, int flags,
+    const char *mbextra)
+{
+	return istrsenvisx(&mbdst, &dlen, mbsrc, len, flags, mbextra, NULL);
+}
+
+int
+strsenvisx(char *mbdst, size_t dlen, const char *mbsrc, size_t len, int flags,
+    const char *mbextra, int *cerr_ptr)
+{
+	return istrsenvisx(&mbdst, &dlen, mbsrc, len, flags, mbextra, cerr_ptr);
+}
+#endif
+
+#if !HAVE_VIS
+/*
+ * vis - visually encode characters
+ */
+char *
+vis(char *mbdst, int c, int flags, int nextc)
+{
+	char cc[2];
+	int ret;
+
+	cc[0] = c;
+	cc[1] = nextc;
+
+	ret = istrsenvisx(&mbdst, NULL, cc, 1, flags, "", NULL);
+	if (ret < 0)
+		return NULL;
+	return mbdst + ret;
+}
+
+char *
+nvis(char *mbdst, size_t dlen, int c, int flags, int nextc)
+{
+	char cc[2];
+	int ret;
+
+	cc[0] = c;
+	cc[1] = nextc;
+
+	ret = istrsenvisx(&mbdst, &dlen, cc, 1, flags, "", NULL);
+	if (ret < 0)
+		return NULL;
+	return mbdst + ret;
+}
+
+/*
+ * strvis - visually encode characters from src into dst
+ *
+ *	Dst must be 4 times the size of src to account for possible
+ *	expansion.  The length of dst, not including the trailing NULL,
+ *	is returned.
+ */
+
+int
+strvis(char *mbdst, const char *mbsrc, int flags)
+{
+	return istrsenvisxl(&mbdst, NULL, mbsrc, flags, "", NULL);
+}
+
+int
+strnvis(char *mbdst, size_t dlen, const char *mbsrc, int flags)
+{
+	return istrsenvisxl(&mbdst, &dlen, mbsrc, flags, "", NULL);
+}
+
+int
+stravis(char **mbdstp, const char *mbsrc, int flags)
+{
+	*mbdstp = NULL;
+	return istrsenvisxl(mbdstp, NULL, mbsrc, flags, "", NULL);
+}
+
+/*
+ * strvisx - visually encode characters from src into dst
+ *
+ *	Dst must be 4 times the size of src to account for possible
+ *	expansion.  The length of dst, not including the trailing NULL,
+ *	is returned.
+ *
+ *	Strvisx encodes exactly len characters from src into dst.
+ *	This is useful for encoding a block of data.
+ */
+
+int
+strvisx(char *mbdst, const char *mbsrc, size_t len, int flags)
+{
+	return istrsenvisx(&mbdst, NULL, mbsrc, len, flags, "", NULL);
+}
+
+int
+strnvisx(char *mbdst, size_t dlen, const char *mbsrc, size_t len, int flags)
+{
+	return istrsenvisx(&mbdst, &dlen, mbsrc, len, flags, "", NULL);
+}
+
+int
+strenvisx(char *mbdst, size_t dlen, const char *mbsrc, size_t len, int flags,
+    int *cerr_ptr)
+{
+	return istrsenvisx(&mbdst, &dlen, mbsrc, len, flags, "", cerr_ptr);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vwarn.c third_party/newlib-4.1.0/newlib/libc/sys/arm/vwarn.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vwarn.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/vwarn.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,55 @@
+/*	$NetBSD: vwarn.c,v 1.16 2014/01/16 17:21:38 christos Exp $	*/
+
+/*-
+ * Copyright (c) 2014 The NetBSD Foundation, Inc.
+ * All rights reserved.
+ *
+ * This code is derived from software contributed to The NetBSD Foundation
+ * by Christos Zoulas.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
+ * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+ * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+__RCSID("$NetBSD: vwarn.c,v 1.16 2014/01/16 17:21:38 christos Exp $");
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <errno.h>
+
+#ifdef __weak_alias
+__weak_alias(vwarn, _vwarn)
+#endif
+
+#if !HAVE_ERR_H
+void
+vwarn(const char *fmt, va_list ap)
+{
+	vwarnc(errno, fmt, ap);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vwarnc.c third_party/newlib-4.1.0/newlib/libc/sys/arm/vwarnc.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vwarnc.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/vwarnc.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,67 @@
+/*	$NetBSD: vwarnc.c,v 1.3 2014/06/06 11:38:41 joerg Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: vwarnc.c,v 1.3 2014/06/06 11:38:41 joerg Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#ifdef __weak_alias
+__weak_alias(vwarnc, _vwarnc)
+#endif
+
+#if !HAVE_ERR_H || !HAVE_DECL_VWARNC
+void
+vwarnc(int code, const char *fmt, va_list ap)
+{
+	(void)fprintf(stderr, "%s: ", getprogname());
+	if (fmt != NULL) {
+		(void)vfprintf(stderr, fmt, ap);
+		(void)fprintf(stderr, ": ");
+	}
+	(void)fprintf(stderr, "%s\n", strerror(code));
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vwarnx.c third_party/newlib-4.1.0/newlib/libc/sys/arm/vwarnx.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/vwarnx.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/vwarnx.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,64 @@
+/*	$NetBSD: vwarnx.c,v 1.15 2011/07/17 20:54:34 joerg Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: vwarnx.c,v 1.15 2011/07/17 20:54:34 joerg Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+
+#ifdef __weak_alias
+__weak_alias(vwarnx, _vwarnx)
+#endif
+
+#if !HAVE_ERR_H
+void
+vwarnx(const char *fmt, va_list ap)
+{
+	(void)fprintf(stderr, "%s: ", getprogname());
+	if (fmt != NULL)
+		(void)vfprintf(stderr, fmt, ap);
+	(void)fprintf(stderr, "\n");
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/wait.c third_party/newlib-4.1.0/newlib/libc/sys/arm/wait.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/wait.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/wait.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,32 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/* @brief Wait for a process terminate
+ * 
+ */
+pid_t waitpid (pid_t pid, int *status, int options)
+{
+  pid_t rpid;
+  
+  rpid = _swi_waitpid (pid, status, options);
+  
+  if (rpid < 0) {
+    errno = -rpid;
+    return -1;
+  }
+  
+  return rpid;
+}
+
+
+/* @brief Wait for any process to terminate
+ * 
+ */
+int wait (int *status)
+{
+ return waitpid (-1, status, 0);
+}
+
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warn.c third_party/newlib-4.1.0/newlib/libc/sys/arm/warn.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warn.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/warn.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,63 @@
+/*	$NetBSD: warn.c,v 1.14 2007/06/18 14:13:54 ginsbach Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: warn.c,v 1.14 2007/06/18 14:13:54 ginsbach Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+
+#ifdef __weak_alias
+__weak_alias(warn, _warn)
+#endif
+
+#if !HAVE_ERR_H
+void
+warn(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	vwarn(fmt, ap);
+	va_end(ap);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warnc.c third_party/newlib-4.1.0/newlib/libc/sys/arm/warnc.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warnc.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/warnc.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,63 @@
+/*	$NetBSD: warnc.c,v 1.3 2014/06/06 11:38:41 joerg Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: warnc.c,v 1.3 2014/06/06 11:38:41 joerg Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+
+#ifdef __weak_alias
+__weak_alias(warnc, _warnc)
+#endif
+
+#if !HAVE_ERR_H || !HAVE_DECL_WARNC
+void
+warnc(int code, const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	vwarnc(code, fmt, ap);
+	va_end(ap);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warning.h third_party/newlib-4.1.0/newlib/libc/sys/arm/warning.h
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warning.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/warning.h	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,43 @@
+#ifndef __WARNING_H__
+#define __WARNING_H__
+
+#ifdef HAVE_GNU_LD
+# ifdef HAVE_ELF
+
+/* We want the .gnu.warning.SYMBOL section to be unallocated.  */
+#  ifdef HAVE_ASM_PREVIOUS_DIRECTIVE
+#   define __make_section_unallocated(section_string)   \
+  asm(".section " section_string "; .previous");
+#  elif defined (HAVE_ASM_POPSECTION_DIRECTIVE)
+#   define __make_section_unallocated(section_string)   \
+  asm(".pushsection " section_string "; .popsection");
+#  else
+#   define __make_section_unallocated(section_string)
+#  endif
+
+#  ifdef HAVE_SECTION_ATTRIBUTES
+#   define link_warning(symbol, msg)                     \
+  __make_section_unallocated (".gnu.warning." #symbol)  \
+  static const char __evoke_link_warning_##symbol[]     \
+    __attribute__ ((section (".gnu.warning." #symbol))) = msg;
+#  else
+#   define link_warning(symbol, msg)
+#  endif
+
+#else /* !ELF */
+
+#  define link_warning(symbol, msg)             \
+  asm(".stabs \"" msg "\",30,0,0,0\n"   \
+      ".stabs \"" __SYMBOL_PREFIX #symbol "\",1,0,0,0\n");
+# endif
+#else /* !GNULD */
+/* We will never be heard; they will all die horribly.  */
+# define link_warning(symbol, msg)
+#endif
+
+/* A canned warning for sysdeps/stub functions.  */
+#define stub_warning(name) \
+  link_warning (name, \
+                "warning: " #name " is not implemented and will always fail")
+
+#endif /* __WARNING_H__ */
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warnx.c third_party/newlib-4.1.0/newlib/libc/sys/arm/warnx.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/warnx.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/warnx.c	2024-03-17 17:47:03.411194527 +0000
@@ -0,0 +1,63 @@
+/*	$NetBSD: warnx.c,v 1.14 2007/06/18 14:13:54 ginsbach Exp $	*/
+
+/*-
+ * Copyright (c) 1993
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+#if HAVE_NBTOOL_CONFIG_H
+#include "nbtool_config.h"
+#endif
+
+#include <sys/cdefs.h>
+#if defined(LIBC_SCCS) && !defined(lint)
+#if 0
+static char sccsid[] = "@(#)err.c	8.1 (Berkeley) 6/4/93";
+#else
+__RCSID("$NetBSD: warnx.c,v 1.14 2007/06/18 14:13:54 ginsbach Exp $");
+#endif
+#endif /* LIBC_SCCS and not lint */
+
+#include "namespace.h"
+#include <err.h>
+#include <stdarg.h>
+
+#ifdef __weak_alias
+__weak_alias(warnx, _warnx)
+#endif
+
+#if !HAVE_ERR_H
+void
+warnx(const char *fmt, ...)
+{
+	va_list ap;
+
+	va_start(ap, fmt);
+	vwarnx(fmt, ap);
+	va_end(ap);
+}
+#endif
diff -aurN third_party_original/newlib-4.1.0/newlib/libc/sys/arm/write.c third_party/newlib-4.1.0/newlib/libc/sys/arm/write.c
--- third_party_original/newlib-4.1.0/newlib/libc/sys/arm/write.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-4.1.0/newlib/libc/sys/arm/write.c	2024-03-17 17:47:03.407194450 +0000
@@ -0,0 +1,22 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+/* @brief Write to a file
+ * 
+ */
+ssize_t write (int fd, const void *buf, size_t nbyte)
+{
+    ssize_t sz;
+    
+    sz = _swi_write(fd, buf, nbyte);
+    
+    if (sz < 0) {
+        errno = -sz;
+        return -1;
+    }
+	
+	return sz;
+}
+
