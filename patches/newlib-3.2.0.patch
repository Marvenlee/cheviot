diff -urN third_party/newlib-3.2.0/configure third_party_new_z/newlib-3.2.0/configure
--- third_party/newlib-3.2.0/configure
+++ third_party_new_z/newlib-3.2.0/configure
@@ -3620,6 +3620,9 @@
 
 # Disable newlib and libgloss for various target OSes.
 case "${target}" in
+  arm*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   alpha*-dec-osf*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -urN third_party/newlib-3.2.0/configure.ac third_party_new_z/newlib-3.2.0/configure.ac
--- third_party/newlib-3.2.0/configure.ac
+++ third_party_new_z/newlib-3.2.0/configure.ac
@@ -956,6 +956,9 @@
 
 # Disable newlib and libgloss for various target OSes.
 case "${target}" in
+  arm*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   alpha*-dec-osf*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -urN third_party/newlib-3.2.0/newlib/configure.host third_party_new_z/newlib-3.2.0/newlib/configure.host
--- third_party/newlib-3.2.0/newlib/configure.host
+++ third_party_new_z/newlib-3.2.0/newlib/configure.host
@@ -464,11 +464,11 @@
 	have_crt0="no"
 	;;
   arm*-*-*)
-	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB"
+	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB -D_HAVE_STDC"
 	sys_dir=arm
-	if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
-	  have_crt0="no"
-	fi
+    newlib_cflags="${newlib_cflags} -DHAVE_GETTIMEOFDAY -DMALLOC_PROVIDED -DEXIT_PROVIDED -DMISSING_SYSCALL_NAMES -DHAVE_OPENDIR -DHAVE_RENAME"
+	newlib_cflags="${newlib_cflags} -D_NO_GETLOGIN -D_NO_GETPWENT -D_NO_GETUT -D_NO_GETPASS -D_NO_WORDEXP -D_NO_POPEN"
+	unix_dir=unix
 	;;
   bfin-*-*)
 	sys_dir=
@@ -691,7 +691,7 @@
 	syscall_dir=syscalls
 	;;
   arm*-*-*)
-	syscall_dir=syscalls
+	syscall_dir=
 # If newlib is supplying syscalls, select which debug protocol is being used.
 # ARM_RDP_MONITOR selects the Demon monitor.
 # ARM_RDI_MONITOR selects the Angel monitor.
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/access.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/access.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/access.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/access.c
@@ -1,33 +1,43 @@
-/* This is file ACCESS.C */
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+
+
 /*
- * Copyright (C) 1993 DJ Delorie
- * All rights reserved.
- *
- * Redistribution, modification, and use in source and binary forms is permitted
- * provided that the above copyright notice and following paragraph are
- * duplicated in all such forms.
  *
- * This file is distributed WITHOUT ANY WARRANTY; without even the implied
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  */
 
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <unistd.h>
+int access(const char *path, int amode)
+{
+    int sc;
+    
+  	sc = Access(path, amode);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
+
+
+
+
+/*
+ *
+ */
 
-int access(const char *fn, int flags)
+mode_t umask(mode_t cmask)
 {
-  struct stat s;
-  if (stat(fn, &s))
-    return -1;
-  if (s.st_mode & S_IFDIR)
-    return 0;
-  if (flags & W_OK)
-  {
-    if (s.st_mode & S_IWRITE)
-      return 0;
-    return -1;
-  }
-  return 0;
+    mode_t mask;
+    
+  	mask = Umask(cmask);
+    return mask;	
+
 }
-	
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h
@@ -0,0 +1,26 @@
+/* Name of package.  */
+#undef PACKAGE
+
+/* Version of package.  */
+#undef VERSION
+
+/* Missing syscall names */
+#undef MISSING_SYSCALL_NAMES
+
+/* Using ELF format */
+#undef HAVE_ELF
+
+/* Using GNU LD */
+#undef HAVE_GNU_LD
+
+/* .previous directive allowed */
+#undef HAVE_ASM_PREVIOUS_DIRECTIVE
+
+/* .pushsection/.popsection directives allowed */
+#undef HAVE_ASM_POPSECTION_DIRECTIVE
+
+/* support for section attributes */
+#undef HAVE_SECTION_ATTRIBUTES
+
+/* symbol prefix */
+#undef __SYMBOL_PREFIX
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c
@@ -1,13 +0,0 @@
-#include <stdlib.h>
-
-/* forward declaration */
-extern int __cxa_atexit (void (*) (void *), void *, void *);
-
-/* Register a function to be called by exit or when a shared library
-   is unloaded.  This routine is like __cxa_atexit, but uses the
-   calling sequence required by the ARM EABI.  */
-int
-__aeabi_atexit (void *arg, void (*func) (void *), void *d)
-{
-  return __cxa_atexit (func, arg, d);
-}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/alarm.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/alarm.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/alarm.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/alarm.c
@@ -0,0 +1,13 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+
+
+
+unsigned int alarm (unsigned int seconds)
+{
+  return Alarm(seconds);
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/arm.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/arm.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/arm.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/arm.h
@@ -29,27 +29,25 @@
 #ifndef _LIBGLOSS_ARM_H
 #define _LIBGLOSS_ARM_H
 
-#include "acle-compat.h"
-
-/* Checking for targets supporting only Thumb instructions (eg. ARMv6-M) or
-   supporting Thumb-2 instructions, whether ARM instructions are available or
-   not, is done many times in libgloss/arm.  So factor it out and use
-   PREFER_THUMB instead.  */
-#if __thumb2__ || (__thumb__ && !__ARM_ARCH_ISA_ARM)
-# define PREFER_THUMB
-#endif
-
-/* Processor only capable of executing Thumb-1 instructions.  */
-#if __ARM_ARCH_ISA_THUMB == 1 && !__ARM_ARCH_ISA_ARM
-# define THUMB1_ONLY
+/* __thumb2__ stands for thumb on armva7(A/R/M/EM) architectures,
+   __ARM_ARCH_6M__ stands for armv6-M(thumb only) architecture,
+   __ARM_ARCH_7M__ stands for armv7-M(thumb only) architecture.
+   __ARM_ARCH_7EM__ stands for armv7e-M(thumb only) architecture.
+   There are some macro combinations used many times in libgloss/arm,
+   like (__thumb2__ || (__thumb__ && __ARM_ARCH_6M__)), so factor
+   it out and use THUMB_V7_V6M instead, which stands for thumb on
+   v6-m/v7 arch as the combination does.  */
+#if defined(__thumb2__) || (defined(__thumb__) && defined(__ARM_ARCH_6M__))
+# define THUMB_V7_V6M
 #endif
 
-/* M profile architectures.  This is a different set of architectures than
-   those not having ARM ISA because it does not contain ARMv7.  This macro is
-   necessary to test which architectures use bkpt as semihosting interface from
-   architectures using svc.  */
-#if !__ARM_ARCH_ISA_ARM && !__ARM_ARCH_7__
-# define THUMB_VXM
+/* The (__ARM_ARCH_7EM__ || __ARM_ARCH_7M__ || __ARM_ARCH_6M__) combination
+   stands for cortex-M profile architectures, which don't support ARM state.
+   Factor it out and use THUMB_V7M_V6M instead.  */
+#if defined(__ARM_ARCH_7M__)     \
+    || defined(__ARM_ARCH_7EM__) \
+    || defined(__ARM_ARCH_6M__)
+# define THUMB_V7M_V6M
 #endif
 
 /* Defined if this target supports the BLX Rm instruction.  */
@@ -61,30 +59,4 @@
 # define HAVE_CALL_INDIRECT
 #endif
 
-/* A and R profiles (and legacy Arm).
-	Current Program Status Register (CPSR)
-	M[4:0]		Mode bits. M[4] is always 1 for 32-bit modes.
-	T[5]			1: Thumb, 0: ARM instruction set
-	F[6]			1: disables FIQ
-	I[7]			1: disables IRQ
-	A[8]			1: disables imprecise aborts
-	E[9]			0: Little-endian, 1: Big-endian
-	J[24]			1: Jazelle instruction set
- */
-#define CPSR_M_USR			0x00	/* User mode.  */
-#define CPSR_M_FIQ			0x01	/* Fast Interrupt mode.  */
-#define CPSR_M_IRQ			0x02	/* Interrupt mode.  */
-#define CPSR_M_SVR			0x03	/* Supervisor mode.  */
-#define CPSR_M_MON			0x06	/* Monitor mode.  */
-#define CPSR_M_ABT			0x07	/* Abort mode.  */
-#define CPSR_M_HYP			0x0A	/* Hypervisor mode.  */
-#define CPSR_M_UND			0x0B	/* Undefined mode.  */
-#define CPSR_M_SYS			0x0F	/* System mode.  */
-#define CPSR_M_32BIT		0x10	/* 32-bit mode.  */
-#define CPSR_T_BIT			0x20	/* Thumb bit.  */
-#define CPSR_F_MASK			0x40	/* FIQ bit.  */
-#define CPSR_I_MASK			0x80	/* IRQ bit.  */
-
-#define CPSR_M_MASK			0x0F	/* Mode mask except M[4].  */
-
 #endif /* _LIBGLOSS_ARM_H */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/cheviot.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/cheviot.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/cheviot.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/cheviot.c
@@ -0,0 +1,3 @@
+// Cheviot-Specific system calls.
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/chmod.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/chmod.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/chmod.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/chmod.c
@@ -0,0 +1,38 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+
+int chmod(const char *__path, mode_t __mode )
+{
+  int sc;
+  
+  sc = Chmod(__path, __mode);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+int chown (const char *__path, uid_t __owner, gid_t __group )
+{
+  int sc;
+  
+  sc = Chown(__path, __owner, __group);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/close.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/close.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/close.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/close.c
@@ -0,0 +1,21 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+int close (int fd)
+{
+    int sc;
+    
+    sc = Close(fd);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/closedir.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/closedir.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/closedir.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/closedir.c
@@ -0,0 +1,33 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+int closedir (DIR *dir)
+{
+    int sc;
+    	
+	if (dir == NULL)
+	{
+		errno = EINVAL;
+		return -1;
+	}
+	
+	sc = Close (dir->fd);
+	
+	if (sc < 0)
+	{
+	    errno = -sc;
+		return -1;
+    }
+    
+	free (dir->buf);
+	free (dir);
+	return 0;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/configure third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/configure
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/configure
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/configure
@@ -561,7 +561,7 @@
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
-ac_unique_file="trap.S"
+ac_unique_file="cheviot.c"
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 sys_dir
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/configure.in third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/configure.in
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/configure.in
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/configure.in
@@ -3,7 +3,7 @@
 
 AC_PREREQ(2.59)
 AC_INIT([newlib],[NEWLIB_VERSION])
-AC_CONFIG_SRCDIR([trap.S])
+AC_CONFIG_SRCDIR([cheviot.c])
 
 dnl Can't be done in NEWLIB_CONFIGURE because that confuses automake. 
 AC_CONFIG_AUX_DIR(../../../..)
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/creat.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/creat.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/creat.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/creat.c
@@ -0,0 +1,15 @@
+#include <fcntl.h>
+#include <sys/syscalls.h>
+
+
+
+
+/*
+ *
+ */
+
+int creat (const char *path, mode_t mode)
+{
+  return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/crt0.S third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/crt0.S
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/crt0.S
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/crt0.S
@@ -1,6 +1,7 @@
 #include "newlib.h"
 #include "arm.h"
-#include "swi.h"
+
+.extern environ
 
 /* ANSI concatenation macros.  */
 #define CONCAT(a, b) CONCAT2(a, b)
@@ -12,6 +13,7 @@
 #error __USER_LABEL_PREFIX is not defined
 #endif
 
+
 #ifdef HAVE_INITFINI_ARRAY
 #define _init	__libc_init_array
 #define _fini	__libc_fini_array
@@ -41,38 +43,25 @@
 #endif
 #endif
 
+
+
 /* .text is used instead of .section .text so it works with arm-aout too.  */
 	.text
 	.syntax unified
-#ifdef PREFER_THUMB
+#ifdef THUMB_V7_V6M
 	.thumb
 .macro FUNC_START name
 	.global \name
 	.thumb_func
 \name:
-.endm
+.endm	
 #else
 	.code 32
 .macro FUNC_START name
-	.global \name
+	.global	\name
 \name:
-.endm
-#endif
-
-/* Annotation for EABI unwinding tables.  */
-.macro FN_EH_START
-#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
-	.fnstart
+.endm	
 #endif
-.endm
-
-.macro FN_EH_END
-#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
-	/* Protect against unhandled exceptions.  */
-	.cantunwind
-	.fnend
-#endif
-.endm
 
 .macro indirect_call reg
 #ifdef HAVE_CALL_INDIRECT
@@ -83,552 +72,74 @@
 #endif
 .endm
 
-/* For armv4t and newer, toolchains will transparently convert
-   'bx lr' to 'mov pc, lr' if needed. GCC has deprecated support
-   for anything older than armv4t, but this should handle that
-   corner case in case anyone needs it anyway.  */
-.macro  FN_RETURN
-#if __ARM_ARCH <= 4 && __ARM_ARCH_ISA_THUMB == 0
-	mov	pc, lr
-#else
-	bx	lr
-#endif
-.endm
 
 
 
-/******************************************************************************
-* User mode only:           This routine makes default target specific Stack
-*   +-----+ <- SL_sys,    Pointer initialization for different processor modes:
-*   |     |    SL_usr     FIQ, Abort, IRQ, Undefined, Supervisor, System (User)
-*   | SYS |               and setups a default Stack Limit in-case the code has
-*   | USR | -=0x10000     been compiled with "-mapcs-stack-check" for FIQ and
-*   |     |               System (User) modes.
-*   |     |
-*   +-----+ <- initial SP,
-*           becomes SP_sys   Hard-wiring SL value is not ideal, since there is
-*           and SL_usr     currently no support for checking that the heap and
-*                          stack have not collided, or that this default 64k is
-* All modes:               is enough for the program being executed. However,
-*   +-----+ <- SL_sys,     it ensures that this simple crt0 world will not
-*   |     |    SL_usr      immediately cause an overflow event.
-*   | SYS |
-*   | USR | -=0x10000        We go through all execution modes and set up SP
-*   |     |                for each of them.
-*   +-----+ <- SP_sys,
-*   |     |    SP_usr      Notes:
-*   | SVC | -= 0x8000       - This code will not work as intended if the system
-*   |     |                   starts in secure mode. In particular the methods
-*   +-----+ <- SP_svc         of getting in and out of secure state are not as
-*   |     |                   simple as writing to the CPSR mode bits.
-*   | IRQ | -= 0x2000       - Mode switch via CPSR is not allowed once in
-*   |     |                   non-privileged mode, so we take care not to enter
-* ^ +-----+ <- SP_und         "User" to set up its SP, and also skip most
-* s |     |                   operations if already in that mode.
-* t | UND | -= 0x1000
-* a |     |                Input parameters:
-* c +-----+ <- SP_und       - sp - Initialized SP
-* k |     |                 - r2 - May contain SL value from semihosting
-*   | ABT | -= 0x1000              SYS_HEAPINFO call
-* g |     |                Scratch registers:
-* r +-----+ <- SP_abt,      - r1 - new value of CPSR
-* o |     |    SL_fiq       - r2 - intermediate value (in standalone mode)
-* w | FIQ | -= 0x1000       - r3 - new SP value
-* t |     |                 - r4 - save/restore CPSR on entry/exit
-* h +-----+ <- initial SP,
-*           becomes SP_fiq   Declared as "weak" so that user can write and use
-*                          his own implementation if current doesn't fit.
-*
-******************************************************************************/
-	.align	0
-	FUNC_START	_stack_init
-	.weak FUNCTION (_stack_init)
-	FN_EH_START
-
-	/* M profile doesn't have CPSR register.  */
-#if (__ARM_ARCH_PROFILE != 'M')
-	/* Following code is compatible for both ARM and Thumb ISA.  */
-	mrs	r4, CPSR
-	/* Test mode bits - in User of all are 0.  */
-	tst	r4, #(CPSR_M_MASK)
-	/* "eq" means r4 AND #0x0F is 0.  */
-	beq	.Lskip_cpu_modes
-
-	mov	r3, sp /* Save input SP value.  */
-
-	/* FIQ mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_FIQ|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	sl, sp, #0x1000	/* FIQ mode has its own SL.  */
-
-	/* Abort mode, interrupts disabled.  */
-	mov	r3, sl
-	mov	r1, #(CPSR_M_ABT|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x1000
-
-	/* Undefined mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_UND|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x1000
-
-	/* IRQ mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_IRQ|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x2000
-
-	/* Supervisory mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_SVR|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-
-	sub	r3, r3, #0x8000	/* Min size 32k.  */
-	bic	r3, r3, #0x00FF	/* Align with current 64k block.  */
-	bic	r3, r3, #0xFF00
-
-# if __ARM_ARCH >= 4
-	/* System (shares regs with User) mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_SYS|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-# else
-	/* Keep this for ARMv3, but GCC actually dropped it.  */
-	/* Move value into user mode SP without changing modes,  */
-	/* via '^' form of ldm.  */
-	str	r3, [r3, #-4]
-	ldmdb	r3, {sp}^
-# endif
-
-	/* Back to original mode, presumably SVC, with diabled FIQ/IRQ.  */
-	orr	r4, r4, #(CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r4
 
-.Lskip_cpu_modes:
-#endif
-
-	/* Set SL register.  */
-#if defined (ARM_RDI_MONITOR) /* semihosting */
-	cmp	r2, #0
-	beq	.Lsl_forced_zero
-	/* Allow slop for stack overflow handling and small frames.  */
-# ifdef THUMB1_ONLY
-	adds	r2, #128
-	adds	r2, #128
-	mov	sl, r2
-# else
-	add	sl, r2, #256
-# endif
-.Lsl_forced_zero:
-
-#else /* standalone */
-	/* r3 contains SP for System/User mode. Set SL = SP - 0x10000.  */
-	#ifdef THUMB1_ONLY
-	movs	r2, #64
-	lsls	r2, r2, #10
-	subs	r2, r3, r2
-	mov	sl, r2
-	#else
-	/* Still assumes 256bytes below SL.  */
-	sub	sl, r3, #64 << 10
-	#endif
-#endif
-
-	FN_RETURN
-	FN_EH_END
 
+.balign 	16
 
-/*******************************************************************************
-* Main library startup code.
-*******************************************************************************/
-	.align 	0
 	FUNC_START	_mainCRTStartup
 	FUNC_START	_start
-	FN_EH_START
+	FUNC_START	start
 
-/* Start by setting up a stack.  */
-#ifdef ARM_RDP_MONITOR
-	/*  Issue Demon SWI to read stack info.  */
-	swi	SWI_GetEnv	/*  Returns command line in r0.  */
-	mov	sp,r1		/*  and the highest memory address in r1.  */
-
-	/*  Stack limit is at end of data.  */
-	/*  Allow slop for stack overflow handling and small frames.  */
-#ifdef THUMB1_ONLY
-	ldr	r0, .LC2
-	adds	r0, #128
-	adds	r0, #128
-	mov	sl, r0
-#else
-	ldr	sl, .LC2
-	add	sl, sl, #256
-#endif
-#else
-#ifdef ARM_RDI_MONITOR
-	/*  Issue Angel SWI to read stack info.  */
-	movs	r0, #AngelSWI_Reason_HeapInfo
-	adr	r1, .LC0	/*  Point at ptr to 4 words to receive data.  */
-#ifdef THUMB_VXM
-	bkpt	AngelSWI
-#elif defined(__thumb2__)
-	/*  We are in thumb mode for startup on armv7 architectures.  */
-	AngelSWIAsm	AngelSWI
-#else
-	/*  We are always in ARM mode for startup on pre armv7 archs.  */
-	AngelSWIAsm	AngelSWI_ARM
-#endif
-	ldr	r0, .LC0	/*  Point at values read.  */
-
-	/* Set __heap_limit.  */
-	ldr     r1, [r0, #4]
-	cmp     r1, #0
-	beq     .LC33
-	ldr     r2, =__heap_limit
-	str     r1, [r2]
-.LC33:
-	ldr     r1, [r0, #0]
-	cmp     r1, #0
-	bne     .LC32
-	/* If the heap base value [r0, #0] is 0 then the heap base is actually 
-	   at the end of program data (i.e. __end__). See:
-           http://infocenter.arm.com/help/topic/com.arm.doc.dui0471-/Bacbefaa.html
-	   for more information.  */
-	ldr     r1, .LC31
-	str     r1, [r0, #0]
-.LC32:	
-	ldr	r1, [r0, #8]
-	ldr	r2, [r0, #12]
-	/*  We skip setting SP/SL if 0 returned from semihosting.
-	    - According to semihosting docs, if 0 returned from semihosting,
-	      the system was unable to calculate the real value, so it's ok
-	      to skip setting SP/SL to 0 here.
-	    - Considering M-profile processors, We might want to initialize
-	      SP by the first entry of vector table and return 0 to SYS_HEAPINFO
-	      semihosting call, which will be skipped here.
-	    - Considering R-profile processors there is no automatic SP init by hardware
-	      so we need to initialize it by default value.  */
-	ldr	r3, .Lstack
-	cmp	r1, #0
-	beq	.LC26
-	mov	r3, r1
-.LC26:
-	mov	sp, r3
-
-	/* r2 (SL value) will be used in _stack_init.  */
-	bl FUNCTION (_stack_init)
-
-
-#else /* standalone */
-	/*  Set up the stack pointer to a fixed value. */
-	/*  Changes by toralf:
-	    - Allow linker script to provide stack via __stack symbol - see
-	      defintion of .Lstack
-	    - Provide "hooks" that may be used by the application to add
-	      custom init code - see .Lhwinit and .Lswinit.  */
-
-	ldr	r3, .Lstack
-	cmp	r3, #0
-#ifdef __thumb2__
-	it	eq
-#endif	
-#ifdef THUMB1_ONLY
-	bne	.LC28
-	ldr	r3, .LC0
-.LC28:
-#else
-	ldreq	r3, .LC0
-#endif
-	/* Note: This 'mov' is essential when starting in User, and ensures we
-		 always get *some* SP value for the initial mode, even if we
-		 have somehow missed it below (in which case it gets the same
-		 value as FIQ - not ideal, but better than nothing).  */
-	mov	sp, r3
+// r0 argc
+// r1 argv
+// r2 envc
+// r3 envv
 
-	/* We don't care of r2 value in standalone.  */
-	bl FUNCTION (_stack_init)
+    ldr r4, =environ
+    str r3, [r4]
 
+#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+	/* Annotation for EABI unwinding tables.  */
+	.fnstart
 #endif
-#endif
-	/* Zero the memory in the .bss section.  */
-	movs 	a2, #0			/* Second arg: fill value.  */
-	mov	fp, a2			/* Null frame pointer.  */
-	mov	r7, a2			/* Null frame pointer for Thumb.  */
-	
-	ldr	a1, .LC1		/* First arg: start of memory block.  */
-	ldr	a3, .LC2	
-	subs	a3, a3, a1		/* Third arg: length of block.  */
-	
-
-#if __thumb__ && !defined(PREFER_THUMB)
-	/* Enter Thumb mode...  */
-	add	a4, pc, #1	/* Get the address of the Thumb block.  */
-	bx	a4		/* Go there and start Thumb decoding.  */
 
-	.code 16
-	.global __change_mode
-	.thumb_func
-__change_mode:	
-#endif
-	
-	bl	FUNCTION (memset)
-#if !defined (ARM_RDP_MONITOR) && !defined (ARM_RDI_MONITOR)
-/* Changes by toralf: Taken from libgloss/m68k/crt0.S
-   initialize target specific stuff. Only execute these
-   functions it they exist.  */
-	ldr	r3, .Lhwinit
-	cmp	r3, #0
-	beq	.LC24
-	indirect_call r3
-.LC24:	
-	ldr	r3, .Lswinit
-	cmp	r3, #0
-	beq	.LC25
-	indirect_call r3
-
-.LC25:	
-	movs	r0, #0		/* No arguments.  */
-	movs	r1, #0		/* No argv either.  */
-#else
-	/* Need to set up standard file handles.  */
-	bl	FUNCTION (initialise_monitor_handles)
-	
-#ifdef ARM_RDP_MONITOR
-	swi	SWI_GetEnv	/* Sets r0 to point to the command line.  */
-	movs	r1, r0
-#else
-	movs	r0, #AngelSWI_Reason_GetCmdLine
-	ldr	r1, .LC30	/* Space for command line.  */
-#ifdef THUMB_VXM
-	bkpt	AngelSWI
-#else
- 	AngelSWIAsm	AngelSWI
-#endif
-	ldr	r1, .LC30
-	ldr	r1, [r1]
-#endif
-	/*  Parse string at r1.  */
-	movs	r0, #0		/* Count of arguments so far.  */
-	/* Push a NULL argument onto the end of the list.  */
-#ifdef __thumb__
-	push	{r0}
-#else
-	stmfd	sp!, {r0}
-#endif
-.LC10:
-/*  Skip leading blanks.  */
-#ifdef __thumb__
-	ldrb	r3, [r1]
-	adds	r1, #1
-#else
-	ldrb	r3, [r1], #1
-#endif
-	cmp	r3, #0
-	beq	.LC12
-	cmp	r3, #' '
-	beq	.LC10
-
-/* See whether we are scanning a string.  */
-	cmp	r3, #'\"'
-#ifdef __thumb__
-	beq	.LC20
-	cmp	r3, #'\''
-	bne	.LC21
-.LC20:
-	movs	r2, r3
-	b	.LC22
-
-.LC21:
-	movs	r2, #' '	/* Terminator type.  */
-	subs	r1, r1, #1	/* Adjust back to point at start char.  */
-.LC22:
-#else
-	cmpne	r3, #'\''
-	moveq	r2, r3
-	movne	r2, #' '	/* Terminator type.  */
-	subne	r1, r1, #1	/* Adjust back to point at start char.  */
-#endif
 
-/*  Stack a pointer to the current argument.  */
-#ifdef __thumb__
-	push	{r1}
-#else
-	stmfd	sp!, {r1}
-#endif
-	adds	r0, r0, #1
-.LC11:
-#ifdef __thumb__
-	ldrb	r3, [r1]
-	adds	r1, #1
-#else
-	ldrb	r3, [r1], #1
-#endif
-	cmp	r3, #0
-	beq	.LC12
-	cmp	r2, r3		/* Reached terminator ?  */
-	bne	.LC11
-	movs	r2, #0
-	subs	r3, r1, #1
-	strb	r2, [r3]	/* Terminate the arg string.  */
-	b	.LC10
-
-.LC12:
-	mov	r1, sp		/* Point at stacked arg pointers.  */
-	/* We've now got the stacked args in order, reverse them.  */
-#ifdef __thumb__
-	movs	r2, r0
-	lsls	r2, #2
-	add	r2, sp
-	mov	r3, sp
-.LC15:	cmp	r2, r3
-	bls	.LC14
-	subs	r2, #4
-	ldr	r4, [r2]
-	ldr	r5, [r3]
-	str	r5, [r2]
-	str	r4, [r3]
-	adds	r3, #4
-	b	.LC15
-.LC14:	
-	/* Ensure doubleword stack alignment.  */
-	mov	r4, sp
-	movs	r5, #7
-	bics	r4, r5
-	mov	sp, r4
-#else
-	add	r2, sp, r0, LSL #2	/* End of args.  */
-	mov	r3, sp			/* Start of args.  */
-.LC13:	cmp	r2, r3
-	ldrhi	r4,[r2, #-4]		/* Reverse ends of list.  */
-	ldrhi	r5, [r3]
-	strhi	r5, [r2, #-4]!
-	strhi	r4, [r3], #4
-	bhi	.LC13
-	/* Ensure doubleword stack alignment.  */
-	bic	sp, sp, #7
-#endif
-#endif
+// FIXME:  Assumes bss/common is clear.
 
 #ifdef __USES_INITFINI__
-	/* Some arm/elf targets use the .init and .fini sections
-	   to create constructors and destructors, and for these
-	   targets we need to call the _init function and arrange
-	   for _fini to be called at program exit.  */
 	movs	r4, r0
 	movs	r5, r1
-#ifdef _LITE_EXIT
-	/* Make reference to atexit weak to avoid unconditionally pulling in
-	   support code.  Refer to comments in __atexit.c for more details.  */
-	.weak	FUNCTION(atexit)
-	ldr	r0, .Latexit
-	cmp	r0, #0
-	beq	.Lweak_atexit
-#endif
 	ldr	r0, .Lfini
 	bl	FUNCTION (atexit)
-.Lweak_atexit:
 	bl	FUNCTION (_init)
 	movs	r0, r4
 	movs	r1, r5
-#endif
+#endif	
 	bl	FUNCTION (main)
-
 	bl	FUNCTION (exit)		/* Should not return.  */
 
-#if __thumb__ && !defined(PREFER_THUMB)
-	/* Come out of Thumb mode.  This code should be redundant.  */
-	mov	a4, pc
-	bx	a4
 
-	.code 32
-	.global change_back
-change_back:
-	/* Halt the execution.  This code should never be executed.  */
-	/* With no debug monitor, this probably aborts (eventually).
-	   With a Demon debug monitor, this halts cleanly.
-	   With an Angel debug monitor, this will report 'Unknown SWI'.  */
-	swi	SWI_Exit
-#endif
-	
-	FN_EH_END
 
-	/* For Thumb, constants must be after the code since only 
-	   positive offsets are supported for PC relative addresses.  */
-	.align 0
-.LC0:
-#ifdef ARM_RDI_MONITOR
-	.word	HeapBase
-#else
-#ifndef ARM_RDP_MONITOR
-	/* Changes by toralf: Provide alternative "stack" variable whose value
-	   may be defined externally; .Lstack will be used instead of .LC0 if
-	   it points to a non-0 value. Also set up references to "hooks" that
-           may be used by the application to provide additional init code.  */
-#ifdef __pe__
-	.word	0x800000
-#else
-	.word	0x80000			/* Top of RAM on the PIE board.  */
-#endif
-.Lhwinit:	
-	.word	FUNCTION (hardware_init_hook)
-.Lswinit:
-	.word	FUNCTION (software_init_hook)
-
-	/* Set up defaults for the above variables in the form of weak symbols
-	   - so that application will link correctly, and get value 0 in
-	   runtime (meaning "ignore setting") for the variables, when the user
-	   does not provide the symbols. (The linker uses a weak symbol if,
-	   and only if, a normal version of the same symbol isn't provided
-	   e.g. by a linker script or another object file.)  */
 
-	.weak FUNCTION (hardware_init_hook) 
-	.weak FUNCTION (software_init_hook)
-#endif
-	
+
+
+
+
+
+.balign 16
+
+
+#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+	/* Protect against unhandled exceptions.  */
+	.cantunwind
+	.fnend
 #endif
 
-.Lstack:
-	.word	__stack
-	.weak	__stack
 
 .LC1:
 	.word	__bss_start__
 .LC2:
 	.word	__bss_end__
-#ifdef __USES_INITFINI__
-#ifdef _LITE_EXIT
-.Latexit:
-	.word	FUNCTION(atexit)
 
-	/* Weak reference _fini in case of lite exit.  */
-	.weak	FUNCTION(_fini)
-#endif
+
+#ifdef __USES_INITFINI__
 .Lfini:
 	.word	FUNCTION(_fini)
 #endif
-#ifdef ARM_RDI_MONITOR
-.LC30:
-	.word	AngelSWIArgs
-.LC31:
-	.word	__end__
-
-/*  Workspace for Angel calls.  */
-	.data
-/*  Data returned by monitor SWI.  */
-.global	__stack_base__
-HeapBase:	.word	0
-HeapLimit:	.word	0
-__stack_base__:	.word	0
-StackLimit:	.word	0
-CommandLine:	.space	256,0	/*  Maximum length of 255 chars handled.  */
-AngelSWIArgs:
-	.word	CommandLine
-	.word	255
-#endif
-	
-#ifdef __pe__
-	.section .idata$3
-	.long	0,0,0,0,0,0,0,0
-#endif
+
+
+.balign 16
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/debug.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/debug.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/debug.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/debug.c
@@ -0,0 +1,20 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/debug.h>
+#include <stdarg.h>
+#include <string.h>
+
+static char __klog_buf[80];
+
+void KLogOut(const char *format, ...) {
+  va_list ap;
+
+  va_start(ap, format);
+
+  vsnprintf(__klog_buf, 79, format, ap);
+  Debug(__klog_buf);
+
+  va_end(ap);
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/dir.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/dir.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/dir.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/dir.c
@@ -0,0 +1,87 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+#include <sys/param.h>
+#include <errno.h>
+
+
+
+
+
+char *getwd (char *__buf )
+{
+  // FIXME: Difference between getcwd ?  why pass a buf and why get a buf ?  
+  return getcwd (__buf, MAXPATHLEN);
+}
+
+
+
+int chdir (const char *path)
+{
+    int sc;
+    
+    sc = ChDir(path);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return 0;
+}
+
+
+int fchdir (int fd)
+{
+    int sc;
+    
+    sc = FChDir (fd);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return 0;
+}
+
+
+int mkdir (const char *path, mode_t mode)
+{
+    int sc;
+    
+    sc = MkDir (path, mode);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return 0;
+}
+
+
+
+
+int rmdir (const char *path)
+{
+    int sc;
+    
+    sc = RmDir (path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return 0;
+}
+
+
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/dirname.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/dirname.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/dirname.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/dirname.c
@@ -0,0 +1,32 @@
+#ifndef _NO_DIRNAME
+
+/* Copyright 2005 Shaun Jackman
+ * Permission to use, copy, modify, and distribute this software
+ * is freely granted, provided that this notice is preserved.
+ */
+
+#include <libgen.h>
+#include <string.h>
+
+char *
+_DEFUN (dirname, (path),
+	char *path)
+{
+	char *p;
+	if( path == NULL || *path == '\0' )
+		return ".";
+	p = path + strlen(path) - 1;
+	while( *p == '/' ) {
+		if( p == path )
+			return path;
+		*p-- = '\0';
+	}
+	while( p >= path && *p != '/' )
+		p--;
+	return
+		p < path ? "." :
+		p == path ? "/" :
+		(*p = '\0', path);
+}
+
+#endif /* !_NO_DIRNAME  */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/dup.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/dup.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/dup.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/dup.c
@@ -0,0 +1,35 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+
+
+
+
+
+int dup(int fd) {
+  int dfd;
+  
+  dfd = Dup(fd);
+  if (dfd < 0) {
+    errno = -dfd;
+    return -1;
+  }
+  
+  return dfd;
+}
+
+
+int dup2(int fd1, int fd2) {
+  int dfd;
+  
+  dfd = Dup2(fd1, fd2);
+  if (dfd < 0) {
+    errno = -dfd;
+    return -1;
+  }
+  
+  return dfd;
+
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/environ.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/environ.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/environ.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/environ.c
@@ -0,0 +1,9 @@
+/*
+ * Version of environ for no OS.
+ */
+
+char *__env[1] = { 0 }; 
+char **environ = __env;
+int __argc = 0;
+char **__argv;
+int __envc = 0;
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/execl.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execl.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/execl.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execl.c
@@ -0,0 +1,32 @@
+/* execl.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+
+/* Only deal with a pointer to environ, to work around subtle bugs with shared
+   libraries and/or small data systems where the user declares his own
+   'environ'.  */
+static char ***p_environ = &environ;
+
+
+#include <stdarg.h>
+
+int execl (const char *path, const char *arg0, ...)
+{
+  int i;
+  va_list args;
+  const char *argv[256];
+
+  va_start (args, arg0);
+  argv[0] = arg0;
+  i = 1;
+  do
+      argv[i] = va_arg (args, char *);
+  while (argv[i++] != NULL);
+  va_end (args);
+
+  return execve (path, (char * const  *) argv, *p_environ);
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/execle.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execle.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/execle.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execle.c
@@ -0,0 +1,28 @@
+/* execle.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+
+#include <stdarg.h>
+
+int execle (const char *path, const char *arg0, ...)
+{
+  int i;
+  va_list args;
+  const char * const *envp;
+  const char *argv[256];
+
+  va_start (args, arg0);
+  argv[0] = arg0;
+  i = 1;
+  do
+    argv[i] = va_arg (args, const char *);
+  while (argv[i++] != NULL);
+  envp = va_arg (args, const char * const *);
+  va_end (args);
+
+  return execve (path, (char * const *) argv, (char * const *) envp);
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/execlp.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execlp.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/execlp.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execlp.c
@@ -0,0 +1,26 @@
+/* execlp.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+
+#include <stdarg.h>
+
+int execlp (const char *path, const char *arg0, ...)
+{
+  int i;
+  va_list args;
+  const char *argv[256];
+
+  va_start (args, arg0);
+  argv[0] = arg0;
+  i = 1;
+  do
+      argv[i] = va_arg (args, const char *);
+  while (argv[i++] != NULL);
+  va_end (args);
+
+  return execvp (path, (char * const *) argv);
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/execv.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execv.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/execv.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execv.c
@@ -0,0 +1,12 @@
+/* execv.c */
+
+#include <_ansi.h>
+#include <unistd.h>
+
+static char ***p_environ = &environ;
+
+int execv (const char *path, char * const argv[])
+{
+  return execve (path, (char **) argv, *p_environ);
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/execve.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execve.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/execve.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execve.c
@@ -0,0 +1,42 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/unistd.h>
+#include <sys/execargs.h>
+#include <stdlib.h>
+#include <errno.h>
+
+/*
+ *
+ */ 
+int execve (const char *__path, char * const __argv[], char * const __envp[] )
+{
+    struct execargs args;
+    int argc = 0;
+    int envc = 0;
+    int sc;
+    
+    if (__argv != NULL) {
+        for (argc = 0; __argv[argc] != NULL; argc++);
+    }
+    
+    if (__envp != NULL) {
+        for (envc = 0; __envp[envc] != NULL; envc++);
+    }
+        
+    args.argc = argc;
+    args.envc = envc;    
+    args.envv = (char **)__envp;
+    args.argv = (char **)__argv;
+    args.total_size = 0;
+    sc = Exec(__path, &args);
+
+    // It can only be an error if it fails.
+    errno = -sc;
+    return -1;
+}
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/execvp.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execvp.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/execvp.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/execvp.c
@@ -0,0 +1,62 @@
+/* execvp.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#define PATH_DELIM ':'
+
+/*
+ * Copy string, until c or <nul> is encountered.
+ * NUL-terminate the destination string (s1).
+ */
+
+static char *strccpy (char *s1, char *s2, char c)
+{
+  char *dest = s1;
+
+  while (*s2 && *s2 != c)
+    *s1++ = *s2++;
+  *s1 = 0;
+
+  return dest;
+}
+
+int execvp (const char *file, char * const argv[])
+{
+  char *path = getenv ("PATH");
+  char buf[MAXNAMLEN];
+
+  /* If $PATH doesn't exist, just pass FILE on unchanged.  */
+  if (!path)
+    return execv (file, argv);
+
+  /* If FILE contains a directory, don't search $PATH.  */
+  if (strchr (file, '/')
+      )
+    return execv (file, argv);
+
+  while (*path)
+    {
+      strccpy (buf, path, PATH_DELIM);
+      /* An empty entry means the current directory.  */
+      if (*buf != 0 && buf[strlen(buf) - 1] != '/')
+	strcat (buf, "/");
+      strcat (buf, file);
+      if (execv (buf, argv) == -1 && errno != ENOENT)
+	return -1;
+      while (*path && *path != PATH_DELIM)
+	path++;
+      if (*path == PATH_DELIM)
+	path++;			/* skip over delim */
+    }
+
+  return -1;
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/_exit.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/_exit.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/_exit.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/_exit.c
@@ -0,0 +1,20 @@
+#include <limits.h>
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/debug.h>
+
+
+
+
+/*
+ * Exit, flushing stdio buffers if necessary.
+ */
+
+void _exit (int rc)
+{
+	Exit (rc);
+	while (1);
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c
@@ -0,0 +1,59 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+
+
+
+
+/*
+ * fcntl();
+ */
+
+int fcntl(int fd, int cmd, ...)
+{
+	va_list ap;
+	int arg;
+	int rc;
+	
+	va_start(ap, cmd);
+	
+	switch (cmd)
+	{
+		case F_DUPFD:
+		case F_SETFD:
+		case F_SETFL:
+		case F_SETOWN:
+			arg = va_arg(ap, int);
+			rc = Fcntl(fd, cmd, arg);
+			
+			if (rc < 0) {
+			  errno = -rc;
+			  rc = -1;
+			}
+			
+			break;
+
+  	case F_GETFD:
+		case F_GETFL:
+		case F_GETOWN:
+			rc = Fcntl(fd, cmd, 0);
+
+			if (rc < 0) {
+			  errno = -rc;
+			  rc = -1;
+			}
+
+			break;
+
+		default:
+			errno = EINVAL;
+			rc = -1;
+	}
+	
+	va_end(ap);
+	return rc;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/fork.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/fork.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/fork.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/fork.c
@@ -0,0 +1,21 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+int fork(void)
+{
+    int pid;
+    
+    pid = Fork();
+    if (pid < 0) {
+        errno = -pid;
+        return -1;
+    }
+    
+    return pid;    
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/format.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/format.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/format.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/format.c
@@ -0,0 +1,18 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscall.h>
+
+
+
+
+/*
+ *
+ */
+ 
+int kos_format (char *mount, char *label, unsigned long flags, unsigned long cluster_size)
+{
+	return __syscall5 (_sysidx_format, mount, label, flags, cluster_size);
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/fstat.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/fstat.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/fstat.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/fstat.c
@@ -0,0 +1,11 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <stdio.h>
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/getpid.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/getpid.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/getpid.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/getpid.c
@@ -0,0 +1,27 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+
+
+
+pid_t getpid(void)
+{
+  pid_t pid;
+  
+  pid = GetPID();
+
+  return pid;
+}
+
+pid_t getppid(void)
+{
+  pid_t ppid;
+  
+  ppid = GetPPID();
+  
+  return ppid;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/gettod.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/gettod.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/gettod.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/gettod.c
@@ -0,0 +1,40 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+/*
+ *
+ */
+
+int gettimeofday (struct timeval  *ptimeval, void *ptimezone)
+{
+	int sc;
+	
+	sc = GetTimeOfDay(ptimeval);
+	
+	if (sc < 0) {
+	  errno = -sc;
+	  return -1;
+	}
+	
+	return 0;
+}
+
+
+
+
+/*
+ *
+ */
+
+int settimeofday(const struct timeval *tp, const struct timezone *tzp)
+{
+	return 0;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/id.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/id.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/id.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/id.c
@@ -0,0 +1,87 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <pwd.h>
+
+
+
+
+/*
+ *
+ */
+
+int getpgrp(void)
+{
+//	return __syscall0 (_sysidx_getpgrp);
+}
+
+
+
+
+/*
+ * 
+ */
+
+pid_t setpgrp(void)
+{
+//	return __syscall0 (_sysidx_setpgrp);
+}
+
+
+
+
+uid_t geteuid(void)
+{
+  uid_t euid;
+  
+  euid = GetEUID();
+
+  return euid;
+}
+
+
+uid_t getuid(void)
+{
+  uid_t uid;
+  
+  uid = GetUID();
+
+  return uid;
+}
+
+gid_t getgid(void)
+{
+  gid_t gid;
+  
+  gid = GetGID();
+
+  return gid;
+}
+
+gid_t getegid(void)
+{
+  gid_t egid;
+  
+  egid = GetEGID();
+
+  return egid;
+}
+
+int setuid(uid_t uid)
+{
+  return SetUID(uid);
+}
+
+int setgid(gid_t gid)
+{
+  return SetGID(gid);
+}
+
+
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h
@@ -0,0 +1,173 @@
+/*
+ *  This file lists the minimums for the limits set by each of
+ *  the POSIX features subsets.
+ *
+ *  XXX: Careful attention needs to be paid to section 2.8 in 1003.1b-1993
+ *       to segregrate the variables below based on their "class" according
+ *       to our implementation.  We also need to set the Run-Time Invariant
+ *       and other related values.
+ *
+ *  $Id: limits.h,v 1.2 1999/09/07 21:18:36 ranjith Exp $
+ */
+
+#ifndef _GCC_LIMITS_H_  /* if we have not seen gcc's limits.h yet */
+#include_next <limits.h>
+#endif
+
+#include <sys/syslimits.h>
+
+#ifndef __POSIX_LIMITS_h
+#define __POSIX_LIMITS_h
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.1b-1993 defines the constants below this comment.          *
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_AIO_LISTIO_MAX   2
+#define _POSIX_AIO_MAX          1
+#define _POSIX_ARG_MAX          4096
+#define _POSIX_CHILD_MAX        6
+#define _POSIX_DELAYTIMER_MAX   32
+#define _POSIX_LINK_MAX         8
+#define _POSIX_MAX_CANON        255
+#define _POSIX_MAX_INPUT        255
+#define _POSIX_MQ_OPEN_MAX      8
+#define _POSIX_MQ_PRIO_MAX      32
+#define _POSIX_NAME_MAX         255
+#define _POSIX_NGROUPS_MAX      0
+#define _POSIX_OPEN_MAX         64
+#define _POSIX_PATH_MAX         1024
+#define _POSIX_PIPE_BUF         512
+#define _POSIX_RTSIG_MAX        8
+#define _POSIX_SEM_NSEMS_MAX    256
+#define _POSIX_SEM_VALUE_MAX    32767
+#define _POSIX_SIGQUEUE_MAX     32
+#define _POSIX_SSIZE_MAX        32767
+#define _POSIX_STREAM_MAX       8
+#define _POSIX_TIMER_MAX        32
+#define _POSIX_TZNAME_MAX       3
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ */
+
+#define AIO_LISTIO_MAX          2
+#define AIO_MAX                 1
+#define AIO_PRIO_DELTA_MAX      0
+#define DELAYTIMER_MAX          32
+#define MQ_OPEN_MAX             8
+#define MQ_PRIO_MAX             32
+#define PAGESIZE                4096
+#define RTSIG_MAX               8
+#define SEM_NSEMS_MAX           256
+#define SEM_VALUE_MAX           32767
+#define SIGQUEUE_MAX            32
+#define STREAM_MAX              8
+#define TIMER_MAX               32
+#define TZNAME_MAX              3
+#define SYMLOOP_MAX				8
+
+/*
+ *  Invariant values
+ */
+
+#define SSIZE_MAX               32767
+
+/*
+ *  Maximum Values
+ */
+
+#define _POSIX_CLOCKRES_MIN      0   /* in nanoseconds */
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.1c/D10 defines the constants below this comment.           *
+ *
+ *  XXX: doc seems to have printing problems in this table :(
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_LOGIN_NAME_MAX                9
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS  4
+#define _POSIX_THREAD_KEYS_MAX               128
+#define _POSIX_THREAD_THREADS_MAX            64
+#define _POSIX_TTY_NAME_MAX                  9
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ *
+ *  NOTE:  LOGIN_NAME_MAX is named LOGNAME_MAX under Solaris 2.x.  Perhaps
+ *         the draft specification will be changing.  jrs 05/24/96
+ */
+
+#define LOGIN_NAME_MAX                      _POSIX_LOGIN_NAME_MAX
+#define TTY_NAME_MAX                        _POSIX_TTY_NAME_MAX
+#define PTHREAD_DESTRUCTOR_ITERATIONS       _POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/*
+ *  RTEMS is smart enough to give us the minimum stack size if we ask
+ *  for too little.  Because the real RTEMS limit for this is cpu dependent
+ *  AND rtems header files are not installed yet, we cannot use the cpu
+ *  dependent constant CPU_STACK_MINIMUM_SIZE.  Moreover, we do not want
+ *  to duplicate that information here so we will just let RTEMS magically
+ *  give us its minimum stack size.
+ *
+ *  NOTE:  The other alternative is to have this be a macro for a 
+ *         routine in RTEMS which returns the constant.
+ */
+
+#define PTHREAD_STACK_MIN                   0
+
+/*
+ *  The maximum number of keys (PTHREAD_KEYS_MAX) and threads
+ *  (PTHREAD_THREADS_MAX) are configurable and may exceed the minimum.
+ *
+#define PTHREAD_KEYS_MAX                    _POSIX_THREAD_KEYS_MAX
+#define PTHREAD_THREADS_MAX                 _POSIX_THREAD_THREADS_MAX
+*/
+
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.4b/D8 defines the constants below this comment.            *
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_INTERRUPT_OVERRUN_MAX        32
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ */
+
+#define INTERRUPT_OVERRUN_MAX               32
+
+/*
+ *  Pathname Variables
+ */
+
+#define MIN_ALLOC_SIZE      				0
+#define REC_MIN_XFER_SIZE   
+#define REC_MAX_XFER_SIZE   
+#define REC_INCR_XFER_SIZE  
+#define REC_XFER_ALIGN      
+#define MAX_ATOMIC_SIZE
+
+#define NAME_MAX							_POSIX_NAME_MAX
+#define PATH_MAX							_POSIX_PATH_MAX
+#define SYMLINK_MAX							_POSIX_SYMLINK_MAX
+
+
+
+#endif
+/* end of include file */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h
@@ -0,0 +1,87 @@
+#ifndef	_MNTENT_H
+#define	_MNTENT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+
+
+
+/*
+ *
+ */
+
+struct mntent
+{
+	char    *mnt_fsname;
+	char    *mnt_dir;
+	char    *mnt_type;
+	char    *mnt_opts;
+	int     mnt_freq;
+	int     mnt_passno;
+};
+
+
+
+
+/*
+ *
+ */
+
+#define MNT_CHECKLIST  "/etc/fstab" 
+#define	MNTTAB		"/etc/mnttab"
+#define	VFSTAB		"/etc/vfstab"
+#define	MNTMAXSTR	128
+
+
+/*
+ *
+ */
+ 
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+
+
+/*
+ * Generic mount options
+ */
+
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+
+
+/*
+ * Prototypes
+ */
+
+FILE *setmntent(const char *filename, const char *type);
+struct mntent *getmntent(FILE *filep);
+int addmntent(FILE *filep, const struct mntent *mnt);
+int endmntent(FILE *filep);
+char *hasmntopt(const struct mntent *mnt, const char *opt);
+struct mntent *getmntent_r (FILE *stream, struct mntent *result, char *buffer, int bufsize);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h
@@ -0,0 +1,169 @@
+/* 
+ */
+
+
+
+#ifndef _NETDB_H_
+#define _NETDB_H_
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/cdefs.h>
+#include <netinet/in.h>
+
+
+
+/* The <netdb.h> header may define the in_port_t type and the in_addr_t type
+ *  as described in <netinet/in.h>.
+ */
+
+
+
+struct hostent
+{
+	char   *h_name;
+	char  **h_aliases;
+	int     h_addrtype;
+	int     h_length;
+	char  **h_addr_list;
+}; 
+   
+
+
+struct netent
+{
+	char     *n_name;
+	char    **n_aliases;
+	int       n_addrtype;
+	uint32_t n_net;
+};
+
+
+
+
+struct protoent
+{
+	char   *p_name;
+	char  **p_aliases;
+	int     p_proto;
+};
+
+
+
+struct servent
+{
+	char   *s_name;
+	char  **s_aliases;
+	int     s_port;
+	char   *s_proto;
+};
+
+
+
+
+#define IPPORT_RESERVED   1
+
+extern int h_errno;
+
+
+
+
+#define HOST_NOT_FOUND 1
+#define NO_DATA 2
+#define NO_RECOVERY 3
+#define TRY_AGAIN 4
+
+
+
+struct addrinfo
+{
+	int               ai_flags;
+	int               ai_family;
+	int               ai_socktype;
+	int               ai_protocol;
+	socklen_t         ai_addrlen;
+	struct sockaddr  *ai_addr;
+	char             *ai_canonname;
+	struct addrinfo  *ai_next;
+};
+
+
+
+
+#define AI_PASSIVE			(1<<0)
+#define AI_CANONNAME		(1<<1)
+#define AI_NUMERICHOST		(1<<2)
+#define AI_NUMERICSERV		(1<<3)
+#define AI_V4MAPPED			(1<<4)
+#define AI_ALL				(1<<5)
+#define AI_ADDRCONFIG		(1<<6)
+
+
+
+
+#define NI_NOFQDN			(1<<0)
+#define NI_NUMERICHOST		(1<<1)
+#define NI_NAMEREQD			(1<<2)
+#define NI_NUMERICSERV		(1<<3)
+#define NI_NUMERICSCOPE		(1<<4)
+#define NI_DGRAM			(1<<5)
+
+
+
+
+#define EAI_AGAIN			1
+#define EAI_BADFLAGS		2
+#define EAI_FAIL			3
+#define EAI_FAMILY			4
+#define EAI_MEMORY			5
+#define EAI_NONAME			6
+#define EAI_SERVICE			7
+#define EAI_SOCKTYPE		8
+#define EAI_SYSTEM			9
+#define EAI_OVERFLOW		10
+#define EAI_NODATA          11
+
+#define EAI_ADDRFAMILY      12
+
+
+
+
+
+
+void endhostent (void);
+void endnetent (void);
+void endprotoent (void);
+void endservent (void);
+void freeaddrinfo (struct addrinfo *);
+const char *gai_strerror (int);
+int getaddrinfo (const char *restrict, const char *restrict, const struct addrinfo *restrict, struct addrinfo **restrict);
+struct hostent *gethostbyaddr (const void *, socklen_t, int);
+struct hostent *gethostbyname (const char *);
+struct hostent *gethostent (void);
+int getnameinfo (const struct sockaddr *restrict, socklen_t, char *restrict, socklen_t, char *restrict, socklen_t, int);
+struct netent *getnetbyaddr (uint32_t, int);
+struct netent *getnetbyname (const char *);
+struct netent *getnetent (void);
+struct protoent *getprotobyname (const char *);
+struct protoent *getprotobynumber (int);
+struct protoent *getprotoent (void);
+struct servent *getservbyname (const char *, const char *);
+struct servent *getservbyport (int, const char *);
+struct servent *getservent (void);
+void sethostent (int);
+void setnetent (int);
+void setprotoent (int);
+void setservent (int);
+
+
+
+
+
+
+
+
+
+
+#endif /* !_NETDB_ */
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h
@@ -0,0 +1,30 @@
+#ifndef _POLL_H
+#define _POLL_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+
+#define POLLIN      (1<<0)
+#define POLLRDNORM  (1<<1)
+#define POLLRDBAND  (1<<2)
+#define POLLPRI     (1<<3)
+#define POLLOUT     (1<<4)
+#define POLLWRNORM  (1<<5)
+#define POLLWRBAND  (1<<6)
+#define POLLERR     (1<<7)
+#define POLLNVAL    (1<<8)
+
+typedef unsigned int  nfds_t;
+
+struct pollfd
+{
+  int fd;
+  short events;
+  short revents;
+};
+
+
+int poll (struct pollfd[], nfds_t nfds, int timeout);
+		   
+#endif 
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h
@@ -0,0 +1,11 @@
+/* termios.h
+ */
+
+#ifndef _TERMIOS_H_
+#define _TERMIOS_H_
+
+#include <sys/termios.h>
+
+
+#endif /* !_TERMIOS_H_ */
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h
@@ -0,0 +1,93 @@
+#ifndef	_UCONTEXT_H
+#define	_UCONTEXT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <signal.h>
+#include <sys/signal.h>
+
+typedef struct mcontext {
+  uint32_t sp;
+  uint32_t lr;
+  uint32_t cpsr; // Should be svc_mode spsr
+  uint32_t r1;
+  uint32_t r2;
+  uint32_t r3;
+  uint32_t r4;
+  uint32_t r5;
+  uint32_t r6;
+  uint32_t r7;
+  uint32_t r8;
+  uint32_t r9;
+  uint32_t r10;
+  uint32_t r11;
+  uint32_t r12;
+  uint32_t r0;
+  uint32_t pc; // Should be xyz_ svc_mode LR register.
+  uint32_t pad;
+} mcontext_t __attribute__((packed));
+
+
+
+/*
+ * ucontext_t
+ */
+
+#define UCF_SWAPPED     0x00000001      /* Used by swapcontext(3). */
+
+typedef struct __ucontext
+{
+	mcontext_t	uc_mcontext;
+	
+	sigset_t	uc_sigmask;
+	stack_t		uc_stack;
+	int			uc_flags;
+	struct __ucontext *uc_link;
+
+} ucontext_t;
+ 
+ 
+
+/*
+ *
+ */
+ 
+typedef void __sighandler_t (int);
+typedef	void __siginfohandler_t (int, siginfo_t *, void *);
+
+
+
+
+/*
+ * struct sigframe
+ */
+
+struct sigframe
+{
+  int          sf_signum;
+  siginfo_t    *sf_siginfo;     /* pointer to sf_si */
+  ucontext_t   *sf_ucontext;    /* pointer to sf_uc */
+
+  union
+  {
+		__siginfohandler_t      *sf_action;
+		__sighandler_t          *sf_handler;
+	} sf_ahu;
+    
+  ucontext_t      sf_uc;          /* = *sf_ucontext */
+  siginfo_t       sf_si;          /* = *sf_siginfo (SA_SIGINFO case) */
+};
+
+
+ 
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/inhibit.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/inhibit.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/inhibit.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/inhibit.c
@@ -0,0 +1,28 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscall.h>
+
+
+
+
+/*
+ *
+ */
+
+int kos_inhibit (char *mount)
+{
+	return __syscall1 (_sysidx_inhibit, mount);
+}
+
+
+
+
+/*
+ *
+ */
+
+int kos_uninhibit (char *mount)
+{
+	return __syscall1 (_sysidx_uninhibit, mount);
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c
@@ -0,0 +1,27 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+
+int ioctl (int fd, int request, ... )
+{
+  va_list ap;
+  int sc;
+
+  va_start(ap, request);
+  sc = Ioctl(fd, request, va_arg(ap, void *));
+  va_end(ap);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+
+	return sc;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c
@@ -1,15 +0,0 @@
-/* Support files for GNU libc.  Files in the C namespace go here.
-   Files in the system namespace (ie those that start with an underscore)
-   go in syscalls.c.
-   
-   Note: These functions are in a seperate file so that OS providers can
-   overrride the system call stubs (defined in syscalls.c) without having
-   to provide libc funcitons as well.  */
-#include "swi.h"
-
-
-
-void
-alarm (void)
-{
-}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/link.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/link.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/link.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/link.c
@@ -0,0 +1,44 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+
+
+
+
+/*
+ *
+ */
+
+int link (const char *existing, const char *new)
+{
+  errno = ENOSYS;
+  return -1;
+}
+
+
+
+
+/*
+ *
+ */
+
+int readlink(const char *path, char *buf, size_t bufsize)
+{
+	errno = EINVAL;
+	return -1;
+}
+
+
+
+
+/*
+ *
+ */
+
+int symlink(const char *path1, const char *path2)
+{
+  errno = ENOSYS;
+  return -1;	
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/lseek.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/lseek.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/lseek.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/lseek.c
@@ -0,0 +1,36 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+
+off_t lseek (int fd, off_t offset, int whence)
+{
+    int sc;
+    
+    sc = Seek(fd, offset, whence);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+off64_t lseek64 (int fd, off64_t offset, int whence)
+{
+    int sc;
+    
+    sc = Seek64(fd, &offset, whence);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return offset;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h
@@ -0,0 +1,6 @@
+/*
+ *  $Id: limits.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+/* intentionally empty file */
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h
@@ -0,0 +1,92 @@
+/*
+ *  $Id: param.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef _MACHINE_PARAM_H_
+#define	_MACHINE_PARAM_H_
+
+/*
+ * These aren't really machine-dependent for RTEMS.....
+ */
+
+/*
+#define MACHINE		"i386"
+#define MID_MACHINE	MID_I386
+*/
+
+/*
+ * Round p (pointer or byte index) up to a correctly-aligned value
+ * for all data types (int, long, ...).   The result is unsigned int
+ * and must be cast to any desired pointer type.
+ */
+#define ALIGNBYTES	(sizeof(int) - 1)
+#define ALIGN(p)	(((unsigned)(p) + ALIGNBYTES) & ~ALIGNBYTES)
+
+#define PAGE_SHIFT	12		/* LOG2(PAGE_SIZE) */
+#define PAGE_SIZE	(1<<PAGE_SHIFT)	/* bytes/page */
+#define PAGE_MASK	(PAGE_SIZE-1)
+#define NPTEPG		(PAGE_SIZE/(sizeof (pt_entry_t)))
+
+#define NPDEPG		(PAGE_SIZE/(sizeof (pd_entry_t)))
+#define PDRSHIFT	22		/* LOG2(NBPDR) */
+#define NBPDR		(1<<PDRSHIFT)	/* bytes/page dir */
+
+#define DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
+#define DEV_BSIZE	(1<<DEV_BSHIFT)
+
+#define BLKDEV_IOSIZE	2048
+#define MAXPHYS		(64 * 1024)	/* max raw I/O transfer size */
+
+#define UPAGES	2		/* pages of u-area */
+
+/*
+ * Constants related to network buffer management.
+ * MCLBYTES must be no larger than CLBYTES (the software page size), and,
+ * on machines that exchange pages of input or output buffers with mbuf
+ * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
+ * of the hardware page size.
+ */
+#ifndef	MSIZE
+#define MSIZE		128		/* size of an mbuf */
+#endif	/* MSIZE */
+
+#ifndef	MCLSHIFT
+#define MCLSHIFT	11		/* convert bytes to m_buf clusters */
+#endif	/* MCLSHIFT */
+#define MCLBYTES	(1 << MCLSHIFT)	/* size of an m_buf cluster */
+#define MCLOFSET	(MCLBYTES - 1)	/* offset within an m_buf cluster */
+
+/*
+ * Some macros for units conversion
+ */
+
+/* clicks to bytes */
+#define ctob(x)	((x)<<PAGE_SHIFT)
+
+/* bytes to clicks */
+#define btoc(x)	(((unsigned)(x)+PAGE_MASK)>>PAGE_SHIFT)
+
+/*
+ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
+ * want to shift an unsigned type to avoid sign extension and we don't
+ * want to widen `bytes' unnecessarily.  Assume that the result fits in
+ * a daddr_t.
+ */
+#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
+	(sizeof (bytes) > sizeof(long) \
+	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
+	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
+
+#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
+	((off_t)(db) << DEV_BSHIFT)
+
+/*
+ * Mach derived conversion macros
+ */
+#define trunc_page(x)		((unsigned)(x) & ~PAGE_MASK)
+#define round_page(x)		((((unsigned)(x)) + PAGE_MASK) & ~PAGE_MASK)
+
+#define atop(x)			((unsigned)(x) >> PAGE_SHIFT)
+#define ptoa(x)			((unsigned)(x) << PAGE_SHIFT)
+
+#endif /* !_MACHINE_PARAM_H_ */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h
@@ -0,0 +1,32 @@
+#ifndef	_MACHTYPES_H_
+#define	_MACHTYPES_H_
+
+/*
+ *  The following section is RTEMS specific and is needed to more
+ *  closely match the types defined in the BSD machine/types.h.
+ *  This is needed to let the RTEMS/BSD TCP/IP stack compile.
+ */
+#if defined(__rtems__)
+#include <machine/_types.h>
+#endif
+
+#define	_CLOCK_T_	unsigned long		/* clock() */
+#define	_TIME_T_	long long			/* time() */
+#define _CLOCKID_T_ 	unsigned long
+#define _TIMER_T_   	unsigned long
+
+#ifndef _HAVE_SYSTYPES
+typedef long int __off_t;
+typedef int __pid_t;
+#ifdef __GNUC__
+__extension__ typedef long long int __loff_t;
+#else
+typedef long int __loff_t;
+#endif
+#endif
+
+typedef long long int off64_t;
+
+#endif	/* _MACHTYPES_H_ */
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am
@@ -2,28 +2,78 @@
 
 AUTOMAKE_OPTIONS = cygnus
 
-INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
+INCLUDES = -I$(srcdir)/include $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
 
 AM_CCASFLAGS = $(INCLUDES)
 
 noinst_LIBRARIES = lib.a
 
-if MAY_SUPPLY_SYSCALLS
-extra_objs = $(lpfx)libcfunc.o $(lpfx)trap.o $(lpfx)syscalls.o
-else
-extra_objs =
-endif
-
-lib_a_SOURCES = access.c aeabi_atexit.c
-lib_a_LIBADD = $(extra_objs)
-EXTRA_lib_a_SOURCES = trap.S syscalls.c libcfunc.c
-lib_a_DEPENDENCIES = $(extra_objs)
+lib_a_SOURCES = \
+  _exit.c \
+  access.c \
+	alarm.c \
+	chmod.c \
+	close.c \
+	closedir.c \
+	creat.c \
+	debug.c \
+	dir.c \
+	dup.c \
+	environ.c \
+	execl.c \
+	execle.c \
+	execlp.c \
+	execv.c \
+	execve.c \
+	execvp.c \
+	fcntl.c \
+	fork.c \
+	fstat.c \
+	getpid.c \
+	gettod.c \
+	id.c \
+	ioctl.c \
+	link.c \
+	lseek.c \
+	malloc.c \
+	mmap.c \
+	mknod.c \
+	mntent.c \
+	mount.c \
+	open.c \
+	opendir.c \
+	pathconf.c \
+	pipe.c \
+	popen.c \
+	pwd.c \
+	read.c \
+	readdir.c \
+	rename.c \
+	resource.c \
+	rewinddir.c \
+	select.c \
+	siglist.c \
+	signal.c \
+	syscall.S \
+	sleep.c \
+	stat.c \
+	statvfs.c \
+	sync.c \
+	sysconf.c \
+	termios.c \
+	time.c \
+	times.c \
+	truncate.c \
+	unlink.c \
+	user_strerror.c \
+	wait.c \
+	write.c
+	
+	
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 
-if MAY_SUPPLY_SYSCALLS
 all-local: crt0.o
-endif
 
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
 CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in
@@ -68,9 +68,36 @@
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 lib_a_AR = $(AR) $(ARFLAGS)
-@MAY_SUPPLY_SYSCALLS_TRUE@am__DEPENDENCIES_1 = $(lpfx)libcfunc.o \
-@MAY_SUPPLY_SYSCALLS_TRUE@	$(lpfx)trap.o $(lpfx)syscalls.o
-am_lib_a_OBJECTS = lib_a-access.$(OBJEXT) lib_a-aeabi_atexit.$(OBJEXT)
+lib_a_LIBADD =
+am_lib_a_OBJECTS = lib_a-_exit.$(OBJEXT) lib_a-access.$(OBJEXT) \
+	lib_a-alarm.$(OBJEXT) lib_a-chmod.$(OBJEXT) \
+	lib_a-close.$(OBJEXT) lib_a-closedir.$(OBJEXT) \
+	lib_a-creat.$(OBJEXT) lib_a-debug.$(OBJEXT) \
+	lib_a-dir.$(OBJEXT) lib_a-dup.$(OBJEXT) \
+	lib_a-environ.$(OBJEXT) lib_a-execl.$(OBJEXT) \
+	lib_a-execle.$(OBJEXT) lib_a-execlp.$(OBJEXT) \
+	lib_a-execv.$(OBJEXT) lib_a-execve.$(OBJEXT) \
+	lib_a-execvp.$(OBJEXT) lib_a-fcntl.$(OBJEXT) \
+	lib_a-fork.$(OBJEXT) lib_a-fstat.$(OBJEXT) \
+	lib_a-getpid.$(OBJEXT) lib_a-gettod.$(OBJEXT) \
+	lib_a-id.$(OBJEXT) lib_a-ioctl.$(OBJEXT) lib_a-link.$(OBJEXT) \
+	lib_a-lseek.$(OBJEXT) lib_a-malloc.$(OBJEXT) \
+	lib_a-mmap.$(OBJEXT) lib_a-mknod.$(OBJEXT) \
+	lib_a-mntent.$(OBJEXT) lib_a-mount.$(OBJEXT) \
+	lib_a-open.$(OBJEXT) lib_a-opendir.$(OBJEXT) \
+	lib_a-pathconf.$(OBJEXT) lib_a-pipe.$(OBJEXT) \
+	lib_a-popen.$(OBJEXT) lib_a-pwd.$(OBJEXT) lib_a-read.$(OBJEXT) \
+	lib_a-readdir.$(OBJEXT) lib_a-rename.$(OBJEXT) \
+	lib_a-resource.$(OBJEXT) lib_a-rewinddir.$(OBJEXT) \
+	lib_a-select.$(OBJEXT) lib_a-siglist.$(OBJEXT) \
+	lib_a-signal.$(OBJEXT) lib_a-syscall.$(OBJEXT) \
+	lib_a-sleep.$(OBJEXT) lib_a-stat.$(OBJEXT) \
+	lib_a-statvfs.$(OBJEXT) lib_a-sync.$(OBJEXT) \
+	lib_a-sysconf.$(OBJEXT) lib_a-termios.$(OBJEXT) \
+	lib_a-time.$(OBJEXT) lib_a-times.$(OBJEXT) \
+	lib_a-truncate.$(OBJEXT) lib_a-unlink.$(OBJEXT) \
+	lib_a-user_strerror.$(OBJEXT) lib_a-wait.$(OBJEXT) \
+	lib_a-write.$(OBJEXT)
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
@@ -264,11 +291,11 @@
 .S.obj:
 	$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
-lib_a-trap.o: trap.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-trap.o `test -f 'trap.S' || echo '$(srcdir)/'`trap.S
+lib_a-syscall.o: syscall.S
+	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-syscall.o `test -f 'syscall.S' || echo '$(srcdir)/'`syscall.S
 
-lib_a-trap.obj: trap.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-trap.obj `if test -f 'trap.S'; then $(CYGPATH_W) 'trap.S'; else $(CYGPATH_W) '$(srcdir)/trap.S'; fi`
+lib_a-syscall.obj: syscall.S
+	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-syscall.obj `if test -f 'syscall.S'; then $(CYGPATH_W) 'syscall.S'; else $(CYGPATH_W) '$(srcdir)/syscall.S'; fi`
 
 .c.o:
 	$(COMPILE) -c $<
@@ -276,29 +303,353 @@
 .c.obj:
 	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 
+lib_a-_exit.o: _exit.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-_exit.o `test -f '_exit.c' || echo '$(srcdir)/'`_exit.c
+
+lib_a-_exit.obj: _exit.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-_exit.obj `if test -f '_exit.c'; then $(CYGPATH_W) '_exit.c'; else $(CYGPATH_W) '$(srcdir)/_exit.c'; fi`
+
 lib_a-access.o: access.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.o `test -f 'access.c' || echo '$(srcdir)/'`access.c
 
 lib_a-access.obj: access.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.obj `if test -f 'access.c'; then $(CYGPATH_W) 'access.c'; else $(CYGPATH_W) '$(srcdir)/access.c'; fi`
 
-lib_a-aeabi_atexit.o: aeabi_atexit.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_atexit.o `test -f 'aeabi_atexit.c' || echo '$(srcdir)/'`aeabi_atexit.c
+lib_a-alarm.o: alarm.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-alarm.o `test -f 'alarm.c' || echo '$(srcdir)/'`alarm.c
+
+lib_a-alarm.obj: alarm.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-alarm.obj `if test -f 'alarm.c'; then $(CYGPATH_W) 'alarm.c'; else $(CYGPATH_W) '$(srcdir)/alarm.c'; fi`
+
+lib_a-chmod.o: chmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-chmod.o `test -f 'chmod.c' || echo '$(srcdir)/'`chmod.c
+
+lib_a-chmod.obj: chmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-chmod.obj `if test -f 'chmod.c'; then $(CYGPATH_W) 'chmod.c'; else $(CYGPATH_W) '$(srcdir)/chmod.c'; fi`
+
+lib_a-close.o: close.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-close.o `test -f 'close.c' || echo '$(srcdir)/'`close.c
+
+lib_a-close.obj: close.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-close.obj `if test -f 'close.c'; then $(CYGPATH_W) 'close.c'; else $(CYGPATH_W) '$(srcdir)/close.c'; fi`
+
+lib_a-closedir.o: closedir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-closedir.o `test -f 'closedir.c' || echo '$(srcdir)/'`closedir.c
+
+lib_a-closedir.obj: closedir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-closedir.obj `if test -f 'closedir.c'; then $(CYGPATH_W) 'closedir.c'; else $(CYGPATH_W) '$(srcdir)/closedir.c'; fi`
+
+lib_a-creat.o: creat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-creat.o `test -f 'creat.c' || echo '$(srcdir)/'`creat.c
+
+lib_a-creat.obj: creat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-creat.obj `if test -f 'creat.c'; then $(CYGPATH_W) 'creat.c'; else $(CYGPATH_W) '$(srcdir)/creat.c'; fi`
+
+lib_a-debug.o: debug.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-debug.o `test -f 'debug.c' || echo '$(srcdir)/'`debug.c
+
+lib_a-debug.obj: debug.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-debug.obj `if test -f 'debug.c'; then $(CYGPATH_W) 'debug.c'; else $(CYGPATH_W) '$(srcdir)/debug.c'; fi`
+
+lib_a-dir.o: dir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dir.o `test -f 'dir.c' || echo '$(srcdir)/'`dir.c
+
+lib_a-dir.obj: dir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dir.obj `if test -f 'dir.c'; then $(CYGPATH_W) 'dir.c'; else $(CYGPATH_W) '$(srcdir)/dir.c'; fi`
+
+lib_a-dup.o: dup.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dup.o `test -f 'dup.c' || echo '$(srcdir)/'`dup.c
+
+lib_a-dup.obj: dup.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dup.obj `if test -f 'dup.c'; then $(CYGPATH_W) 'dup.c'; else $(CYGPATH_W) '$(srcdir)/dup.c'; fi`
+
+lib_a-environ.o: environ.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-environ.o `test -f 'environ.c' || echo '$(srcdir)/'`environ.c
+
+lib_a-environ.obj: environ.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-environ.obj `if test -f 'environ.c'; then $(CYGPATH_W) 'environ.c'; else $(CYGPATH_W) '$(srcdir)/environ.c'; fi`
+
+lib_a-execl.o: execl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execl.o `test -f 'execl.c' || echo '$(srcdir)/'`execl.c
+
+lib_a-execl.obj: execl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execl.obj `if test -f 'execl.c'; then $(CYGPATH_W) 'execl.c'; else $(CYGPATH_W) '$(srcdir)/execl.c'; fi`
+
+lib_a-execle.o: execle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execle.o `test -f 'execle.c' || echo '$(srcdir)/'`execle.c
+
+lib_a-execle.obj: execle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execle.obj `if test -f 'execle.c'; then $(CYGPATH_W) 'execle.c'; else $(CYGPATH_W) '$(srcdir)/execle.c'; fi`
+
+lib_a-execlp.o: execlp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execlp.o `test -f 'execlp.c' || echo '$(srcdir)/'`execlp.c
+
+lib_a-execlp.obj: execlp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execlp.obj `if test -f 'execlp.c'; then $(CYGPATH_W) 'execlp.c'; else $(CYGPATH_W) '$(srcdir)/execlp.c'; fi`
+
+lib_a-execv.o: execv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execv.o `test -f 'execv.c' || echo '$(srcdir)/'`execv.c
+
+lib_a-execv.obj: execv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execv.obj `if test -f 'execv.c'; then $(CYGPATH_W) 'execv.c'; else $(CYGPATH_W) '$(srcdir)/execv.c'; fi`
+
+lib_a-execve.o: execve.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execve.o `test -f 'execve.c' || echo '$(srcdir)/'`execve.c
+
+lib_a-execve.obj: execve.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execve.obj `if test -f 'execve.c'; then $(CYGPATH_W) 'execve.c'; else $(CYGPATH_W) '$(srcdir)/execve.c'; fi`
+
+lib_a-execvp.o: execvp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execvp.o `test -f 'execvp.c' || echo '$(srcdir)/'`execvp.c
+
+lib_a-execvp.obj: execvp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execvp.obj `if test -f 'execvp.c'; then $(CYGPATH_W) 'execvp.c'; else $(CYGPATH_W) '$(srcdir)/execvp.c'; fi`
+
+lib_a-fcntl.o: fcntl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fcntl.o `test -f 'fcntl.c' || echo '$(srcdir)/'`fcntl.c
+
+lib_a-fcntl.obj: fcntl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fcntl.obj `if test -f 'fcntl.c'; then $(CYGPATH_W) 'fcntl.c'; else $(CYGPATH_W) '$(srcdir)/fcntl.c'; fi`
+
+lib_a-fork.o: fork.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fork.o `test -f 'fork.c' || echo '$(srcdir)/'`fork.c
+
+lib_a-fork.obj: fork.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fork.obj `if test -f 'fork.c'; then $(CYGPATH_W) 'fork.c'; else $(CYGPATH_W) '$(srcdir)/fork.c'; fi`
+
+lib_a-fstat.o: fstat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fstat.o `test -f 'fstat.c' || echo '$(srcdir)/'`fstat.c
+
+lib_a-fstat.obj: fstat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fstat.obj `if test -f 'fstat.c'; then $(CYGPATH_W) 'fstat.c'; else $(CYGPATH_W) '$(srcdir)/fstat.c'; fi`
+
+lib_a-getpid.o: getpid.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpid.o `test -f 'getpid.c' || echo '$(srcdir)/'`getpid.c
+
+lib_a-getpid.obj: getpid.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpid.obj `if test -f 'getpid.c'; then $(CYGPATH_W) 'getpid.c'; else $(CYGPATH_W) '$(srcdir)/getpid.c'; fi`
+
+lib_a-gettod.o: gettod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettod.o `test -f 'gettod.c' || echo '$(srcdir)/'`gettod.c
+
+lib_a-gettod.obj: gettod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettod.obj `if test -f 'gettod.c'; then $(CYGPATH_W) 'gettod.c'; else $(CYGPATH_W) '$(srcdir)/gettod.c'; fi`
+
+lib_a-id.o: id.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-id.o `test -f 'id.c' || echo '$(srcdir)/'`id.c
+
+lib_a-id.obj: id.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-id.obj `if test -f 'id.c'; then $(CYGPATH_W) 'id.c'; else $(CYGPATH_W) '$(srcdir)/id.c'; fi`
+
+lib_a-ioctl.o: ioctl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ioctl.o `test -f 'ioctl.c' || echo '$(srcdir)/'`ioctl.c
+
+lib_a-ioctl.obj: ioctl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ioctl.obj `if test -f 'ioctl.c'; then $(CYGPATH_W) 'ioctl.c'; else $(CYGPATH_W) '$(srcdir)/ioctl.c'; fi`
+
+lib_a-link.o: link.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-link.o `test -f 'link.c' || echo '$(srcdir)/'`link.c
+
+lib_a-link.obj: link.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-link.obj `if test -f 'link.c'; then $(CYGPATH_W) 'link.c'; else $(CYGPATH_W) '$(srcdir)/link.c'; fi`
+
+lib_a-lseek.o: lseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-lseek.o `test -f 'lseek.c' || echo '$(srcdir)/'`lseek.c
+
+lib_a-lseek.obj: lseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-lseek.obj `if test -f 'lseek.c'; then $(CYGPATH_W) 'lseek.c'; else $(CYGPATH_W) '$(srcdir)/lseek.c'; fi`
+
+lib_a-malloc.o: malloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-malloc.o `test -f 'malloc.c' || echo '$(srcdir)/'`malloc.c
+
+lib_a-malloc.obj: malloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-malloc.obj `if test -f 'malloc.c'; then $(CYGPATH_W) 'malloc.c'; else $(CYGPATH_W) '$(srcdir)/malloc.c'; fi`
+
+lib_a-mmap.o: mmap.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mmap.o `test -f 'mmap.c' || echo '$(srcdir)/'`mmap.c
+
+lib_a-mmap.obj: mmap.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mmap.obj `if test -f 'mmap.c'; then $(CYGPATH_W) 'mmap.c'; else $(CYGPATH_W) '$(srcdir)/mmap.c'; fi`
+
+lib_a-mknod.o: mknod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mknod.o `test -f 'mknod.c' || echo '$(srcdir)/'`mknod.c
+
+lib_a-mknod.obj: mknod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mknod.obj `if test -f 'mknod.c'; then $(CYGPATH_W) 'mknod.c'; else $(CYGPATH_W) '$(srcdir)/mknod.c'; fi`
+
+lib_a-mntent.o: mntent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mntent.o `test -f 'mntent.c' || echo '$(srcdir)/'`mntent.c
+
+lib_a-mntent.obj: mntent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mntent.obj `if test -f 'mntent.c'; then $(CYGPATH_W) 'mntent.c'; else $(CYGPATH_W) '$(srcdir)/mntent.c'; fi`
+
+lib_a-mount.o: mount.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mount.o `test -f 'mount.c' || echo '$(srcdir)/'`mount.c
+
+lib_a-mount.obj: mount.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mount.obj `if test -f 'mount.c'; then $(CYGPATH_W) 'mount.c'; else $(CYGPATH_W) '$(srcdir)/mount.c'; fi`
+
+lib_a-open.o: open.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-open.o `test -f 'open.c' || echo '$(srcdir)/'`open.c
+
+lib_a-open.obj: open.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-open.obj `if test -f 'open.c'; then $(CYGPATH_W) 'open.c'; else $(CYGPATH_W) '$(srcdir)/open.c'; fi`
+
+lib_a-opendir.o: opendir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-opendir.o `test -f 'opendir.c' || echo '$(srcdir)/'`opendir.c
+
+lib_a-opendir.obj: opendir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-opendir.obj `if test -f 'opendir.c'; then $(CYGPATH_W) 'opendir.c'; else $(CYGPATH_W) '$(srcdir)/opendir.c'; fi`
+
+lib_a-pathconf.o: pathconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pathconf.o `test -f 'pathconf.c' || echo '$(srcdir)/'`pathconf.c
+
+lib_a-pathconf.obj: pathconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pathconf.obj `if test -f 'pathconf.c'; then $(CYGPATH_W) 'pathconf.c'; else $(CYGPATH_W) '$(srcdir)/pathconf.c'; fi`
+
+lib_a-pipe.o: pipe.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pipe.o `test -f 'pipe.c' || echo '$(srcdir)/'`pipe.c
+
+lib_a-pipe.obj: pipe.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pipe.obj `if test -f 'pipe.c'; then $(CYGPATH_W) 'pipe.c'; else $(CYGPATH_W) '$(srcdir)/pipe.c'; fi`
+
+lib_a-popen.o: popen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-popen.o `test -f 'popen.c' || echo '$(srcdir)/'`popen.c
+
+lib_a-popen.obj: popen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-popen.obj `if test -f 'popen.c'; then $(CYGPATH_W) 'popen.c'; else $(CYGPATH_W) '$(srcdir)/popen.c'; fi`
+
+lib_a-pwd.o: pwd.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pwd.o `test -f 'pwd.c' || echo '$(srcdir)/'`pwd.c
+
+lib_a-pwd.obj: pwd.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pwd.obj `if test -f 'pwd.c'; then $(CYGPATH_W) 'pwd.c'; else $(CYGPATH_W) '$(srcdir)/pwd.c'; fi`
+
+lib_a-read.o: read.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-read.o `test -f 'read.c' || echo '$(srcdir)/'`read.c
+
+lib_a-read.obj: read.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-read.obj `if test -f 'read.c'; then $(CYGPATH_W) 'read.c'; else $(CYGPATH_W) '$(srcdir)/read.c'; fi`
+
+lib_a-readdir.o: readdir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-readdir.o `test -f 'readdir.c' || echo '$(srcdir)/'`readdir.c
+
+lib_a-readdir.obj: readdir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-readdir.obj `if test -f 'readdir.c'; then $(CYGPATH_W) 'readdir.c'; else $(CYGPATH_W) '$(srcdir)/readdir.c'; fi`
+
+lib_a-rename.o: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.o `test -f 'rename.c' || echo '$(srcdir)/'`rename.c
+
+lib_a-rename.obj: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.obj `if test -f 'rename.c'; then $(CYGPATH_W) 'rename.c'; else $(CYGPATH_W) '$(srcdir)/rename.c'; fi`
+
+lib_a-resource.o: resource.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-resource.o `test -f 'resource.c' || echo '$(srcdir)/'`resource.c
+
+lib_a-resource.obj: resource.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-resource.obj `if test -f 'resource.c'; then $(CYGPATH_W) 'resource.c'; else $(CYGPATH_W) '$(srcdir)/resource.c'; fi`
+
+lib_a-rewinddir.o: rewinddir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewinddir.o `test -f 'rewinddir.c' || echo '$(srcdir)/'`rewinddir.c
+
+lib_a-rewinddir.obj: rewinddir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewinddir.obj `if test -f 'rewinddir.c'; then $(CYGPATH_W) 'rewinddir.c'; else $(CYGPATH_W) '$(srcdir)/rewinddir.c'; fi`
+
+lib_a-select.o: select.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-select.o `test -f 'select.c' || echo '$(srcdir)/'`select.c
+
+lib_a-select.obj: select.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-select.obj `if test -f 'select.c'; then $(CYGPATH_W) 'select.c'; else $(CYGPATH_W) '$(srcdir)/select.c'; fi`
+
+lib_a-siglist.o: siglist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-siglist.o `test -f 'siglist.c' || echo '$(srcdir)/'`siglist.c
+
+lib_a-siglist.obj: siglist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-siglist.obj `if test -f 'siglist.c'; then $(CYGPATH_W) 'siglist.c'; else $(CYGPATH_W) '$(srcdir)/siglist.c'; fi`
+
+lib_a-signal.o: signal.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signal.o `test -f 'signal.c' || echo '$(srcdir)/'`signal.c
+
+lib_a-signal.obj: signal.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signal.obj `if test -f 'signal.c'; then $(CYGPATH_W) 'signal.c'; else $(CYGPATH_W) '$(srcdir)/signal.c'; fi`
+
+lib_a-sleep.o: sleep.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sleep.o `test -f 'sleep.c' || echo '$(srcdir)/'`sleep.c
+
+lib_a-sleep.obj: sleep.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sleep.obj `if test -f 'sleep.c'; then $(CYGPATH_W) 'sleep.c'; else $(CYGPATH_W) '$(srcdir)/sleep.c'; fi`
+
+lib_a-stat.o: stat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stat.o `test -f 'stat.c' || echo '$(srcdir)/'`stat.c
+
+lib_a-stat.obj: stat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stat.obj `if test -f 'stat.c'; then $(CYGPATH_W) 'stat.c'; else $(CYGPATH_W) '$(srcdir)/stat.c'; fi`
+
+lib_a-statvfs.o: statvfs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statvfs.o `test -f 'statvfs.c' || echo '$(srcdir)/'`statvfs.c
+
+lib_a-statvfs.obj: statvfs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statvfs.obj `if test -f 'statvfs.c'; then $(CYGPATH_W) 'statvfs.c'; else $(CYGPATH_W) '$(srcdir)/statvfs.c'; fi`
+
+lib_a-sync.o: sync.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync.o `test -f 'sync.c' || echo '$(srcdir)/'`sync.c
+
+lib_a-sync.obj: sync.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync.obj `if test -f 'sync.c'; then $(CYGPATH_W) 'sync.c'; else $(CYGPATH_W) '$(srcdir)/sync.c'; fi`
+
+lib_a-sysconf.o: sysconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sysconf.o `test -f 'sysconf.c' || echo '$(srcdir)/'`sysconf.c
+
+lib_a-sysconf.obj: sysconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sysconf.obj `if test -f 'sysconf.c'; then $(CYGPATH_W) 'sysconf.c'; else $(CYGPATH_W) '$(srcdir)/sysconf.c'; fi`
+
+lib_a-termios.o: termios.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-termios.o `test -f 'termios.c' || echo '$(srcdir)/'`termios.c
+
+lib_a-termios.obj: termios.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-termios.obj `if test -f 'termios.c'; then $(CYGPATH_W) 'termios.c'; else $(CYGPATH_W) '$(srcdir)/termios.c'; fi`
+
+lib_a-time.o: time.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-time.o `test -f 'time.c' || echo '$(srcdir)/'`time.c
+
+lib_a-time.obj: time.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-time.obj `if test -f 'time.c'; then $(CYGPATH_W) 'time.c'; else $(CYGPATH_W) '$(srcdir)/time.c'; fi`
+
+lib_a-times.o: times.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.o `test -f 'times.c' || echo '$(srcdir)/'`times.c
+
+lib_a-times.obj: times.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.obj `if test -f 'times.c'; then $(CYGPATH_W) 'times.c'; else $(CYGPATH_W) '$(srcdir)/times.c'; fi`
+
+lib_a-truncate.o: truncate.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-truncate.o `test -f 'truncate.c' || echo '$(srcdir)/'`truncate.c
+
+lib_a-truncate.obj: truncate.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-truncate.obj `if test -f 'truncate.c'; then $(CYGPATH_W) 'truncate.c'; else $(CYGPATH_W) '$(srcdir)/truncate.c'; fi`
+
+lib_a-unlink.o: unlink.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlink.o `test -f 'unlink.c' || echo '$(srcdir)/'`unlink.c
+
+lib_a-unlink.obj: unlink.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlink.obj `if test -f 'unlink.c'; then $(CYGPATH_W) 'unlink.c'; else $(CYGPATH_W) '$(srcdir)/unlink.c'; fi`
+
+lib_a-user_strerror.o: user_strerror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-user_strerror.o `test -f 'user_strerror.c' || echo '$(srcdir)/'`user_strerror.c
 
-lib_a-aeabi_atexit.obj: aeabi_atexit.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_atexit.obj `if test -f 'aeabi_atexit.c'; then $(CYGPATH_W) 'aeabi_atexit.c'; else $(CYGPATH_W) '$(srcdir)/aeabi_atexit.c'; fi`
+lib_a-user_strerror.obj: user_strerror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-user_strerror.obj `if test -f 'user_strerror.c'; then $(CYGPATH_W) 'user_strerror.c'; else $(CYGPATH_W) '$(srcdir)/user_strerror.c'; fi`
 
-lib_a-syscalls.o: syscalls.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-syscalls.o `test -f 'syscalls.c' || echo '$(srcdir)/'`syscalls.c
+lib_a-wait.o: wait.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wait.o `test -f 'wait.c' || echo '$(srcdir)/'`wait.c
 
-lib_a-syscalls.obj: syscalls.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-syscalls.obj `if test -f 'syscalls.c'; then $(CYGPATH_W) 'syscalls.c'; else $(CYGPATH_W) '$(srcdir)/syscalls.c'; fi`
+lib_a-wait.obj: wait.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wait.obj `if test -f 'wait.c'; then $(CYGPATH_W) 'wait.c'; else $(CYGPATH_W) '$(srcdir)/wait.c'; fi`
 
-lib_a-libcfunc.o: libcfunc.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-libcfunc.o `test -f 'libcfunc.c' || echo '$(srcdir)/'`libcfunc.c
+lib_a-write.o: write.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-write.o `test -f 'write.c' || echo '$(srcdir)/'`write.c
 
-lib_a-libcfunc.obj: libcfunc.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-libcfunc.obj `if test -f 'libcfunc.c'; then $(CYGPATH_W) 'libcfunc.c'; else $(CYGPATH_W) '$(srcdir)/libcfunc.c'; fi`
+lib_a-write.obj: write.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-write.obj `if test -f 'write.c'; then $(CYGPATH_W) 'write.c'; else $(CYGPATH_W) '$(srcdir)/write.c'; fi`
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -472,7 +823,7 @@
 	uninstall-am
 
 
-@MAY_SUPPLY_SYSCALLS_TRUE@all-local: crt0.o
+all-local: crt0.o
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/malloc.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/malloc.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/malloc.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/malloc.c
@@ -0,0 +1,635 @@
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/lists.h>
+#include <stdint.h>
+#include <sys/debug.h>
+
+
+
+
+// Memory management data structures
+// Note we don't know what QBlock we belong to when freeing memory unless
+// we are a large block of memory in which case we find it on the hash.
+// So can't maintain statistics on a per-block basis.
+
+
+struct QHeader
+{
+    size_t prev_size;               // 0 if beginning of block
+    size_t size;                    // (1<<0) holds Q_INUSE flag (needs masking)
+    LIST_ENTRY (QHeader) q_link;    // Can be part of data area to make header overhead 8-bytes
+};
+
+
+struct QBlock
+{
+    int type;
+    void *addr;
+    size_t size;
+    LIST_ENTRY (QBlock) link;
+};
+
+// Memory management alignment macros
+
+#define ALIGN_UP(val, alignment)                                \
+    ((((val) + (alignment) - 1)/(alignment))*(alignment))
+#define ALIGN_DOWN(val, alignment)                              \
+            ((val) - ((val) % (alignment)))
+
+// Memory management constants
+
+#define SIZEOF_QHEADER      16
+#define Q_INUSE             (1<<0)
+#define QF_BLOCK_SZ         0x20000
+#define QF_MAX_ALLOC_SZ     0x08000
+#define QF_GRANULARITY      32
+#define QF_SLOTS            64
+#define QBLOCKS_TO_ALLOC    512
+#define QBLOCK_HASH_SZ      512
+#define HASH_SHIFT          12
+#define MINIMUM_SPLIT_SZ    64
+#define MEMTYPE_ALLOC       0
+#define MEMTYPE_QFIT        1
+#define SIZE_TO_Q(sz)       ((sz/QF_GRANULARITY) - 1)
+
+
+// private variables
+
+static struct QBlock *last_allocated_block = NULL;
+static LIST (QHeader) qheader_list[QF_SLOTS];
+static LIST (QHeader) oddment_list;
+static LIST (QBlock) free_qblock_list;
+static LIST (QBlock) qblock_hash[QBLOCK_HASH_SZ];
+
+// private function prototypes
+
+static void qcoalesce (void);
+static void qcoalesce_block (struct QBlock *blk);
+static void qsplit (struct QHeader *qh, size_t size);
+static void *qallocblock (size_t sz, int type);
+static void qfreeblock (void *mem);
+static size_t qmemsize (void *ptr);
+
+
+
+
+
+// malloc();
+
+void *malloc (size_t size)
+{
+    int q;
+    struct QHeader *qh, *qtail, *best;
+    void *mem;
+    int t;
+    size_t best_size;
+    
+    size = ALIGN_UP (size, QF_GRANULARITY);
+
+    
+    // Perfect Fit then 2 * size + header overhead
+    
+    if (size <= QF_SLOTS * QF_GRANULARITY)
+    {
+        q = SIZE_TO_Q(size);
+        
+        if ((qh = LIST_HEAD (&qheader_list[q])) != NULL)
+        {
+            LIST_REM_HEAD (&qheader_list[q], q_link);
+            qh->size |= Q_INUSE;
+            
+            mem = (uint8 *)qh + SIZEOF_QHEADER;
+            return mem;
+        }
+        
+        q = SIZE_TO_Q(size*2+SIZEOF_QHEADER);
+        
+        if (q < QF_SLOTS)
+        {
+            if ((qh = LIST_HEAD (&qheader_list[q])) != NULL)
+            {
+                LIST_REM_HEAD (&qheader_list[q], q_link);
+                qsplit (qh, size);
+                qh->size |= Q_INUSE;
+
+                mem = (uint8 *)qh + SIZEOF_QHEADER;
+                return mem;
+            }
+        }
+    }
+    
+
+    // Best-Fit
+
+    if (size < QF_MAX_ALLOC_SZ)
+    {   
+        for (t=0; t<2; t++)
+        {
+            if (t == 1)
+                qcoalesce();
+                    
+            if (size <= QF_SLOTS * QF_GRANULARITY)
+            {
+                for (q = SIZE_TO_Q(size); q < QF_SLOTS; q++)
+                {
+                    if ((qh = LIST_HEAD (&qheader_list[q])) != NULL)
+                    {
+                        LIST_REM_HEAD (&qheader_list[q], q_link);
+                        qh->size |= Q_INUSE;
+
+                        mem = (uint8 *)qh + SIZEOF_QHEADER;
+                        return mem;
+                    }
+                }
+            }
+            
+            qh = LIST_HEAD (&oddment_list);
+            best = NULL;
+            best_size = 0;
+                                                
+            while (qh != NULL)
+            {
+                if (qh->size == size)
+                {
+                    LIST_REM_ENTRY (&oddment_list, qh, q_link);
+                    qh->size |= Q_INUSE;
+            
+            
+                    mem = (uint8 *)qh + SIZEOF_QHEADER;
+                    return mem;
+                }
+                
+                if ((best == NULL && qh->size >= size)
+                    || (qh->size < best_size && qh->size >= size))
+                {
+                    best = qh;
+                    best_size = qh->size;
+                }
+                
+                qh = LIST_NEXT (qh, q_link);
+            }
+            
+            if (best != NULL)
+            {
+                LIST_REM_ENTRY (&oddment_list, best, q_link);
+                qsplit (best, size);
+                best->size |= Q_INUSE;
+
+                mem = (uint8 *)best + SIZEOF_QHEADER;
+                return mem;
+
+            }
+        }
+        
+                        
+        // Allocate a new block of memory
+        
+        if ((mem = qallocblock (QF_BLOCK_SZ, MEMTYPE_QFIT)) != NULL)
+        {
+            qh = mem;
+            qh->prev_size = 0;
+            qh->size = QF_BLOCK_SZ - (SIZEOF_QHEADER * 2);  // HEAD + TAIL (zero length).
+                    
+            qtail = mem + QF_BLOCK_SZ - SIZEOF_QHEADER;
+            qtail->prev_size = QF_BLOCK_SZ - (SIZEOF_QHEADER * 2);
+            qtail->size = 0;
+
+            qsplit (qh, size);
+            
+            qh->size |= Q_INUSE;
+            
+            mem = (uint8 *)qh + SIZEOF_QHEADER;
+            return mem;
+        }
+    }
+    else
+    {
+        mem = qallocblock (size, MEMTYPE_ALLOC);
+        return mem;
+    }
+    
+    return NULL;
+}
+
+
+
+
+// free();
+// frees a piece of memory allocated using malloc().
+
+void free (void *mem)
+{
+    struct QHeader *qh;
+    struct QBlock *blk;
+    int key;
+    int q;
+
+    key = ((uintptr_t)mem>>HASH_SHIFT) % QBLOCK_HASH_SZ;
+
+    blk = LIST_HEAD (&qblock_hash[key]);
+
+    while (blk != NULL)
+    {
+        if (blk->addr == mem)
+        {
+            LIST_REM_ENTRY (&qblock_hash[key], blk, link);
+            
+            VirtualFree (mem, 0);  // TODO : FIXME: sz
+            blk->addr = NULL;
+            blk->type = -1;
+            
+            LIST_ADD_HEAD (&free_qblock_list, blk, link);   
+            return;
+        }
+        
+        blk = LIST_NEXT (blk, link);
+    }
+
+
+    qh = (struct QHeader *)((uint8 *)mem - SIZEOF_QHEADER);
+    
+    qh->size = qh->size & ~Q_INUSE;
+    
+    if (qh->size <= QF_SLOTS * QF_GRANULARITY)
+    {
+        q = SIZE_TO_Q (qh->size);
+        LIST_ADD_HEAD (&qheader_list[q], qh, q_link);
+    }
+    else
+    {
+        LIST_ADD_HEAD (&oddment_list, qh, q_link);
+    }
+}   
+
+
+
+
+// realloc();
+// Reallocates a block of memory, either expanding or contracting
+// it. Copies the origianl data to the newly allocated region
+// and frees the old allocation.
+
+void *realloc (void *ptr, size_t size)
+{
+    size_t old_sz;
+    void *nptr;
+    
+    
+    if (ptr == NULL)
+        return malloc (size);
+    else if (size == 0)
+    {
+        free (ptr);
+        return NULL;
+    }
+    else
+    {
+        old_sz = qmemsize (ptr);
+        
+        nptr = malloc (size);
+                
+        if (nptr != NULL)
+        {
+            memcpy (nptr, ptr, old_sz);
+            free(ptr);
+            return nptr;
+        }
+    }
+
+}
+
+
+
+
+// calloc();
+// Allocates and clears an array of nelements of size 'elsize'.
+ 
+void *calloc (size_t nelem, size_t elsize)
+{
+    void *mem;
+
+    if ((mem = malloc (nelem * elsize)) != NULL)
+        memset (mem, 0, nelem * elsize);
+
+    return mem;
+}
+
+
+
+
+// **************************************************************************
+// Private functions called by malloc() and free()
+// **************************************************************************
+
+// qsplit();
+
+static void qsplit (struct QHeader *qh, size_t size)
+{
+    struct QHeader *mid, *next;
+    size_t total_size;
+    int q;
+
+    if (qh->size > size + MINIMUM_SPLIT_SZ)
+    {
+        total_size = qh->size;
+        mid = (struct QHeader *)((uint8 *)qh + SIZEOF_QHEADER + size);
+        
+        mid->size = total_size - size - SIZEOF_QHEADER;
+        mid->prev_size = size;
+        
+        if (mid->size <= QF_SLOTS * QF_GRANULARITY)
+        {
+            q = SIZE_TO_Q (mid->size);
+            LIST_ADD_HEAD (&qheader_list[q], mid, q_link);
+        }   
+        else
+        {
+            LIST_ADD_HEAD (&oddment_list, mid, q_link);
+        }
+                        
+        next = (struct QHeader *)((uint8 *)qh + SIZEOF_QHEADER + qh->size);
+        next->prev_size = mid->size;
+        
+        qh->size = size;
+        return;
+    }
+}
+
+
+
+
+// qcoalesce();
+
+static void qcoalesce (void)
+{
+    int t;
+    struct QBlock *qblk, *next_qblk;
+    
+    
+    for (t=0; t < QBLOCK_HASH_SZ; t++)
+    {
+        qblk = LIST_HEAD (&qblock_hash[t]);
+        
+        while (qblk != NULL)
+        {
+            next_qblk = LIST_NEXT (qblk, link);
+            
+            if (qblk->type == MEMTYPE_QFIT)
+            {
+                qcoalesce_block (qblk);
+            }
+            
+            qblk = next_qblk;
+        }
+    }
+}
+
+
+
+
+// qcoalesce_block();
+
+static void qcoalesce_block (struct QBlock *blk)
+{
+    struct QHeader *head, *qh;
+    size_t new_size;
+    int q;
+
+
+    head = blk->addr;
+    
+    while (head->size != 0)
+    {   
+        if ((head->size & Q_INUSE) == 0)
+        {
+            qh = (struct QHeader *)((uint8*)head + head->size + SIZEOF_QHEADER);
+            
+            new_size = head->size;
+            
+            while (qh->size != 0 && (qh->size & Q_INUSE) == 0)
+            {
+                new_size += qh->size;
+            
+                qh = (struct QHeader *)((uint8 *)qh + (qh->size & ~ Q_INUSE) + SIZEOF_QHEADER);
+                
+                if (qh->size <= QF_SLOTS * QF_GRANULARITY)
+                {
+                    q = SIZE_TO_Q (qh->size);
+                    LIST_REM_ENTRY (&qheader_list[q], qh, q_link);
+                }
+                else
+                {
+                    LIST_REM_ENTRY (&oddment_list, qh, q_link);
+                }   
+            }
+            
+            
+            if (new_size != head->size)
+            {
+                if (head->size <= QF_SLOTS * QF_GRANULARITY)
+                {
+                    q = SIZE_TO_Q (head->size);
+                    LIST_REM_ENTRY (&qheader_list[q], head, q_link);
+                }
+                else
+                {
+                    LIST_REM_ENTRY (&oddment_list, head, q_link);
+                }                   
+            
+                head->size = new_size & ~Q_INUSE;
+                
+                if (head->size <= QF_SLOTS * QF_GRANULARITY)
+                {
+                    q = SIZE_TO_Q (head->size);
+                    LIST_ADD_HEAD (&qheader_list[q], head, q_link);
+                }
+                else
+                {
+                    LIST_ADD_HEAD (&oddment_list, head, q_link);
+                }
+            }
+        }
+        else
+        {
+            head = (struct QHeader *)((uint8*)head + (head->size & ~Q_INUSE) + SIZEOF_QHEADER);
+        }
+    }
+    
+        
+    head = blk->addr;
+    
+    if (head->size == QF_BLOCK_SZ - 2 * SIZEOF_QHEADER)
+    {
+        LIST_REM_ENTRY (&oddment_list, head, q_link);
+        qfreeblock (blk->addr);
+    }
+}
+    
+    
+
+
+// qmemsize();
+// Returns the size of the memory allocation pointed to by 'mem'.
+// First checks the hash table of blocks to see if it is a large
+// allocation. If it is then the size can be obtained from the
+// QBlock structure.
+// Otherwise the size is obtained from the QHeader structure
+// that precedes 'mem'.
+
+static size_t qmemsize (void *mem)
+{
+    size_t memsize;
+    struct QHeader *qh;
+    struct QBlock *blk;
+    int key;
+    int q;
+
+
+    key = ((uintptr_t)mem>>HASH_SHIFT) % QBLOCK_HASH_SZ;
+
+    blk = LIST_HEAD (&qblock_hash[key]);
+
+    while (blk != NULL)
+    {
+        if (blk->addr == mem)
+        {
+            return blk->size & ~Q_INUSE;
+        }
+        
+        blk = LIST_NEXT (blk, link);
+    }
+
+    qh = (struct QHeader *)((uint8 *)mem - SIZEOF_QHEADER);
+    return qh->size & ~Q_INUSE;
+}
+
+
+
+
+// qallocblock();
+// Allocates a large block of memory from the operating system,
+// allocates an associated QBlock structure and adds it to
+// a hash table for quick lookup.
+
+static void *qallocblock (size_t sz, int type)
+{
+    void *mem;
+    struct QBlock *blk, *new_qblocks;
+    int key;
+    int t;
+    
+
+    // Find some way of allocating a smallish table on startup to avoid virtualalloc
+    
+    
+    if (LIST_HEAD (&free_qblock_list) == NULL)
+    {
+        if ((new_qblocks = VirtualAlloc (NULL, QBLOCKS_TO_ALLOC * sizeof (struct QBlock), PROT_READWRITE)) == NULL)
+        {
+            return NULL;
+        }
+        
+        for (t=0; t < QBLOCKS_TO_ALLOC; t++)
+        {
+            LIST_ADD_TAIL(&free_qblock_list, &new_qblocks[t], link);
+        }
+    }
+    
+    blk = LIST_HEAD (&free_qblock_list);
+    
+    if ((mem = VirtualAlloc (NULL, sz, PROT_READWRITE)) == NULL)
+    {
+        errno = ENOMEM;
+        return NULL;
+    }
+        
+    LIST_REM_HEAD (&free_qblock_list, link);
+    key = (int)mem % QBLOCK_HASH_SZ;
+    LIST_ADD_HEAD (&qblock_hash[key], blk, link);
+    blk->addr = mem;
+    blk->type = type;
+    last_allocated_block = blk;
+    
+    return blk->addr;
+}
+
+
+
+
+// qfreeblock();
+// Frees a block of memory obtained from the operating system.
+// Removes it from the qblock hash table.
+
+static void qfreeblock (void *mem)
+{
+    struct QBlock *blk;
+    int key;
+    
+    key = ((int)mem>>HASH_SHIFT) % QBLOCK_HASH_SZ;
+
+    blk = LIST_HEAD (&qblock_hash[key]);
+
+    while (blk != NULL)
+    {
+        if (blk->addr == mem)
+        {
+            LIST_REM_ENTRY (&qblock_hash[key], blk, link);
+            
+            VirtualFree(mem, 0);  // TODO: FIXME: Size
+            blk->addr = NULL;
+            blk->type = -1;
+            
+            if (blk == last_allocated_block)
+                last_allocated_block = NULL;
+            
+            LIST_ADD_HEAD (&free_qblock_list, blk, link);   
+            return;
+        }
+        
+        blk = LIST_NEXT (blk, link);
+    }
+}
+
+
+
+
+
+
+
+
+/*
+ * Reentrant memory management functions needed by Newlib.
+ */
+
+void *_malloc_r (struct _reent *r, size_t size)
+{
+    return malloc (size);
+}
+
+
+void _free_r (struct _reent *r, void *ptr)
+{
+    free (ptr);
+}
+
+
+void *_calloc_r (struct _reent *r, size_t nelem, size_t elsize)
+{
+    return calloc (nelem, elsize);
+}
+
+
+void *_realloc_r (struct _reent *r, void *ptr, size_t size)
+{
+    return realloc (ptr, size);
+}
+
+
+void *__mempcpy(void *dst, void *src, size_t sz)
+{
+  return memcpy(dst, src, sz);
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/mknod.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mknod.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/mknod.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mknod.c
@@ -0,0 +1,20 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+
+
+/*
+ *
+ */
+
+int mknod (const char *path, mode_t mode, dev_t dev)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/mmap.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mmap.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/mmap.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mmap.c
@@ -0,0 +1,8 @@
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mntent.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mntent.c
@@ -0,0 +1,67 @@
+#include <stdio.h>
+#include <mntent.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+
+/*
+ *
+ */
+
+FILE *setmntent(const char *filename, const char *type)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+struct mntent *getmntent(FILE *filep)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+int addmntent(FILE *filep, const struct mntent *mnt)
+{
+	errno = ENOSYS;
+	return 0;
+}
+
+
+
+
+int endmntent(FILE *filep)
+{
+	errno = ENOSYS;
+	return 0;
+}
+
+
+
+
+/*
+ *
+ */
+
+char *hasmntopt(const struct mntent *mnt, const char *opt)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mntent.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mntent.h
@@ -0,0 +1,65 @@
+#ifndef	_MNTENT_H
+#define	_MNTENT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+
+struct mntent
+{
+	char    *mnt_fsname;    /* name of mounted file system */
+	char    *mnt_dir;      /* file system path prefix */
+	char    *mnt_type;      /* mount type (see mntent.h) */
+	char    *mnt_opts;      /* mount options (see mntent.h) */
+	int     mnt_freq;      /* dump frequency in days */
+	int     mnt_passno;     /* pass number on parallel fsck */
+};
+
+
+
+
+#define MNT_CHECKLIST  "/etc/fstab" 
+#define	MNTTAB		"/etc/mnttab"
+#define	VFSTAB		"/etc/vfstab"
+#define	MNTMAXSTR	128
+
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+/* Generic mount options.  */
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+
+
+
+
+
+
+FILE *setmntent(const char *filename, const char *type);
+struct mntent *getmntent(FILE *filep);
+int addmntent(FILE *filep, const struct mntent *mnt);
+int endmntent(FILE *filep);
+char *hasmntopt(const struct mntent *mnt, const char *opt);
+struct mntent *getmntent_r (FILE *stream, struct mntent *result, char *buffer, int bufsize);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/mount.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mount.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/mount.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/mount.c
@@ -0,0 +1,31 @@
+#include <_ansi.h>
+#include <errno.h>
+#include <sys/mount.h>
+#include <sys/syscalls.h>
+
+
+
+
+
+/*
+ * FIXME:  Needs to call opendir/readdir/kos_mountinfo
+ */
+
+int getfsstat (struct statfs *buf, int bufsize, int flags)
+{
+	return 0;
+}
+
+
+
+
+/*
+ *
+ */
+
+int getmntinfo (struct statfs **mntbufp, int flags)
+{
+	return 0;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h
@@ -0,0 +1,59 @@
+/* 
+ */
+
+
+
+#ifndef _NETINET_IN_H_
+#define _NETINET_IN_H_
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/cdefs.h>
+
+
+
+typedef uint16_t in_port_t;
+typedef uint32_t in_addr_t;
+
+
+
+struct in_addr
+{
+	in_addr_t s_addr;
+};
+
+
+struct sockaddr_in
+{
+	sa_family_t sin_family;
+	in_port_t sin_port;
+	struct in_addr sin_addr;
+};
+
+
+
+
+#define IPPROTO_IP			1
+#define IPPROTO_ICMP		2
+#define IPPROTO_RAW			3
+#define IPPROTO_TCP			4
+#define IPPROTO_UDP			5
+
+
+
+#define INADDR_ANY			1
+#define INADDR_BROADCAST	2
+
+
+#define INET_ADDRSTRLEN		16
+
+
+
+
+
+
+
+
+#endif /* !_NETINET_IN_ */
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/open.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/open.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/open.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/open.c
@@ -0,0 +1,37 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+
+
+int open (const char *file, int flags, ...)
+{
+	int mode;
+	int fd;
+	
+	va_list ap;
+	
+	va_start(ap, flags);
+
+	if (flags & O_CREAT)
+		mode = va_arg(ap, int);
+	else
+		mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
+	
+	va_end(ap);
+	
+//	filename_sz = strlen(file) + 1;
+	
+	fd = Open (file, flags, mode);
+	
+	if (fd < 0) {
+	    errno = -fd;
+	    return -1;
+	}
+
+  return fd;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/opendir.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/opendir.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/opendir.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/opendir.c
@@ -0,0 +1,51 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+DIR *opendir (const char *path)
+{
+	DIR *dir;
+    void *buf;
+    int fd;
+
+	if ((dir = malloc (sizeof (DIR))) == NULL)
+		return NULL;
+	
+	if ((buf = malloc (DIRENTS_BUF_SZ)) == NULL)
+	{
+		free (dir);
+		return NULL;
+	}	
+	    
+    fd = OpenDir (path);
+
+    if (fd < 0)
+    {
+		free (buf);
+		free (dir);
+        errno = -fd;
+        return NULL;
+    }
+		
+	dir->fd = fd;
+	dir->buf = buf;
+    dir->buf_offset = 0; 
+	dir->buf_sz = 0;
+	dir->eof = false;
+	return dir;
+}
+
+
+int
+dirfd(DIR *dirp)
+{
+
+	return dirp->fd;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c
@@ -0,0 +1,22 @@
+
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+
+
+long fpathconf(int filedes, int name)
+{
+	return -1;
+}
+
+
+long pathconf(const char *path, int name)
+{
+	return -1;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/pipe.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/pipe.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/pipe.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/pipe.c
@@ -0,0 +1,28 @@
+
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+
+/*
+ * pipe()
+ */
+ 
+int pipe (int fdp[2])
+{
+  int sc;
+  
+  sc = Pipe(fdp);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+
+  return 0;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/popen.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/popen.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/popen.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/popen.c
@@ -0,0 +1,34 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <stdio.h>
+
+
+
+
+/*
+ *
+ */
+
+FILE *popen (const char *command, const char *mode)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+int pclose (FILE *stream)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/pwd.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/pwd.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/pwd.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/pwd.c
@@ -0,0 +1,166 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <pwd.h>
+
+
+
+
+/*
+ *
+ */
+
+struct passwd *getpwnam(const char *name)
+{
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+char *crypt(const char *key, const char *salt)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+char *getlogin(void)
+{
+	return NULL;
+}
+
+
+
+
+
+/*
+ *
+ */
+
+struct passwd *getpwuid(uid_t uid)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+struct group *getgrgid(gid_t gid)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+struct group *getgrnam(const char *name)
+{
+	errno = ENOSYS;
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+struct passwd *getpwent(void)
+{
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+void setpwent(void)
+{
+}
+
+
+
+
+/*
+ *
+ */
+
+void endpwent(void)
+{
+}
+
+
+
+
+/*
+ *
+ */
+
+void endgrent(void)
+{
+}
+
+
+
+
+/*
+ *
+ */
+
+struct group *getgrent(void)
+{
+	return NULL;
+}
+
+
+
+
+/*
+ *
+ */
+
+void setgrent(void)
+{
+}
+
+
+
+
+/*
+ *
+ */
+
+int setgroups (int ngroups, const gid_t *grouplist)
+{
+	errno = ENOSYS;
+	return -1;
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/read.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/read.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/read.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/read.c
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+ssize_t read (int fd, void *buf, size_t nbyte)
+{
+    ssize_t sz;
+    
+    sz = Read(fd, buf, nbyte);
+    
+    if (sz < 0) {
+        errno = -sz;
+        return -1;
+    }
+	
+	return sz;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/readdir.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/readdir.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/readdir.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/readdir.c
@@ -0,0 +1,51 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+struct dirent *readdir(DIR *dir)
+{
+    struct dirent *dent;
+    int sz;
+    
+    if (dir == NULL)
+    {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    if (dir->eof == true)
+    {
+        return NULL;
+    }
+    
+    // Check if any more dirents in buffer, else we read in new dirents
+    
+    if (dir->buf_offset >= dir->buf_sz)
+    {   
+        sz = ReadDir (dir->fd, dir->buf, DIRENTS_BUF_SZ);
+
+        if (sz < 0) {
+            errno = -sz;
+            dir->buf_sz = 0;
+            dir->eof = true;
+            return NULL;
+        } else if (sz == 0) {
+            dir->buf_sz = 0;
+            dir->eof = true;
+            return NULL;
+        } if (sz > DIRENTS_BUF_SZ) {
+           exit(-1);
+        }
+
+        dir->buf_sz = sz; 
+        dir->buf_offset = 0;
+    }
+        
+    dent = (struct dirent *)((uint8_t *)dir->buf + dir->buf_offset);
+    dir->buf_offset += dent->d_reclen;
+    return dent;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/readme.txt third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/readme.txt
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/readme.txt
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/readme.txt
@@ -0,0 +1,9 @@
+
+When adding files to this directory, add the name
+of the object file to makefile.am then run the following
+commands in this directory.
+
+
+aclocal -I ../../..
+autoconf
+automake --cygnus --add-missing Makefile
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/rename.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/rename.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/rename.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/rename.c
@@ -0,0 +1,25 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ * open();
+ *
+ * Needs fixing, to use the vararg 'mode' depending on flags.
+ */
+
+int rename (const char *oldname, const char *newname)
+{
+    int sc;
+
+    sc = Rename(oldname, newname);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/resource.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/resource.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/resource.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/resource.c
@@ -0,0 +1,33 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/resource.h>
+
+
+
+
+/*
+ *
+ */
+
+int getrlimit(int resource, struct rlimit *rlp)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+
+
+
+/*
+ *
+ */
+
+int setrlimit(int resource, const struct rlimit *rlp)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c
@@ -0,0 +1,30 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+void rewinddir (DIR *dir)
+{    	
+    int sc;
+    
+	if (dir == NULL)
+	{
+		errno = EINVAL;
+		return;
+	}
+    
+    sc = RewindDir(dir->fd);
+    if (sc < 0) {
+        errno = -sc;
+        return;
+    }
+    
+    dir->buf_offset = 0;
+    dir->buf_sz = 0;
+    dir->eof = false;    
+    return;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/select.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/select.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/select.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/select.c
@@ -0,0 +1,50 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/signal.h>
+
+
+
+/*
+ *
+ */
+int poll (struct pollfd *pfds, nfds_t nfds, int timeout)
+{
+  int sc;
+  
+  sc = Poll (pfds, nfds, timeout);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }  
+  return sc;
+}
+
+/*
+ *
+ */
+int pselect(int nfds, fd_set *readfds,
+       fd_set *writefds, fd_set *errorfds,
+       const struct timespec *timeout,
+       const sigset_t *sigmask)
+{
+	errno = EINTR;
+	return -1;
+}
+       
+/* 
+ *
+ */    
+int select(int nfds, fd_set *readfds,
+       fd_set *writefds, fd_set *errorfds,
+       struct timeval *timeout)
+{
+	errno = EINTR;
+	return -1;
+}
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/siglist.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/siglist.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/siglist.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/siglist.c
@@ -0,0 +1,126 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <signal.h>
+
+
+
+
+/*
+ *
+ */
+ 
+const char * const sys_siglist[NSIG] =
+{
+	/*  0           */ "Unknown Signal",
+	/*  1 SIGHUP    */ "Hangup",
+	/*  2 SIGINT    */ "Interrupt",
+	/*  3 SIGQUIT   */ "Quit",
+	/*  4 SIGILL    */ "Illegal instruction",
+	/*  5 SIGTRAP   */ "BPT trace/trap",
+	/*  6 SIGABORT  */ "ABORT instruction",
+	/*  7 SIGEMT    */ "EMT instruction",
+	/*  8 SIGFPE    */ "Floating point exception",
+	/*  9 SIGKILL   */ "Killed",
+	/* 10 SIGBUS    */ "Bus error",
+	/* 11 SIGSEGV   */ "Segmentation fault",
+	/* 12 SIGSYS    */ "Bad system call",
+	/* 13 SIGPIPE   */ "Broken pipe",
+	/* 14 SIGALRM   */ "Alarm clock",
+	/* 15 SIGTERM   */ "Terminated",
+	/* 16 SIGURG    */ "Urgent IO condition",
+	/* 17 SIGSTOP   */ "Stopped (signal)",
+	/* 18 SIGTSTP   */ "Stopped",
+	/* 19 SIGCONT   */ "Continue",
+	/* 20 SIGCHLD   */ "Child death or stop",
+	/* 21 SIGTTIN   */ "Stopped (tty input)",
+	/* 22 SIGTTOU   */ "Stopped (tty output)",
+	/* 23 SIGIO     */ "I/O ready",
+	/* 24 SIGXCPU   */ "CPU limit",
+	/* 25 SIGXFSZ   */ "File limit",
+	/* 26 SIGVTALRM */ "Alarm (virtual)",
+	/* 27 SIGPROF   */ "Alarm (profile)",
+	/* 28 SIGWINCH  */ "Window changed",
+	/* 29 SIGLOST   */ "Record lock",
+	/* 30 SIGUSR1   */ "User signal 1",
+	/* 31 SIGUSR2   */ "User signal 2"
+};
+
+
+
+
+/*
+ *
+ */
+
+const char * const sys_signame[NSIG] =
+{
+	/*  0           */ "signal 0",
+	/*  1 SIGHUP    */ "hup",
+	/*  2 SIGINT    */ "int",
+	/*  3 SIGQUIT   */ "quit",
+	/*  4 SIGILL    */ "ill",
+	/*  5 SIGTRAP   */ "trap",
+	/*  6 SIGABORT  */ "abort",
+	/*  7 SIGEMT    */ "emt",
+	/*  8 SIGFPE    */ "fpe",
+	/*  9 SIGKILL   */ "kill",
+	/* 10 SIGBUS    */ "bus",
+	/* 11 SIGSEGV   */ "segv",
+	/* 12 SIGSYS    */ "sys",
+	/* 13 SIGPIPE   */ "pipe",
+	/* 14 SIGALRM   */ "alrm",
+	/* 15 SIGTERM   */ "term",
+	/* 16 SIGURG    */ "urg",
+	/* 17 SIGSTOP   */ "stop",
+	/* 18 SIGTSTP   */ "tstp",
+	/* 19 SIGCONT   */ "cont",
+	/* 20 SIGCHLD   */ "chld",
+	/* 21 SIGTTIN   */ "ttin",
+	/* 22 SIGTTOU   */ "ttou",
+	/* 23 SIGIO     */ "io",
+	/* 24 SIGXCPU   */ "xcpu",
+	/* 25 SIGXFSZ   */ "xfsz",
+	/* 26 SIGVTALRM */ "vtalrm",
+	/* 27 SIGPROF   */ "prof",
+	/* 28 SIGWINCH  */ "winch",
+	/* 29 SIGLOST   */ "lost",
+	/* 30 SIGUSR1   */ "usr1",
+	/* 31 SIGUSR2   */ "usr2"
+};
+
+
+
+
+/*
+ * 
+ */
+
+char *strsignal (int sig)
+{
+	if (sig > 0 && sig <NSIG)
+		return (char *) sys_siglist[sig];
+	else
+		return "Unknown signal";
+}
+
+
+
+
+/*
+ *
+ */
+
+void psignal (int sig, const char *s)
+{
+	const char *sig_str;
+	
+	if (sig > 0 && sig < NSIG)
+		sig_str = sys_siglist[sig];
+	else
+		sig_str = "Unknown signal";
+
+	printf ("%s: %s\n", s, sig_str);
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/signal.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/signal.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/signal.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/signal.c
@@ -0,0 +1,114 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <signal.h>
+#include <sys/signal.h>
+#include <unistd.h>
+
+
+
+_sig_func_ptr signal (int sig, _sig_func_ptr handler)
+{
+	struct sigaction act;
+	
+	act.sa_flags = SA_RESETHAND;
+	act.sa_mask = 0;
+	act.sa_handler = handler;
+		
+	sigaction (sig, &act, NULL);
+}
+
+
+int kill (int pid, int sig)
+{
+	int sc;
+	
+	sc = Kill(pid, sig);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+int sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+	int sc;
+	
+	sc = SigAction(sig, act, oact);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+int raise (int sig)
+{
+	int sc;
+	
+	sc = Kill(GetPID(), sig);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+
+int sigprocmask (int how, const sigset_t *set, sigset_t *oset)
+{
+	int sc;
+	
+	sc = SigProcMask(how, set, oset);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+int sigsuspend (const sigset_t *sigmask)
+{
+	int sc;
+	
+	sc = SigSuspend(sigmask);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+
+int sigpending (sigset_t *set)
+{
+	int sc;
+	
+	sc = SigPending(set);
+
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s
@@ -0,0 +1,66 @@
+.global __kielder_sigtramp
+.equ SF_SIGNUM,     0
+.equ SF_SIGINFO,    4
+.equ SF_UCONTEXT,   8
+.equ SF_SIGHANDLER, 12
+
+
+
+
+.text
+.align 16
+
+
+
+
+/ ****************************************************************************
+/ __kielder_sigtramp:
+/
+/ 
+/ Kernel passes control to __sigtramp to begin signal handling.
+/ A sigframe is placed on the stack by the kernel, stack pointer points to
+/ the sigframe structure.
+
+
+
+__kielder_sigtramp:
+	movl SF_SIGINFO(%esp), %eax
+	cmpl $0x00000000, %eax
+	jne Lcall_siginfohandler
+
+
+Lcall_sighandler:
+	movl SF_SIGNUM(%esp), %eax
+	movl SF_SIGHANDLER(%esp), %edx
+	
+	push %eax
+	call *%edx
+	
+	add $4, %esp
+	movl %esp, %ebx
+	movl $0xffffffff, %eax
+	int $0x30
+	
+	
+Lcall_siginfohandler:
+	movl SF_UCONTEXT(%esp), %eax
+	movl SF_SIGINFO(%esp), %ebx
+	movl SF_SIGNUM(%esp), %ecx
+	movl SF_SIGHANDLER(%esp), %edx
+		
+	push %eax
+	push %ebx
+	push %ecx
+	
+	call *%edx
+
+	add $4, %esp
+	movl %esp, %ebx
+	movl $0xffffffff, %eax
+	int $0x30
+
+
+
+
+	
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sleep.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sleep.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sleep.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sleep.c
@@ -0,0 +1,57 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+unsigned int sleep (unsigned int seconds)
+{
+  int sc;
+ 
+  sc = Sleep(seconds);
+  if (sc < 0) {
+      errno = -sc;
+      return -1;
+  }
+
+  return 0;
+}
+
+
+
+/*
+ *
+ */
+
+int nanosleep (const struct timespec *rqtp, struct timespec *rmtp)
+{
+	int rc;
+	
+	if (rqtp->tv_nsec < 1000000000)
+	{
+
+// TODO:		__syscall2 (_sysidx_sleep, 0, rqtp->tv_nsec / 1000);
+	
+		if (rmtp != NULL)
+		{
+			rmtp->tv_nsec = 0;
+		}
+		
+		rc = 0;
+	}
+	else
+	{
+		errno = EINVAL;
+		rc = -1;
+	}
+	
+	return rc;	
+}
+
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/stat.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/stat.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/stat.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/stat.c
@@ -0,0 +1,86 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+
+
+
+int fstat(int fd, struct stat *buf)
+{
+    int sc;
+    
+    sc = Fstat(fd, buf);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+
+
+
+
+
+
+int stat (const char *path, struct stat *buf)
+{
+    int sc;
+
+    sc = Stat(path, buf);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+/*
+ *
+ */
+
+int lstat (const char *pathname, struct stat *st)
+{
+	return stat(pathname, st);
+}
+
+
+
+
+/*
+ *
+ */
+
+int statfs(const char *path, struct statfs *buf)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+
+
+
+/*
+ *
+ */
+
+int fstatfs(int fd, struct statfs *buf)
+{
+	errno = ENOSYS;
+	return -1;
+}
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c
@@ -0,0 +1,48 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+/*
+ *
+ */
+
+int fstatvfs (int fd, struct statvfs *st)
+{
+	/* __syscall2 (_sysidx_fstatvfs, fd, st); */
+
+	return -1;
+}
+
+
+
+
+/*
+ *
+ */
+
+int statvfs (const char *pathname, struct statvfs *st)
+{
+	int fd;
+	
+	
+	if ((fd = open (pathname, O_RDONLY)) < 0)
+		return -1;
+		
+	if (fstatvfs (fd, st) < 0)
+		return -1;
+
+	if (close(fd) <	0)
+		return -1;
+		
+	return 0;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/swi.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/swi.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/swi.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/swi.h
@@ -1,91 +0,0 @@
-#include "arm.h"
-
-/* SWI numbers for RDP (Demon) monitor.  */
-#define SWI_WriteC                 0x0
-#define SWI_Write0                 0x2
-#define SWI_ReadC                  0x4
-#define SWI_CLI                    0x5
-#define SWI_GetEnv                 0x10
-#define SWI_Exit                   0x11
-#define SWI_EnterOS                0x16
-
-#define SWI_GetErrno               0x60
-#define SWI_Clock                  0x61
-#define SWI_Time                   0x63
-#define SWI_Remove                 0x64
-#define SWI_Rename                 0x65
-#define SWI_Open                   0x66
-
-#define SWI_Close                  0x68
-#define SWI_Write                  0x69
-#define SWI_Read                   0x6a
-#define SWI_Seek                   0x6b
-#define SWI_Flen                   0x6c
-
-#define SWI_IsTTY                  0x6e
-#define SWI_TmpNam                 0x6f
-#define SWI_InstallHandler         0x70
-#define SWI_GenerateError          0x71
-
-
-/* Now the SWI numbers and reason codes for RDI (Angel) monitors.  */
-#define AngelSWI_ARM 			0x123456
-#ifdef __thumb__
-#define AngelSWI 			0xAB
-#else
-#define AngelSWI 			AngelSWI_ARM
-#endif
-/* For thumb only architectures use the BKPT instruction instead of SWI.  */
-#ifdef THUMB_VXM
-#define AngelSWIInsn			"bkpt"
-#define AngelSWIAsm			bkpt
-#else
-#define AngelSWIInsn			"swi"
-#define AngelSWIAsm			swi
-#endif
-
-/* The reason codes:  */
-#define AngelSWI_Reason_Open		0x01
-#define AngelSWI_Reason_Close		0x02
-#define AngelSWI_Reason_WriteC		0x03
-#define AngelSWI_Reason_Write0		0x04
-#define AngelSWI_Reason_Write		0x05
-#define AngelSWI_Reason_Read		0x06
-#define AngelSWI_Reason_ReadC		0x07
-#define AngelSWI_Reason_IsTTY		0x09
-#define AngelSWI_Reason_Seek		0x0A
-#define AngelSWI_Reason_FLen		0x0C
-#define AngelSWI_Reason_TmpNam		0x0D
-#define AngelSWI_Reason_Remove		0x0E
-#define AngelSWI_Reason_Rename		0x0F
-#define AngelSWI_Reason_Clock		0x10
-#define AngelSWI_Reason_Time		0x11
-#define AngelSWI_Reason_System		0x12
-#define AngelSWI_Reason_Errno		0x13
-#define AngelSWI_Reason_GetCmdLine 	0x15
-#define AngelSWI_Reason_HeapInfo 	0x16
-#define AngelSWI_Reason_EnterSVC 	0x17
-#define AngelSWI_Reason_ReportException 0x18
-#define ADP_Stopped_ApplicationExit 	((2 << 16) + 38)
-#define ADP_Stopped_RunTimeError 	((2 << 16) + 35)
-
-#if defined(ARM_RDI_MONITOR) && !defined(__ASSEMBLER__)
-
-static inline int
-do_AngelSWI (int reason, void * arg)
-{
-  int value;
-  asm volatile ("mov r0, %1; mov r1, %2; " AngelSWIInsn " %a3; mov %0, r0"
-       : "=r" (value) /* Outputs */
-       : "r" (reason), "r" (arg), "i" (AngelSWI) /* Inputs */
-       : "r0", "r1", "r2", "r3", "ip", "lr", "memory", "cc"
-		/* Clobbers r0 and r1, and lr if in supervisor mode */);
-                /* Accordingly to page 13-77 of ARM DUI 0040D other registers
-                   can also be clobbered.  Some memory positions may also be
-                   changed by a system call, so they should not be kept in
-                   registers. Note: we are assuming the manual is right and
-                   Angel is respecting the APCS.  */
-  return value;
-}
-
-#endif
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sync.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sync.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sync.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sync.c
@@ -0,0 +1,35 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+int fsync (int fd)
+{
+  int sc;
+  
+  sc = Fsync(fd);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+int sync (void)
+{
+  int sc;
+  
+  sc = Sync();
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h
@@ -0,0 +1,48 @@
+#ifndef _SYS_DEBUG_H
+#define _SYS_DEBUG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+extern char __assertion_string[32];
+
+void KLogOut(const char *format, ...);
+
+#ifndef NDEBUG
+
+#define KLog(fmt, args...) KLogOut(fmt, ##args)
+
+#define KAssert(expr)                                                          \
+  {                                                                            \
+    if (!(expr)) {                                                             \
+      KLogOut("@ %s, %d, %s", __FILE__, __LINE__, __FUNCTION__);               \
+      KLogOut("KASSERT (" #expr ") failed");                                   \
+      snprintf(__assertion_string, 32, "@ %s, %d, %s", __FILE__, __LINE__,     \
+               __FUNCTION__);                                                  \
+      Exit(EXIT_ASSERTION, __assertion_string);                                \
+    }                                                                          \
+  }
+
+#else
+
+#define KLog(fmt, args...)
+
+#define KAssert(expr)
+
+#endif
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h
@@ -0,0 +1,56 @@
+/*
+ *  $Id: utime.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef __DIRENT_h__
+#define __DIRENT_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *
+ */
+
+#include <sys/types.h>
+#include <limits.h>
+#include <stdbool.h>
+
+#define DIRENTS_BUF_SZ 4096
+
+typedef struct _dir
+{
+	int	fd;
+	void *buf;
+	int buf_sz;
+  int buf_offset;
+  bool eof;
+} DIR;
+
+
+# define __dirfd(dp)	((dp)->fd)
+
+int closedir(DIR *);
+DIR *opendir(const char *);
+struct dirent *readdir(DIR *);
+
+
+
+struct dirent
+{
+    int d_cookie;
+    int d_reclen;  			/* Length of this dirent */
+	long d_ino;
+	char d_name[0];
+};
+
+
+#define DIRENT_ALIGN		32
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h
@@ -0,0 +1,29 @@
+#ifndef _SYS_EXECARGS_H
+#define _SYS_EXECARGS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+
+
+struct execargs
+{
+    char **argv;
+    int argc;
+    char **envv;
+    int envc;
+    size_t total_size;   
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h
@@ -3,10 +3,4 @@
 
 #include <sys/_default_fcntl.h>
 
-/* We want to support O_BINARY for the open syscall.
-   For example, the Demon debug monitor has a separate
-   flag value for "rb" vs "r". */
-#define _FBINARY        0x10000
-#define O_BINARY        _FBINARY
-
 #endif /* _SYS_FCNTL_H_ */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h
@@ -0,0 +1,302 @@
+#ifndef SYS_FSREQ_H
+#define SYS_FSREQ_H
+
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/dirent.h>
+#include <sys/stat.h>
+
+
+
+
+
+
+
+// TODO Move into newlib
+
+#define WSTAT_MODE  (1<<0)
+#define WSTAT_UID   (1<<1)
+#define WSTAT_GID   (1<<2)
+#define WSTAT_SIZE  (1<<3)
+#define WSTAT_ATIME (1<<4)
+#define WSTAT_MTIME (1<<5)
+#define WSTAT_CTIME (1<<6)
+
+#define CMD_LOOKUP          0
+#define CMD_CLOSE           1
+#define CMD_READ            2
+#define CMD_WRITE           3
+#define CMD_READDIR         4
+#define CMD_UNLINK          5
+#define CMD_RMDIR           6
+#define CMD_MKDIR           7
+#define CMD_MKNOD           8
+#define CMD_RENAME          9
+#define CMD_STAT            10
+#define CMD_MKLINK          11
+#define CMD_CREATE          12
+#define CMD_TRUNCATE        13
+#define CMD_CHOWN           14
+#define CMD_CHMOD           15
+#define CMD_ISATTY          16
+
+#define CMD_TCGETATTR       17
+#define CMD_TCSETATTR       18
+
+
+
+
+
+
+
+
+
+
+
+struct fsreq
+{
+    int cmd;    
+
+    // TODO: add timestamp here or should it be in each?
+
+    union
+    {
+        struct {
+            // TODO: Add flags to create, mode and uid/gid, date fields.
+            uint32_t dir_inode_nr;
+            int name_sz;
+        } lookup;
+
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            uint32_t oflags;
+            mode_t mode;
+            int uid;
+            int gid;
+        } create;
+        
+        struct {
+            uint32_t inode_nr;
+        } close;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;
+        } read;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;            
+        } write;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;
+        } readdir;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } mkdir;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } unlink;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } rmdir;
+        
+        struct {
+            uint32_t inode_nr;
+            int uid;
+            int gid;
+        } chown;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+        } chmod;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t size;
+        } truncate;
+
+        struct {
+            uint32_t inode_nr;
+        } stat;
+        
+        struct {
+           uint32_t src_dir_inode_nr;
+           uint32_t src_name_sz;
+           uint32_t dst_dir_inode_nr;
+           uint32_t dst_name_sz;
+        } rename;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            mode_t mode;
+            int uid;
+            int gid;
+        } mknod;
+
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            uint32_t link_sz;
+        } mklink;
+
+        struct {
+            uint32_t inode_nr;
+        } rdlink;
+        
+        struct {
+            uint32_t inode_nr;
+        } isatty;
+
+        struct
+        {
+          uint32_t inode_nr;
+        } tcgetattr;
+
+        struct
+        {
+          uint32_t inode_nr;
+        } tcsetattr;
+
+    } args;
+};
+
+
+struct fsreply
+{
+    int cmd;    
+
+    union
+    {
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+            int32_t status;
+        } lookup;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+            int32_t status;
+        } create;
+        
+        struct {
+            int32_t status;
+        } close;
+        
+        struct {
+            int32_t nbytes_read;
+        } read;
+        
+        struct {
+            int32_t nbytes_written;
+        } write;
+
+        struct {
+            int32_t nbytes_read;
+            off64_t offset;
+        } readdir;
+        
+        struct {
+            int32_t status;
+        } unlink;
+        
+        struct {
+            int32_t status;
+        } mkdir;
+        
+        struct {
+            int32_t status;
+        } rmdir;
+        
+        struct {
+            int32_t status;
+        } chown;
+
+        struct {
+            int32_t status;
+        } chmod;
+
+        struct {
+            int32_t status;
+        } truncate;
+
+        struct {
+            int32_t status;
+            struct stat stat;
+        } stat;
+           
+        struct {
+            int32_t status;
+        } rename;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+            int32_t status;
+        } mknod;   
+
+        struct {
+            uint32_t inode_nr;
+            int32_t status;
+        } mklink;   
+
+        struct {
+            uint32_t inode_nr;
+            int32_t status;
+        } rdlink;   
+
+        struct {
+            bool isatty;
+            int32_t status;
+        } isatty;   
+
+        struct {
+            int32_t status;
+        } tcgetattr;   
+
+        struct {
+            int32_t status;
+        } tcsetattr;   
+
+
+    } args;
+};
+
+
+
+#endif
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h
@@ -0,0 +1,24 @@
+#ifndef _SYS_INTERRUPTS_H
+#define _SYS_INTERRUPTS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+struct InterruptAPI
+{
+  int (*MaskInterrupt)(int irq);
+  int (*UnmaskInterrupt)(int irq);
+  int (*PollNotifyFromISR)(struct InterruptAPI *api, uint32_t mask, uint32_t events);
+
+  struct VNode *interrupt_vnode;
+};
+
+
+#ifdef __cplusplus
+}
+#endif 
+#endif
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h
@@ -0,0 +1,21 @@
+#ifndef _SYS_IOCTL_H
+#define _SYS_IOCTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+#define  IOCTL_CON_SETMAP	0
+
+
+
+int ioctl (int fd, int request, ...);
+
+
+#ifdef __cplusplus
+}
+#endif 
+#endif
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h
@@ -0,0 +1,648 @@
+#ifndef SYS_LISTS_H
+#define SYS_LISTS_H
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Double linked list with head and tail pointers in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+/* Could add a name, makes it easier for arrays */
+
+#define LIST_INITIALIZER	{NULL, NULL}
+
+#define LIST_TYPE(type)			 											\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+
+#define LIST(type)															\
+	struct																	\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+
+#define LIST_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+     
+#define LIST_DEFINE(name)													\
+		struct name
+     
+
+#define LIST_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+		struct type *prev;													\
+	}
+	
+
+#define LIST_INIT( header)													\
+	{																		\
+		(header)->head = NULL;												\
+		(header)->tail = NULL;												\
+	}
+	
+
+#define LIST_CONCAT( dest, src, field)										\
+	{																		\
+		if ((src)->head != NULL)											\
+		{																	\
+			if ((dest)->head != NULL)										\
+			{																\
+				((dest)->tail)->field.next = (src)->head;					\
+				((src)->head)->field.prev = (dest)->tail;					\
+				(dest)->tail = (src)->tail;									\
+			}																\
+			else															\
+			{																\
+				((src)->head)->field.prev = NULL;							\
+				(dest)->head = (src)->head;									\
+				(dest)->tail = (src)->tail;									\
+			}																\
+		}																	\
+	}
+
+
+#define LIST_EMPTY( header)													\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define LIST_HEAD( header)													\
+	((header)->head)
+
+
+#define LIST_TAIL( header)													\
+	((header)->tail)
+
+
+#define LIST_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define LIST_PREV( entry, field)											\
+	((entry)->field.prev)
+
+
+#define LIST_ADD_HEAD( header, new_head, field)								\
+	{																		\
+		(new_head)->field.next = (header)->head;							\
+		(new_head)->field.prev = NULL;										\
+																			\
+		if ((header)->head != NULL)											\
+			 (header)->head->field.prev = new_head;							\
+		else																\
+			(header)->tail = new_head;										\
+																			\
+		(header)->head = new_head;											\
+	}
+
+
+#define LIST_ADD_TAIL( header, new_tail, field)								\
+	{																	\
+		(new_tail)->field.next = NULL;										\
+		(new_tail)->field.prev = (header)->tail;							\
+		if ((header)->tail != NULL)											\
+			(header)->tail->field.next = new_tail;							\
+		else																\
+			(header)->head = new_tail;										\
+		(header)->tail = new_tail;											\
+	}
+
+
+#define LIST_REM_HEAD( header, field)										\
+	{																	\
+		(header)->head = (header)->head->field.next;						\
+		if ((header)->head != NULL)											\
+			(header)->head->field.prev = NULL;								\
+		else																\
+			(header)->tail = NULL;											\
+	}
+
+
+#define LIST_REM_TAIL( header, field)										\
+	{																		\
+		(header)->tail = (header)->tail->field.prev;						\
+		if ((header)->tail != NULL)											\
+			(header)->tail->field.next = NULL;								\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+#define LIST_INSERT_AFTER( header, prev_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(new_entry)->field.prev = prev_entry;								\
+		(prev_entry)->field.next = new_entry;								\
+		if ((new_entry)->field.next != NULL)								\
+			(new_entry)->field.next->field.prev = new_entry;				\
+		else																\
+			(header)->tail = new_entry;										\
+	}
+	
+
+#define LIST_INSERT_BEFORE( header, next_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.prev = (next_entry)->field.prev;					\
+		(new_entry)->field.next = next_entry;								\
+		(next_entry)->field.prev = new_entry;								\
+		if ((new_entry)->field.prev != NULL)								\
+			(new_entry)->field.prev->field.next = new_entry;				\
+		else																\
+			(header)->head = new_entry;										\
+	}
+	
+
+#define LIST_REM_ENTRY( header, entry, field)								\
+	{																		\
+		if ((entry)->field.prev != NULL)									\
+			(entry)->field.prev->field.next = (entry)->field.next;			\
+		else																\
+			(header)->head = (entry)->field.next;								\
+		if ((entry)->field.next != NULL)									\
+			(entry)->field.next->field.prev = (entry)->field.prev;			\
+		else																\
+			(header)->tail = (entry)->field.prev;								\
+	}
+
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Single linked queue with head and tail pointers in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define QUEUE_INITIALIZER	{NULL, NULL}
+
+#define QUEUE_TYPE(type)			 										\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+#define QUEUE( type)														\
+	struct																	\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+
+
+#define QUEUE_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+     
+#define QUEUE_DEFINE(name)													\
+		struct name
+
+
+#define QUEUE_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+	}
+
+
+#define QUEUE_INIT( header)													\
+	{																		\
+		(header)->head = NULL;												\
+		(header)->tail = NULL;												\
+	}
+
+
+#define QUEUE_EMPTY( header)												\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define QUEUE_HEAD( header)													\
+	((header)->head)
+
+
+#define QUEUE_TAIL( header)													\
+	((header)->tail)
+
+
+#define QUEUE_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define QUEUE_ADD_TAIL( header, new_tail, field)							\
+	{																		\
+		(new_tail)->field.next = NULL;										\
+		if ((header)->tail != NULL)											\
+			(header)->tail->field.next = new_tail;							\
+		else																\
+			(header)->head = new_tail;										\
+		(header)->tail = new_tail;											\
+	}
+
+
+#define QUEUE_REM_HEAD( header, field)										\
+	{																		\
+		(header)->head = (header)->head->field.next;						\
+		if ((header)->head == NULL)											\
+			(header)->tail = NULL;											\
+	}
+
+
+#define QUEUE_INSERT_AFTER( header, prec_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(prev_entry)->field.next = new_entry;								\
+		if ((new_entry)->field.next == NULL)								\
+			(header)->tail = new_entry;										\
+	}
+
+#define QUEUE_REM_AFTER( header, prec_entry, rem_entry, field)				\
+	{																		\
+		if (prec_entry != NULL)												\
+			(prec_entry)->field.next = (rem_entry)->field.next;				\
+		else																\
+		{																	\
+			(header)->head = (header)->head->field.next;					\
+			if ((header)->head == NULL)										\
+				(header)->tail = NULL;										\
+		}																	\
+	}
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Single linked list with only a head pointer in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define STACK_INITIALIZER		{NULL}
+
+#define STACK_TYPE(type)			 										\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+	}
+
+
+
+#define STACK( type)														\
+	struct																	\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define STACK_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+	}
+
+     
+#define STACK_DEFINE(name)													\
+		struct name
+
+
+#define STACK_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+	}
+
+
+#define STACK_INIT( header)													\
+	(header)->head = NULL;
+
+
+#define STACK_EMPTY( header)												\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define STACK_HEAD( header)													\
+	((header)->head)
+
+
+#define STACK_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define STACK_ADD_HEAD( header, new_head, field)							\
+	{																		\
+		(new_head)->field.next = (header)->head;							\
+		(header)->head = new_head;											\
+	}
+
+
+#define STACK_REM_HEAD( header, field)										\
+	(header)->head = (header)->head->field.next;
+	
+
+#define STACK_INSERT_AFTER( header, prec_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(prev_entry)->field.next = new_entry;								\
+	}
+
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Double linked list with only a head pointer in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define HEAP_INITIALIZER		{NULL}
+
+#define HEAP_TYPE(type)			 											\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define HEAP( type)															\
+	struct																	\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define HEAP_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+	}
+
+     
+#define HEAP_DEFINE(name)													\
+		struct name
+
+
+#define HEAP_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+		struct type *prev;													\
+	}
+
+
+#define HEAP_INIT( header)													\
+	(header)->head = NULL;
+
+
+#define HEAP_EMPTY( header)													\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define HEAP_HEAD( header)													\
+	((header)->head)
+
+
+#define HEAP_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define HEAP_PREV( entry, field)											\
+	((entry)->field.prev)
+
+
+#define HEAP_ADD_HEAD( header, new_head, field)								\
+	{																		\
+		(new_head)->field.next = (header)->head;							\
+		(new_head)->field.prev = NULL;										\
+		if ((header)->head != NULL)											\
+			(header)->head->field.prev = new_head;							\
+		(header)->head = new_head;											\
+	}
+
+
+#define HEAP_REM_HEAD( header, field)										\
+	{																		\
+		(header)->head = (header)->head->field.next;						\
+		if ((header)->head != NULL)											\
+			(header)->head->field.prev = NULL;								\
+	}
+
+
+#define HEAP_INSERT_AFTER( header, prev_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(new_entry)->field.prev = prev_entry;								\
+		(prev_entry)->field.next = new_entry;								\
+		if ((new_entry)->field.next != NULL)								\
+			(new_entry)->field.next->field.prev = new_entry;				\
+	}
+
+
+#define HEAP_INSERT_BEFORE( header, next_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.prev = (next_entry)->field.prev;					\
+		(new_entry)->field.next = next_entry;								\
+		(next_entry)->field.prev = new_entry;								\
+		if ((new_entry)->field.prev != NULL)								\
+			(new_entry)->field.prev->field.next = new_entry;				\
+		else																\
+			(header)->head = new_entry;										\
+	}
+
+
+#define HEAP_REM_ENTRY( header, entry, field)								\
+	{																		\
+		if ((entry)->field.prev != NULL)									\
+			(entry)->field.prev->field.next = (entry)->field.next;			\
+		else																\
+			(header)->head = entry->field.next;								\
+		if ((entry)->field.next != NULL)									\
+			(entry)->field.next->field.prev = (entry)->field.prev;			\
+	}
+
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Circular queue with pointer to current head in header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define CIRCLEQ_INITIALIZER			{NULL}
+
+#define CIRCLEQ_TYPE(type)			 										\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define CIRCLEQ( type)														\
+	struct																	\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define CIRCLEQ_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+	}
+
+     
+#define CIRCLEQ_DEFINE(name)												\
+		struct name
+
+
+#define CIRCLEQ_ENTRY( type)												\
+	struct																	\
+	{																		\
+		struct type *next;													\
+		struct type *prev;													\
+	}
+
+
+#define CIRCLEQ_INIT( header)												\
+	(header)->head = NULL;
+
+#define CIRCLEQ_SET_HEAD( header, new_head)									\
+	(header)->head = new_head;
+
+#define CIRCLEQ_EMPTY( header)												\
+	(((header)->head == NULL) ? 1 : 0)
+
+
+#define CIRCLEQ_HEAD( header)												\
+	((header)->head)
+
+
+#define CIRCLEQ_TAIL( header, field)										\
+	 (((header)->head != NULL) ? (header)->head->field.prev : NULL)
+	 
+	 
+#define CIRCLEQ_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define CIRCLEQ_PREV( entry, field)											\
+	((entry)->field.prev)
+
+
+#define CIRCLEQ_FORWARD( header, field)										\
+	{																		\
+			(header)->head = (header)->head->field.next;					\
+	}
+
+
+#define CIRCLEQ_REVERSE( header, field)										\
+	{																		\
+		if ((header)->head != NULL)											\
+			(header)->head = (header)->head->field.next;					\
+	}
+
+
+#define CIRCLEQ_ADD_HEAD( header, new_head, field)							\
+	{																		\
+		if ((header)->head != NULL)											\
+		{																	\
+			(new_head)->field.next = (header)->head;						\
+			(new_head)->field.prev = (header)->head->field.prev;			\
+			(header)->head->field.prev = (new_head);						\
+			(new_head)->field.prev->field.next = (new_head);				\
+		}																	\
+		else																\
+		{																	\
+			(new_head)->field.next = (new_head);							\
+			(new_head)->field.prev = (new_head);							\
+		}																	\
+		(header)->head = (new_head);										\
+	}
+
+
+#define CIRCLEQ_ADD_TAIL( header, new_tail, field)							\
+	{																		\
+		if ((header)->head != NULL)											\
+		{																	\
+			(new_tail)->field.next = (header)->head;						\
+			(new_tail)->field.prev = (header)->head->field.prev;			\
+			(new_tail)->field.next->field.prev = (new_tail);				\
+			(new_tail)->field.prev->field.next = (new_tail);				\
+		}																	\
+		else																\
+		{																	\
+			(new_tail)->field.next = (new_tail);							\
+			(new_tail)->field.prev = (new_tail);							\
+			(header)->head = (new_tail);									\
+		}																	\
+	}
+
+
+#define CIRCLEQ_REM_HEAD( header, field)									\
+	{																		\
+		if ((header)->head->field.next != (header)->head)					\
+		{																	\
+			(header)->head->field.next->field.prev = (header)->head->field.prev;\
+			(header)->head->field.prev->field.next = (header)->head->field.next;\
+			(header)->head = (header)->head->field.next;					\
+		}																	\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+#define CIRCLEQ_REM_TAIL( header, field)									\
+	{																		\
+		if ((header)->head->field.next != (header)->head)					\
+		{																	\
+			(header)->head->field.prev->field.prev->field.next = (header)->head;\
+			(header)->head->field.prev = (header)->head->field.prev->field.prev;\
+		}																	\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+#define CIRCLEQ_REM_ENTRY( header, entry, field)							\
+	{																		\
+		if ((entry)->field.next != (entry))									\
+		{																	\
+			(entry)->field.next->field.prev = (entry)->field.prev;			\
+			(entry)->field.prev->field.next = (entry)->field.next;			\
+			if ((header)->head == (entry))									\
+				(header)->head = (entry)->field.next;						\
+		}																	\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+
+
+#endif
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h
@@ -0,0 +1,117 @@
+#ifndef	_SYS_MNTENT_H
+#define	_SYS_MNTENT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+
+
+
+
+#define	MNTTYPE_ZFS			"zfs"		/* ZFS file system */
+#define	MNTTYPE_UFS			"ufs"		/* Unix file system */
+#define	MNTTYPE_NFS			"nfs"		/* NFS file system */
+#define	MNTTYPE_NFS3		"nfs3"		/* NFS Version 3 file system */
+#define	MNTTYPE_NFS4		"nfs4"		/* NFS Version 4 file system */
+#define	MNTTYPE_CACHEFS		"cachefs"	/* Cache File System */
+#define	MNTTYPE_PCFS		"pcfs"		/* PC (MSDOS) file system */
+#define	MNTTYPE_PC	MNTTYPE_PCFS		/* Deprecated name; use MNTTYPE_PCFS */
+#define	MNTTYPE_LOFS		"lofs"		/* Loop back file system */
+#define	MNTTYPE_LO	MNTTYPE_LOFS		/* Deprecated name; use MNTTYPE_LOFS */
+#define	MNTTYPE_HSFS		"hsfs"		/* High Sierra (9660) file system */
+#define	MNTTYPE_SWAP		"swap"		/* Swap file system */
+#define	MNTTYPE_TMPFS		"tmpfs"		/* Tmp volatile file system */
+#define	MNTTYPE_AUTOFS		"autofs"	/* Automounter ``file'' system */
+#define	MNTTYPE_MNTFS		"mntfs"		/* In-kernel mnttab */
+#define	MNTTYPE_XMEMFS		"xmemfs"	/* Extended memory FS, IA32 only */
+#define	MNTTYPE_DEV			"dev"		/* /dev file system */
+#define	MNTTYPE_CTFS		"ctfs"		/* Contract file system */
+#define	MNTTYPE_OBJFS		"objfs"		/* Kernel object file system */
+
+#define	MNTOPT_RO			"ro"		/* Read only */
+#define	MNTOPT_RW			"rw"		/* Read/write */
+#define	MNTOPT_RQ			"rq"		/* Read/write with quotas */
+#define	MNTOPT_QUOTA		"quota"		/* Check quotas */
+#define	MNTOPT_NOQUOTA		"noquota"	/* Don't check quotas */
+#define	MNTOPT_ONERROR		"onerror"	/* action to taken on error */
+#define	MNTOPT_SOFT			"soft"		/* Soft mount */
+#define	MNTOPT_SEMISOFT		"semisoft"	/* partial soft, uncommited interface */
+#define	MNTOPT_HARD			"hard"		/* Hard mount */
+#define	MNTOPT_SUID			"suid"		/* Both setuid and devices allowed */
+#define	MNTOPT_NOSUID		"nosuid"	/* Neither setuid nor devices allowed */
+#define	MNTOPT_DEVICES		"devices"	/* Device-special allowed */
+#define	MNTOPT_NODEVICES	"nodevices"	/* Device-special disallowed */
+#define	MNTOPT_SETUID		"setuid"	/* Set uid allowed */
+#define	MNTOPT_NOSETUID		"nosetuid"	/* Set uid not allowed */
+#define	MNTOPT_GRPID		"grpid"		/* SysV-compatible gid on create */
+#define	MNTOPT_REMOUNT		"remount"	/* Change mount options */
+#define	MNTOPT_NOSUB		"nosub"		/* Disallow mounts on subdirs */
+#define	MNTOPT_MULTI		"multi"		/* Do multi-component lookup */
+#define	MNTOPT_INTR			"intr"		/* Allow NFS ops to be interrupted */
+#define	MNTOPT_NOINTR		"nointr"	/* Don't allow interrupted ops */
+#define	MNTOPT_PORT			"port"		/* NFS server IP port number */
+#define	MNTOPT_SECURE		"secure"	/* Secure (AUTH_DES) mounting */
+#define	MNTOPT_RSIZE		"rsize"		/* Max NFS read size (bytes) */
+#define	MNTOPT_WSIZE		"wsize"		/* Max NFS write size (bytes) */
+#define	MNTOPT_TIMEO		"timeo"		/* NFS timeout (1/10 sec) */
+#define	MNTOPT_RETRANS		"retrans"	/* Max retransmissions (soft mnts) */
+#define	MNTOPT_ACTIMEO		"actimeo"	/* Attr cache timeout (sec) */
+#define	MNTOPT_ACREGMIN		"acregmin"	/* Min attr cache timeout (files) */
+#define	MNTOPT_ACREGMAX		"acregmax"	/* Max attr cache timeout (files) */
+#define	MNTOPT_ACDIRMIN		"acdirmin"	/* Min attr cache timeout (dirs) */
+#define	MNTOPT_ACDIRMAX		"acdirmax"	/* Max attr cache timeout (dirs) */
+#define	MNTOPT_NOAC			"noac"		/* Don't cache attributes at all */
+#define	MNTOPT_NOCTO		"nocto"		/* No close-to-open consistency */
+#define	MNTOPT_BG			"bg"		/* Do mount retries in background */
+#define	MNTOPT_FG			"fg"		/* Do mount retries in foreground */
+#define	MNTOPT_RETRY		"retry"		/* Number of mount retries */
+#define	MNTOPT_DEV			"dev"		/* Device id of mounted fs */
+#define	MNTOPT_POSIX		"posix"		/* Get static pathconf for mount */
+#define	MNTOPT_MAP			"map"		/* Automount map */
+#define	MNTOPT_DIRECT		"direct"	/* Automount   direct map mount */
+#define	MNTOPT_INDIRECT		"indirect"	/* Automount indirect map mount */
+#define	MNTOPT_LLOCK		"llock"		/* Local locking (no lock manager) */
+#define	MNTOPT_IGNORE		"ignore"	/* Ignore this entry */
+#define	MNTOPT_VERS			"vers"		/* protocol version number indicator */
+#define	MNTOPT_PROTO		"proto"		/* protocol network_id indicator */
+#define	MNTOPT_SEC			"sec"		/* Security flavor indicator */
+#define	MNTOPT_SYNCDIR		"syncdir"	/* Synchronous local directory ops */
+#define	MNTOPT_NOSETSEC		"nosec"		/* Do no allow setting sec attrs */
+#define	MNTOPT_NOPRINT		"noprint"	/* Do not print messages */
+#define	MNTOPT_LARGEFILES 	"largefiles"		/* allow large files */
+#define	MNTOPT_NOLARGEFILES "nolargefiles" 		/* don't allow large files */
+#define	MNTOPT_FORCEDIRECTIO 	"forcedirectio" /* Force DirectIO on all files */
+#define	MNTOPT_NOFORCEDIRECTIO	"noforcedirectio" /* No Force DirectIO */
+#define	MNTOPT_DISABLEDIRECTIO	"disabledirectio" /* Disable DirectIO ioctls */
+#define	MNTOPT_PUBLIC		"public"	/* Use NFS public file handlee */
+#define	MNTOPT_LOGGING 		"logging" 	/* enable logging */
+#define	MNTOPT_NOLOGGING	"nologging"	/* disable logging */
+#define	MNTOPT_ATIME		"atime"		/* update atime for files */
+#define	MNTOPT_NOATIME 	 	"noatime"	/* do not update atime for files */
+#define	MNTOPT_GLOBAL		"global"	/* Cluster-wide global mount */
+#define	MNTOPT_NOGLOBAL		"noglobal"	/* Mount local to single node */
+#define	MNTOPT_DFRATIME		"dfratime"	/* Deferred access time updates */
+#define	MNTOPT_NODFRATIME 	"nodfratime"/* No Deferred access time updates */
+#define	MNTOPT_NBMAND		"nbmand"	/* allow non-blocking mandatory locks */
+#define	MNTOPT_NONBMAND		"nonbmand"	/* deny non-blocking mandatory locks */
+#define	MNTOPT_XATTR		"xattr"		/* enable extended attributes */
+#define	MNTOPT_NOXATTR		"noxattr"	/* disable extended attributes */
+#define	MNTOPT_EXEC			"exec"		/* enable executables */
+#define	MNTOPT_NOEXEC		"noexec"	/* disable executables */
+#define	MNTOPT_RESTRICT		"restrict"	/* restricted autofs mount */
+#define	MNTOPT_BROWSE		"browse"	/* browsable autofs mount */
+#define	MNTOPT_NOBROWSE		"nobrowse"	/* non-browsable autofs mount */
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
\ No newline at end of file
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h
@@ -0,0 +1,74 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+
+// mount flags
+#define MOUNTF_NOCACHE          (1<<0)
+#define MOUNTF_NODNLC           (1<<1)
+#define MOUNTF_DEFAULT_UID      (1<<2)
+#define MOUNTF_DEFAULT_GID      (1<<3)
+#define MOUNTF_DEFAULT_MODE     (1<<4)
+
+
+int Mount (char *_mountpoint, uint32_t flags, struct stat *stat);
+int Unmount (int fd, bool force);
+
+
+typedef struct { long val[2]; } fsid_t;
+
+#define MFSNAMELEN   15 /* length of fs type name, not inc. nul */
+#define MNAMELEN     90 /* length of buffer for returned name */
+
+
+
+
+#define MNT_NOWAIT 0
+#define MNT_WAIT 1
+
+#define MNT_RDONLY 0x00000001 /* read only filesystem */
+#define MNT_SYNCHRONOUS 0x00000002 /* file system written 
+    synchronously */
+#define MNT_NOEXEC 0x00000004 /* can't exec from filesystem 
+    */
+#define MNT_NOSUID 0x00000008 /* don't honor setuid bits on 
+    fs */
+#define MNT_NODEV 0x00000010 /* don't interpret special 
+    files */
+#define MNT_UNION 0x00000020 /* union with underlying 
+    filesystem */
+#define MNT_ASYNC 0x00000040 /* file system written 
+    asynchronously */
+#define MNT_DONTBROWSE 0x00100000 /* file system is not 
+    appropriate path to user data */
+#define MNT_IGNORE_OWNERSHIP 0x00200000 /* VFS will ignore 
+    ownership information on filesystem objects */
+#define MNT_AUTOMOUNTED 0x00400000 /* filesystem was mounted
+    by automounter */
+#define MNT_JOURNALED 0x00800000 /* filesystem is journaled 
+    */
+#define MNT_NOUSERXATTR 0x01000000 /* Don't allow user 
+    extended attributes */
+#define MNT_DEFWRITE 0x02000000 /* filesystem should defer 
+    writes */
+
+
+int getfsstat (struct statfs *buf, int bufsize, int flags);
+int getmntinfo (struct statfs **mntbufp, int flags);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h
@@ -0,0 +1,241 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)param.h	8.3 (Berkeley) 4/4/95
+ * $Id: param.h,v 1.3 2004/05/07 20:29:24 jjohnstn Exp $
+ */
+
+#ifndef _SYS_PARAM_H_
+#define _SYS_PARAM_H_
+
+/* from newlib's <sys/param.h> */
+
+#include <sys/config.h>
+#include <machine/endian.h>
+
+# define HZ (60)
+# define PATHSIZE (1024)
+
+/* end of from newlib's <sys/param.h> */
+
+#include <unistd.h>
+
+#define	BSD	199506		/* System version (year & month). */
+#define BSD4_3	1
+#define BSD4_4	1
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef LOCORE
+#include <sys/types.h>
+#endif
+
+/*
+ * Machine-independent constants (some used in following include files).
+ * Redefined constants are from POSIX 1003.1 limits file.
+ *
+ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
+ * MAXLOGNAME should be >= UT_NAMESIZE (see <utmp.h>)
+ */
+#include <sys/syslimits.h>
+
+#define	MAXCOMLEN	16		/* max command name remembered */
+#define	MAXINTERP	32		/* max interpreter file name length */
+#define	MAXLOGNAME	12		/* max login name length */
+#define	MAXUPRC		CHILD_MAX	/* max simultaneous processes */
+#define	NCARGS		ARG_MAX		/* max bytes for an exec function */
+#define	NGROUPS		NGROUPS_MAX	/* max number groups */
+#define	NOFILE		OPEN_MAX	/* max open files per process */
+#define	NOGROUP		65535		/* marker for empty group set member */
+#define MAXHOSTNAMELEN	256		/* max hostname size */
+
+/* More types and definitions used throughout the kernel. */
+#ifdef KERNEL
+#include <sys/cdefs.h>
+#include <sys/errno.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/ucred.h>
+#include <sys/uio.h>
+#include <sys/rtprio.h>
+
+#ifndef FALSE
+#define	FALSE	0
+#endif
+#ifndef TRUE
+#define	TRUE	1
+#endif
+#endif
+
+/* Signals. */
+#include <sys/signal.h>
+
+/* Machine type dependent parameters. */
+#include <machine/param.h>
+#include <machine/limits.h>
+
+/*
+ * Priorities.  Note that with 32 run queues, differences less than 4 are
+ * insignificant.
+ */
+#define	PSWP	0
+#define	PVM	4
+#define	PINOD	8
+#define	PRIBIO	16
+#define	PVFS	20
+#define	PZERO	22		/* No longer magic, shouldn't be here.  XXX */
+#define	PSOCK	24
+#define	PWAIT	32
+#define	PLOCK	36
+#define	PPAUSE	40
+#define	PUSER	50
+#define	MAXPRI	127		/* Priorities range from 0 through MAXPRI. */
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
+
+#define	NZERO	0		/* default "nice" */
+
+#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
+
+#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
+#define	NODEV	(dev_t)(-1)	/* non-existent device */
+
+/*
+ * Clustering of hardware pages on machines with ridiculously small
+ * page sizes is done here.  The paging subsystem deals with units of
+ * CLSIZE pte's describing PAGE_SIZE (from machine/machparam.h) pages each.
+ */
+#if 0
+#define	CLBYTES		(CLSIZE*PAGE_SIZE)
+#endif
+
+#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
+#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
+				/* Data chars/clist. */
+#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
+#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
+
+/*
+ * File system parameters and macros.
+ *
+ * The file system is made out of blocks of at most MAXBSIZE units, with
+ * smaller units (fragments) only in the last direct block.  MAXBSIZE
+ * primarily determines the size of buffers in the buffer pool.  It may be
+ * made larger without any effect on existing file systems; however making
+ * it smaller make make some file systems unmountable.  Also, MAXBSIZE
+ * must be less than MAXPHYS!!!  DFLTBSIZE is the average amount of
+ * memory allocated by vfs_bio per nbuf.  BKVASIZE is the average amount
+ * of kernel virtual space allocated per nbuf.  BKVASIZE should be >=
+ * DFLTBSIZE.  If it is significantly bigger than DFLTBSIZE, then
+ * kva fragmentation causes fewer performance problems.
+ */
+#define	MAXBSIZE	65536
+#define BKVASIZE	8192
+#define DFLTBSIZE	4096
+#define MAXFRAG 	8
+
+/*
+ * MAXPATHLEN defines the longest permissible path length after expanding
+ * symbolic links. It is used to allocate a temporary buffer from the buffer
+ * pool in which to do the name expansion, hence should be a power of two,
+ * and must be less than or equal to MAXBSIZE.  MAXSYMLINKS defines the
+ * maximum number of symbolic links that may be expanded in a path name.
+ * It should be set high enough to allow all legitimate uses, but halt
+ * infinite loops reasonably quickly.
+ */
+#if !defined(__rtems__)
+#define	MAXPATHLEN	PATH_MAX
+#endif
+#define MAXSYMLINKS	32
+
+/* Bit map related macros. */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding. */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif
+#define	rounddown(x, y)	(((x)/(y))*(y))
+#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
+#define	roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#define powerof2(x)	((((x)-1)&(x))==0)
+
+/* Macros for min/max. */
+#ifndef KERNEL
+#define	MIN(a,b) (((a)<(b))?(a):(b))
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+#endif
+
+/*
+ * Constants for setting the parameters of the kernel memory allocator.
+ *
+ * 2 ** MINBUCKET is the smallest unit of memory that will be
+ * allocated. It must be at least large enough to hold a pointer.
+ *
+ * Units of memory less or equal to MAXALLOCSAVE will permanently
+ * allocate physical memory; requests for these size pieces of
+ * memory are quite fast. Allocations greater than MAXALLOCSAVE must
+ * always allocate and free physical memory; requests for these
+ * size allocations should be done infrequently as they will be slow.
+ *
+ * Constraints: PAGE_SIZE <= MAXALLOCSAVE <= 2 ** (MINBUCKET + 14), and
+ * MAXALLOCSIZE must be a power of two.
+ */
+#define MINBUCKET	4		/* 4 => min allocation of 16 bytes */
+#define MAXALLOCSAVE	(2 * PAGE_SIZE)
+
+/*
+ * Scale factor for scaled integers used to count %cpu time and load avgs.
+ *
+ * The number of CPU `tick's that map to a unique `%age' can be expressed
+ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+ * can be calculated (assuming 32 bits) can be closely approximated using
+ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
+ *
+ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
+ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
+ */
+#define	FSHIFT	11		/* bits to right of fixed binary point */
+#define FSCALE	(1<<FSHIFT)
+
+#endif	/* _SYS_PARAM_H_ */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h
@@ -0,0 +1,42 @@
+#ifndef _SYS_RESOURCE_H_
+#define _SYS_RESOURCE_H_
+
+#include <sys/time.h>
+
+
+
+
+typedef unsigned long rlim_t;
+
+#define RLIM_INFINITY		0xffffffff
+#define RLIM_SAVED_MAX		0xfffffffe
+#define RLIM_SAVED_CUR		0xfffffffd
+
+
+
+#define RLIMIT_CORE			0
+#define RLIMIT_CPU			1
+#define RLIMIT_DATA			2
+#define RLIMIT_FSIZE		3
+#define RLIMIT_NOFILE		4
+#define RLIMIT_STACK		5
+#define RLIMIT_AS			6
+
+struct rlimit
+{
+	rlim_t rlim_cur;
+	rlim_t rlim_max;
+};
+
+
+
+#define	RUSAGE_SELF	0		/* calling process */
+#define	RUSAGE_CHILDREN	-1		/* terminated child processes */
+
+struct rusage {
+  	struct timeval ru_utime;	/* user time used */
+	struct timeval ru_stime;	/* system time used */
+};
+
+#endif
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h
@@ -0,0 +1,333 @@
+/* sys/signal.h */
+
+#ifndef _SYS_SIGNAL_H
+#define _SYS_SIGNAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "_ansi.h"
+#include <sys/cdefs.h>
+#include <sys/features.h>
+#include <sys/types.h>
+#include <sys/_sigset.h>
+#include <sys/_timespec.h>
+
+#if !defined(_SIGSET_T_DECLARED)
+#define	_SIGSET_T_DECLARED
+typedef	__sigset_t	sigset_t;
+#endif
+
+#if defined(__CYGWIN__)
+#include <cygwin/signal.h>
+#else
+
+/* sigev_notify values
+   NOTE: P1003.1c/D10, p. 34 adds SIGEV_THREAD.  */
+
+#define SIGEV_NONE   1  /* No asynchronous notification shall be delivered */
+                        /*   when the event of interest occurs. */
+#define SIGEV_SIGNAL 2  /* A queued signal, with an application defined */
+                        /*  value, shall be delivered when the event of */
+                        /*  interest occurs. */
+#define SIGEV_THREAD 3  /* A notification function shall be called to */
+                        /*   perform notification. */
+
+/*  Signal Generation and Delivery, P1003.1b-1993, p. 63
+    NOTE: P1003.1c/D10, p. 34 adds sigev_notify_function and
+          sigev_notify_attributes to the sigevent structure.  */
+
+union sigval {
+  int    sival_int;    /* Integer signal value */
+  void  *sival_ptr;    /* Pointer signal value */
+};
+
+struct sigevent {
+  int              sigev_notify;               /* Notification type */
+  int              sigev_signo;                /* Signal number */
+  union sigval     sigev_value;                /* Signal value */
+
+#if defined(_POSIX_THREADS)
+  void           (*sigev_notify_function)( union sigval );
+                                               /* Notification function */
+  pthread_attr_t  *sigev_notify_attributes;    /* Notification Attributes */
+#endif
+};
+
+/* Signal Actions, P1003.1b-1993, p. 64 */
+/* si_code values, p. 66 */
+
+#define SI_USER    1    /* Sent by a user. kill(), abort(), etc */
+#define SI_QUEUE   2    /* Sent by sigqueue() */
+#define SI_TIMER   3    /* Sent by expiration of a timer_settime() timer */
+#define SI_ASYNCIO 4    /* Indicates completion of asycnhronous IO */
+#define SI_MESGQ   5    /* Indicates arrival of a message at an empty queue */
+
+typedef struct {
+  int          si_signo;    /* Signal number */
+  int          si_code;     /* Cause of the signal */
+  union sigval si_value;    /* Signal value */
+} siginfo_t;
+
+#define SA_NOCLDSTOP      (1<<0)
+#define SA_RESETHAND      (1<<1)
+#define SA_SIGINFO        (1<<2)
+#define SA_NODEFER        (1<<3)
+#define SA_TRAMPOLINE     (1<<4)
+
+typedef void (*_sig_func_ptr)(int);
+
+struct sigaction 
+{
+	void (* sa_trampoline)(void);
+	sigset_t sa_mask;
+	int sa_flags;
+
+  union {
+    _sig_func_ptr _handler;  /* SIG_DFL, SIG_IGN, or pointer to a function */
+    void        (*_sigaction)( int, siginfo_t *, void * );
+  } _signal_handlers;
+};
+
+#define sa_handler    _signal_handlers._handler
+#define sa_sigaction  _signal_handlers._sigaction
+
+#endif /* defined(__CYGWIN__) */
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+/*
+ * Minimum and default signal stack constants. Allow for target overrides
+ * from <sys/features.h>.
+ */
+#ifndef	MINSIGSTKSZ
+#define	MINSIGSTKSZ	2048
+#endif
+#ifndef	SIGSTKSZ
+#define	SIGSTKSZ	8192
+#endif
+
+/*
+ * Possible values for ss_flags in stack_t below.
+ */
+#define	SS_ONSTACK	0x1
+#define	SS_DISABLE	0x2
+
+#endif
+
+/*
+ * Structure used in sigaltstack call.
+ */
+typedef struct sigaltstack {
+  void     *ss_sp;    /* Stack base or pointer.  */
+  int       ss_flags; /* Flags.  */
+  size_t    ss_size;  /* Stack size.  */
+} stack_t;
+
+#define SIG_SETMASK 0	/* set mask with sigprocmask() */
+#define SIG_BLOCK 1	/* set of signals to block */
+#define SIG_UNBLOCK 2	/* set of signals to, well, unblock */
+
+int sigprocmask (int, const sigset_t *, sigset_t *);
+
+#if __POSIX_VISIBLE >= 199506
+int pthread_sigmask (int, const sigset_t *, sigset_t *);
+#endif
+
+#ifdef _COMPILING_NEWLIB
+int _kill (pid_t, int);
+#endif /* _COMPILING_NEWLIB */
+
+int kill (pid_t, int);
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4
+int killpg (pid_t, int);
+#endif
+
+int sigaction (int, const struct sigaction *, struct sigaction *);
+int sigaddset (sigset_t *, const int);
+int sigdelset (sigset_t *, const int);
+int sigismember (const sigset_t *, int);
+int sigfillset (sigset_t *);
+int sigemptyset (sigset_t *);
+int sigpending (sigset_t *);
+int sigsuspend (const sigset_t *);
+int sigwait (const sigset_t *, int *);
+
+#if !defined(__CYGWIN__) && !defined(__rtems__)
+/* These depend upon the type of sigset_t, which right now 
+   is always a long.. They're in the POSIX namespace, but
+   are not ANSI. */
+#define sigaddset(what,sig) (*(what) |= (1<<(sig)), 0)
+#define sigdelset(what,sig) (*(what) &= ~(1<<(sig)), 0)
+#define sigemptyset(what)   (*(what) = 0, 0)
+#define sigfillset(what)    (*(what) = ~(0), 0)
+#define sigismember(what,sig) (((*(what)) & (1<<(sig))) != 0)
+#endif /* !__CYGWIN__ && !__rtems__ */
+
+/* There are two common sigpause variants, both of which take an int argument.
+   If you request _XOPEN_SOURCE or _GNU_SOURCE, you get the System V version,
+   which removes the given signal from the process's signal mask; otherwise
+   you get the BSD version, which sets the process's signal mask to the given
+   value. */
+#if __XSI_VISIBLE && !defined(__INSIDE_CYGWIN__)
+# ifdef __GNUC__
+int sigpause (int) __asm__ (__ASMNAME ("__xpg_sigpause"));
+# else
+int __xpg_sigpause (int);
+#  define sigpause __xpg_sigpause
+# endif
+#elif __BSD_VISIBLE
+int sigpause (int);
+#endif
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int sigaltstack (const stack_t *__restrict, stack_t *__restrict);
+#endif
+
+#if __POSIX_VISIBLE >= 199506
+int pthread_kill (pthread_t, int);
+#endif
+
+#if __POSIX_VISIBLE >= 199309
+
+/*  3.3.8 Synchronously Accept a Signal, P1003.1b-1993, p. 76
+    NOTE: P1003.1c/D10, p. 39 adds sigwait().  */
+
+int sigwaitinfo (const sigset_t *, siginfo_t *);
+int sigtimedwait (const sigset_t *, siginfo_t *, const struct timespec *);
+/*  3.3.9 Queue a Signal to a Process, P1003.1b-1993, p. 78 */
+int sigqueue (pid_t, int, const union sigval);
+
+#endif /* __POSIX_VISIBLE >= 199309 */
+
+#if defined(___AM29K__)
+/* These all need to be defined for ANSI C, but I don't think they are
+   meaningful.  */
+#define SIGABRT 1
+#define SIGFPE 1
+#define SIGILL 1
+#define SIGINT 1
+#define SIGSEGV 1
+#define SIGTERM 1
+/* These need to be defined for POSIX, and some others do too.  */
+#define SIGHUP 1
+#define SIGQUIT 1
+#define NSIG 2
+#elif defined(__GO32__)
+#define SIGINT  1
+#define SIGKILL 2
+#define SIGPIPE 3
+#define SIGFPE  4
+#define SIGHUP  5
+#define SIGTERM 6
+#define SIGSEGV 7
+#define SIGTSTP 8
+#define SIGQUIT 9
+#define SIGTRAP 10
+#define SIGILL  11
+#define SIGEMT  12
+#define SIGALRM 13
+#define SIGBUS  14
+#define SIGLOST 15
+#define SIGSTOP 16
+#define SIGABRT 17
+#define SIGUSR1	18
+#define SIGUSR2	19
+#define NSIG    20
+#elif !defined(SIGTRAP)
+#define	SIGHUP	1	/* hangup */
+#define	SIGINT	2	/* interrupt */
+#define	SIGQUIT	3	/* quit */
+#define	SIGILL	4	/* illegal instruction (not reset when caught) */
+#define	SIGTRAP	5	/* trace trap (not reset when caught) */
+#define	SIGIOT	6	/* IOT instruction */
+#define	SIGABRT 6	/* used by abort, replace SIGIOT in the future */
+#define	SIGEMT	7	/* EMT instruction */
+#define	SIGFPE	8	/* floating point exception */
+#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
+#define	SIGBUS	10	/* bus error */
+#define	SIGSEGV	11	/* segmentation violation */
+#define	SIGSYS	12	/* bad argument to system call */
+#define	SIGPIPE	13	/* write on a pipe with no one to read it */
+#define	SIGALRM	14	/* alarm clock */
+#define	SIGTERM	15	/* software termination signal from kill */
+
+#if defined(__rtems__)
+#define	SIGURG	16	/* urgent condition on IO channel */
+#define	SIGSTOP	17	/* sendable stop signal not from tty */
+#define	SIGTSTP	18	/* stop signal from tty */
+#define	SIGCONT	19	/* continue a stopped process */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define	SIGCLD	20	/* System V name for SIGCHLD */
+#define	SIGTTIN	21	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define	SIGIO	23	/* input/output possible signal */
+#define	SIGPOLL	SIGIO	/* System V name for SIGIO */
+#define	SIGWINCH 24	/* window changed */
+#define	SIGUSR1 25	/* user defined signal 1 */
+#define	SIGUSR2 26	/* user defined signal 2 */
+
+/* Real-Time Signals Range, P1003.1b-1993, p. 61
+   NOTE: By P1003.1b-1993, this should be at least RTSIG_MAX
+         (which is a minimum of 8) signals.
+ */
+#define SIGRTMIN 27
+#define SIGRTMAX 31
+#define __SIGFIRSTNOTRT SIGHUP
+#define __SIGLASTNOTRT  SIGUSR2
+
+#define NSIG	32      /* signal 0 implied */
+
+#elif defined(__svr4__)
+/* svr4 specifics. different signals above 15, and sigaction. */
+#define	SIGUSR1	16
+#define SIGUSR2	17
+#define SIGCLD	18
+#define	SIGPWR	19
+#define SIGWINCH 20
+#define	SIGPOLL	22	/* 20 for x.out binaries!!!! */
+#define	SIGSTOP	23	/* sendable stop signal not from tty */
+#define	SIGTSTP	24	/* stop signal from tty */
+#define	SIGCONT	25	/* continue a stopped process */
+#define	SIGTTIN	26	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	27	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define NSIG	28	
+#else
+#define	SIGURG	16	/* urgent condition on IO channel */
+#define	SIGSTOP	17	/* sendable stop signal not from tty */
+#define	SIGTSTP	18	/* stop signal from tty */
+#define	SIGCONT	19	/* continue a stopped process */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define	SIGCLD	20	/* System V name for SIGCHLD */
+#define	SIGTTIN	21	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define	SIGIO	23	/* input/output possible signal */
+#define	SIGPOLL	SIGIO	/* System V name for SIGIO */
+#define	SIGXCPU	24	/* exceeded CPU time limit */
+#define	SIGXFSZ	25	/* exceeded file size limit */
+#define	SIGVTALRM 26	/* virtual time alarm */
+#define	SIGPROF	27	/* profiling time alarm */
+#define	SIGWINCH 28	/* window changed */
+#define	SIGLOST 29	/* resource lost (eg, record-lock lost) */
+#define	SIGUSR1 30	/* user defined signal 1 */
+#define	SIGUSR2 31	/* user defined signal 2 */
+#define NSIG	32      /* signal 0 implied */
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(__CYGWIN__)
+#if __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+#include <sys/ucontext.h>
+#endif
+#endif
+
+#ifndef _SIGNAL_H_
+/* Some applications take advantage of the fact that <sys/signal.h>
+ * and <signal.h> are equivalent in glibc.  Allow for that here.  */
+#include <signal.h>
+#endif
+#endif /* _SYS_SIGNAL_H */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h
@@ -0,0 +1,187 @@
+#ifndef	_SYS_STAT_H
+#define	_SYS_STAT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <time.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/_timespec.h>
+
+/* dj's stat defines _STAT_H_ */
+#ifndef _STAT_H_
+
+/* It is intended that the layout of this structure not change when the
+   sizes of any of the basic types change (short, int, long) [via a compile
+   time option].  */
+
+#ifdef __CYGWIN__
+#include <cygwin/stat.h>
+#ifdef _COMPILING_NEWLIB
+#define stat64 stat
+#endif
+#else
+struct	stat 
+{
+  dev_t		st_dev;
+  ino_t		st_ino;
+  mode_t	st_mode;
+  nlink_t	st_nlink;
+  uid_t		st_uid;
+  gid_t		st_gid;
+  dev_t		st_rdev;
+  off_t		st_size;
+#if defined(__svr4__) && !defined(__PPC__) && !defined(__sun__)
+  time_t	st_atime;
+  time_t	st_mtime;
+  time_t	st_ctime;
+#else
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+  blksize_t     st_blksize;
+  blkcnt_t	st_blocks;
+#if !defined(__rtems__)
+  long		st_spare4[2];
+#endif
+#endif
+};
+
+#if !(defined(__svr4__) && !defined(__PPC__) && !defined(__sun__)) && !defined(__cris__)
+#define st_atime st_atim.tv_sec
+#define st_ctime st_ctim.tv_sec
+#define st_mtime st_mtim.tv_sec
+#endif
+
+#endif
+
+#define	_IFMT		0170000	/* type of file */
+#define		_IFDIR	0040000	/* directory */
+#define		_IFCHR	0020000	/* character special */
+#define		_IFBLK	0060000	/* block special */
+#define		_IFREG	0100000	/* regular */
+#define		_IFLNK	0120000	/* symbolic link */
+#define		_IFSOCK	0140000	/* socket */
+#define		_IFIFO	0010000	/* fifo */
+#define		_IFPORT	0160000	/* message port */
+#define		_IFIRQ	0150000	/* interrupt */
+
+#define 	S_BLKSIZE  1024 /* size of a block */
+
+#define	S_ISUID		0004000	/* set user id on execution */
+#define	S_ISGID		0002000	/* set group id on execution */
+#define	S_ISVTX		0001000	/* save swapped text even after use */
+#if __BSD_VISIBLE
+#define	S_IREAD		0000400	/* read permission, owner */
+#define	S_IWRITE 	0000200	/* write permission, owner */
+#define	S_IEXEC		0000100	/* execute/search permission, owner */
+#define	S_ENFMT 	0002000	/* enforcement-mode locking */
+#endif	/* !_BSD_VISIBLE */
+
+#define	S_IFMT		_IFMT
+#define	S_IFDIR		_IFDIR
+#define	S_IFCHR		_IFCHR
+#define	S_IFBLK		_IFBLK
+#define	S_IFREG		_IFREG
+#define	S_IFLNK		_IFLNK
+#define	S_IFSOCK	_IFSOCK
+#define	S_IFIFO		_IFIFO
+#define	S_IFPORT  _IFPORT /* message port */
+#define	S_IFIRQ	  _IFIRQ  /* interrupt */
+
+
+#ifdef _WIN32
+/* The Windows header files define _S_ forms of these, so we do too
+   for easier portability.  */
+#define _S_IFMT		_IFMT
+#define _S_IFDIR	_IFDIR
+#define _S_IFCHR	_IFCHR
+#define _S_IFIFO	_IFIFO
+#define _S_IFREG	_IFREG
+#define _S_IREAD	0000400
+#define _S_IWRITE	0000200
+#define _S_IEXEC	0000100
+#endif
+
+#define	S_IRWXU 	(S_IRUSR | S_IWUSR | S_IXUSR)
+#define		S_IRUSR	0000400	/* read permission, owner */
+#define		S_IWUSR	0000200	/* write permission, owner */
+#define		S_IXUSR 0000100/* execute/search permission, owner */
+#define	S_IRWXG		(S_IRGRP | S_IWGRP | S_IXGRP)
+#define		S_IRGRP	0000040	/* read permission, group */
+#define		S_IWGRP	0000020	/* write permission, grougroup */
+#define		S_IXGRP 0000010/* execute/search permission, group */
+#define	S_IRWXO		(S_IROTH | S_IWOTH | S_IXOTH)
+#define		S_IROTH	0000004	/* read permission, other */
+#define		S_IWOTH	0000002	/* write permission, other */
+#define		S_IXOTH 0000001/* execute/search permission, other */
+
+#if __BSD_VISIBLE
+#define ACCESSPERMS (S_IRWXU | S_IRWXG | S_IRWXO) /* 0777 */
+#define ALLPERMS (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO) /* 07777 */
+#define DEFFILEMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) /* 0666 */
+#endif
+
+#define	S_ISBLK(m)	(((m)&_IFMT) == _IFBLK)
+#define	S_ISCHR(m)	(((m)&_IFMT) == _IFCHR)
+#define	S_ISDIR(m)	(((m)&_IFMT) == _IFDIR)
+#define	S_ISFIFO(m)	(((m)&_IFMT) == _IFIFO)
+#define	S_ISREG(m)	(((m)&_IFMT) == _IFREG)
+#define	S_ISLNK(m)	(((m)&_IFMT) == _IFLNK)
+#define	S_ISSOCK(m)	(((m)&_IFMT) == _IFSOCK)
+#define	S_ISPORT(m)	(((m)&_IFMT) == _IFPORT)
+#define	S_ISIRQ(m)	(((m)&_IFMT) == _IFIRQ)
+
+
+#if defined(__CYGWIN__)
+/* Special tv_nsec values for futimens(2) and utimensat(2). */
+#define UTIME_NOW	-2L
+#define UTIME_OMIT	-1L
+#endif
+
+int	chmod (const char *__path, mode_t __mode );
+int     fchmod (int __fd, mode_t __mode);
+int	fstat (int __fd, struct stat *__sbuf );
+int	mkdir (const char *_path, mode_t __mode );
+int	mkfifo (const char *__path, mode_t __mode );
+int	stat (const char *__restrict __path, struct stat *__restrict __sbuf );
+mode_t	umask (mode_t __mask );
+
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
+int	lstat (const char *__restrict __path, struct stat *__restrict __buf );
+int	mknod (const char *__path, mode_t __mode, dev_t __dev );
+#endif
+
+#if __ATFILE_VISIBLE && !defined(__INSIDE_CYGWIN__)
+int	fchmodat (int, const char *, mode_t, int);
+int	fstatat (int, const char *__restrict , struct stat *__restrict, int);
+int	mkdirat (int, const char *, mode_t);
+int	mkfifoat (int, const char *, mode_t);
+int	mknodat (int, const char *, mode_t, dev_t);
+int	utimensat (int, const char *, const struct timespec *, int);
+#endif
+#if __POSIX_VISIBLE >= 200809 && !defined(__INSIDE_CYGWIN__)
+int	futimens (int, const struct timespec *);
+#endif
+
+/* Provide prototypes for most of the _<systemcall> names that are
+   provided in newlib for some compilers.  */
+#ifdef _COMPILING_NEWLIB
+int	_fstat (int __fd, struct stat *__sbuf );
+int	_stat (const char *__restrict __path, struct stat *__restrict __sbuf );
+int	_mkdir (const char *_path, mode_t __mode );
+#ifdef __LARGE64_FILES
+struct stat64;
+int	_stat64 (const char *__restrict __path, struct stat64 *__restrict __sbuf );
+int	_fstat64 (int __fd, struct stat64 *__sbuf );
+#endif
+#endif
+
+#endif /* !_STAT_H_ */
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STAT_H */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h
@@ -0,0 +1,56 @@
+#ifndef	_SYS_STATVFS_H
+#define	_SYS_STATVFS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <time.h>
+#include <sys/types.h>
+
+
+struct statvfs 
+{
+  int f_type;
+  char *f_mntfromname;
+  char *f_mntonname;  
+	unsigned long f_bsize;    /* File system block size */
+	unsigned long f_frsize;   /* Fundamental file system block size */
+	fsblkcnt_t    f_blocks;   /* Num blocks in units of f_frsize */
+	fsblkcnt_t    f_bfree;    /* Num free blocks */
+	fsblkcnt_t    f_bavail;   /* Num free blocks for non-privileged process */
+	fsfilcnt_t    f_files;    /* Total number of file serial numbers */ 
+	fsfilcnt_t    f_ffree;    /* Total number of free file serial numbers */ 
+	fsfilcnt_t    f_favail;   /* ... for non-privileged process */ 
+	unsigned long f_fsid;     /* File system ID */ 
+	unsigned long f_flag;     /* Bit mask of f_flag values */  
+	unsigned long f_namemax ; /* Maximum filename length */ 
+};
+
+
+struct statfs 
+{
+  int f_type;
+  char *f_mntfromname;
+  char *f_mntonname;  
+	unsigned long f_bsize;    /* File system block size */
+	unsigned long f_frsize;   /* Fundamental file system block size */
+	fsblkcnt_t    f_blocks;   /* Num blocks in units of f_frsize */
+	fsblkcnt_t    f_bfree;    /* Num free blocks */
+	fsblkcnt_t    f_bavail;   /* Num free blocks for non-privileged process */
+	fsfilcnt_t    f_files;    /* Total number of file serial numbers */ 
+	fsfilcnt_t    f_ffree;    /* Total number of free file serial numbers */ 
+	fsfilcnt_t    f_favail;   /* ... for non-privileged process */ 
+	unsigned long f_fsid;     /* File system ID */ 
+	unsigned long f_flag;     /* Bit mask of f_flag values */  
+	unsigned long f_namemax ; /* Maximum filename length */ 
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STATVFS_H */
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h
@@ -0,0 +1,184 @@
+#ifndef _SYS_KSYSCALLS_H
+#define _SYS_KSYSCALLS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/execargs.h>
+#include <sys/signal.h>
+#include <poll.h>
+
+
+typedef signed char 		int8;
+typedef unsigned char 		uint8;
+typedef signed short		int16;
+typedef unsigned short		uint16;
+typedef signed long			int32;
+typedef unsigned long		uint32;
+typedef signed long long 	int64;
+typedef unsigned long long 	uint64;
+typedef signed long			err32;
+typedef uint32_t				vm_offset;
+typedef uint32_t				vm_size;
+typedef unsigned char		bits8_t;
+typedef unsigned short		bits16_t;
+typedef unsigned long		bits32_t;
+typedef long long			uuid_t;
+
+
+
+/*
+ * Exit()/Join() Status
+ */
+#define EXIT_OK                 0
+#define EXIT_ERROR              1
+#define EXIT_FATAL              2
+#define EXIT_KILLED             3
+
+
+/*
+ * Time related structures
+ */
+struct TimeVal
+{
+	long long seconds;
+	long microseconds;
+};
+
+
+struct InterruptAPI;
+
+
+/*
+ * Timer types
+ */
+#define TIMER_TYPE_RELATIVE     0
+#define TIMER_TYPE_ABSOLUTE     1
+
+
+/*
+ * VirtualAlloc() protections
+ */
+#define PROT_NONE			    0
+#define PROT_READ			    (1<<0)
+#define PROT_WRITE			    (1<<1)
+#define PROT_EXEC			    (1<<2)
+#define PROT_ALL			    (PROT_READ | PROT_WRITE | PROT_EXEC)
+#define PROT_READWRITE 		    (PROT_READ | PROT_WRITE)
+#define PROT_READEXEC		    (PROT_READ | PROT_EXEC)
+
+#define MAP_FIXED				(1<<3)
+#define MAP_WIRED				(1<<4)
+#define MAP_NOX64				(1<<5)
+#define MAP_BELOW16M			(1<<6)
+#define MAP_BELOW4G				(1<<7)
+
+#define CACHE_DEFAULT	 		(0<<8)
+#define CACHE_WRITEBACK	 		(1<<8)
+#define CACHE_WRITETHRU	 		(2<<8)
+#define CACHE_WRITECOMBINE 		(3<<8)
+#define CACHE_UNCACHEABLE  		(4<<8)
+#define CACHE_WEAKUNCACHEABLE	(5<<8)
+#define CACHE_WRITEPROTECT		(6<<8)
+
+#define PROT_MASK				0x00000007
+#define CACHE_MASK   		0x00000f00
+
+
+
+struct stat;
+
+/*
+ * System call prototypes
+ */
+
+void Debug (char *str);
+
+int Fork (void);
+int Exec (char *filename, struct execargs *args);
+void Exit (int status);
+int WaitPid (int pid, int *loc_stat, int options);
+int Kill (int pid, int sig);
+int SetSchedParams (int policy, int priority);
+int GetSystemTime (struct TimeVal *tv);
+
+void *VirtualAlloc (void *addr, size_t size, bits32_t flags);
+void *VirtualAllocPhys (void *addr, size_t size, bits32_t flags, void *phys_addr);
+int VirtualFree (void *addr, size_t sz);
+int VirtualProtect (void *addr, size_t sz, bits32_t flags);
+void *VirtualToPhysAddr(void *addr);
+
+int Close (int handle);
+
+int CreateTimer (void);
+int SetTimer (int handle, int type, struct TimeVal *tv);
+
+int CreateInterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api));
+int MaskInterrupt (int irq);
+int UnmaskInterrupt (int irq);
+
+int Sleep(int seconds);
+
+int OpenDir(const char *path);
+ssize_t GetDirents (int fd, void *buf, size_t buf_sz);
+int RewindDir (int fd);
+
+off_t Seek(int fd, off_t offs, int whence);
+off64_t Seek64(int fd, off64_t *offs, int whence);
+
+int PivotRoot(char *new_root, char *old_root);
+
+int WaitSignals(uint32_t sigmask);
+
+int ReceiveMsg(int fd, int *ino, void *buf, size_t buf_sz);
+int ReplyMsg(int fd, int ino, int status);
+int ReadMsg(int fd, int ino, void *buf, size_t buf_sz);
+int WriteMsg(int fd, int ino, void *buf, size_t buf_sz);
+int SeekMsg(int fd, int ino, off_t offset);
+
+int ReadStream(int fd, int ino, void *buf, size_t buf_sz);
+int WriteStream(int fd, int ino, void *buf, size_t buf_sz);
+
+int Stat(char *path, struct stat *stat);
+int FStat(int fd, struct stat *stat);
+
+int Poll(struct pollfd *pfds, nfds_t nfds, int timeout);
+
+int SignalNotify(int fd, int ino, int signal);
+int PollNotify(int fd, int ino, short events);
+
+int Chdir(char *path);
+int FChDir(int fd);
+
+int Fcntl(int fd, int cmd, int arg);
+int IsATTY(int fd);
+
+int Fsync(int fd);
+int Sync(void);
+int Chmod(char *_path, mode_t mode);
+int Chown(char *_path, uid_t uid, gid_t gid);
+
+int SymLink(char *_path, char *_link);
+int ReadLink(char *_path, char *_link, size_t link_size);
+
+int Ioctl(int fd, int cmd, void *arg);
+
+int SigProcMask(int how, const sigset_t *set, sigset_t *oset);
+int sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
+int sigpending(sigset_t *set);
+int sigsuspend(const sigset_t *set);
+
+int MkNod(char *_path, uint32_t flags, struct stat *stat);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h
@@ -0,0 +1,47 @@
+/* "sys/syslimits.h"
+ * 
+ * Values in this file should match those in "limits.h"
+ */
+ 
+#ifndef _SYS_SYSLIMITS_H_
+#define _SYS_SYSLIMITS_H_
+
+
+
+
+/*
+ * Might be useful to make them match limits.h
+ */
+
+#define	ARG_MAX			 4096
+
+#ifndef CHILD_MAX
+#define	CHILD_MAX		    6
+#endif
+
+#define	LINK_MAX		    8
+#define	MAX_CANON		  255
+#define	MAX_INPUT		  255
+#define	NAME_MAX		  255
+#define	NGROUPS_MAX		   16
+
+#ifndef OPEN_MAX
+#define	OPEN_MAX		   64
+#endif
+
+#define	PATH_MAX		 1024
+#define	PIPE_BUF		  512
+#define	IOV_MAX			 1024
+#define	BC_BASE_MAX		   99
+#define	BC_DIM_MAX		 2048
+#define	BC_SCALE_MAX	   99
+#define	BC_STRING_MAX	 1000
+#define	COLL_WEIGHTS_MAX    0
+#define	EXPR_NEST_MAX	   32
+#define	LINE_MAX		 2048
+#define	RE_DUP_MAX		  255
+
+
+
+
+#endif /* !_SYS_SYSLIMITS_H_ */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h
@@ -0,0 +1,245 @@
+/* termios.h
+ *
+ * termios.h is identical to /sys/termios.h.  Some applications appear to use
+ * different source directories, so this file exists in both directories.
+ */
+
+#ifndef _SYS_TERMIOS_H_
+#define _SYS_TERMIOS_H_
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+
+
+
+
+/*
+ * Control Characters in termios.c_cc[]
+ */
+ 
+#define	VEOF		0
+#define	VEOL		1
+#define	VEOL2		2
+#define	VERASE		3
+#define VWERASE 	4
+#define VKILL		5
+#define	VREPRINT 	6
+#define VINTR		8
+#define VQUIT		9
+#define VSUSP		10
+#define VDSUSP		11
+#define VSTART		12
+#define VSTOP		13
+#define	VLNEXT		14
+#define	VDISCARD	15
+#define VMIN		16
+#define VTIME		17
+#define VSTATUS		18
+#define	NCCS		20
+
+
+
+
+/*
+ * Input flags
+ */
+
+#define	IGNBRK		0x00000001
+#define	BRKINT		0x00000002
+#define	IGNPAR		0x00000004
+#define	PARMRK		0x00000008
+#define	INPCK		0x00000010
+#define	ISTRIP		0x00000020
+#define	INLCR		0x00000040
+#define	IGNCR		0x00000080
+#define	ICRNL		0x00000100
+#define	IXON		0x00000200
+#define	IXOFF		0x00000400
+#define	IXANY		0x00000800
+#define IMAXBEL		0x00002000
+
+
+
+
+/*
+ * Output flags
+ */
+
+#define	OPOST		0x00000001
+#define ONLCR		0x00000002
+#define OXTABS		0x00000004
+#define ONOEOT		0x00000008
+#define OCRNL		0x00000010
+#define ONOCR		0x00000020
+#define ONLRET		0x00000040
+
+
+
+
+/*
+ * Control flags - hardware control of terminal
+ */
+
+#define	CIGNORE		0x00000001
+#define CSIZE		0x00000300
+#define CS5		    0x00000000
+#define CS6		    0x00000100
+#define CS7		    0x00000200
+#define CS8		    0x00000300
+#define CSTOPB		0x00000400
+#define CREAD		0x00000800
+#define PARENB		0x00001000
+#define PARODD		0x00002000
+#define HUPCL		0x00004000
+#define CLOCAL		0x00008000
+#define	CRTSCTS		0x00010000
+#define	CRTS_IFLOW	CRTSCTS
+#define	CCTS_OFLOW	CRTSCTS
+#define	CDTRCTS		0x00020000
+#define	MDMBUF		0x00100000
+#define	CHWFLOW		(MDMBUF|CRTSCTS|CDTRCTS)
+
+
+
+
+/*
+ * Local flags 
+ */
+
+#define	ECHOKE		0x00000001
+#define	ECHOE		0x00000002
+#define	ECHOK		0x00000004
+#define ECHO		0x00000008
+#define	ECHONL		0x00000010
+#define	ECHOPRT		0x00000020
+#define ECHOCTL  	0x00000040
+#define	ISIG		0x00000080
+#define	ICANON		0x00000100
+#define ALTWERASE	0x00000200
+#define	IEXTEN		0x00000400
+#define EXTPROC     0x00000800
+#define TOSTOP		0x00400000
+#define FLUSHO		0x00800000
+#define	NOKERNINFO	0x02000000
+#define PENDIN		0x20000000
+#define	NOFLSH		0x80000000
+
+
+
+
+/*
+ * struct termios and types
+ */
+
+typedef unsigned int	tcflag_t;
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+
+struct termios
+{
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t     c_cc[NCCS];
+	int      c_ispeed;
+	int      c_ospeed;
+};
+
+
+
+
+/*
+ * tcsetattr() action commands
+ */
+ 
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+#define TCSASOFT	0x10
+
+
+
+
+/*
+ * Standard speeds
+ */
+
+#define B0	0
+#define B50	50
+#define B75	75
+#define B110	110
+#define B134	134
+#define B150	150
+#define B200	200
+#define B300	300
+#define B600	600
+#define B1200	1200
+#define	B1800	1800
+#define B2400	2400
+#define B4800	4800
+#define B9600	9600
+#define B19200	19200
+#define B38400	38400
+#define B7200	7200
+#define B14400	14400
+#define B28800	28800
+#define B57600	57600
+#define B76800	76800
+#define B115200	115200
+#define B230400	230400
+#define EXTA	19200
+#define EXTB	38400
+
+
+/*
+ * Line Control
+ */
+
+#define	TCIFLUSH	1
+#define	TCOFLUSH	2
+#define TCIOFLUSH	3
+#define	TCOOFF		1
+#define	TCOON		2
+#define TCIOFF		3
+#define TCION		4
+
+
+/*
+ * Ioctls
+ */
+ 
+#define TCSETS      (('T'<<8) | 1)
+#define TCSETSW     (('T'<<8) | 2)
+#define TCSETSF     (('T'<<8) | 3)
+#define TCGETS      (('T'<<8) | 4)
+
+#define TIOCGPGRP   (('T'<<8) | 5)
+#define TIOCSPGRP   (('T'<<8) | 6)
+#define TCXONC      (('T'<<8) | 7)
+#define TCFLSH      (('T'<<8) | 8)
+
+
+/*
+ * Prototypes
+ */
+
+int	cfsetispeed (struct termios *termios_p, speed_t speed);
+int	cfsetospeed (struct termios *termios_p, speed_t speed);
+int	tcgetattr (int fd, struct termios *termios_p);
+int	tcsetattr (int fd, int actions, const struct termios *termios_p);
+int	tcdrain (int fd);
+int	tcflow (int fd, int actions);
+int	tcflush (int fd, int queue_sel);
+int	tcsendbreak (int fd, int duration);
+pid_t tcgetsid (int fd);
+speed_t	cfgetispeed (const struct termios *termios_p);
+speed_t	cfgetospeed (const struct termios *termios_p);
+void cfmakeraw (struct termios *termios_p);
+int	cfsetspeed (struct termios *termios_p, speed_t speed);
+
+
+
+
+#endif /* !_SYS_TERMIOS_H_ */
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h
@@ -0,0 +1,32 @@
+/*
+ *  $Id: utime.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef __UTIME_h__
+#define __UTIME_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *  POSIX 1003.1b 5.6.6 Set File Access and Modification Times
+ */
+
+struct utimbuf {
+  time_t  actime;   /* Access time */
+  time_t  modtime;  /* Modification time */
+};
+
+/* Functions */
+
+int utime(
+  const char           *path,
+  const struct utimbuf *times
+);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _SYS_UTIME_H */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/syscall.S third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/syscall.S
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/syscall.S
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/syscall.S
@@ -0,0 +1,122 @@
+.extern __real_set_errno
+
+.text
+
+#define SYSCALL0(name, idx)     \
+.global name;                   \
+name:;                          \
+    swi idx;                    \
+    bx lr;
+
+#define SYSCALL1 SYSCALL0
+#define SYSCALL2 SYSCALL0
+#define SYSCALL3 SYSCALL0
+#define SYSCALL4 SYSCALL0
+
+SYSCALL1( Debug, 1)
+SYSCALL1( Fork, 2)
+SYSCALL1( Exit, 3)
+SYSCALL3( WaitPid, 4)
+SYSCALL0( Kill, 5)
+SYSCALL2( SetSchedParams, 6)
+
+SYSCALL1( Sleep, 7)
+SYSCALL1( Alarm, 8)
+SYSCALL2( SetTimer, 9)
+SYSCALL0( GetTimeOfDay, 10)
+SYSCALL1( SetTimeOfDay, 11)
+
+SYSCALL3( VirtualAlloc, 12)
+SYSCALL4( VirtualAllocPhys, 13)
+SYSCALL2( VirtualFree, 14)
+SYSCALL2( VirtualProtect, 15)
+
+SYSCALL1( CreateInterrupt, 16)
+SYSCALL1( MaskInterrupt, 17)
+SYSCALL1( UnmaskInterrupt, 18)
+
+SYSCALL3( Poll, 19)
+
+SYSCALL2( Exec, 20)
+
+SYSCALL4( Mount, 21)
+SYSCALL1( Unmount, 22)
+
+SYSCALL3( SeekMsg, 23)
+
+SYSCALL4( ReceiveMsg, 24)
+SYSCALL3( ReplyMsg, 25)
+SYSCALL4( ReadMsg, 26)
+SYSCALL4( WriteMsg, 27)
+
+SYSCALL3( Open, 28)
+SYSCALL1( Close, 29)
+SYSCALL1( Dup, 30)
+SYSCALL1( Dup2, 31)
+
+SYSCALL3( Read, 32)
+SYSCALL3( Write, 33)
+SYSCALL3( Seek, 34)
+SYSCALL3( Seek64, 35)
+
+SYSCALL2( Truncate, 36)
+SYSCALL1( Unlink, 37)
+
+SYSCALL2( MkDir, 38)
+SYSCALL1( OpenDir, 39)
+SYSCALL3( ReadDir, 40)
+SYSCALL1( RewindDir, 41)
+SYSCALL1( RmDir, 42)
+
+SYSCALL2( Rename, 43)
+
+SYSCALL1( Pipe, 44)
+SYSCALL1( SocketPair, 45)
+
+SYSCALL1( ChDir, 46)
+SYSCALL1( FChDir, 47)
+
+SYSCALL2( Stat, 48)
+SYSCALL2( Fstat, 49)
+    
+SYSCALL2( SymLink, 50)
+SYSCALL2( ReadLink, 51)
+
+SYSCALL2 ( Chmod, 52)
+SYSCALL2 ( Chown, 53)
+SYSCALL2 ( Access, 54)
+SYSCALL1 ( Umask, 55)
+
+SYSCALL0 (GetPID, 56)
+SYSCALL0 (GetPPID, 57)
+SYSCALL0 (GetUID, 58)
+SYSCALL0 (GetGID, 59)
+SYSCALL0 (GetEUID, 60)
+SYSCALL0 (GetEGID, 61)
+SYSCALL1 (SetUID, 62)
+SYSCALL1 (SetGID, 63)
+
+SYSCALL0 (SetPGRP, 64)
+SYSCALL0 (GetPGRP, 65)
+
+SYSCALL1 (VirtualToPhysAddr, 66)
+
+SYSCALL3 (SignalNotify, 67)
+
+SYSCALL3 (PollNotify, 68)
+
+SYSCALL2( PivotRoot, 69)
+
+SYSCALL3( Fcntl, 70)
+SYSCALL1( IsATTY, 71)
+SYSCALL3( Ioctl, 72)
+
+SYSCALL0( Sync, 73)
+SYSCALL1( Fsync, 74)
+
+SYSCALL3( SigAction, 75)
+SYSCALL3( SigProcMask, 76)
+SYSCALL1( SigPending, 77)
+SYSCALL1( SigSuspend, 78)
+SYSCALL3( MkNod, 79)
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c
@@ -1,716 +0,0 @@
-/* Support files for GNU libc.  Files in the system namespace go here.
-   Files in the C namespace (ie those that do not start with an
-   underscore) go in .c.  */
-
-#include <_ansi.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/fcntl.h>
-#include <stdio.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/times.h>
-#include <errno.h>
-#include <reent.h>
-#include <signal.h>
-#include <unistd.h>
-#include <sys/wait.h>
-#include "swi.h"
-
-/* Forward prototypes.  */
-int	_system		(const char *);
-int	_rename		(const char *, const char *);
-int	_isatty		(int);
-clock_t _times		(struct tms *);
-int	_gettimeofday	(struct timeval *, void *);
-void	_raise		(void);
-int	_unlink		(const char *);
-int	_link		(const char *, const char *);
-int	_stat		(const char *, struct stat *);
-int	_fstat		(int, struct stat *);
-void *	_sbrk		(ptrdiff_t);
-pid_t	_getpid		(void);
-int	_kill		(int, int);
-void	_exit		(int);
-int	_close		(int);
-int	_swiclose	(int);
-int	_open		(const char *, int, ...);
-int	_swiopen	(const char *, int);
-int	_write		(int, const void *, size_t);
-int	_swiwrite	(int, const void *, size_t);
-_off_t	_lseek		(int, _off_t, int);
-_off_t	_swilseek	(int, _off_t, int);
-int	_read		(int, void *, size_t);
-int	_swiread	(int, void *, size_t);
-void	initialise_monitor_handles (void);
-
-static int	wrap		(int);
-static int	error		(int);
-static int	get_errno	(void);
-static int	remap_handle	(int);
-static int	findslot	(int);
-static int	_kill_shared	(int, int, int) __attribute__((__noreturn__));
-
-/* Register name faking - works in collusion with the linker.  */
-register char * stack_ptr asm ("sp");
-
-
-/* following is copied from libc/stdio/local.h to check std streams */
-extern void   __sinit (struct _reent *);
-#define CHECK_INIT(ptr) \
-  do						\
-    {						\
-      if ((ptr) && !(ptr)->__sdidinit)		\
-	__sinit (ptr);				\
-    }						\
-  while (0)
-
-/* Adjust our internal handles to stay away from std* handles.  */
-#define FILE_HANDLE_OFFSET (0x20)
-
-static int monitor_stdin;
-static int monitor_stdout;
-static int monitor_stderr;
-
-/* Struct used to keep track of the file position, just so we
-   can implement fseek(fh,x,SEEK_CUR).  */
-typedef struct
-{
-  int handle;
-  off_t pos;
-}
-poslog;
-
-#define MAX_OPEN_FILES 20
-static poslog openfiles [MAX_OPEN_FILES];
-
-static int
-findslot (int fh)
-{
-  int i;
-  for (i = 0; i < MAX_OPEN_FILES; i ++)
-    if (openfiles[i].handle == fh)
-      break;
-  return i;
-}
-
-/* Function to convert std(in|out|err) handles to internal versions.  */
-static int
-remap_handle (int fh)
-{
-  CHECK_INIT(_REENT);
-
-  if (fh == STDIN_FILENO)
-    return monitor_stdin;
-  if (fh == STDOUT_FILENO)
-    return monitor_stdout;
-  if (fh == STDERR_FILENO)
-    return monitor_stderr;
-
-  return fh - FILE_HANDLE_OFFSET;
-}
-
-void
-initialise_monitor_handles (void)
-{
-  int i;
-  
-  /* Open the standard file descriptors by opening the special
-   * teletype device, ":tt", read-only to obtain a descriptor for
-   * standard input and write-only to obtain a descriptor for standard
-   * output. Finally, open ":tt" in append mode to obtain a descriptor
-   * for standard error. Since this is a write mode, most kernels will
-   * probably return the same value as for standard output, but the
-   * kernel can differentiate the two using the mode flag and return a
-   * different descriptor for standard error.
-   */
-
-#ifdef ARM_RDI_MONITOR
-  int volatile block[3];
-
-  block[0] = (int) ":tt";
-  block[2] = 3;     /* length of filename */
-  block[1] = 0;     /* mode "r" */
-  monitor_stdin = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
-
-  block[0] = (int) ":tt";
-  block[2] = 3;     /* length of filename */
-  block[1] = 4;     /* mode "w" */
-  monitor_stdout = monitor_stderr
-    = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
-#else
-  int fh;
-  const char * name;
-
-  name = ":tt";
-  asm ("mov r0,%2; mov r1, #0; swi %a1; mov %0, r0"
-       : "=r"(fh)
-       : "i" (SWI_Open),"r"(name)
-       : "r0","r1");
-  monitor_stdin = fh;
-
-  name = ":tt";
-  asm ("mov r0,%2; mov r1, #4; swi %a1; mov %0, r0"
-       : "=r"(fh)
-       : "i" (SWI_Open),"r"(name)
-       : "r0","r1");
-  monitor_stdout = monitor_stderr = fh;
-#endif
-
-  for (i = 0; i < MAX_OPEN_FILES; i ++)
-    openfiles[i].handle = -1;
-
-  openfiles[0].handle = monitor_stdin;
-  openfiles[0].pos = 0;
-  openfiles[1].handle = monitor_stdout;
-  openfiles[1].pos = 0;
-}
-
-static int
-get_errno (void)
-{
-#ifdef ARM_RDI_MONITOR
-  return do_AngelSWI (AngelSWI_Reason_Errno, NULL);
-#else
-  register int r0 asm("r0");
-  asm ("swi %a1" : "=r"(r0) : "i" (SWI_GetErrno));
-  return r0;
-#endif
-}
-
-/* Set errno and return result. */
-static int
-error (int result)
-{
-  errno = get_errno ();
-  return result;
-}
-
-static int
-wrap (int result)
-{
-  if (result == -1)
-    return error (-1);
-  return result;
-}
-
-/* file, is a valid user file handle.
-   ptr, is a null terminated string.
-   len, is the length in bytes to read. 
-   Returns the number of bytes *not* written. */
-int
-_swiread (int file, void * ptr, size_t len)
-{
-  int fh = remap_handle (file);
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-
-  block[0] = fh;
-  block[1] = (int) ptr;
-  block[2] = (int) len;
-
-  return do_AngelSWI (AngelSWI_Reason_Read, block);
-#else
-  register int r0 asm("r0") = fh;
-  register int r1 asm("r1") = (int) ptr;
-  register int r2 asm("r2") = (int) len;
-  asm ("swi %a4"
-       : "=r" (r0)
-       : "0"(r0), "r"(r1), "r"(r2), "i"(SWI_Read));
-  return r0;
-#endif
-}
-
-/* file, is a valid user file handle.
-   Translates the return of _swiread into
-   bytes read. */
-int __attribute__((weak))
-_read (int file, void * ptr, size_t len)
-{
-  int slot = findslot (remap_handle (file));
-  int x = _swiread (file, ptr, len);
-
-  if (x < 0)
-    return error (-1);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles [slot].pos += len - x;
-
-  /* x == len is not an error, at least if we want feof() to work.  */
-  return len - x;
-}
-
-/* file, is a user file descriptor. */
-off_t
-_swilseek (int file, off_t ptr, int dir)
-{
-  _off_t res;
-  int fh = remap_handle (file);
-  int slot = findslot (fh);
-
-  if (dir == SEEK_CUR)
-    {
-      off_t pos;
-      if (slot == MAX_OPEN_FILES)
-	return -1;
-      pos = openfiles[slot].pos;
-
-      /* Avoid SWI SEEK command when just querying file position. */
-      if (ptr == 0)
-	return pos;
-
-      ptr += pos;
-      dir = SEEK_SET;
-    }
-
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  if (dir == SEEK_END)
-    {
-      block[0] = fh;
-      ptr += do_AngelSWI (AngelSWI_Reason_FLen, block);
-    }
-
-  /* This code only does absolute seeks.  */
-  block[0] = remap_handle (file);
-  block[1] = ptr;
-  res = do_AngelSWI (AngelSWI_Reason_Seek, block);
-#else
-  register int r0 asm("r0");
-  register int r1 asm("r1");
-  if (dir == SEEK_END)
-    {
-      r0 = (int) fh;
-      asm ("swi %a2"
-	   : "=r" (r0)
-	   : "0"(r0), "i" (SWI_Flen));
-      res = r0;
-      ptr += res;
-    }
-
-  /* This code only does absolute seeks.  */
-  r0 = (int) fh;
-  r1 = (int) ptr;
-  asm ("swi %a3"
-       : "=r" (r0)
-       : "0"(r0), "r"(r1), "i" (SWI_Seek));
-  res = r0;
-#endif
-
-  if (slot != MAX_OPEN_FILES && res == 0)
-    openfiles[slot].pos = ptr;
-
-  /* This is expected to return the position in the file.  */
-  return res == 0 ? ptr : -1;
-}
-
-off_t
-_lseek (int file, off_t ptr, int dir)
-{
-  return wrap (_swilseek (file, ptr, dir));
-}
-
-/* file, is a valid internal file handle.
-   Returns the number of bytes *not* written. */
-int
-_swiwrite (int file, const void * ptr, size_t len)
-{
-  int fh = remap_handle (file);
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-
-  block[0] = fh;
-  block[1] = (int) ptr;
-  block[2] = (int) len;
-
-  return do_AngelSWI (AngelSWI_Reason_Write, block);
-#else
-  register int r0 asm("r0") = fh;
-  register int r1 asm("r1") = (int) ptr;
-  register int r2 asm("r2") = (int) len;
-
-  asm ("swi %a4"
-       : "=r" (r0)
-       : "0"(fh), "r"(r1), "r"(r2), "i"(SWI_Write));
-  return r0;
-#endif
-}
-
-/* file, is a user file descriptor. */
-int __attribute__((weak))
-_write (int file, const void * ptr, size_t len)
-{
-  int slot = findslot (remap_handle (file));
-  int x = _swiwrite (file, ptr, len);
-
-  if (x == -1 || x == len)
-    return error (-1);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles[slot].pos += len - x;
-
-  return len - x;
-}
-
-extern int strlen (const char *);
-
-int
-_swiopen (const char * path, int flags)
-{
-  int aflags = 0, fh;
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-#endif
-
-  int i = findslot (-1);
-
-  if (i == MAX_OPEN_FILES)
-    return -1;
-
-  /* The flags are Unix-style, so we need to convert them.  */
-#ifdef O_BINARY
-  if (flags & O_BINARY)
-    aflags |= 1;
-#endif
-
-  if (flags & O_RDWR)
-    aflags |= 2;
-
-  if (flags & O_CREAT)
-    aflags |= 4;
-
-  if (flags & O_TRUNC)
-    aflags |= 4;
-
-  if (flags & O_APPEND)
-    {
-      aflags &= ~4; /* Can't ask for w AND a; means just 'a'.  */
-      aflags |= 8;
-    }
-
-#ifdef ARM_RDI_MONITOR
-  block[0] = (int) path;
-  block[2] = strlen (path);
-  block[1] = aflags;
-
-  fh = do_AngelSWI (AngelSWI_Reason_Open, block);
-
-#else
-  register int r0 asm("r0") = (int) path;
-  register int r1 asm("r1") = (int) aflags;;
-  asm ("swi %a3"
-       : "=r"(r0)
-       : "0"(r0), "r"(r1), "i" (SWI_Open));
-  fh = r0;
-#endif
-
-  if (fh >= 0)
-    {
-      openfiles[i].handle = fh;
-      openfiles[i].pos = 0;
-    }
-
-  return fh >= 0 ? fh + FILE_HANDLE_OFFSET : error (fh);
-}
-
-int
-_open (const char * path, int flags, ...)
-{
-  return wrap (_swiopen (path, flags));
-}
-
-int
-_swiclose (int file)
-{
-  int myhan = remap_handle (file);
-  int slot = findslot (myhan);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles[slot].handle = -1;
-
-#ifdef ARM_RDI_MONITOR
-  return do_AngelSWI (AngelSWI_Reason_Close, & myhan);
-#else
-  register int r0 asm("r0") = myhan;
-  asm ("swi %a2" : "=r"(r0): "0"(r0), "i" (SWI_Close));
-  return r0;
-#endif
-}
-
-int
-_close (int file)
-{
-  return wrap (_swiclose (file));
-}
-
-static int
-_kill_shared (int pid, int sig, int reason)
-{
-  (void) pid; (void) sig;
-#ifdef ARM_RDI_MONITOR
-  /* Note: The pid argument is thrown away.  */
-  int block[2];
-  block[1] = sig;
-  block[0] = reason;
-  int insn;
-
-#if SEMIHOST_V2
-  if (_has_ext_exit_extended ())
-    {
-      insn = AngelSWI_Reason_ReportExceptionExtended;
-    }
-  else
-#endif
-    {
-      insn = AngelSWI_Reason_ReportException;
-    }
-
-#if SEMIHOST_V2
-if (_has_ext_exit_extended ())
-  do_AngelSWI (insn, block);
-else
-#endif
-  do_AngelSWI (insn, (void*)block[0]);
-
-#else
-  asm ("swi %a0" :: "i" (SWI_Exit));
-#endif
-
-  __builtin_unreachable();
-}
-
-int
-_kill (int pid, int sig)
-{
-  if (sig == SIGABRT)
-    _kill_shared (pid, sig, ADP_Stopped_RunTimeError);
-  else
-    _kill_shared (pid, sig, ADP_Stopped_ApplicationExit);
-}
-
-void
-_exit (int status)
-{
-  /* The same SWI is used for both _exit and _kill.
-     For _exit, call the SWI with "reason" set to ADP_Stopped_ApplicationExit
-     to mark a standard exit.
-     Note: The RDI implementation of _kill_shared throws away all its
-     arguments and all implementations ignore the first argument.  */
-  _kill_shared (-1, status, ADP_Stopped_ApplicationExit);
-}
-
-pid_t
-_getpid (void)
-{
-  return (pid_t)1;
-}
-
-/* Heap limit returned from SYS_HEAPINFO Angel semihost call.  */
-uint __heap_limit = 0xcafedead;
-
-void * __attribute__((weak))
-_sbrk (ptrdiff_t incr)
-{
-  extern char   end asm ("end"); /* Defined by the linker.  */
-  static char * heap_end;
-  char *        prev_heap_end;
-
-  if (heap_end == NULL)
-    heap_end = & end;
-
-  prev_heap_end = heap_end;
-
-  if ((heap_end + incr > stack_ptr)
-      /* Honour heap limit if it's valid.  */
-      || (__heap_limit != 0xcafedead && heap_end + incr > (char *)__heap_limit))
-    {
-      /* Some of the libstdc++-v3 tests rely upon detecting
-	 out of memory errors, so do not abort here.  */
-#if 0
-      extern void abort (void);
-
-      _write (1, "_sbrk: Heap and stack collision\n", 32);
-
-      abort ();
-#else
-      errno = ENOMEM;
-      return (void *) -1;
-#endif
-    }
-
-  heap_end += incr;
-
-  return (void *) prev_heap_end;
-}
-
-extern void memset (struct stat *, int, unsigned int);
-
-int __attribute__((weak))
-_fstat (int file, struct stat * st)
-{
-  memset (st, 0, sizeof (* st));
-  st->st_mode = S_IFCHR;
-  st->st_blksize = 1024;
-  return 0;
-  file = file;
-}
-
-int __attribute__((weak))
-_stat (const char *fname, struct stat *st)
-{
-  int file;
-
-  /* The best we can do is try to open the file readonly.  If it exists,
-     then we can guess a few things about it.  */
-  if ((file = _open (fname, O_RDONLY)) < 0)
-    return -1;
-
-  memset (st, 0, sizeof (* st));
-  st->st_mode = S_IFREG | S_IREAD;
-  st->st_blksize = 1024;
-  _swiclose (file); /* Not interested in the error.  */
-  return 0;
-}
-
-int __attribute__((weak))
-_link (const char *__path1 __attribute__ ((unused)), const char *__path2 __attribute__ ((unused)))
-{
-  errno = ENOSYS;
-  return -1;
-}
-
-int
-_unlink (const char *path)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  block[0] = (int)path;
-  block[1] = strlen(path);
-  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-void
-_raise (void)
-{
-  return;
-}
-
-int
-_gettimeofday (struct timeval * tp, void * tzvp)
-{
-  struct timezone *tzp = tzvp;
-  if (tp)
-    {
-    /* Ask the host for the seconds since the Unix epoch.  */
-#ifdef ARM_RDI_MONITOR
-      tp->tv_sec = do_AngelSWI (AngelSWI_Reason_Time,NULL);
-#else
-      {
-	register int r0 asm("r0");
-	asm ("swi %a1" : "=r" (r0): "i" (SWI_Time));
-	tp->tv_sec = r0;
-      }
-#endif
-      tp->tv_usec = 0;
-    }
-
-  /* Return fixed data for the timezone.  */
-  if (tzp)
-    {
-      tzp->tz_minuteswest = 0;
-      tzp->tz_dsttime = 0;
-    }
-
-  return 0;
-}
-
-/* Return a clock that ticks at 100Hz.  */
-clock_t
-_times (struct tms * tp)
-{
-  clock_t timeval;
-
-#ifdef ARM_RDI_MONITOR
-  timeval = do_AngelSWI (AngelSWI_Reason_Clock, NULL);
-#else
-  register int r0 asm("r0");
-  asm ("swi %a1" : "=r" (r0): "i" (SWI_Clock));
-  timeval = (clock_t) r0;
-#endif
-
-  if (tp)
-    {
-      tp->tms_utime  = timeval;	/* user time */
-      tp->tms_stime  = 0;	/* system time */
-      tp->tms_cutime = 0;	/* user time, children */
-      tp->tms_cstime = 0;	/* system time, children */
-    }
-
-  return timeval;
-};
-
-
-int
-_isatty (int fd)
-{
-#ifdef ARM_RDI_MONITOR
-  int fh = remap_handle (fd);
-  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
-#else
-  return (fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
-#endif
-}
-
-int
-_system (const char *s)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  int e;
-
-  /* Hmmm.  The ARM debug interface specification doesn't say whether
-     SYS_SYSTEM does the right thing with a null argument, or assign any
-     meaning to its return value.  Try to do something reasonable....  */
-  if (!s)
-    return 1;  /* maybe there is a shell available? we can hope. :-P */
-  block[0] = (int)s;
-  block[1] = strlen (s);
-  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
-  if ((e >= 0) && (e < 256))
-    {
-      /* We have to convert e, an exit status to the encoded status of
-         the command.  To avoid hard coding the exit status, we simply
-	 loop until we find the right position.  */
-      int exit_code;
-
-      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
-	continue;
-    }
-  return e;
-#else
-  if (s == NULL)
-    return 0;
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-int
-_rename (const char * oldpath, const char * newpath)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[4];
-  block[0] = (int) oldpath;
-  block[1] = strlen(oldpath);
-  block[2] = (int) newpath;
-  block[3] = strlen(newpath);
-  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c
@@ -0,0 +1,18 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+
+
+/*
+ * sysconf();
+ */
+
+long sysconf (int c)
+{
+	return -1;
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/termios.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/termios.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/termios.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/termios.c
@@ -0,0 +1,96 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+#include <termios.h>
+#include <sys/termios.h>
+
+int isatty (int fd)
+{    
+  return IsATTY(fd);  
+}
+
+int tcgetattr(int fd,struct termios *termios_p)
+{
+  return ioctl(fd, TCGETS, termios_p);
+}
+
+int tcsetattr(int fd,int optional_actions, const struct termios *termios_p)
+{
+  int cmd;
+
+  switch (optional_actions) {
+    case TCSANOW:
+      cmd = TCSETS;
+      break;
+    case TCSADRAIN:
+      cmd = TCSETSW;
+      break;
+    case TCSAFLUSH:
+      cmd = TCSETSF;
+      break;
+    default:
+      errno = EINVAL;
+      return -1;
+  }
+  
+  return ioctl(fd, cmd, termios_p);
+}
+
+pid_t tcgetpgrp(int fd)
+{
+  int p;
+    
+  if (ioctl(fd,TIOCGPGRP,&p) < 0) {
+    return (pid_t)-1;
+  }
+  
+  return (pid_t)p;
+}
+
+int tcsetpgrp(int fd, pid_t pid)
+{
+  int p = (int)pid;
+  return ioctl(fd,TIOCSPGRP, &p);
+}
+
+int tcflow (int fd, int action)
+{
+  return ioctl(fd, TCXONC, action);
+}
+
+int tcflush (int fd, int queue_selector)
+{
+  return ioctl(fd, TCFLSH, queue_selector);
+}
+
+int cfsetispeed (struct termios *termios_p, speed_t speed)
+{
+	termios_p->c_ispeed = speed;
+	return 0;
+}
+
+int cfsetospeed (struct termios *termios_p, speed_t speed)
+{
+	termios_p->c_ospeed = speed;
+	return 0;
+}
+
+speed_t cfgetispeed (const struct termios *termios_p)
+{
+	return termios_p->c_ispeed;
+}
+
+speed_t cfgetospeed (const struct termios *termios_p)
+{
+	return termios_p->c_ospeed;
+}
+
+char *ttyname(int fildes)
+{
+	return "/dev/tty";
+}
+
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/time.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/time.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/time.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/time.c
@@ -0,0 +1,35 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <utime.h>
+#include <errno.h>
+
+
+
+
+/*
+ *
+ */
+
+time_t time (time_t *tloc)
+{
+	struct timeval tv;
+	
+	gettimeofday (&tv, NULL);
+	
+	return tv.tv_sec;
+}
+
+
+
+
+/*
+ *
+ */
+
+int utime(const char *path, const struct utimbuf *times)
+{
+	return 0;
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/times.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/times.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/times.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/times.c
@@ -0,0 +1,18 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+
+/*
+ *
+ */
+
+clock_t times (struct tms *buf)
+{
+  errno = ENOSYS;
+  return -1;
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/trap.S third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/trap.S
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/trap.S
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/trap.S
@@ -1,95 +0,0 @@
-        /* Run-time exception support */
-#ifndef __ARM_EABI__
-#include "swi.h"
-
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-        .align 0
-        .global __rt_stkovf_split_big
-        .global __rt_stkovf_split_small
-
-/* The following functions are provided for software stack checking.
-   If hardware stack-checking is being used then the code can be
-   compiled without the PCS entry checks, and simply rely on VM
-   management to extend the stack for a thread.
-
-   The stack extension event occurs when the PCS function entry code
-   would result in a stack-pointer beneath the stack-limit register
-   value.  The system relies on the following map:
-
-        +-----------------------------------+ <-- end of stack block
-        | ...                               |
-        | ...                               |
-        | active stack                      |
-        | ...                               | <-- sp (stack-pointer) somewhere in here
-        | ...                               |
-        +-----------------------------------+ <-- sl (stack-limit)
-        | stack-extension handler workspace |
-        +-----------------------------------+ <-- base of stack block
-
-   The "stack-extension handler workspace" is an amount of memory in
-   which the stack overflow support code must execute.  It must be
-   large enough to deal with the worst case path through the extension
-   code.  At the moment the compiler expects this to be AT LEAST
-   256bytes.  It uses this fact to code functions with small local
-   data usage within the overflow space.
-
-   In a true target environment We may need to increase the space
-   between sl and the true limit to allow for the stack extension
-   code, SWI handlers and for undefined instruction handlers of the
-   target environment.  */
-
-__rt_stkovf_split_small:
-        mov     ip,sp   @ Ensure we can calculate the stack required
-        @ and fall through to...
-__rt_stkovf_split_big:
-        @ in:   sp = current stack-pointer (beneath stack-limit)
-        @       sl = current stack-limit
-        @       ip = low stack point we require for the current function
-        @       lr = return address into the current function
-        @       fp = frame-pointer
-        @               original sp --> +----------------------------------+
-        @                               | pc (12 ahead of PCS entry store) |
-        @               current fp ---> +----------------------------------+
-        @                               | lr (on entry) pc (on exit)       |
-        @                               +----------------------------------+
-        @                               | sp ("original sp" on entry)      |
-        @                               +----------------------------------+
-        @                               | fp (on entry to function)        |
-        @                               +----------------------------------+
-        @                               |                                  |
-        @                               | ..argument and work registers..  |
-        @                               |                                  |
-        @               current sp ---> +----------------------------------+
-        @
-        @ The "current sl" is somewhere between "original sp" and "current sp"
-        @ but above "true sl". The "current sl" should be at least 256bytes
-        @ above the "true sl". The 256byte stack guard should be large enough
-        @ to deal with the worst case function entry stacking (160bytes) plus
-        @ the stack overflow handler stacking requirements, plus the stack
-        @ required for the memory allocation routines.
-        @
-        @ Normal PCS entry (before stack overflow check) can stack 16
-        @ standard registers (64bytes) and 8 floating point registers
-        @ (96bytes). This gives a minimum stack guard of 160bytes (excluding
-        @ the stack required for the code). (Actually only a maximum of
-        @ 14standard registers are ever stacked on entry to a function).
-        @
-        @ NOTE: Structure returns are performed by the caller allocating a
-        @       dummy space on the stack and passing in a "phantom" arg1 into
-        @       the function. This means that we do not need to worry about
-        @       preserving the stack under "sp" even on function return.
-        @ 
-        @        Code should never poke values beneath sp. The sp register
-        @        should always be "dropped" first to cover the data. This
-        @        protects the data against any events that may try and use
-        @        the stack.
-
-        SUB     ip, sp, ip      @ extra stack required for function
-        @ Add stack extension code here.  If desired a new stack chunk
-        @ can be allocated, and the register state updated suitably.
-
-        @ We now know how much extra stack the function requires.
-        @ Terminate the program for the moment:
-        swi     SWI_Exit
-#endif
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/truncate.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/truncate.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/truncate.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/truncate.c
@@ -0,0 +1,50 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+
+
+
+
+int ftruncate (int fd, off_t size)
+{
+    int sc;
+    
+    sc = Truncate(fd, size);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+
+
+
+int truncate (const char *path, off_t size)
+{
+    int fd;
+    int sc;
+    
+    fd = open(path, O_WRONLY);
+    
+    if (fd < 0) {
+      errno = -fd;
+      return -1;
+    }
+        
+    sc = Truncate(fd, size);
+    close(fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/unlink.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/unlink.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/unlink.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/unlink.c
@@ -0,0 +1,24 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+
+/*
+ *
+ */
+
+int unlink (char *path)
+{
+    int sc;
+    
+  	sc = Unlink(path);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/update.sh third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/update.sh
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/update.sh
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/update.sh
@@ -0,0 +1,7 @@
+# When adding files to this directory, add the name
+# of the object file to makefile.am then run the following
+# script in this directory.
+
+aclocal -I ../../..
+autoconf
+automake --cygnus Makefile
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c
@@ -0,0 +1,22 @@
+#include <_ansi.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+
+
+
+char * _user_strerror (int errnum)
+{
+	char *error;
+	
+	switch (errnum)
+	{
+		default:
+			error = NULL;
+	}
+	
+	return error;		
+}
+
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/wait.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/wait.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/wait.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/wait.c
@@ -0,0 +1,33 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+
+
+
+
+pid_t waitpid (pid_t pid, int *status, int options)
+{
+  pid_t rpid;
+  
+  rpid = WaitPid (pid, status, options);
+  
+  if (rpid < 0) {
+    errno = -rpid;
+    return -1;
+  }
+  
+  return rpid;
+}
+
+
+
+
+int wait (int *status)
+{
+ return waitpid (-1, status, 0);
+}
+
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/warning.h third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/warning.h
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/warning.h
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/warning.h
@@ -0,0 +1,43 @@
+#ifndef __WARNING_H__
+#define __WARNING_H__
+
+#ifdef HAVE_GNU_LD
+# ifdef HAVE_ELF
+
+/* We want the .gnu.warning.SYMBOL section to be unallocated.  */
+#  ifdef HAVE_ASM_PREVIOUS_DIRECTIVE
+#   define __make_section_unallocated(section_string)   \
+  asm(".section " section_string "; .previous");
+#  elif defined (HAVE_ASM_POPSECTION_DIRECTIVE)
+#   define __make_section_unallocated(section_string)   \
+  asm(".pushsection " section_string "; .popsection");
+#  else
+#   define __make_section_unallocated(section_string)
+#  endif
+
+#  ifdef HAVE_SECTION_ATTRIBUTES
+#   define link_warning(symbol, msg)                     \
+  __make_section_unallocated (".gnu.warning." #symbol)  \
+  static const char __evoke_link_warning_##symbol[]     \
+    __attribute__ ((section (".gnu.warning." #symbol))) = msg;
+#  else
+#   define link_warning(symbol, msg)
+#  endif
+
+#else /* !ELF */
+
+#  define link_warning(symbol, msg)             \
+  asm(".stabs \"" msg "\",30,0,0,0\n"   \
+      ".stabs \"" __SYMBOL_PREFIX #symbol "\",1,0,0,0\n");
+# endif
+#else /* !GNULD */
+/* We will never be heard; they will all die horribly.  */
+# define link_warning(symbol, msg)
+#endif
+
+/* A canned warning for sysdeps/stub functions.  */
+#define stub_warning(name) \
+  link_warning (name, \
+                "warning: " #name " is not implemented and will always fail")
+
+#endif /* __WARNING_H__ */
diff -urN third_party/newlib-3.2.0/newlib/libc/sys/arm/write.c third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/write.c
--- third_party/newlib-3.2.0/newlib/libc/sys/arm/write.c
+++ third_party_new_z/newlib-3.2.0/newlib/libc/sys/arm/write.c
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+
+
+ssize_t write (int fd, const void *buf, size_t nbyte)
+{
+    ssize_t sz;
+    
+    sz = Write(fd, buf, nbyte);
+    
+    if (sz < 0) {
+        errno = -sz;
+        return -1;
+    }
+	
+	return sz;
+}
+
+
