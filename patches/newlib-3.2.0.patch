diff -aurN third_party_original/newlib-3.2.0/configure third_party/newlib-3.2.0/configure
--- third_party_original/newlib-3.2.0/configure	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/configure	2022-06-29 14:50:02.709940671 +0100
@@ -3620,6 +3620,9 @@
 
 # Disable newlib and libgloss for various target OSes.
 case "${target}" in
+  arm*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   alpha*-dec-osf*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -aurN third_party_original/newlib-3.2.0/configure.ac third_party/newlib-3.2.0/configure.ac
--- third_party_original/newlib-3.2.0/configure.ac	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/configure.ac	2022-06-29 14:50:02.709940671 +0100
@@ -956,6 +956,9 @@
 
 # Disable newlib and libgloss for various target OSes.
 case "${target}" in
+  arm*-*-*)
+    noconfigdirs="$noconfigdirs target-libgloss"
+    ;;
   alpha*-dec-osf*)
     noconfigdirs="$noconfigdirs target-newlib target-libgloss"
     ;;
diff -aurN third_party_original/newlib-3.2.0/newlib/configure.host third_party/newlib-3.2.0/newlib/configure.host
--- third_party_original/newlib-3.2.0/newlib/configure.host	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/configure.host	2022-06-29 14:50:02.713940787 +0100
@@ -464,11 +464,11 @@
 	have_crt0="no"
 	;;
   arm*-*-*)
-	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB"
+	newlib_cflags="${newlib_cflags} -D_COMPILING_NEWLIB -D_HAVE_STDC"
 	sys_dir=arm
-	if [ "x${newlib_may_supply_syscalls}" = "xno" ] ; then
-	  have_crt0="no"
-	fi
+    newlib_cflags="${newlib_cflags} -DMALLOC_PROVIDED -DHAVE_GETTIMEOFDAY -DEXIT_PROVIDED -DMISSING_SYSCALL_NAMES -DHAVE_OPENDIR -DHAVE_RENAME"
+	newlib_cflags="${newlib_cflags} -D_NO_GETLOGIN -D_NO_GETPWENT -D_NO_GETUT -D_NO_GETPASS -D_NO_WORDEXP -D_NO_POPEN"
+	unix_dir=unix
 	;;
   bfin-*-*)
 	sys_dir=
@@ -691,7 +691,7 @@
 	syscall_dir=syscalls
 	;;
   arm*-*-*)
-	syscall_dir=syscalls
+	syscall_dir=
 # If newlib is supplying syscalls, select which debug protocol is being used.
 # ARM_RDP_MONITOR selects the Demon monitor.
 # ARM_RDI_MONITOR selects the Angel monitor.
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/stdlib/mallocr.c third_party/newlib-3.2.0/newlib/libc/stdlib/mallocr.c
--- third_party_original/newlib-3.2.0/newlib/libc/stdlib/mallocr.c	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/stdlib/mallocr.c	2022-06-29 14:50:02.713940787 +0100
@@ -610,7 +610,7 @@
 */
 
 #ifndef HAVE_MMAP
-#define HAVE_MMAP 1
+#define HAVE_MMAP 0
 #endif
 
 /*
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/access.c third_party/newlib-3.2.0/newlib/libc/sys/arm/access.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/access.c	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/access.c	2022-06-29 14:50:02.713940787 +0100
@@ -1,33 +1,36 @@
-/* This is file ACCESS.C */
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
 /*
- * Copyright (C) 1993 DJ Delorie
- * All rights reserved.
  *
- * Redistribution, modification, and use in source and binary forms is permitted
- * provided that the above copyright notice and following paragraph are
- * duplicated in all such forms.
- *
- * This file is distributed WITHOUT ANY WARRANTY; without even the implied
- * warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
  */
+int access(const char *path, int amode)
+{
+    int sc;
+    
+  	sc = _swi_access(path, amode);
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
 
-#include <fcntl.h>
-#include <sys/stat.h>
-#include <unistd.h>
 
-int access(const char *fn, int flags)
+/*
+ *
+ */
+mode_t umask(mode_t cmask)
 {
-  struct stat s;
-  if (stat(fn, &s))
-    return -1;
-  if (s.st_mode & S_IFDIR)
-    return 0;
-  if (flags & W_OK)
-  {
-    if (s.st_mode & S_IWRITE)
-      return 0;
-    return -1;
-  }
-  return 0;
+    mode_t mask;
+    
+  	mask = _swi_umask(cmask);
+    return mask;
 }
-	
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h third_party/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/acconfig.h	2022-06-29 14:50:02.713940787 +0100
@@ -0,0 +1,26 @@
+/* Name of package.  */
+#undef PACKAGE
+
+/* Version of package.  */
+#undef VERSION
+
+/* Missing syscall names */
+#undef MISSING_SYSCALL_NAMES
+
+/* Using ELF format */
+#undef HAVE_ELF
+
+/* Using GNU LD */
+#undef HAVE_GNU_LD
+
+/* .previous directive allowed */
+#undef HAVE_ASM_PREVIOUS_DIRECTIVE
+
+/* .pushsection/.popsection directives allowed */
+#undef HAVE_ASM_POPSECTION_DIRECTIVE
+
+/* support for section attributes */
+#undef HAVE_SECTION_ATTRIBUTES
+
+/* symbol prefix */
+#undef __SYMBOL_PREFIX
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/aclocal.m4 third_party/newlib-3.2.0/newlib/libc/sys/arm/aclocal.m4
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/aclocal.m4	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/aclocal.m4	2022-06-29 14:50:02.717940889 +0100
@@ -1,4 +1,4 @@
-# generated automatically by aclocal 1.11.6 -*- Autoconf -*-
+# generated automatically by aclocal 1.12 -*- Autoconf -*-
 
 # Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
 # 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation,
@@ -14,20 +14,19 @@
 
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
-m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.68],,
-[m4_warning([this file was generated for autoconf 2.68.
+m4_if(m4_defn([AC_AUTOCONF_VERSION]), [2.64],,
+[m4_warning([this file was generated for autoconf 2.64.
 You have another version of autoconf.  It may work, but is not guaranteed to.
 If you have problems, you may need to regenerate the build system entirely.
-To do so, use the procedure documented by the package, typically `autoreconf'.])])
+To do so, use the procedure documented by the package, typically 'autoreconf'.])])
 
-# Copyright (C) 2002, 2003, 2005, 2006, 2007, 2008, 2011 Free Software
-# Foundation, Inc.
+# Copyright (C) 2002-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 8
 
 # AM_AUTOMAKE_VERSION(VERSION)
 # ----------------------------
@@ -35,10 +34,10 @@
 # generated from the m4 files accompanying Automake X.Y.
 # (This private macro should not be called outside this file.)
 AC_DEFUN([AM_AUTOMAKE_VERSION],
-[am__api_version='1.11'
+[am__api_version='1.12'
 dnl Some users find AM_AUTOMAKE_VERSION and mistake it for a way to
 dnl require some minimum version.  Point them to the right macro.
-m4_if([$1], [1.11.6], [],
+m4_if([$1], [1.12], [],
       [AC_FATAL([Do not call $0, use AM_INIT_AUTOMAKE([$1]).])])dnl
 ])
 
@@ -54,24 +53,24 @@
 # Call AM_AUTOMAKE_VERSION and AM_AUTOMAKE_VERSION so they can be traced.
 # This function is AC_REQUIREd by AM_INIT_AUTOMAKE.
 AC_DEFUN([AM_SET_CURRENT_AUTOMAKE_VERSION],
-[AM_AUTOMAKE_VERSION([1.11.6])dnl
+[AM_AUTOMAKE_VERSION([1.12])dnl
 m4_ifndef([AC_AUTOCONF_VERSION],
   [m4_copy([m4_PACKAGE_VERSION], [AC_AUTOCONF_VERSION])])dnl
 _AM_AUTOCONF_VERSION(m4_defn([AC_AUTOCONF_VERSION]))])
 
 # AM_AUX_DIR_EXPAND                                         -*- Autoconf -*-
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # For projects using AC_CONFIG_AUX_DIR([foo]), Autoconf sets
-# $ac_aux_dir to `$srcdir/foo'.  In other projects, it is set to
-# `$srcdir', `$srcdir/..', or `$srcdir/../..'.
+# $ac_aux_dir to '$srcdir/foo'.  In other projects, it is set to
+# '$srcdir', '$srcdir/..', or '$srcdir/../..'.
 #
 # Of course, Automake must honor this variable whenever it calls a
 # tool from the auxiliary directory.  The problem is that $srcdir (and
@@ -90,7 +89,7 @@
 #
 # The reason of the latter failure is that $top_srcdir and $ac_aux_dir
 # are both prefixed by $srcdir.  In an in-source build this is usually
-# harmless because $srcdir is `.', but things will broke when you
+# harmless because $srcdir is '.', but things will broke when you
 # start a VPATH build or use an absolute $srcdir.
 #
 # So we could use something similar to $top_srcdir/$ac_aux_dir/missing,
@@ -116,22 +115,21 @@
 
 # AM_CONDITIONAL                                            -*- Autoconf -*-
 
-# Copyright (C) 1997, 2000, 2001, 2003, 2004, 2005, 2006, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 9
+# serial 10
 
 # AM_CONDITIONAL(NAME, SHELL-CONDITION)
 # -------------------------------------
 # Define a conditional.
 AC_DEFUN([AM_CONDITIONAL],
-[AC_PREREQ(2.52)dnl
- ifelse([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
-	[$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
+[AC_PREREQ([2.52])dnl
+ m4_if([$1], [TRUE],  [AC_FATAL([$0: invalid condition: $1])],
+       [$1], [FALSE], [AC_FATAL([$0: invalid condition: $1])])dnl
 AC_SUBST([$1_TRUE])dnl
 AC_SUBST([$1_FALSE])dnl
 _AM_SUBST_NOTMAKE([$1_TRUE])dnl
@@ -150,16 +148,15 @@
 Usually this means the macro was only invoked conditionally.]])
 fi])])
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2009,
-# 2010, 2011 Free Software Foundation, Inc.
+# Copyright (C) 1999-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 12
+# serial 16
 
-# There are a few dirty hacks below to avoid letting `AC_PROG_CC' be
+# There are a few dirty hacks below to avoid letting 'AC_PROG_CC' be
 # written in clear, in which case automake, when reading aclocal.m4,
 # will think it sees a *use*, and therefore will trigger all it's
 # C support machinery.  Also note that it means that autoscan, seeing
@@ -182,12 +179,12 @@
 AC_REQUIRE([AM_MAKE_INCLUDE])dnl
 AC_REQUIRE([AM_DEP_TRACK])dnl
 
-ifelse([$1], CC,   [depcc="$CC"   am_compiler_list=],
-       [$1], CXX,  [depcc="$CXX"  am_compiler_list=],
-       [$1], OBJC, [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
-       [$1], UPC,  [depcc="$UPC"  am_compiler_list=],
-       [$1], GCJ,  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
-                   [depcc="$$1"   am_compiler_list=])
+m4_if([$1], [CC],   [depcc="$CC"   am_compiler_list=],
+      [$1], [CXX],  [depcc="$CXX"  am_compiler_list=],
+      [$1], [OBJC], [depcc="$OBJC" am_compiler_list='gcc3 gcc'],
+      [$1], [UPC],  [depcc="$UPC"  am_compiler_list=],
+      [$1], [GCJ],  [depcc="$GCJ"  am_compiler_list='gcc3 gcc'],
+                    [depcc="$$1"   am_compiler_list=])
 
 AC_CACHE_CHECK([dependency style of $depcc],
                [am_cv_$1_dependencies_compiler_type],
@@ -195,8 +192,8 @@
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -236,16 +233,16 @@
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -254,8 +251,8 @@
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -263,7 +260,7 @@
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -311,7 +308,7 @@
 # AM_SET_DEPDIR
 # -------------
 # Choose a directory name for dependency files.
-# This macro is AC_REQUIREd in _AM_DEPENDENCIES
+# This macro is AC_REQUIREd in _AM_DEPENDENCIES.
 AC_DEFUN([AM_SET_DEPDIR],
 [AC_REQUIRE([AM_SET_LEADING_DOT])dnl
 AC_SUBST([DEPDIR], ["${am__leading_dot}deps"])dnl
@@ -321,9 +318,13 @@
 # AM_DEP_TRACK
 # ------------
 AC_DEFUN([AM_DEP_TRACK],
-[AC_ARG_ENABLE(dependency-tracking,
-[  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors])
+[AC_ARG_ENABLE([dependency-tracking], [dnl
+AS_HELP_STRING(
+  [--enable-dependency-tracking],
+  [do not reject slow dependency extractors])
+AS_HELP_STRING(
+  [--disable-dependency-tracking],
+  [speeds up one-time build])])
 if test "x$enable_dependency_tracking" != xno; then
   am_depcomp="$ac_aux_dir/depcomp"
   AMDEPBACKSLASH='\'
@@ -338,14 +339,13 @@
 
 # Generate code to set up dependency tracking.              -*- Autoconf -*-
 
-# Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1999-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-#serial 5
+# serial 6
 
 # _AM_OUTPUT_DEPENDENCY_COMMANDS
 # ------------------------------
@@ -364,7 +364,7 @@
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -376,21 +376,19 @@
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
     test -z "am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`AS_DIRNAME(["$file"])`
@@ -408,7 +406,7 @@
 # This macro should only be invoked once -- use via AC_REQUIRE.
 #
 # This code is only required when automatic dependency tracking
-# is enabled.  FIXME.  This creates each `.P' file that we will
+# is enabled.  FIXME.  This creates each '.P' file that we will
 # need in order to bootstrap the dependency handling code.
 AC_DEFUN([AM_OUTPUT_DEPENDENCY_COMMANDS],
 [AC_CONFIG_COMMANDS([depfiles],
@@ -418,14 +416,13 @@
 
 # Do all the work for Automake.                             -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
-# 2005, 2006, 2008, 2009 Free Software Foundation, Inc.
+# Copyright (C) 1996-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 16
+# serial 18
 
 # This macro actually does too much.  Some checks are only needed if
 # your package does certain things.  But this isn't really a big deal.
@@ -476,23 +473,25 @@
  AC_SUBST([VERSION], [$2])],
 [_AM_SET_OPTIONS([$1])dnl
 dnl Diagnose old-style AC_INIT with new-style AM_AUTOMAKE_INIT.
-m4_if(m4_ifdef([AC_PACKAGE_NAME], 1)m4_ifdef([AC_PACKAGE_VERSION], 1), 11,,
+m4_if(
+  m4_ifdef([AC_PACKAGE_NAME], [ok]):m4_ifdef([AC_PACKAGE_VERSION], [ok]),
+  [ok:ok],,
   [m4_fatal([AC_INIT should be called with package and version arguments])])dnl
  AC_SUBST([PACKAGE], ['AC_PACKAGE_TARNAME'])dnl
  AC_SUBST([VERSION], ['AC_PACKAGE_VERSION'])])dnl
 
 _AM_IF_OPTION([no-define],,
-[AC_DEFINE_UNQUOTED(PACKAGE, "$PACKAGE", [Name of package])
- AC_DEFINE_UNQUOTED(VERSION, "$VERSION", [Version number of package])])dnl
+[AC_DEFINE_UNQUOTED([PACKAGE], ["$PACKAGE"], [Name of package])
+ AC_DEFINE_UNQUOTED([VERSION], ["$VERSION"], [Version number of package])])dnl
 
 # Some tools Automake needs.
 AC_REQUIRE([AM_SANITY_CHECK])dnl
 AC_REQUIRE([AC_ARG_PROGRAM])dnl
-AM_MISSING_PROG(ACLOCAL, aclocal-${am__api_version})
-AM_MISSING_PROG(AUTOCONF, autoconf)
-AM_MISSING_PROG(AUTOMAKE, automake-${am__api_version})
-AM_MISSING_PROG(AUTOHEADER, autoheader)
-AM_MISSING_PROG(MAKEINFO, makeinfo)
+AM_MISSING_PROG([ACLOCAL], [aclocal-${am__api_version}])
+AM_MISSING_PROG([AUTOCONF], [autoconf])
+AM_MISSING_PROG([AUTOMAKE], [automake-${am__api_version}])
+AM_MISSING_PROG([AUTOHEADER], [autoheader])
+AM_MISSING_PROG([MAKEINFO], [makeinfo])
 AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
 AC_REQUIRE([AM_PROG_INSTALL_STRIP])dnl
 AC_REQUIRE([AM_PROG_MKDIR_P])dnl
@@ -506,28 +505,28 @@
 			     [_AM_PROG_TAR([v7])])])
 _AM_IF_OPTION([no-dependencies],,
 [AC_PROVIDE_IFELSE([AC_PROG_CC],
-		  [_AM_DEPENDENCIES(CC)],
+		  [_AM_DEPENDENCIES([CC])],
 		  [define([AC_PROG_CC],
-			  defn([AC_PROG_CC])[_AM_DEPENDENCIES(CC)])])dnl
+			  defn([AC_PROG_CC])[_AM_DEPENDENCIES([CC])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_CXX],
-		  [_AM_DEPENDENCIES(CXX)],
+		  [_AM_DEPENDENCIES([CXX])],
 		  [define([AC_PROG_CXX],
-			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES(CXX)])])dnl
+			  defn([AC_PROG_CXX])[_AM_DEPENDENCIES([CXX])])])dnl
 AC_PROVIDE_IFELSE([AC_PROG_OBJC],
-		  [_AM_DEPENDENCIES(OBJC)],
+		  [_AM_DEPENDENCIES([OBJC])],
 		  [define([AC_PROG_OBJC],
-			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES(OBJC)])])dnl
+			  defn([AC_PROG_OBJC])[_AM_DEPENDENCIES([OBJC])])])dnl
 ])
 _AM_IF_OPTION([silent-rules], [AC_REQUIRE([AM_SILENT_RULES])])dnl
-dnl The `parallel-tests' driver may need to know about EXEEXT, so add the
-dnl `am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
+dnl The 'parallel-tests' driver may need to know about EXEEXT, so add the
+dnl 'am__EXEEXT' conditional if _AM_COMPILER_EXEEXT was seen.  This macro
 dnl is hooked onto _AC_COMPILER_EXEEXT early, see below.
 AC_CONFIG_COMMANDS_PRE(dnl
 [m4_provide_if([_AM_COMPILER_EXEEXT],
   [AM_CONDITIONAL([am__EXEEXT], [test -n "$EXEEXT"])])])dnl
 ])
 
-dnl Hook into `_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
+dnl Hook into '_AC_COMPILER_EXEEXT' early to learn its expansion.  Do not
 dnl add the conditional right here, as _AC_COMPILER_EXEEXT may be further
 dnl mangled by Autoconf and run in a shell conditional statement.
 m4_define([_AC_COMPILER_EXEEXT],
@@ -555,14 +554,13 @@
 done
 echo "timestamp for $_am_arg" >`AS_DIRNAME(["$_am_arg"])`/stamp-h[]$_am_stamp_count])
 
-# Copyright (C) 2001, 2003, 2005, 2008, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 8
 
 # AM_PROG_INSTALL_SH
 # ------------------
@@ -577,9 +575,9 @@
     install_sh="\${SHELL} $am_aux_dir/install-sh"
   esac
 fi
-AC_SUBST(install_sh)])
+AC_SUBST([install_sh])])
 
-# Copyright (C) 2003, 2005  Free Software Foundation, Inc.
+# Copyright (C) 2003-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -603,20 +601,19 @@
 # Add --enable-maintainer-mode option to configure.         -*- Autoconf -*-
 # From Jim Meyering
 
-# Copyright (C) 1996, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2008,
-# 2011 Free Software Foundation, Inc.
+# Copyright (C) 1996-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 7
 
 # AM_MAINTAINER_MODE([DEFAULT-MODE])
 # ----------------------------------
 # Control maintainer-specific portions of Makefiles.
-# Default is to disable them, unless `enable' is passed literally.
-# For symmetry, `disable' may be passed as well.  Anyway, the user
+# Default is to disable them, unless 'enable' is passed literally.
+# For symmetry, 'disable' may be passed as well.  Anyway, the user
 # can override the default with the --enable/--disable switch.
 AC_DEFUN([AM_MAINTAINER_MODE],
 [m4_case(m4_default([$1], [disable]),
@@ -627,10 +624,11 @@
 AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])
   dnl maintainer-mode's default is 'disable' unless 'enable' is passed
   AC_ARG_ENABLE([maintainer-mode],
-[  --][am_maintainer_other][-maintainer-mode  am_maintainer_other make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer],
-      [USE_MAINTAINER_MODE=$enableval],
-      [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
+    [AS_HELP_STRING([--]am_maintainer_other[-maintainer-mode],
+      am_maintainer_other[ make rules and dependencies not useful
+      (and sometimes confusing) to the casual installer])],
+    [USE_MAINTAINER_MODE=$enableval],
+    [USE_MAINTAINER_MODE=]m4_if(am_maintainer_other, [enable], [no], [yes]))
   AC_MSG_RESULT([$USE_MAINTAINER_MODE])
   AM_CONDITIONAL([MAINTAINER_MODE], [test $USE_MAINTAINER_MODE = yes])
   MAINT=$MAINTAINER_MODE_TRUE
@@ -642,13 +640,13 @@
 
 # Check to see how 'make' treats includes.	            -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2009  Free Software Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 4
+# serial 5
 
 # AM_MAKE_INCLUDE()
 # -----------------
@@ -667,7 +665,7 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -694,14 +692,13 @@
 
 # Fake the existence of programs that GNU maintainers use.  -*- Autoconf -*-
 
-# Copyright (C) 1997, 1999, 2000, 2001, 2003, 2004, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1997-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 6
+# serial 7
 
 # AM_MISSING_PROG(NAME, PROGRAM)
 # ------------------------------
@@ -731,22 +728,21 @@
   am_missing_run="$MISSING --run "
 else
   am_missing_run=
-  AC_MSG_WARN([`missing' script is too old or missing])
+  AC_MSG_WARN(['missing' script is too old or missing])
 fi
 ])
 
-# Copyright (C) 2003, 2004, 2005, 2006, 2011 Free Software Foundation,
-# Inc.
+# Copyright (C) 2003-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # AM_PROG_MKDIR_P
 # ---------------
-# Check for `mkdir -p'.
+# Check for 'mkdir -p'.
 AC_DEFUN([AM_PROG_MKDIR_P],
 [AC_PREREQ([2.60])dnl
 AC_REQUIRE([AC_PROG_MKDIR_P])dnl
@@ -766,14 +762,13 @@
 
 # Helper functions for option handling.                     -*- Autoconf -*-
 
-# Copyright (C) 2001, 2002, 2003, 2005, 2008, 2010 Free Software
-# Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 6
 
 # _AM_MANGLE_OPTION(NAME)
 # -----------------------
@@ -784,7 +779,7 @@
 # --------------------
 # Set option NAME.  Presently that only means defining a flag for this option.
 AC_DEFUN([_AM_SET_OPTION],
-[m4_define(_AM_MANGLE_OPTION([$1]), 1)])
+[m4_define(_AM_MANGLE_OPTION([$1]), [1])])
 
 # _AM_SET_OPTIONS(OPTIONS)
 # ------------------------
@@ -800,22 +795,18 @@
 
 # Check to make sure that the build environment is sane.    -*- Autoconf -*-
 
-# Copyright (C) 1996, 1997, 2000, 2001, 2003, 2005, 2008
-# Free Software Foundation, Inc.
+# Copyright (C) 1996-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 5
+# serial 9
 
 # AM_SANITY_CHECK
 # ---------------
 AC_DEFUN([AM_SANITY_CHECK],
 [AC_MSG_CHECKING([whether build environment is sane])
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
@@ -826,32 +817,40 @@
 esac
 case $srcdir in
   *[[\\\"\#\$\&\'\`$am_lf\ \	]]*)
-    AC_MSG_ERROR([unsafe srcdir value: `$srcdir']);;
+    AC_MSG_ERROR([unsafe srcdir value: '$srcdir']);;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$[*]" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$[*]" != "X $srcdir/configure conftest.file" \
-      && test "$[*]" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
-alias in your environment])
-   fi
-
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$[*]" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$[*]" != "X $srcdir/configure conftest.file" \
+	&& test "$[*]" != "X conftest.file $srcdir/configure"; then
+
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	AC_MSG_ERROR([ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment])
+     fi
+     if test "$[2]" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$[2]" = conftest.file
    )
 then
@@ -861,39 +860,55 @@
    AC_MSG_ERROR([newly created file is older than distributed files!
 Check your system clock])
 fi
-AC_MSG_RESULT(yes)])
+AC_MSG_RESULT([yes])
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+AC_CONFIG_COMMANDS_PRE(
+  [AC_MSG_CHECKING([that generated files are newer than configure])
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   AC_MSG_RESULT([done])])
+rm -f conftest.file
+])
 
-# Copyright (C) 2001, 2003, 2005, 2011 Free Software Foundation, Inc.
+# Copyright (C) 2001-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 1
+# serial 2
 
 # AM_PROG_INSTALL_STRIP
 # ---------------------
-# One issue with vendor `install' (even GNU) is that you can't
+# One issue with vendor 'install' (even GNU) is that you can't
 # specify the program used to strip binaries.  This is especially
 # annoying in cross-compiling environments, where the build's strip
 # is unlikely to handle the host's binaries.
 # Fortunately install-sh will honor a STRIPPROG variable, so we
-# always use install-sh in `make install-strip', and initialize
+# always use install-sh in "make install-strip", and initialize
 # STRIPPROG with the value of the STRIP variable (set by the user).
 AC_DEFUN([AM_PROG_INSTALL_STRIP],
 [AC_REQUIRE([AM_PROG_INSTALL_SH])dnl
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
-dnl Don't test for $cross_compiling = yes, because it might be `maybe'.
+# will honor the 'STRIP' environment variable to overrule this program.
+dnl Don't test for $cross_compiling = yes, because it might be 'maybe'.
 if test "$cross_compiling" != no; then
   AC_CHECK_TOOL([STRIP], [strip], :)
 fi
 INSTALL_STRIP_PROGRAM="\$(install_sh) -c -s"
 AC_SUBST([INSTALL_STRIP_PROGRAM])])
 
-# Copyright (C) 2006, 2008, 2010 Free Software Foundation, Inc.
+# Copyright (C) 2006-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
@@ -914,18 +929,18 @@
 
 # Check how to create a tarball.                            -*- Autoconf -*-
 
-# Copyright (C) 2004, 2005, 2012 Free Software Foundation, Inc.
+# Copyright (C) 2004-2012 Free Software Foundation, Inc.
 #
 # This file is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
 
-# serial 2
+# serial 3
 
 # _AM_PROG_TAR(FORMAT)
 # --------------------
 # Check how to create a tarball in format FORMAT.
-# FORMAT should be one of `v7', `ustar', or `pax'.
+# FORMAT should be one of 'v7', 'ustar', or 'pax'.
 #
 # Substitute a variable $(am__tar) that is a command
 # writing to stdout a FORMAT-tarball containing the directory
@@ -948,7 +963,7 @@
 _am_tools='gnutar m4_if([$1], [ustar], [plaintar]) pax cpio none'
 _am_tools=${am_cv_prog_tar_$1-$_am_tools}
 # Do not fold the above two line into one, because Tru64 sh and
-# Solaris sh will not grok spaces in the rhs of `-'.
+# Solaris sh will not grok spaces in the rhs of '-'.
 for _am_tool in $_am_tools
 do
   case $_am_tool in
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c third_party/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/aeabi_atexit.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,13 +0,0 @@
-#include <stdlib.h>
-
-/* forward declaration */
-extern int __cxa_atexit (void (*) (void *), void *, void *);
-
-/* Register a function to be called by exit or when a shared library
-   is unloaded.  This routine is like __cxa_atexit, but uses the
-   calling sequence required by the ARM EABI.  */
-int
-__aeabi_atexit (void *arg, void (*func) (void *), void *d)
-{
-  return __cxa_atexit (func, arg, d);
-}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/alarm.c third_party/newlib-3.2.0/newlib/libc/sys/arm/alarm.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/alarm.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/alarm.c	2022-06-29 14:50:02.717940889 +0100
@@ -0,0 +1,15 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+unsigned int alarm (unsigned int seconds)
+{
+    return _swi_alarm(seconds);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/arm.h third_party/newlib-3.2.0/newlib/libc/sys/arm/arm.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/arm.h	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/arm.h	2022-06-29 14:50:02.717940889 +0100
@@ -29,27 +29,25 @@
 #ifndef _LIBGLOSS_ARM_H
 #define _LIBGLOSS_ARM_H
 
-#include "acle-compat.h"
-
-/* Checking for targets supporting only Thumb instructions (eg. ARMv6-M) or
-   supporting Thumb-2 instructions, whether ARM instructions are available or
-   not, is done many times in libgloss/arm.  So factor it out and use
-   PREFER_THUMB instead.  */
-#if __thumb2__ || (__thumb__ && !__ARM_ARCH_ISA_ARM)
-# define PREFER_THUMB
-#endif
-
-/* Processor only capable of executing Thumb-1 instructions.  */
-#if __ARM_ARCH_ISA_THUMB == 1 && !__ARM_ARCH_ISA_ARM
-# define THUMB1_ONLY
+/* __thumb2__ stands for thumb on armva7(A/R/M/EM) architectures,
+   __ARM_ARCH_6M__ stands for armv6-M(thumb only) architecture,
+   __ARM_ARCH_7M__ stands for armv7-M(thumb only) architecture.
+   __ARM_ARCH_7EM__ stands for armv7e-M(thumb only) architecture.
+   There are some macro combinations used many times in libgloss/arm,
+   like (__thumb2__ || (__thumb__ && __ARM_ARCH_6M__)), so factor
+   it out and use THUMB_V7_V6M instead, which stands for thumb on
+   v6-m/v7 arch as the combination does.  */
+#if defined(__thumb2__) || (defined(__thumb__) && defined(__ARM_ARCH_6M__))
+# define THUMB_V7_V6M
 #endif
 
-/* M profile architectures.  This is a different set of architectures than
-   those not having ARM ISA because it does not contain ARMv7.  This macro is
-   necessary to test which architectures use bkpt as semihosting interface from
-   architectures using svc.  */
-#if !__ARM_ARCH_ISA_ARM && !__ARM_ARCH_7__
-# define THUMB_VXM
+/* The (__ARM_ARCH_7EM__ || __ARM_ARCH_7M__ || __ARM_ARCH_6M__) combination
+   stands for cortex-M profile architectures, which don't support ARM state.
+   Factor it out and use THUMB_V7M_V6M instead.  */
+#if defined(__ARM_ARCH_7M__)     \
+    || defined(__ARM_ARCH_7EM__) \
+    || defined(__ARM_ARCH_6M__)
+# define THUMB_V7M_V6M
 #endif
 
 /* Defined if this target supports the BLX Rm instruction.  */
@@ -61,30 +59,4 @@
 # define HAVE_CALL_INDIRECT
 #endif
 
-/* A and R profiles (and legacy Arm).
-	Current Program Status Register (CPSR)
-	M[4:0]		Mode bits. M[4] is always 1 for 32-bit modes.
-	T[5]			1: Thumb, 0: ARM instruction set
-	F[6]			1: disables FIQ
-	I[7]			1: disables IRQ
-	A[8]			1: disables imprecise aborts
-	E[9]			0: Little-endian, 1: Big-endian
-	J[24]			1: Jazelle instruction set
- */
-#define CPSR_M_USR			0x00	/* User mode.  */
-#define CPSR_M_FIQ			0x01	/* Fast Interrupt mode.  */
-#define CPSR_M_IRQ			0x02	/* Interrupt mode.  */
-#define CPSR_M_SVR			0x03	/* Supervisor mode.  */
-#define CPSR_M_MON			0x06	/* Monitor mode.  */
-#define CPSR_M_ABT			0x07	/* Abort mode.  */
-#define CPSR_M_HYP			0x0A	/* Hypervisor mode.  */
-#define CPSR_M_UND			0x0B	/* Undefined mode.  */
-#define CPSR_M_SYS			0x0F	/* System mode.  */
-#define CPSR_M_32BIT		0x10	/* 32-bit mode.  */
-#define CPSR_T_BIT			0x20	/* Thumb bit.  */
-#define CPSR_F_MASK			0x40	/* FIQ bit.  */
-#define CPSR_I_MASK			0x80	/* IRQ bit.  */
-
-#define CPSR_M_MASK			0x0F	/* Mode mask except M[4].  */
-
 #endif /* _LIBGLOSS_ARM_H */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/chmod.c third_party/newlib-3.2.0/newlib/libc/sys/arm/chmod.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/chmod.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/chmod.c	2022-06-29 14:50:02.717940889 +0100
@@ -0,0 +1,43 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+int chmod(const char *__path, mode_t __mode )
+{
+  int sc;
+  
+  sc = _swi_chmod(__path, __mode);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
+
+/*
+ *
+ */
+int chown (const char *__path, uid_t __owner, gid_t __group )
+{
+  int sc;
+  
+  sc = _swi_chown(__path, __owner, __group);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return sc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/close.c third_party/newlib-3.2.0/newlib/libc/sys/arm/close.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/close.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/close.c	2022-06-29 14:50:02.717940889 +0100
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int close (int fd)
+{
+    int sc;
+    
+    sc = _swi_close(fd);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/closedir.c third_party/newlib-3.2.0/newlib/libc/sys/arm/closedir.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/closedir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/closedir.c	2022-06-29 14:50:02.717940889 +0100
@@ -0,0 +1,32 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int closedir (DIR *dir)
+{
+    int sc;
+    	
+    if (dir == NULL) {
+        errno = EINVAL;
+        return -1;
+    }
+
+    sc = _swi_close (dir->fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    free (dir->buf);
+    free (dir);
+    return 0;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/configure third_party/newlib-3.2.0/newlib/libc/sys/arm/configure
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/configure	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/configure	2022-06-29 14:50:02.721940993 +0100
@@ -1,13 +1,11 @@
 #! /bin/sh
 # Guess values for system-dependent variables and create Makefiles.
-# Generated by GNU Autoconf 2.68 for newlib 3.2.0.
-#
+# Generated by GNU Autoconf 2.64 for newlib 3.2.0.
 #
 # Copyright (C) 1992, 1993, 1994, 1995, 1996, 1998, 1999, 2000, 2001,
-# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010 Free Software
+# 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software
 # Foundation, Inc.
 #
-#
 # This configure script is free software; the Free Software Foundation
 # gives unlimited permission to copy, distribute and modify it.
 ## -------------------- ##
@@ -89,7 +87,6 @@
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -214,18 +211,11 @@
   # We cannot yet assume a decent shell, so we have to provide a
 	# neutralization value for shells without unset; and this also
 	# works around shells that cannot unset nonexistent variables.
-	# Preserve -v and -x to the replacement shell.
 	BASH_ENV=/dev/null
 	ENV=/dev/null
 	(unset BASH_ENV) >/dev/null 2>&1 && unset BASH_ENV ENV
 	export CONFIG_SHELL
-	case $- in # ((((
-	  *v*x* | *x*v* ) as_opts=-vx ;;
-	  *v* ) as_opts=-v ;;
-	  *x* ) as_opts=-x ;;
-	  * ) as_opts= ;;
-	esac
-	exec "$CONFIG_SHELL" $as_opts "$as_myself" ${1+"$@"}
+	exec "$CONFIG_SHELL" "$as_myself" ${1+"$@"}
 fi
 
     if test x$as_have_required = xno; then :
@@ -323,7 +313,7 @@
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -363,19 +353,19 @@
 fi # as_fn_arith
 
 
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
+# script with status $?, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
   fi
-  $as_echo "$as_me: error: $2" >&2
+  $as_echo "$as_me: error: $1" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -533,11 +523,10 @@
 as_tr_sh="eval sed 'y%*+%pp%;s%[^_$as_cr_alnum]%_%g'"
 
 
-test -n "$DJDIR" || exec 7<&0 </dev/null
-exec 6>&1
+exec 7<&0 </dev/null 6>&1
 
 # Name of the host.
-# hostname on some systems (SVR3.2, old GNU/Linux) returns a bogus exit status,
+# hostname on some systems (SVR3.2, Linux) returns a bogus exit status,
 # so uname gets run too.
 ac_hostname=`(hostname || uname -n) 2>/dev/null | sed 1q`
 
@@ -561,7 +550,7 @@
 PACKAGE_BUGREPORT=''
 PACKAGE_URL=''
 
-ac_unique_file="trap.S"
+ac_unique_file="virtualalloc.c"
 ac_subst_vars='LTLIBOBJS
 LIBOBJS
 sys_dir
@@ -760,9 +749,8 @@
   fi
 
   case $ac_option in
-  *=?*) ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
-  *=)   ac_optarg= ;;
-  *)    ac_optarg=yes ;;
+  *=*)	ac_optarg=`expr "X$ac_option" : '[^=]*=\(.*\)'` ;;
+  *)	ac_optarg=yes ;;
   esac
 
   # Accept the important Cygnus configure options, so we can diagnose typos.
@@ -807,7 +795,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*disable-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -833,7 +821,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*enable-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid feature name: $ac_useropt"
+      as_fn_error "invalid feature name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1037,7 +1025,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*with-\([^=]*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1053,7 +1041,7 @@
     ac_useropt=`expr "x$ac_option" : 'x-*without-\(.*\)'`
     # Reject names that are not valid shell variable names.
     expr "x$ac_useropt" : ".*[^-+._$as_cr_alnum]" >/dev/null &&
-      as_fn_error $? "invalid package name: $ac_useropt"
+      as_fn_error "invalid package name: $ac_useropt"
     ac_useropt_orig=$ac_useropt
     ac_useropt=`$as_echo "$ac_useropt" | sed 's/[-+.]/_/g'`
     case $ac_user_opts in
@@ -1083,8 +1071,8 @@
   | --x-librar=* | --x-libra=* | --x-libr=* | --x-lib=* | --x-li=* | --x-l=*)
     x_libraries=$ac_optarg ;;
 
-  -*) as_fn_error $? "unrecognized option: \`$ac_option'
-Try \`$0 --help' for more information"
+  -*) as_fn_error "unrecognized option: \`$ac_option'
+Try \`$0 --help' for more information."
     ;;
 
   *=*)
@@ -1092,7 +1080,7 @@
     # Reject names that are not valid shell variable names.
     case $ac_envvar in #(
       '' | [0-9]* | *[!_$as_cr_alnum]* )
-      as_fn_error $? "invalid variable name: \`$ac_envvar'" ;;
+      as_fn_error "invalid variable name: \`$ac_envvar'" ;;
     esac
     eval $ac_envvar=\$ac_optarg
     export $ac_envvar ;;
@@ -1102,7 +1090,7 @@
     $as_echo "$as_me: WARNING: you should use --build, --host, --target" >&2
     expr "x$ac_option" : ".*[^-._$as_cr_alnum]" >/dev/null &&
       $as_echo "$as_me: WARNING: invalid host type: $ac_option" >&2
-    : "${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}"
+    : ${build_alias=$ac_option} ${host_alias=$ac_option} ${target_alias=$ac_option}
     ;;
 
   esac
@@ -1110,13 +1098,13 @@
 
 if test -n "$ac_prev"; then
   ac_option=--`echo $ac_prev | sed 's/_/-/g'`
-  as_fn_error $? "missing argument to $ac_option"
+  as_fn_error "missing argument to $ac_option"
 fi
 
 if test -n "$ac_unrecognized_opts"; then
   case $enable_option_checking in
     no) ;;
-    fatal) as_fn_error $? "unrecognized options: $ac_unrecognized_opts" ;;
+    fatal) as_fn_error "unrecognized options: $ac_unrecognized_opts" ;;
     *)     $as_echo "$as_me: WARNING: unrecognized options: $ac_unrecognized_opts" >&2 ;;
   esac
 fi
@@ -1139,7 +1127,7 @@
     [\\/$]* | ?:[\\/]* )  continue;;
     NONE | '' ) case $ac_var in *prefix ) continue;; esac;;
   esac
-  as_fn_error $? "expected an absolute directory name for --$ac_var: $ac_val"
+  as_fn_error "expected an absolute directory name for --$ac_var: $ac_val"
 done
 
 # There might be people who depend on the old broken behavior: `$host'
@@ -1153,8 +1141,8 @@
 if test "x$host_alias" != x; then
   if test "x$build_alias" = x; then
     cross_compiling=maybe
-    $as_echo "$as_me: WARNING: if you wanted to set the --build type, don't use --host.
-    If a cross compiler is detected then cross compile mode will be used" >&2
+    $as_echo "$as_me: WARNING: If you wanted to set the --build type, don't use --host.
+    If a cross compiler is detected then cross compile mode will be used." >&2
   elif test "x$build_alias" != "x$host_alias"; then
     cross_compiling=yes
   fi
@@ -1169,9 +1157,9 @@
 ac_pwd=`pwd` && test -n "$ac_pwd" &&
 ac_ls_di=`ls -di .` &&
 ac_pwd_ls_di=`cd "$ac_pwd" && ls -di .` ||
-  as_fn_error $? "working directory cannot be determined"
+  as_fn_error "working directory cannot be determined"
 test "X$ac_ls_di" = "X$ac_pwd_ls_di" ||
-  as_fn_error $? "pwd does not report name of working directory"
+  as_fn_error "pwd does not report name of working directory"
 
 
 # Find the source files, if location was not specified.
@@ -1210,11 +1198,11 @@
 fi
 if test ! -r "$srcdir/$ac_unique_file"; then
   test "$ac_srcdir_defaulted" = yes && srcdir="$ac_confdir or .."
-  as_fn_error $? "cannot find sources ($ac_unique_file) in $srcdir"
+  as_fn_error "cannot find sources ($ac_unique_file) in $srcdir"
 fi
 ac_msg="sources are in $srcdir, but \`cd $srcdir' does not work"
 ac_abs_confdir=`(
-	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error $? "$ac_msg"
+	cd "$srcdir" && test -r "./$ac_unique_file" || as_fn_error "$ac_msg"
 	pwd)`
 # When building in place, set srcdir=.
 if test "$ac_abs_confdir" = "$ac_pwd"; then
@@ -1254,7 +1242,7 @@
       --help=short        display options specific to this package
       --help=recursive    display the short help of all the included packages
   -V, --version           display version information and exit
-  -q, --quiet, --silent   do not print \`checking ...' messages
+  -q, --quiet, --silent   do not print \`checking...' messages
       --cache-file=FILE   cache test results in FILE [disabled]
   -C, --config-cache      alias for \`--cache-file=config.cache'
   -n, --no-create         do not create output files
@@ -1327,10 +1315,13 @@
   --disable-newlib-io-float disable printf/scanf family float support
   --disable-newlib-supplied-syscalls disable newlib from supplying syscalls
   --disable-newlib-fno-builtin disable -fno-builtin flag to allow compiler to use builtin library functions
-  --disable-dependency-tracking  speeds up one-time build
-  --enable-dependency-tracking   do not reject slow dependency extractors
-  --enable-maintainer-mode  enable make rules and dependencies not useful
-			  (and sometimes confusing) to the casual installer
+  --enable-dependency-tracking
+                          do not reject slow dependency extractors
+  --disable-dependency-tracking
+                          speeds up one-time build
+  --enable-maintainer-mode
+                          enable make rules and dependencies not useful (and
+                          sometimes confusing) to the casual installer
 
 Some influential environment variables:
   CCAS        assembler compiler command (defaults to CC)
@@ -1403,9 +1394,9 @@
 if $ac_init_version; then
   cat <<\_ACEOF
 newlib configure 3.2.0
-generated by GNU Autoconf 2.68
+generated by GNU Autoconf 2.64
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2009 Free Software Foundation, Inc.
 This configure script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it.
 _ACEOF
@@ -1449,8 +1440,8 @@
 
 	ac_retval=1
 fi
-  eval $as_lineno_stack; ${as_lineno_stack:+:} unset as_lineno
-  as_fn_set_status $ac_retval
+  eval $as_lineno_stack; test "x$as_lineno_stack" = x && { as_lineno=; unset as_lineno;}
+  return $ac_retval
 
 } # ac_fn_c_try_compile
 cat >config.log <<_ACEOF
@@ -1458,7 +1449,7 @@
 running configure, to aid debugging if configure makes a mistake.
 
 It was created by newlib $as_me 3.2.0, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.64.  Invocation command line was
 
   $ $0 $@
 
@@ -1568,9 +1559,11 @@
   {
     echo
 
-    $as_echo "## ---------------- ##
+    cat <<\_ASBOX
+## ---------------- ##
 ## Cache variables. ##
-## ---------------- ##"
+## ---------------- ##
+_ASBOX
     echo
     # The following way of writing the cache mishandles newlines in values,
 (
@@ -1604,9 +1597,11 @@
 )
     echo
 
-    $as_echo "## ----------------- ##
+    cat <<\_ASBOX
+## ----------------- ##
 ## Output variables. ##
-## ----------------- ##"
+## ----------------- ##
+_ASBOX
     echo
     for ac_var in $ac_subst_vars
     do
@@ -1619,9 +1614,11 @@
     echo
 
     if test -n "$ac_subst_files"; then
-      $as_echo "## ------------------- ##
+      cat <<\_ASBOX
+## ------------------- ##
 ## File substitutions. ##
-## ------------------- ##"
+## ------------------- ##
+_ASBOX
       echo
       for ac_var in $ac_subst_files
       do
@@ -1635,9 +1632,11 @@
     fi
 
     if test -s confdefs.h; then
-      $as_echo "## ----------- ##
+      cat <<\_ASBOX
+## ----------- ##
 ## confdefs.h. ##
-## ----------- ##"
+## ----------- ##
+_ASBOX
       echo
       cat confdefs.h
       echo
@@ -1692,12 +1691,7 @@
 ac_site_file1=NONE
 ac_site_file2=NONE
 if test -n "$CONFIG_SITE"; then
-  # We do not want a PATH search for config.site.
-  case $CONFIG_SITE in #((
-    -*)  ac_site_file1=./$CONFIG_SITE;;
-    */*) ac_site_file1=$CONFIG_SITE;;
-    *)   ac_site_file1=./$CONFIG_SITE;;
-  esac
+  ac_site_file1=$CONFIG_SITE
 elif test "x$prefix" != xNONE; then
   ac_site_file1=$prefix/share/config.site
   ac_site_file2=$prefix/etc/config.site
@@ -1708,22 +1702,18 @@
 for ac_site_file in "$ac_site_file1" "$ac_site_file2"
 do
   test "x$ac_site_file" = xNONE && continue
-  if test /dev/null != "$ac_site_file" && test -r "$ac_site_file"; then
+  if test -r "$ac_site_file"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading site script $ac_site_file" >&5
 $as_echo "$as_me: loading site script $ac_site_file" >&6;}
     sed 's/^/| /' "$ac_site_file" >&5
-    . "$ac_site_file" \
-      || { { $as_echo "$as_me:${as_lineno-$LINENO}: error: in \`$ac_pwd':" >&5
-$as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
-as_fn_error $? "failed to load site script $ac_site_file
-See \`config.log' for more details" "$LINENO" 5; }
+    . "$ac_site_file"
   fi
 done
 
 if test -r "$cache_file"; then
-  # Some versions of bash will fail to source /dev/null (special files
-  # actually), so we avoid doing that.  DJGPP emulates it as a regular file.
-  if test /dev/null != "$cache_file" && test -f "$cache_file"; then
+  # Some versions of bash will fail to source /dev/null (special
+  # files actually), so we avoid doing that.
+  if test -f "$cache_file"; then
     { $as_echo "$as_me:${as_lineno-$LINENO}: loading cache $cache_file" >&5
 $as_echo "$as_me: loading cache $cache_file" >&6;}
     case $cache_file in
@@ -1792,7 +1782,7 @@
 $as_echo "$as_me: error: in \`$ac_pwd':" >&2;}
   { $as_echo "$as_me:${as_lineno-$LINENO}: error: changes in the environment can compromise the build" >&5
 $as_echo "$as_me: error: changes in the environment can compromise the build" >&2;}
-  as_fn_error $? "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
+  as_fn_error "run \`make distclean' and/or \`rm $cache_file' and start over" "$LINENO" 5
 fi
 ## -------------------- ##
 ## Main body of script. ##
@@ -1809,22 +1799,16 @@
 
 ac_aux_dir=
 for ac_dir in ../../../.. "$srcdir"/../../../..; do
-  if test -f "$ac_dir/install-sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install-sh -c"
-    break
-  elif test -f "$ac_dir/install.sh"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/install.sh -c"
-    break
-  elif test -f "$ac_dir/shtool"; then
-    ac_aux_dir=$ac_dir
-    ac_install_sh="$ac_aux_dir/shtool install -c"
-    break
-  fi
+  for ac_t in install-sh install.sh shtool; do
+    if test -f "$ac_dir/$ac_t"; then
+      ac_aux_dir=$ac_dir
+      ac_install_sh="$ac_aux_dir/$ac_t -c"
+      break 2
+    fi
+  done
 done
 if test -z "$ac_aux_dir"; then
-  as_fn_error $? "cannot find install-sh, install.sh, or shtool in ../../../.. \"$srcdir\"/../../../.." "$LINENO" 5
+  as_fn_error "cannot find install-sh, install.sh, or shtool in ../../../.. \"$srcdir\"/../../../.." "$LINENO" 5
 fi
 
 # These three variables are undocumented and unsupported,
@@ -1840,27 +1824,27 @@
 
 # Make sure we can run config.sub.
 $SHELL "$ac_aux_dir/config.sub" sun4 >/dev/null 2>&1 ||
-  as_fn_error $? "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
+  as_fn_error "cannot run $SHELL $ac_aux_dir/config.sub" "$LINENO" 5
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking build system type" >&5
 $as_echo_n "checking build system type... " >&6; }
-if ${ac_cv_build+:} false; then :
+if test "${ac_cv_build+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_build_alias=$build_alias
 test "x$ac_build_alias" = x &&
   ac_build_alias=`$SHELL "$ac_aux_dir/config.guess"`
 test "x$ac_build_alias" = x &&
-  as_fn_error $? "cannot guess build type; you must specify one" "$LINENO" 5
+  as_fn_error "cannot guess build type; you must specify one" "$LINENO" 5
 ac_cv_build=`$SHELL "$ac_aux_dir/config.sub" $ac_build_alias` ||
-  as_fn_error $? "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
+  as_fn_error "$SHELL $ac_aux_dir/config.sub $ac_build_alias failed" "$LINENO" 5
 
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: $ac_cv_build" >&5
 $as_echo "$ac_cv_build" >&6; }
 case $ac_cv_build in
 *-*-*) ;;
-*) as_fn_error $? "invalid value of canonical build" "$LINENO" 5;;
+*) as_fn_error "invalid value of canonical build" "$LINENO" 5;;
 esac
 build=$ac_cv_build
 ac_save_IFS=$IFS; IFS='-'
@@ -1878,14 +1862,14 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking host system type" >&5
 $as_echo_n "checking host system type... " >&6; }
-if ${ac_cv_host+:} false; then :
+if test "${ac_cv_host+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test "x$host_alias" = x; then
   ac_cv_host=$ac_cv_build
 else
   ac_cv_host=`$SHELL "$ac_aux_dir/config.sub" $host_alias` ||
-    as_fn_error $? "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
+    as_fn_error "$SHELL $ac_aux_dir/config.sub $host_alias failed" "$LINENO" 5
 fi
 
 fi
@@ -1893,7 +1877,7 @@
 $as_echo "$ac_cv_host" >&6; }
 case $ac_cv_host in
 *-*-*) ;;
-*) as_fn_error $? "invalid value of canonical host" "$LINENO" 5;;
+*) as_fn_error "invalid value of canonical host" "$LINENO" 5;;
 esac
 host=$ac_cv_host
 ac_save_IFS=$IFS; IFS='-'
@@ -1909,7 +1893,7 @@
 case $host_os in *\ *) host_os=`echo "$host_os" | sed 's/ /-/g'`;; esac
 
 
-am__api_version='1.11'
+am__api_version='1.12'
 
 # Find a good install program.  We prefer a C program (faster),
 # so one script is as good as another.  But avoid the broken or
@@ -1928,7 +1912,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for a BSD-compatible install" >&5
 $as_echo_n "checking for a BSD-compatible install... " >&6; }
 if test -z "$INSTALL"; then
-if ${ac_cv_path_install+:} false; then :
+if test "${ac_cv_path_install+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -2006,56 +1990,71 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether build environment is sane" >&5
 $as_echo_n "checking whether build environment is sane... " >&6; }
-# Just in case
-sleep 1
-echo timestamp > conftest.file
 # Reject unsafe characters in $srcdir or the absolute working directory
 # name.  Accept space and tab only in the latter.
 am_lf='
 '
 case `pwd` in
   *[\\\"\#\$\&\'\`$am_lf]*)
-    as_fn_error $? "unsafe absolute working directory name" "$LINENO" 5;;
+    as_fn_error "unsafe absolute working directory name" "$LINENO" 5;;
 esac
 case $srcdir in
   *[\\\"\#\$\&\'\`$am_lf\ \	]*)
-    as_fn_error $? "unsafe srcdir value: \`$srcdir'" "$LINENO" 5;;
+    as_fn_error "unsafe srcdir value: '$srcdir'" "$LINENO" 5;;
 esac
 
-# Do `set' in a subshell so we don't clobber the current shell's
+# Do 'set' in a subshell so we don't clobber the current shell's
 # arguments.  Must try -L first in case configure is actually a
 # symlink; some systems play weird games with the mod time of symlinks
 # (eg FreeBSD returns the mod time of the symlink's containing
 # directory).
 if (
-   set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
-   if test "$*" = "X"; then
-      # -L didn't work.
-      set X `ls -t "$srcdir/configure" conftest.file`
-   fi
-   rm -f conftest.file
-   if test "$*" != "X $srcdir/configure conftest.file" \
-      && test "$*" != "X conftest.file $srcdir/configure"; then
-
-      # If neither matched, then we have a broken ls.  This can happen
-      # if, for instance, CONFIG_SHELL is bash and it inherits a
-      # broken ls alias from the environment.  This has actually
-      # happened.  Such a system could not be considered "sane".
-      as_fn_error $? "ls -t appears to fail.  Make sure there is not a broken
-alias in your environment" "$LINENO" 5
-   fi
+   am_has_slept=no
+   for am_try in 1 2; do
+     echo "timestamp, slept: $am_has_slept" > conftest.file
+     set X `ls -Lt "$srcdir/configure" conftest.file 2> /dev/null`
+     if test "$*" = "X"; then
+	# -L didn't work.
+	set X `ls -t "$srcdir/configure" conftest.file`
+     fi
+     if test "$*" != "X $srcdir/configure conftest.file" \
+	&& test "$*" != "X conftest.file $srcdir/configure"; then
 
+	# If neither matched, then we have a broken ls.  This can happen
+	# if, for instance, CONFIG_SHELL is bash and it inherits a
+	# broken ls alias from the environment.  This has actually
+	# happened.  Such a system could not be considered "sane".
+	as_fn_error "ls -t appears to fail.  Make sure there is not a broken
+  alias in your environment" "$LINENO" 5
+     fi
+     if test "$2" = conftest.file || test $am_try -eq 2; then
+       break
+     fi
+     # Just in case.
+     sleep 1
+     am_has_slept=yes
+   done
    test "$2" = conftest.file
    )
 then
    # Ok.
    :
 else
-   as_fn_error $? "newly created file is older than distributed files!
+   as_fn_error "newly created file is older than distributed files!
 Check your system clock" "$LINENO" 5
 fi
 { $as_echo "$as_me:${as_lineno-$LINENO}: result: yes" >&5
 $as_echo "yes" >&6; }
+# If we didn't sleep, we still need to ensure time stamps of config.status and
+# generated files are strictly newer.
+am_sleep_pid=
+if grep 'slept: no' conftest.file >/dev/null 2>&1; then
+  ( sleep 1 ) &
+  am_sleep_pid=$!
+fi
+
+rm -f conftest.file
+
 test "$program_prefix" != NONE &&
   program_transform_name="s&^&$program_prefix&;$program_transform_name"
 # Use a double $ so make ignores it.
@@ -2082,8 +2081,8 @@
   am_missing_run="$MISSING --run "
 else
   am_missing_run=
-  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: \`missing' script is too old or missing" >&5
-$as_echo "$as_me: WARNING: \`missing' script is too old or missing" >&2;}
+  { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: 'missing' script is too old or missing" >&5
+$as_echo "$as_me: WARNING: 'missing' script is too old or missing" >&2;}
 fi
 
 if test x"${install_sh}" != xset; then
@@ -2095,17 +2094,17 @@
   esac
 fi
 
-# Installed binaries are usually stripped using `strip' when the user
-# run `make install-strip'.  However `strip' might not be the right
+# Installed binaries are usually stripped using 'strip' when the user
+# run "make install-strip".  However 'strip' might not be the right
 # tool to use in cross-compilation environments, therefore Automake
-# will honor the `STRIP' environment variable to overrule this program.
+# will honor the 'STRIP' environment variable to overrule this program.
 if test "$cross_compiling" != no; then
   if test -n "$ac_tool_prefix"; then
   # Extract the first word of "${ac_tool_prefix}strip", so it can be a program name with args.
 set dummy ${ac_tool_prefix}strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_STRIP+:} false; then :
+if test "${ac_cv_prog_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$STRIP"; then
@@ -2145,7 +2144,7 @@
 set dummy strip; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_STRIP+:} false; then :
+if test "${ac_cv_prog_ac_ct_STRIP+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_STRIP"; then
@@ -2198,7 +2197,7 @@
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for a thread-safe mkdir -p" >&5
 $as_echo_n "checking for a thread-safe mkdir -p... " >&6; }
 if test -z "$MKDIR_P"; then
-  if ${ac_cv_path_mkdir+:} false; then :
+  if test "${ac_cv_path_mkdir+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -2223,7 +2222,6 @@
 
 fi
 
-  test -d ./--version && rmdir ./--version
   if test "${ac_cv_path_mkdir+set}" = set; then
     MKDIR_P="$ac_cv_path_mkdir -p"
   else
@@ -2231,6 +2229,7 @@
     # value for MKDIR_P within a source directory, because that will
     # break other packages using the cache if that directory is
     # removed, or if the value is a relative name.
+    test -d ./--version && rmdir ./--version
     MKDIR_P="$ac_install_sh -d"
   fi
 fi
@@ -2249,7 +2248,7 @@
 set dummy $ac_prog; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AWK+:} false; then :
+if test "${ac_cv_prog_AWK+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AWK"; then
@@ -2289,7 +2288,7 @@
 $as_echo_n "checking whether ${MAKE-make} sets \$(MAKE)... " >&6; }
 set x ${MAKE-make}
 ac_make=`$as_echo "$2" | sed 's/+/p/g; s/[^a-zA-Z0-9_]/_/g'`
-if eval \${ac_cv_prog_make_${ac_make}_set+:} false; then :
+if { as_var=ac_cv_prog_make_${ac_make}_set; eval "test \"\${$as_var+set}\" = set"; }; then :
   $as_echo_n "(cached) " >&6
 else
   cat >conftest.make <<\_ACEOF
@@ -2297,7 +2296,7 @@
 all:
 	@echo '@@@%%%=$(MAKE)=@@@%%%'
 _ACEOF
-# GNU make sometimes prints "make[1]: Entering ...", which would confuse us.
+# GNU make sometimes prints "make[1]: Entering...", which would confuse us.
 case `${MAKE-make} -f conftest.make 2>/dev/null` in
   *@@@%%%=?*=@@@%%%*)
     eval ac_cv_prog_make_${ac_make}_set=yes;;
@@ -2344,7 +2343,7 @@
 _am_result=none
 # First try GNU make style include.
 echo "include confinc" > confmf
-# Ignore all kinds of additional output from `make'.
+# Ignore all kinds of additional output from 'make'.
 case `$am_make -s -f confmf 2> /dev/null` in #(
 *the\ am__doit\ target*)
   am__include=include
@@ -2394,7 +2393,7 @@
   enableval=$enable_multilib; case "${enableval}" in
   yes) multilib=yes ;;
   no)  multilib=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for multilib option" "$LINENO" 5 ;;
  esac
 else
   multilib=yes
@@ -2405,7 +2404,7 @@
   enableval=$enable_target_optspace; case "${enableval}" in
   yes) target_optspace=yes ;;
   no)  target_optspace=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for target-optspace option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for target-optspace option" "$LINENO" 5 ;;
  esac
 else
   target_optspace=
@@ -2416,7 +2415,7 @@
   enableval=$enable_malloc_debugging; case "${enableval}" in
   yes) malloc_debugging=yes ;;
   no)  malloc_debugging=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for malloc-debugging option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for malloc-debugging option" "$LINENO" 5 ;;
  esac
 else
   malloc_debugging=
@@ -2427,7 +2426,7 @@
   enableval=$enable_newlib_multithread; case "${enableval}" in
   yes) newlib_multithread=yes ;;
   no)  newlib_multithread=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-multithread option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-multithread option" "$LINENO" 5 ;;
  esac
 else
   newlib_multithread=yes
@@ -2439,7 +2438,7 @@
    case "${enableval}" in
      yes) newlib_iconv=yes ;;
      no)  newlib_iconv=no ;;
-     *)   as_fn_error $? "bad value ${enableval} for newlib-iconv option" "$LINENO" 5 ;;
+     *)   as_fn_error "bad value ${enableval} for newlib-iconv option" "$LINENO" 5 ;;
    esac
  fi
 else
@@ -2454,7 +2453,7 @@
   2)   newlib_elix_level=2 ;;
   3)   newlib_elix_level=3 ;;
   4)   newlib_elix_level=4 ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-elix-level option" "$LINENO" 5 ;;
  esac
 else
   newlib_elix_level=0
@@ -2465,7 +2464,7 @@
   enableval=$enable_newlib_io_float; case "${enableval}" in
   yes) newlib_io_float=yes ;;
   no)  newlib_io_float=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-io-float option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-io-float option" "$LINENO" 5 ;;
  esac
 else
   newlib_io_float=yes
@@ -2476,7 +2475,7 @@
   enableval=$enable_newlib_supplied_syscalls; case "${enableval}" in
   yes) newlib_may_supply_syscalls=yes ;;
   no)  newlib_may_supply_syscalls=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-supplied-syscalls option" "$LINENO" 5 ;;
  esac
 else
   newlib_may_supply_syscalls=yes
@@ -2496,7 +2495,7 @@
   enableval=$enable_newlib_fno_builtin; case "${enableval}" in
   yes) newlib_fno_builtin=yes ;;
   no)  newlib_fno_builtin=no ;;
-  *)   as_fn_error $? "bad value ${enableval} for newlib-fno-builtin option" "$LINENO" 5 ;;
+  *)   as_fn_error "bad value ${enableval} for newlib-fno-builtin option" "$LINENO" 5 ;;
  esac
 else
   newlib_fno_builtin=
@@ -2525,7 +2524,7 @@
   am__isrc=' -I$(srcdir)'
   # test to see if srcdir already configured
   if test -f $srcdir/config.status; then
-    as_fn_error $? "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
+    as_fn_error "source directory already configured; run \"make distclean\" there first" "$LINENO" 5
   fi
 fi
 
@@ -2589,7 +2588,7 @@
 set dummy gcc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2627,15 +2626,15 @@
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking dependency style of $depcc" >&5
 $as_echo_n "checking dependency style of $depcc... " >&6; }
-if ${am_cv_CC_dependencies_compiler_type+:} false; then :
+if test "${am_cv_CC_dependencies_compiler_type+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -z "$AMDEP_TRUE" && test -f "$am_depcomp"; then
   # We make a subdir and do the tests there.  Otherwise we can end up
   # making bogus files that we don't know about and never remove.  For
   # instance it was reported that on HP-UX the gcc test will end up
-  # making a dummy file named `D' -- because `-MD' means `put the output
-  # in D'.
+  # making a dummy file named 'D' -- because '-MD' means "put the output
+  # in D".
   rm -rf conftest.dir
   mkdir conftest.dir
   # Copy depcomp to subdir because otherwise we won't find it if we're
@@ -2670,16 +2669,16 @@
     : > sub/conftest.c
     for i in 1 2 3 4 5 6; do
       echo '#include "conftst'$i'.h"' >> sub/conftest.c
-      # Using `: > sub/conftst$i.h' creates only sub/conftst1.h with
-      # Solaris 8's {/usr,}/bin/sh.
-      touch sub/conftst$i.h
+      # Using ": > sub/conftst$i.h" creates only sub/conftst1.h with
+      # Solaris 10 /bin/sh.
+      echo '/* dummy */' > sub/conftst$i.h
     done
     echo "${am__include} ${am__quote}sub/conftest.Po${am__quote}" > confmf
 
-    # We check with `-c' and `-o' for the sake of the "dashmstdout"
+    # We check with '-c' and '-o' for the sake of the "dashmstdout"
     # mode.  It turns out that the SunPro C++ compiler does not properly
-    # handle `-M -o', and we need to detect this.  Also, some Intel
-    # versions had trouble with output in subdirs
+    # handle '-M -o', and we need to detect this.  Also, some Intel
+    # versions had trouble with output in subdirs.
     am__obj=sub/conftest.${OBJEXT-o}
     am__minus_obj="-o $am__obj"
     case $depmode in
@@ -2688,8 +2687,8 @@
       test "$am__universal" = false || continue
       ;;
     nosideeffect)
-      # after this tag, mechanisms are not by side-effect, so they'll
-      # only be used when explicitly requested
+      # After this tag, mechanisms are not by side-effect, so they'll
+      # only be used when explicitly requested.
       if test "x$enable_dependency_tracking" = xyes; then
 	continue
       else
@@ -2697,7 +2696,7 @@
       fi
       ;;
     msvc7 | msvc7msys | msvisualcpp | msvcmsys)
-      # This compiler won't grok `-c -o', but also, the minuso test has
+      # This compiler won't grok '-c -o', but also, the minuso test has
       # not run yet.  These depmodes are late enough in the game, and
       # so weak that their functioning should not be impacted.
       am__obj=conftest.${OBJEXT-o}
@@ -2756,7 +2755,7 @@
 set dummy cc; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_CC+:} false; then :
+if test "${ac_cv_prog_CC+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$CC"; then
@@ -2806,12 +2805,12 @@
 fi
 
 
-  test -z "$CC" && as_fn_error $? "no acceptable cc found in \$PATH" "$LINENO" 5
+  test -z "$CC" && as_fn_error "no acceptable cc found in \$PATH" "$LINENO" 5
 fi
 
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether we are using GNU C" >&5
 $as_echo_n "checking whether we are using GNU C... " >&6; }
-if ${ac_cv_c_compiler_gnu+:} false; then :
+if test "${ac_cv_c_compiler_gnu+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   cat > conftest.c <<EOF
@@ -2841,7 +2840,7 @@
 ac_save_CFLAGS=$CFLAGS
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether $CC accepts -g" >&5
 $as_echo_n "checking whether $CC accepts -g... " >&6; }
-if ${ac_cv_prog_cc_g+:} false; then :
+if test "${ac_cv_prog_cc_g+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   ac_save_c_werror_flag=$ac_c_werror_flag
@@ -2935,7 +2934,7 @@
 set dummy ${ac_tool_prefix}as; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AS+:} false; then :
+if test "${ac_cv_prog_AS+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AS"; then
@@ -2975,7 +2974,7 @@
 set dummy as; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AS+:} false; then :
+if test "${ac_cv_prog_ac_ct_AS+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_AS"; then
@@ -3027,7 +3026,7 @@
 set dummy ${ac_tool_prefix}ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_AR+:} false; then :
+if test "${ac_cv_prog_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$AR"; then
@@ -3067,7 +3066,7 @@
 set dummy ar; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_AR+:} false; then :
+if test "${ac_cv_prog_ac_ct_AR+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_AR"; then
@@ -3119,7 +3118,7 @@
 set dummy ${ac_tool_prefix}ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_RANLIB+:} false; then :
+if test "${ac_cv_prog_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$RANLIB"; then
@@ -3159,7 +3158,7 @@
 set dummy ranlib; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_RANLIB+:} false; then :
+if test "${ac_cv_prog_ac_ct_RANLIB+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_RANLIB"; then
@@ -3211,7 +3210,7 @@
 set dummy ${ac_tool_prefix}readelf; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_READELF+:} false; then :
+if test "${ac_cv_prog_READELF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$READELF"; then
@@ -3251,7 +3250,7 @@
 set dummy readelf; ac_word=$2
 { $as_echo "$as_me:${as_lineno-$LINENO}: checking for $ac_word" >&5
 $as_echo_n "checking for $ac_word... " >&6; }
-if ${ac_cv_prog_ac_ct_READELF+:} false; then :
+if test "${ac_cv_prog_ac_ct_READELF+set}" = set; then :
   $as_echo_n "(cached) " >&6
 else
   if test -n "$ac_ct_READELF"; then
@@ -3494,21 +3493,10 @@
      :end' >>confcache
 if diff "$cache_file" confcache >/dev/null 2>&1; then :; else
   if test -w "$cache_file"; then
-    if test "x$cache_file" != "x/dev/null"; then
+    test "x$cache_file" != "x/dev/null" &&
       { $as_echo "$as_me:${as_lineno-$LINENO}: updating cache $cache_file" >&5
 $as_echo "$as_me: updating cache $cache_file" >&6;}
-      if test ! -f "$cache_file" || test -h "$cache_file"; then
-	cat confcache >"$cache_file"
-      else
-        case $cache_file in #(
-        */* | ?:*)
-	  mv -f confcache "$cache_file"$$ &&
-	  mv -f "$cache_file"$$ "$cache_file" ;; #(
-        *)
-	  mv -f confcache "$cache_file" ;;
-	esac
-      fi
-    fi
+    cat confcache >$cache_file
   else
     { $as_echo "$as_me:${as_lineno-$LINENO}: not updating unwritable cache $cache_file" >&5
 $as_echo "$as_me: not updating unwritable cache $cache_file" >&6;}
@@ -3560,7 +3548,6 @@
 
 ac_libobjs=
 ac_ltlibobjs=
-U=
 for ac_i in : $LIBOBJS; do test "x$ac_i" = x: && continue
   # 1. Remove the extension, and $U if already installed.
   ac_script='s/\$U\././;s/\.o$//;s/\.obj$//'
@@ -3576,48 +3563,56 @@
 
 
 if test -z "${MAY_SUPPLY_SYSCALLS_TRUE}" && test -z "${MAY_SUPPLY_SYSCALLS_FALSE}"; then
-  as_fn_error $? "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
+  as_fn_error "conditional \"MAY_SUPPLY_SYSCALLS\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
+{ $as_echo "$as_me:${as_lineno-$LINENO}: checking that generated files are newer than configure" >&5
+$as_echo_n "checking that generated files are newer than configure... " >&6; }
+   if test -n "$am_sleep_pid"; then
+     # Hide warnings about reused PIDs.
+     wait $am_sleep_pid 2>/dev/null
+   fi
+   { $as_echo "$as_me:${as_lineno-$LINENO}: result: done" >&5
+$as_echo "done" >&6; }
 
 if test -z "${AMDEP_TRUE}" && test -z "${AMDEP_FALSE}"; then
-  as_fn_error $? "conditional \"AMDEP\" was never defined.
+  as_fn_error "conditional \"AMDEP\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${am__fastdepCC_TRUE}" && test -z "${am__fastdepCC_FALSE}"; then
-  as_fn_error $? "conditional \"am__fastdepCC\" was never defined.
+  as_fn_error "conditional \"am__fastdepCC\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${MAINTAINER_MODE_TRUE}" && test -z "${MAINTAINER_MODE_FALSE}"; then
-  as_fn_error $? "conditional \"MAINTAINER_MODE\" was never defined.
+  as_fn_error "conditional \"MAINTAINER_MODE\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_0_TRUE}" && test -z "${ELIX_LEVEL_0_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_0\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_0\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_1_TRUE}" && test -z "${ELIX_LEVEL_1_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_1\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_1\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_2_TRUE}" && test -z "${ELIX_LEVEL_2_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_2\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_2\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_3_TRUE}" && test -z "${ELIX_LEVEL_3_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_3\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_3\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${ELIX_LEVEL_4_TRUE}" && test -z "${ELIX_LEVEL_4_FALSE}"; then
-  as_fn_error $? "conditional \"ELIX_LEVEL_4\" was never defined.
+  as_fn_error "conditional \"ELIX_LEVEL_4\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 if test -z "${USE_LIBTOOL_TRUE}" && test -z "${USE_LIBTOOL_FALSE}"; then
-  as_fn_error $? "conditional \"USE_LIBTOOL\" was never defined.
+  as_fn_error "conditional \"USE_LIBTOOL\" was never defined.
 Usually this means the macro was only invoked conditionally." "$LINENO" 5
 fi
 
-: "${CONFIG_STATUS=./config.status}"
+: ${CONFIG_STATUS=./config.status}
 ac_write_fail=0
 ac_clean_files_save=$ac_clean_files
 ac_clean_files="$ac_clean_files $CONFIG_STATUS"
@@ -3718,7 +3713,6 @@
 IFS=" ""	$as_nl"
 
 # Find who we are.  Look in the path if we contain no directory separator.
-as_myself=
 case $0 in #((
   *[\\/]* ) as_myself=$0 ;;
   *) as_save_IFS=$IFS; IFS=$PATH_SEPARATOR
@@ -3764,19 +3758,19 @@
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 
-# as_fn_error STATUS ERROR [LINENO LOG_FD]
-# ----------------------------------------
+# as_fn_error ERROR [LINENO LOG_FD]
+# ---------------------------------
 # Output "`basename $0`: error: ERROR" to stderr. If LINENO and LOG_FD are
 # provided, also output the error to LOG_FD, referencing LINENO. Then exit the
-# script with STATUS, using 1 if that was 0.
+# script with status $?, using 1 if that was 0.
 as_fn_error ()
 {
-  as_status=$1; test $as_status -eq 0 && as_status=1
-  if test "$4"; then
-    as_lineno=${as_lineno-"$3"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
-    $as_echo "$as_me:${as_lineno-$LINENO}: error: $2" >&$4
+  as_status=$?; test $as_status -eq 0 && as_status=1
+  if test "$3"; then
+    as_lineno=${as_lineno-"$2"} as_lineno_stack=as_lineno_stack=$as_lineno_stack
+    $as_echo "$as_me:${as_lineno-$LINENO}: error: $1" >&$3
   fi
-  $as_echo "$as_me: error: $2" >&2
+  $as_echo "$as_me: error: $1" >&2
   as_fn_exit $as_status
 } # as_fn_error
 
@@ -3972,7 +3966,7 @@
       test -d "$as_dir" && break
     done
     test -z "$as_dirs" || eval "mkdir $as_dirs"
-  } || test -d "$as_dir" || as_fn_error $? "cannot create directory $as_dir"
+  } || test -d "$as_dir" || as_fn_error "cannot create directory $as_dir"
 
 
 } # as_fn_mkdir_p
@@ -4026,7 +4020,7 @@
 # values after options handling.
 ac_log="
 This file was extended by newlib $as_me 3.2.0, which was
-generated by GNU Autoconf 2.68.  Invocation command line was
+generated by GNU Autoconf 2.64.  Invocation command line was
 
   CONFIG_FILES    = $CONFIG_FILES
   CONFIG_HEADERS  = $CONFIG_HEADERS
@@ -4062,7 +4056,6 @@
 
   -h, --help       print this help, then exit
   -V, --version    print version number and configuration settings, then exit
-      --config     print configuration, then exit
   -q, --quiet, --silent
                    do not print progress messages
   -d, --debug      don't remove temporary files
@@ -4080,13 +4073,12 @@
 
 _ACEOF
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-ac_cs_config="`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`"
 ac_cs_version="\\
 newlib config.status 3.2.0
-configured by $0, generated by GNU Autoconf 2.68,
-  with options \\"\$ac_cs_config\\"
+configured by $0, generated by GNU Autoconf 2.64,
+  with options \\"`$as_echo "$ac_configure_args" | sed 's/^ //; s/[\\""\`\$]/\\\\&/g'`\\"
 
-Copyright (C) 2010 Free Software Foundation, Inc.
+Copyright (C) 2009 Free Software Foundation, Inc.
 This config.status script is free software; the Free Software Foundation
 gives unlimited permission to copy, distribute and modify it."
 
@@ -4104,16 +4096,11 @@
 while test $# != 0
 do
   case $1 in
-  --*=?*)
+  --*=*)
     ac_option=`expr "X$1" : 'X\([^=]*\)='`
     ac_optarg=`expr "X$1" : 'X[^=]*=\(.*\)'`
     ac_shift=:
     ;;
-  --*=)
-    ac_option=`expr "X$1" : 'X\([^=]*\)='`
-    ac_optarg=
-    ac_shift=:
-    ;;
   *)
     ac_option=$1
     ac_optarg=$2
@@ -4127,15 +4114,12 @@
     ac_cs_recheck=: ;;
   --version | --versio | --versi | --vers | --ver | --ve | --v | -V )
     $as_echo "$ac_cs_version"; exit ;;
-  --config | --confi | --conf | --con | --co | --c )
-    $as_echo "$ac_cs_config"; exit ;;
   --debug | --debu | --deb | --de | --d | -d )
     debug=: ;;
   --file | --fil | --fi | --f )
     $ac_shift
     case $ac_optarg in
     *\'*) ac_optarg=`$as_echo "$ac_optarg" | sed "s/'/'\\\\\\\\''/g"` ;;
-    '') as_fn_error $? "missing file argument" ;;
     esac
     as_fn_append CONFIG_FILES " '$ac_optarg'"
     ac_need_defaults=false;;
@@ -4146,7 +4130,7 @@
     ac_cs_silent=: ;;
 
   # This is an error.
-  -*) as_fn_error $? "unrecognized option: \`$1'
+  -*) as_fn_error "unrecognized option: \`$1'
 Try \`$0 --help' for more information." ;;
 
   *) as_fn_append ac_config_targets " $1"
@@ -4203,7 +4187,7 @@
     "depfiles") CONFIG_COMMANDS="$CONFIG_COMMANDS depfiles" ;;
     "Makefile") CONFIG_FILES="$CONFIG_FILES Makefile" ;;
 
-  *) as_fn_error $? "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
+  *) as_fn_error "invalid argument: \`$ac_config_target'" "$LINENO" 5;;
   esac
 done
 
@@ -4225,10 +4209,9 @@
 # after its creation but before its name has been assigned to `$tmp'.
 $debug ||
 {
-  tmp= ac_tmp=
+  tmp=
   trap 'exit_status=$?
-  : "${ac_tmp:=$tmp}"
-  { test ! -d "$ac_tmp" || rm -fr "$ac_tmp"; } && exit $exit_status
+  { test -z "$tmp" || test ! -d "$tmp" || rm -fr "$tmp"; } && exit $exit_status
 ' 0
   trap 'as_fn_exit 1' 1 2 13 15
 }
@@ -4236,13 +4219,12 @@
 
 {
   tmp=`(umask 077 && mktemp -d "./confXXXXXX") 2>/dev/null` &&
-  test -d "$tmp"
+  test -n "$tmp" && test -d "$tmp"
 }  ||
 {
   tmp=./conf$$-$RANDOM
   (umask 077 && mkdir "$tmp")
-} || as_fn_error $? "cannot create a temporary directory in ." "$LINENO" 5
-ac_tmp=$tmp
+} || as_fn_error "cannot create a temporary directory in ." "$LINENO" 5
 
 # Set up the scripts for CONFIG_FILES section.
 # No need to generate them if there are no CONFIG_FILES.
@@ -4259,12 +4241,12 @@
 fi
 ac_cs_awk_cr=`$AWK 'BEGIN { print "a\rb" }' </dev/null 2>/dev/null`
 if test "$ac_cs_awk_cr" = "a${ac_cr}b"; then
-  ac_cs_awk_cr='\\r'
+  ac_cs_awk_cr='\r'
 else
   ac_cs_awk_cr=$ac_cr
 fi
 
-echo 'BEGIN {' >"$ac_tmp/subs1.awk" &&
+echo 'BEGIN {' >"$tmp/subs1.awk" &&
 _ACEOF
 
 
@@ -4273,18 +4255,18 @@
   echo "$ac_subst_vars" | sed 's/.*/&!$&$ac_delim/' &&
   echo "_ACEOF"
 } >conf$$subs.sh ||
-  as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
-ac_delim_num=`echo "$ac_subst_vars" | grep -c '^'`
+  as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
+ac_delim_num=`echo "$ac_subst_vars" | grep -c '$'`
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   . ./conf$$subs.sh ||
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
 
   ac_delim_n=`sed -n "s/.*$ac_delim\$/X/p" conf$$subs.awk | grep -c X`
   if test $ac_delim_n = $ac_delim_num; then
     break
   elif $ac_last_try; then
-    as_fn_error $? "could not make $CONFIG_STATUS" "$LINENO" 5
+    as_fn_error "could not make $CONFIG_STATUS" "$LINENO" 5
   else
     ac_delim="$ac_delim!$ac_delim _$ac_delim!! "
   fi
@@ -4292,7 +4274,7 @@
 rm -f conf$$subs.sh
 
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
-cat >>"\$ac_tmp/subs1.awk" <<\\_ACAWK &&
+cat >>"\$tmp/subs1.awk" <<\\_ACAWK &&
 _ACEOF
 sed -n '
 h
@@ -4306,7 +4288,7 @@
 t delim
 :nl
 h
-s/\(.\{148\}\)..*/\1/
+s/\(.\{148\}\).*/\1/
 t more1
 s/["\\]/\\&/g; s/^/"/; s/$/\\n"\\/
 p
@@ -4320,7 +4302,7 @@
 t nl
 :delim
 h
-s/\(.\{148\}\)..*/\1/
+s/\(.\{148\}\).*/\1/
 t more2
 s/["\\]/\\&/g; s/^/"/; s/$/"/
 p
@@ -4340,7 +4322,7 @@
 rm -f conf$$subs.awk
 cat >>$CONFIG_STATUS <<_ACEOF || ac_write_fail=1
 _ACAWK
-cat >>"\$ac_tmp/subs1.awk" <<_ACAWK &&
+cat >>"\$tmp/subs1.awk" <<_ACAWK &&
   for (key in S) S_is_set[key] = 1
   FS = ""
 
@@ -4372,29 +4354,21 @@
   sed "s/$ac_cr\$//; s/$ac_cr/$ac_cs_awk_cr/g"
 else
   cat
-fi < "$ac_tmp/subs1.awk" > "$ac_tmp/subs.awk" \
-  || as_fn_error $? "could not setup config files machinery" "$LINENO" 5
+fi < "$tmp/subs1.awk" > "$tmp/subs.awk" \
+  || as_fn_error "could not setup config files machinery" "$LINENO" 5
 _ACEOF
 
-# VPATH may cause trouble with some makes, so we remove sole $(srcdir),
-# ${srcdir} and @srcdir@ entries from VPATH if srcdir is ".", strip leading and
+# VPATH may cause trouble with some makes, so we remove $(srcdir),
+# ${srcdir} and @srcdir@ from VPATH if srcdir is ".", strip leading and
 # trailing colons and then remove the whole line if VPATH becomes empty
 # (actually we leave an empty line to preserve line numbers).
 if test "x$srcdir" = x.; then
-  ac_vpsub='/^[	 ]*VPATH[	 ]*=[	 ]*/{
-h
-s///
-s/^/:/
-s/[	 ]*$/:/
-s/:\$(srcdir):/:/g
-s/:\${srcdir}:/:/g
-s/:@srcdir@:/:/g
-s/^:*//
+  ac_vpsub='/^[	 ]*VPATH[	 ]*=/{
+s/:*\$(srcdir):*/:/
+s/:*\${srcdir}:*/:/
+s/:*@srcdir@:*/:/
+s/^\([^=]*=[	 ]*\):*/\1/
 s/:*$//
-x
-s/\(=[	 ]*\).*/\1/
-G
-s/\n//
 s/^[^=]*=[	 ]*$//
 }'
 fi
@@ -4412,7 +4386,7 @@
   esac
   case $ac_mode$ac_tag in
   :[FHL]*:*);;
-  :L* | :C*:*) as_fn_error $? "invalid tag \`$ac_tag'" "$LINENO" 5;;
+  :L* | :C*:*) as_fn_error "invalid tag \`$ac_tag'" "$LINENO" 5;;
   :[FH]-) ac_tag=-:-;;
   :[FH]*) ac_tag=$ac_tag:$ac_tag.in;;
   esac
@@ -4431,7 +4405,7 @@
     for ac_f
     do
       case $ac_f in
-      -) ac_f="$ac_tmp/stdin";;
+      -) ac_f="$tmp/stdin";;
       *) # Look for the file first in the build tree, then in the source tree
 	 # (if the path is not absolute).  The absolute path cannot be DOS-style,
 	 # because $ac_f cannot contain `:'.
@@ -4440,7 +4414,7 @@
 	   [\\/$]*) false;;
 	   *) test -f "$srcdir/$ac_f" && ac_f="$srcdir/$ac_f";;
 	   esac ||
-	   as_fn_error 1 "cannot find input file: \`$ac_f'" "$LINENO" 5;;
+	   as_fn_error "cannot find input file: \`$ac_f'" "$LINENO" 5;;
       esac
       case $ac_f in *\'*) ac_f=`$as_echo "$ac_f" | sed "s/'/'\\\\\\\\''/g"`;; esac
       as_fn_append ac_file_inputs " '$ac_f'"
@@ -4466,8 +4440,8 @@
     esac
 
     case $ac_tag in
-    *:-:* | *:-) cat >"$ac_tmp/stdin" \
-      || as_fn_error $? "could not create $ac_file" "$LINENO" 5 ;;
+    *:-:* | *:-) cat >"$tmp/stdin" \
+      || as_fn_error "could not create $ac_file" "$LINENO" 5 ;;
     esac
     ;;
   esac
@@ -4603,24 +4577,23 @@
 s&@MKDIR_P@&$ac_MKDIR_P&;t t
 $ac_datarootdir_hack
 "
-eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$ac_tmp/subs.awk" \
-  >$ac_tmp/out || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+eval sed \"\$ac_sed_extra\" "$ac_file_inputs" | $AWK -f "$tmp/subs.awk" >$tmp/out \
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
 
 test -z "$ac_datarootdir_hack$ac_datarootdir_seen" &&
-  { ac_out=`sed -n '/\${datarootdir}/p' "$ac_tmp/out"`; test -n "$ac_out"; } &&
-  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' \
-      "$ac_tmp/out"`; test -z "$ac_out"; } &&
+  { ac_out=`sed -n '/\${datarootdir}/p' "$tmp/out"`; test -n "$ac_out"; } &&
+  { ac_out=`sed -n '/^[	 ]*datarootdir[	 ]*:*=/p' "$tmp/out"`; test -z "$ac_out"; } &&
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&5
+which seems to be undefined.  Please make sure it is defined." >&5
 $as_echo "$as_me: WARNING: $ac_file contains a reference to the variable \`datarootdir'
-which seems to be undefined.  Please make sure it is defined" >&2;}
+which seems to be undefined.  Please make sure it is defined." >&2;}
 
-  rm -f "$ac_tmp/stdin"
+  rm -f "$tmp/stdin"
   case $ac_file in
-  -) cat "$ac_tmp/out" && rm -f "$ac_tmp/out";;
-  *) rm -f "$ac_file" && mv "$ac_tmp/out" "$ac_file";;
+  -) cat "$tmp/out" && rm -f "$tmp/out";;
+  *) rm -f "$ac_file" && mv "$tmp/out" "$ac_file";;
   esac \
-  || as_fn_error $? "could not create $ac_file" "$LINENO" 5
+  || as_fn_error "could not create $ac_file" "$LINENO" 5
  ;;
 
 
@@ -4645,7 +4618,7 @@
     # Strip MF so we end up with the name of the file.
     mf=`echo "$mf" | sed -e 's/:.*$//'`
     # Check whether this is an Automake generated Makefile or not.
-    # We used to match only the files named `Makefile.in', but
+    # We used to match only the files named 'Makefile.in', but
     # some people rename them; so instead we look at the file content.
     # Grep'ing the first line is not enough: some people post-process
     # each Makefile.in and add a new line on top of each file to say so.
@@ -4679,21 +4652,19 @@
       continue
     fi
     # Extract the definition of DEPDIR, am__include, and am__quote
-    # from the Makefile without running `make'.
+    # from the Makefile without running 'make'.
     DEPDIR=`sed -n 's/^DEPDIR = //p' < "$mf"`
     test -z "$DEPDIR" && continue
     am__include=`sed -n 's/^am__include = //p' < "$mf"`
     test -z "am__include" && continue
     am__quote=`sed -n 's/^am__quote = //p' < "$mf"`
-    # When using ansi2knr, U may be empty or an underscore; expand it
-    U=`sed -n 's/^U = //p' < "$mf"`
     # Find all dependency output files, they are included files with
     # $(DEPDIR) in their names.  We invoke sed twice because it is the
     # simplest approach to changing $(DEPDIR) to its actual value in the
     # expansion.
     for file in `sed -n "
       s/^$am__include $am__quote\(.*(DEPDIR).*\)$am__quote"'$/\1/p' <"$mf" | \
-	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g' -e 's/\$U/'"$U"'/g'`; do
+	 sed -e 's/\$(DEPDIR)/'"$DEPDIR"'/g'`; do
       # Make sure the directory exists.
       test -f "$dirpart/$file" && continue
       fdir=`$as_dirname -- "$file" ||
@@ -4736,7 +4707,7 @@
 ac_clean_files=$ac_clean_files_save
 
 test $ac_write_fail = 0 ||
-  as_fn_error $? "write failure creating $CONFIG_STATUS" "$LINENO" 5
+  as_fn_error "write failure creating $CONFIG_STATUS" "$LINENO" 5
 
 
 # configure is writing to config.log, and then calls config.status.
@@ -4757,7 +4728,7 @@
   exec 5>>config.log
   # Use ||, not &&, to avoid exiting from the if with $? = 1, which
   # would make configure fail if this is the last instruction.
-  $ac_cs_success || as_fn_exit 1
+  $ac_cs_success || as_fn_exit $?
 fi
 if test -n "$ac_unrecognized_opts" && test "$enable_option_checking" != no; then
   { $as_echo "$as_me:${as_lineno-$LINENO}: WARNING: unrecognized options: $ac_unrecognized_opts" >&5
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/configure.in third_party/newlib-3.2.0/newlib/libc/sys/arm/configure.in
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/configure.in	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/configure.in	2022-06-29 14:50:02.721940993 +0100
@@ -3,7 +3,7 @@
 
 AC_PREREQ(2.59)
 AC_INIT([newlib],[NEWLIB_VERSION])
-AC_CONFIG_SRCDIR([trap.S])
+AC_CONFIG_SRCDIR([virtualalloc.c])
 
 dnl Can't be done in NEWLIB_CONFIGURE because that confuses automake. 
 AC_CONFIG_AUX_DIR(../../../..)
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/creat.c third_party/newlib-3.2.0/newlib/libc/sys/arm/creat.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/creat.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/creat.c	2022-06-30 11:00:37.822919443 +0100
@@ -0,0 +1,12 @@
+#include <fcntl.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int creat (const char *path, mode_t mode)
+{
+    return open (path, O_WRONLY | O_CREAT | O_TRUNC, mode);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/crt0.S third_party/newlib-3.2.0/newlib/libc/sys/arm/crt0.S
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/crt0.S	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/crt0.S	2022-06-29 14:50:02.721940993 +0100
@@ -1,6 +1,7 @@
 #include "newlib.h"
 #include "arm.h"
-#include "swi.h"
+
+.extern environ
 
 /* ANSI concatenation macros.  */
 #define CONCAT(a, b) CONCAT2(a, b)
@@ -12,6 +13,7 @@
 #error __USER_LABEL_PREFIX is not defined
 #endif
 
+
 #ifdef HAVE_INITFINI_ARRAY
 #define _init	__libc_init_array
 #define _fini	__libc_fini_array
@@ -41,38 +43,25 @@
 #endif
 #endif
 
+
+
 /* .text is used instead of .section .text so it works with arm-aout too.  */
 	.text
 	.syntax unified
-#ifdef PREFER_THUMB
+#ifdef THUMB_V7_V6M
 	.thumb
 .macro FUNC_START name
 	.global \name
 	.thumb_func
 \name:
-.endm
+.endm	
 #else
 	.code 32
 .macro FUNC_START name
-	.global \name
+	.global	\name
 \name:
-.endm
-#endif
-
-/* Annotation for EABI unwinding tables.  */
-.macro FN_EH_START
-#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
-	.fnstart
+.endm	
 #endif
-.endm
-
-.macro FN_EH_END
-#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
-	/* Protect against unhandled exceptions.  */
-	.cantunwind
-	.fnend
-#endif
-.endm
 
 .macro indirect_call reg
 #ifdef HAVE_CALL_INDIRECT
@@ -83,552 +72,74 @@
 #endif
 .endm
 
-/* For armv4t and newer, toolchains will transparently convert
-   'bx lr' to 'mov pc, lr' if needed. GCC has deprecated support
-   for anything older than armv4t, but this should handle that
-   corner case in case anyone needs it anyway.  */
-.macro  FN_RETURN
-#if __ARM_ARCH <= 4 && __ARM_ARCH_ISA_THUMB == 0
-	mov	pc, lr
-#else
-	bx	lr
-#endif
-.endm
 
 
 
-/******************************************************************************
-* User mode only:           This routine makes default target specific Stack
-*   +-----+ <- SL_sys,    Pointer initialization for different processor modes:
-*   |     |    SL_usr     FIQ, Abort, IRQ, Undefined, Supervisor, System (User)
-*   | SYS |               and setups a default Stack Limit in-case the code has
-*   | USR | -=0x10000     been compiled with "-mapcs-stack-check" for FIQ and
-*   |     |               System (User) modes.
-*   |     |
-*   +-----+ <- initial SP,
-*           becomes SP_sys   Hard-wiring SL value is not ideal, since there is
-*           and SL_usr     currently no support for checking that the heap and
-*                          stack have not collided, or that this default 64k is
-* All modes:               is enough for the program being executed. However,
-*   +-----+ <- SL_sys,     it ensures that this simple crt0 world will not
-*   |     |    SL_usr      immediately cause an overflow event.
-*   | SYS |
-*   | USR | -=0x10000        We go through all execution modes and set up SP
-*   |     |                for each of them.
-*   +-----+ <- SP_sys,
-*   |     |    SP_usr      Notes:
-*   | SVC | -= 0x8000       - This code will not work as intended if the system
-*   |     |                   starts in secure mode. In particular the methods
-*   +-----+ <- SP_svc         of getting in and out of secure state are not as
-*   |     |                   simple as writing to the CPSR mode bits.
-*   | IRQ | -= 0x2000       - Mode switch via CPSR is not allowed once in
-*   |     |                   non-privileged mode, so we take care not to enter
-* ^ +-----+ <- SP_und         "User" to set up its SP, and also skip most
-* s |     |                   operations if already in that mode.
-* t | UND | -= 0x1000
-* a |     |                Input parameters:
-* c +-----+ <- SP_und       - sp - Initialized SP
-* k |     |                 - r2 - May contain SL value from semihosting
-*   | ABT | -= 0x1000              SYS_HEAPINFO call
-* g |     |                Scratch registers:
-* r +-----+ <- SP_abt,      - r1 - new value of CPSR
-* o |     |    SL_fiq       - r2 - intermediate value (in standalone mode)
-* w | FIQ | -= 0x1000       - r3 - new SP value
-* t |     |                 - r4 - save/restore CPSR on entry/exit
-* h +-----+ <- initial SP,
-*           becomes SP_fiq   Declared as "weak" so that user can write and use
-*                          his own implementation if current doesn't fit.
-*
-******************************************************************************/
-	.align	0
-	FUNC_START	_stack_init
-	.weak FUNCTION (_stack_init)
-	FN_EH_START
-
-	/* M profile doesn't have CPSR register.  */
-#if (__ARM_ARCH_PROFILE != 'M')
-	/* Following code is compatible for both ARM and Thumb ISA.  */
-	mrs	r4, CPSR
-	/* Test mode bits - in User of all are 0.  */
-	tst	r4, #(CPSR_M_MASK)
-	/* "eq" means r4 AND #0x0F is 0.  */
-	beq	.Lskip_cpu_modes
-
-	mov	r3, sp /* Save input SP value.  */
-
-	/* FIQ mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_FIQ|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	sl, sp, #0x1000	/* FIQ mode has its own SL.  */
-
-	/* Abort mode, interrupts disabled.  */
-	mov	r3, sl
-	mov	r1, #(CPSR_M_ABT|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x1000
-
-	/* Undefined mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_UND|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x1000
-
-	/* IRQ mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_IRQ|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-	sub	r3, r3, #0x2000
-
-	/* Supervisory mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_SVR|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-
-	sub	r3, r3, #0x8000	/* Min size 32k.  */
-	bic	r3, r3, #0x00FF	/* Align with current 64k block.  */
-	bic	r3, r3, #0xFF00
-
-# if __ARM_ARCH >= 4
-	/* System (shares regs with User) mode, interrupts disabled.  */
-	mov	r1, #(CPSR_M_SYS|CPSR_M_32BIT|CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r1
-	mov	sp, r3
-# else
-	/* Keep this for ARMv3, but GCC actually dropped it.  */
-	/* Move value into user mode SP without changing modes,  */
-	/* via '^' form of ldm.  */
-	str	r3, [r3, #-4]
-	ldmdb	r3, {sp}^
-# endif
-
-	/* Back to original mode, presumably SVC, with diabled FIQ/IRQ.  */
-	orr	r4, r4, #(CPSR_I_MASK|CPSR_F_MASK)
-	msr	CPSR_c, r4
 
-.Lskip_cpu_modes:
-#endif
-
-	/* Set SL register.  */
-#if defined (ARM_RDI_MONITOR) /* semihosting */
-	cmp	r2, #0
-	beq	.Lsl_forced_zero
-	/* Allow slop for stack overflow handling and small frames.  */
-# ifdef THUMB1_ONLY
-	adds	r2, #128
-	adds	r2, #128
-	mov	sl, r2
-# else
-	add	sl, r2, #256
-# endif
-.Lsl_forced_zero:
-
-#else /* standalone */
-	/* r3 contains SP for System/User mode. Set SL = SP - 0x10000.  */
-	#ifdef THUMB1_ONLY
-	movs	r2, #64
-	lsls	r2, r2, #10
-	subs	r2, r3, r2
-	mov	sl, r2
-	#else
-	/* Still assumes 256bytes below SL.  */
-	sub	sl, r3, #64 << 10
-	#endif
-#endif
-
-	FN_RETURN
-	FN_EH_END
 
+.balign 	16
 
-/*******************************************************************************
-* Main library startup code.
-*******************************************************************************/
-	.align 	0
 	FUNC_START	_mainCRTStartup
 	FUNC_START	_start
-	FN_EH_START
+	FUNC_START	start
 
-/* Start by setting up a stack.  */
-#ifdef ARM_RDP_MONITOR
-	/*  Issue Demon SWI to read stack info.  */
-	swi	SWI_GetEnv	/*  Returns command line in r0.  */
-	mov	sp,r1		/*  and the highest memory address in r1.  */
-
-	/*  Stack limit is at end of data.  */
-	/*  Allow slop for stack overflow handling and small frames.  */
-#ifdef THUMB1_ONLY
-	ldr	r0, .LC2
-	adds	r0, #128
-	adds	r0, #128
-	mov	sl, r0
-#else
-	ldr	sl, .LC2
-	add	sl, sl, #256
-#endif
-#else
-#ifdef ARM_RDI_MONITOR
-	/*  Issue Angel SWI to read stack info.  */
-	movs	r0, #AngelSWI_Reason_HeapInfo
-	adr	r1, .LC0	/*  Point at ptr to 4 words to receive data.  */
-#ifdef THUMB_VXM
-	bkpt	AngelSWI
-#elif defined(__thumb2__)
-	/*  We are in thumb mode for startup on armv7 architectures.  */
-	AngelSWIAsm	AngelSWI
-#else
-	/*  We are always in ARM mode for startup on pre armv7 archs.  */
-	AngelSWIAsm	AngelSWI_ARM
-#endif
-	ldr	r0, .LC0	/*  Point at values read.  */
-
-	/* Set __heap_limit.  */
-	ldr     r1, [r0, #4]
-	cmp     r1, #0
-	beq     .LC33
-	ldr     r2, =__heap_limit
-	str     r1, [r2]
-.LC33:
-	ldr     r1, [r0, #0]
-	cmp     r1, #0
-	bne     .LC32
-	/* If the heap base value [r0, #0] is 0 then the heap base is actually 
-	   at the end of program data (i.e. __end__). See:
-           http://infocenter.arm.com/help/topic/com.arm.doc.dui0471-/Bacbefaa.html
-	   for more information.  */
-	ldr     r1, .LC31
-	str     r1, [r0, #0]
-.LC32:	
-	ldr	r1, [r0, #8]
-	ldr	r2, [r0, #12]
-	/*  We skip setting SP/SL if 0 returned from semihosting.
-	    - According to semihosting docs, if 0 returned from semihosting,
-	      the system was unable to calculate the real value, so it's ok
-	      to skip setting SP/SL to 0 here.
-	    - Considering M-profile processors, We might want to initialize
-	      SP by the first entry of vector table and return 0 to SYS_HEAPINFO
-	      semihosting call, which will be skipped here.
-	    - Considering R-profile processors there is no automatic SP init by hardware
-	      so we need to initialize it by default value.  */
-	ldr	r3, .Lstack
-	cmp	r1, #0
-	beq	.LC26
-	mov	r3, r1
-.LC26:
-	mov	sp, r3
-
-	/* r2 (SL value) will be used in _stack_init.  */
-	bl FUNCTION (_stack_init)
-
-
-#else /* standalone */
-	/*  Set up the stack pointer to a fixed value. */
-	/*  Changes by toralf:
-	    - Allow linker script to provide stack via __stack symbol - see
-	      defintion of .Lstack
-	    - Provide "hooks" that may be used by the application to add
-	      custom init code - see .Lhwinit and .Lswinit.  */
-
-	ldr	r3, .Lstack
-	cmp	r3, #0
-#ifdef __thumb2__
-	it	eq
-#endif	
-#ifdef THUMB1_ONLY
-	bne	.LC28
-	ldr	r3, .LC0
-.LC28:
-#else
-	ldreq	r3, .LC0
-#endif
-	/* Note: This 'mov' is essential when starting in User, and ensures we
-		 always get *some* SP value for the initial mode, even if we
-		 have somehow missed it below (in which case it gets the same
-		 value as FIQ - not ideal, but better than nothing).  */
-	mov	sp, r3
+// r0 argc
+// r1 argv
+// r2 envc
+// r3 envv
 
-	/* We don't care of r2 value in standalone.  */
-	bl FUNCTION (_stack_init)
+    ldr r4, =environ
+    str r3, [r4]
 
+#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+	/* Annotation for EABI unwinding tables.  */
+	.fnstart
 #endif
-#endif
-	/* Zero the memory in the .bss section.  */
-	movs 	a2, #0			/* Second arg: fill value.  */
-	mov	fp, a2			/* Null frame pointer.  */
-	mov	r7, a2			/* Null frame pointer for Thumb.  */
-	
-	ldr	a1, .LC1		/* First arg: start of memory block.  */
-	ldr	a3, .LC2	
-	subs	a3, a3, a1		/* Third arg: length of block.  */
-	
-
-#if __thumb__ && !defined(PREFER_THUMB)
-	/* Enter Thumb mode...  */
-	add	a4, pc, #1	/* Get the address of the Thumb block.  */
-	bx	a4		/* Go there and start Thumb decoding.  */
 
-	.code 16
-	.global __change_mode
-	.thumb_func
-__change_mode:	
-#endif
-	
-	bl	FUNCTION (memset)
-#if !defined (ARM_RDP_MONITOR) && !defined (ARM_RDI_MONITOR)
-/* Changes by toralf: Taken from libgloss/m68k/crt0.S
-   initialize target specific stuff. Only execute these
-   functions it they exist.  */
-	ldr	r3, .Lhwinit
-	cmp	r3, #0
-	beq	.LC24
-	indirect_call r3
-.LC24:	
-	ldr	r3, .Lswinit
-	cmp	r3, #0
-	beq	.LC25
-	indirect_call r3
-
-.LC25:	
-	movs	r0, #0		/* No arguments.  */
-	movs	r1, #0		/* No argv either.  */
-#else
-	/* Need to set up standard file handles.  */
-	bl	FUNCTION (initialise_monitor_handles)
-	
-#ifdef ARM_RDP_MONITOR
-	swi	SWI_GetEnv	/* Sets r0 to point to the command line.  */
-	movs	r1, r0
-#else
-	movs	r0, #AngelSWI_Reason_GetCmdLine
-	ldr	r1, .LC30	/* Space for command line.  */
-#ifdef THUMB_VXM
-	bkpt	AngelSWI
-#else
- 	AngelSWIAsm	AngelSWI
-#endif
-	ldr	r1, .LC30
-	ldr	r1, [r1]
-#endif
-	/*  Parse string at r1.  */
-	movs	r0, #0		/* Count of arguments so far.  */
-	/* Push a NULL argument onto the end of the list.  */
-#ifdef __thumb__
-	push	{r0}
-#else
-	stmfd	sp!, {r0}
-#endif
-.LC10:
-/*  Skip leading blanks.  */
-#ifdef __thumb__
-	ldrb	r3, [r1]
-	adds	r1, #1
-#else
-	ldrb	r3, [r1], #1
-#endif
-	cmp	r3, #0
-	beq	.LC12
-	cmp	r3, #' '
-	beq	.LC10
-
-/* See whether we are scanning a string.  */
-	cmp	r3, #'\"'
-#ifdef __thumb__
-	beq	.LC20
-	cmp	r3, #'\''
-	bne	.LC21
-.LC20:
-	movs	r2, r3
-	b	.LC22
-
-.LC21:
-	movs	r2, #' '	/* Terminator type.  */
-	subs	r1, r1, #1	/* Adjust back to point at start char.  */
-.LC22:
-#else
-	cmpne	r3, #'\''
-	moveq	r2, r3
-	movne	r2, #' '	/* Terminator type.  */
-	subne	r1, r1, #1	/* Adjust back to point at start char.  */
-#endif
 
-/*  Stack a pointer to the current argument.  */
-#ifdef __thumb__
-	push	{r1}
-#else
-	stmfd	sp!, {r1}
-#endif
-	adds	r0, r0, #1
-.LC11:
-#ifdef __thumb__
-	ldrb	r3, [r1]
-	adds	r1, #1
-#else
-	ldrb	r3, [r1], #1
-#endif
-	cmp	r3, #0
-	beq	.LC12
-	cmp	r2, r3		/* Reached terminator ?  */
-	bne	.LC11
-	movs	r2, #0
-	subs	r3, r1, #1
-	strb	r2, [r3]	/* Terminate the arg string.  */
-	b	.LC10
-
-.LC12:
-	mov	r1, sp		/* Point at stacked arg pointers.  */
-	/* We've now got the stacked args in order, reverse them.  */
-#ifdef __thumb__
-	movs	r2, r0
-	lsls	r2, #2
-	add	r2, sp
-	mov	r3, sp
-.LC15:	cmp	r2, r3
-	bls	.LC14
-	subs	r2, #4
-	ldr	r4, [r2]
-	ldr	r5, [r3]
-	str	r5, [r2]
-	str	r4, [r3]
-	adds	r3, #4
-	b	.LC15
-.LC14:	
-	/* Ensure doubleword stack alignment.  */
-	mov	r4, sp
-	movs	r5, #7
-	bics	r4, r5
-	mov	sp, r4
-#else
-	add	r2, sp, r0, LSL #2	/* End of args.  */
-	mov	r3, sp			/* Start of args.  */
-.LC13:	cmp	r2, r3
-	ldrhi	r4,[r2, #-4]		/* Reverse ends of list.  */
-	ldrhi	r5, [r3]
-	strhi	r5, [r2, #-4]!
-	strhi	r4, [r3], #4
-	bhi	.LC13
-	/* Ensure doubleword stack alignment.  */
-	bic	sp, sp, #7
-#endif
-#endif
+// FIXME:  Assumes bss/common is clear.
 
 #ifdef __USES_INITFINI__
-	/* Some arm/elf targets use the .init and .fini sections
-	   to create constructors and destructors, and for these
-	   targets we need to call the _init function and arrange
-	   for _fini to be called at program exit.  */
 	movs	r4, r0
 	movs	r5, r1
-#ifdef _LITE_EXIT
-	/* Make reference to atexit weak to avoid unconditionally pulling in
-	   support code.  Refer to comments in __atexit.c for more details.  */
-	.weak	FUNCTION(atexit)
-	ldr	r0, .Latexit
-	cmp	r0, #0
-	beq	.Lweak_atexit
-#endif
 	ldr	r0, .Lfini
 	bl	FUNCTION (atexit)
-.Lweak_atexit:
 	bl	FUNCTION (_init)
 	movs	r0, r4
 	movs	r1, r5
-#endif
+#endif	
 	bl	FUNCTION (main)
-
 	bl	FUNCTION (exit)		/* Should not return.  */
 
-#if __thumb__ && !defined(PREFER_THUMB)
-	/* Come out of Thumb mode.  This code should be redundant.  */
-	mov	a4, pc
-	bx	a4
 
-	.code 32
-	.global change_back
-change_back:
-	/* Halt the execution.  This code should never be executed.  */
-	/* With no debug monitor, this probably aborts (eventually).
-	   With a Demon debug monitor, this halts cleanly.
-	   With an Angel debug monitor, this will report 'Unknown SWI'.  */
-	swi	SWI_Exit
-#endif
-	
-	FN_EH_END
 
-	/* For Thumb, constants must be after the code since only 
-	   positive offsets are supported for PC relative addresses.  */
-	.align 0
-.LC0:
-#ifdef ARM_RDI_MONITOR
-	.word	HeapBase
-#else
-#ifndef ARM_RDP_MONITOR
-	/* Changes by toralf: Provide alternative "stack" variable whose value
-	   may be defined externally; .Lstack will be used instead of .LC0 if
-	   it points to a non-0 value. Also set up references to "hooks" that
-           may be used by the application to provide additional init code.  */
-#ifdef __pe__
-	.word	0x800000
-#else
-	.word	0x80000			/* Top of RAM on the PIE board.  */
-#endif
-.Lhwinit:	
-	.word	FUNCTION (hardware_init_hook)
-.Lswinit:
-	.word	FUNCTION (software_init_hook)
-
-	/* Set up defaults for the above variables in the form of weak symbols
-	   - so that application will link correctly, and get value 0 in
-	   runtime (meaning "ignore setting") for the variables, when the user
-	   does not provide the symbols. (The linker uses a weak symbol if,
-	   and only if, a normal version of the same symbol isn't provided
-	   e.g. by a linker script or another object file.)  */
 
-	.weak FUNCTION (hardware_init_hook) 
-	.weak FUNCTION (software_init_hook)
-#endif
-	
+
+
+
+
+
+.balign 16
+
+
+#if defined(__ELF__) && !defined(__USING_SJLJ_EXCEPTIONS__)
+	/* Protect against unhandled exceptions.  */
+	.cantunwind
+	.fnend
 #endif
 
-.Lstack:
-	.word	__stack
-	.weak	__stack
 
 .LC1:
 	.word	__bss_start__
 .LC2:
 	.word	__bss_end__
-#ifdef __USES_INITFINI__
-#ifdef _LITE_EXIT
-.Latexit:
-	.word	FUNCTION(atexit)
 
-	/* Weak reference _fini in case of lite exit.  */
-	.weak	FUNCTION(_fini)
-#endif
+
+#ifdef __USES_INITFINI__
 .Lfini:
 	.word	FUNCTION(_fini)
 #endif
-#ifdef ARM_RDI_MONITOR
-.LC30:
-	.word	AngelSWIArgs
-.LC31:
-	.word	__end__
-
-/*  Workspace for Angel calls.  */
-	.data
-/*  Data returned by monitor SWI.  */
-.global	__stack_base__
-HeapBase:	.word	0
-HeapLimit:	.word	0
-__stack_base__:	.word	0
-StackLimit:	.word	0
-CommandLine:	.space	256,0	/*  Maximum length of 255 chars handled.  */
-AngelSWIArgs:
-	.word	CommandLine
-	.word	255
-#endif
-	
-#ifdef __pe__
-	.section .idata$3
-	.long	0,0,0,0,0,0,0,0
-#endif
+
+
+.balign 16
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/debug.c third_party/newlib-3.2.0/newlib/libc/sys/arm/debug.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/debug.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/debug.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,25 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <sys/debug.h>
+#include <stdarg.h>
+#include <string.h>
+
+
+/*
+ *
+ */
+void KLogOut(const char *format, ...) {
+    static char __klog_buf[80];
+
+    va_list ap;
+
+    va_start(ap, format);
+
+    vsnprintf(__klog_buf, 79, format, ap);
+    _swi_debug(__klog_buf);
+
+    va_end(ap);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/dir.c third_party/newlib-3.2.0/newlib/libc/sys/arm/dir.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/dir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/dir.c	2022-06-30 11:00:53.719222907 +0100
@@ -0,0 +1,104 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+#include <sys/param.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+char *getwd (char *__buf )
+{
+    return getcwd (__buf, MAXPATHLEN);
+}
+
+/*
+ *
+ */
+int chroot(const char *path)
+{
+    int sc;
+    
+    sc = _swi_chroot(path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int chdir (const char *path)
+{
+    int sc;
+    
+    sc = _swi_chdir(path);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return 0;
+}
+
+/*
+ *
+ */
+int fchdir (int fd)
+{
+    int sc;
+    
+    sc = _swi_fchdir (fd);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	  return 0;
+}
+
+/*
+ *
+ */
+int mkdir (const char *path, mode_t mode)
+{
+    int sc;
+    
+    sc = _swi_mkdir (path, mode);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	  return 0;
+}
+
+/*
+ *
+ */
+int rmdir (const char *path)
+{
+    int sc;
+    
+    sc = _swi_rmdir (path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	  return 0;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/dirname.c third_party/newlib-3.2.0/newlib/libc/sys/arm/dirname.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/dirname.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/dirname.c	2022-06-30 11:02:04.628424452 +0100
@@ -0,0 +1,37 @@
+#ifndef _NO_DIRNAME
+
+/* Copyright 2005 Shaun Jackman
+ * Permission to use, copy, modify, and distribute this software
+ * is freely granted, provided that this notice is preserved.
+ */
+
+#include <libgen.h>
+#include <string.h>
+
+char *
+_DEFUN (dirname, (path),
+	char *path)
+{
+	char *p;
+	if( path == NULL || *path == '\0' ) {
+		return ".";
+	}
+	
+	p = path + strlen(path) - 1;
+	
+	while( *p == '/' ) {
+		if( p == path ) {
+			return path;
+		}
+		
+		*p-- = '\0';
+	}
+	
+	while( p >= path && *p != '/' ) {
+		p--;
+  }
+  
+	return p < path ? "." : p == path ? "/" : (*p = '\0', path);
+}
+
+#endif /* !_NO_DIRNAME  */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/dup.c third_party/newlib-3.2.0/newlib/libc/sys/arm/dup.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/dup.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/dup.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,37 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int dup(int fd) {
+    int dfd;
+
+    dfd = _swi_dup(fd);
+    if (dfd < 0) {
+        errno = -dfd;
+        return -1;
+    }
+
+    return dfd;
+}
+
+/*
+ *
+ */
+int dup2(int fd1, int fd2) {
+    int dfd;
+
+    dfd = _swi_dup2(fd1, fd2);
+    if (dfd < 0) {
+        errno = -dfd;
+        return -1;
+    }
+
+    return dfd;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/environ.c third_party/newlib-3.2.0/newlib/libc/sys/arm/environ.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/environ.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/environ.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,9 @@
+/*
+ * Version of environ for no OS.
+ */
+
+char *__env[1] = { 0 }; 
+char **environ = __env;
+int __argc = 0;
+char **__argv;
+int __envc = 0;
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execl.c third_party/newlib-3.2.0/newlib/libc/sys/arm/execl.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execl.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/execl.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,34 @@
+/* execl.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+
+/* Only deal with a pointer to environ, to work around subtle bugs with shared
+   libraries and/or small data systems where the user declares his own
+   'environ'.  */
+static char ***p_environ = &environ;
+
+
+#include <stdarg.h>
+
+int execl (const char *path, const char *arg0, ...)
+{
+    int i;
+    va_list args;
+    const char *argv[256];
+
+    va_start (args, arg0);
+    argv[0] = arg0;
+    i = 1;
+
+    do {
+        argv[i] = va_arg (args, char *);
+    } while (argv[i++] != NULL);
+
+    va_end (args);
+
+    return execve (path, (char * const  *) argv, *p_environ);
+}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execle.c third_party/newlib-3.2.0/newlib/libc/sys/arm/execle.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execle.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/execle.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,33 @@
+/* execle.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+/*
+ *
+ */
+int execle (const char *path, const char *arg0, ...)
+{
+    int i;
+    va_list args;
+    const char * const *envp;
+    const char *argv[256];
+
+    va_start (args, arg0);
+    argv[0] = arg0;
+    i = 1;
+
+    do {
+       argv[i] = va_arg (args, const char *);
+    } while (argv[i++] != NULL);
+
+    envp = va_arg (args, const char * const *);
+    va_end (args);
+
+    return execve (path, (char * const *) argv, (char * const *) envp);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execlp.c third_party/newlib-3.2.0/newlib/libc/sys/arm/execlp.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execlp.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/execlp.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,31 @@
+/* execlp.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+
+/*
+ *
+ */
+int execlp (const char *path, const char *arg0, ...)
+{
+    int i;
+    va_list args;
+    const char *argv[256];
+
+    va_start (args, arg0);
+    argv[0] = arg0;
+    i = 1;
+
+    do {
+        argv[i] = va_arg (args, const char *);
+    } while (argv[i++] != NULL);
+
+    va_end (args);
+
+    return execvp (path, (char * const *) argv);
+}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execv.c third_party/newlib-3.2.0/newlib/libc/sys/arm/execv.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execv.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/execv.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,17 @@
+#include <_ansi.h>
+#include <unistd.h>
+
+/*
+ *
+ */
+static char ***p_environ = &environ;
+
+
+/*
+ *
+ */
+int execv (const char *path, char * const argv[])
+{
+    return execve (path, (char **) argv, *p_environ);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execve.c third_party/newlib-3.2.0/newlib/libc/sys/arm/execve.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execve.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/execve.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,43 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/unistd.h>
+#include <sys/execargs.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+/*
+ *
+ */ 
+int execve (const char *__path, char * const __argv[], char * const __envp[] )
+{
+    struct execargs args;
+    int argc = 0;
+    int envc = 0;
+    int sc;
+    
+    if (__argv != NULL) {
+        for (argc = 0; __argv[argc] != NULL; argc++);
+    }
+    
+    if (__envp != NULL) {
+        for (envc = 0; __envp[envc] != NULL; envc++);
+    }
+        
+    args.argc = argc;
+    args.envc = envc;    
+    args.envv = (char **)__envp;
+    args.argv = (char **)__argv;
+    args.total_size = 0;
+    sc = _swi_exec(__path, &args);
+
+    // It can only be an error if it fails.
+    errno = -sc;
+    return -1;
+}
+
+
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execvp.c third_party/newlib-3.2.0/newlib/libc/sys/arm/execvp.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/execvp.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/execvp.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,68 @@
+/* execvp.c */
+
+/* This and the other exec*.c files in this directory require 
+   the target to provide the _execve syscall.  */
+
+#include <_ansi.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <errno.h>
+#include <ctype.h>
+
+#define PATH_DELIM ':'
+
+/*
+ * Copy string, until c or <nul> is encountered.
+ * NUL-terminate the destination string (s1).
+ */
+
+static char *strccpy (char *s1, char *s2, char c)
+{
+    char *dest = s1;
+
+    while (*s2 && *s2 != c) {
+        *s1++ = *s2++;
+    }
+    *s1 = 0;
+
+    return dest;
+}
+
+/*
+ *
+ */
+int execvp (const char *file, char * const argv[])
+{
+  char *path = getenv ("PATH");
+  char buf[MAXNAMLEN];
+
+  if (!path)
+    return execv (file, argv);
+
+  if (strchr (file, '/'))
+    return execv (file, argv);
+
+  while (*path) {
+      strccpy (buf, path, PATH_DELIM);
+
+      if (*buf != 0 && buf[strlen(buf) - 1] != '/')
+          strcat (buf, "/");
+      
+      strcat (buf, file);
+      
+      if (execv (buf, argv) == -1 && errno != ENOENT)
+          return -1;
+      
+      while (*path && *path != PATH_DELIM) {
+        path++;
+      }
+      
+      if (*path == PATH_DELIM)
+         path++;
+  }
+
+  return -1;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/_exit.c third_party/newlib-3.2.0/newlib/libc/sys/arm/_exit.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/_exit.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/_exit.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,20 @@
+#include <limits.h>
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/debug.h>
+
+
+
+
+/*
+ * Exit, flushing stdio buffers if necessary.
+ */
+
+void _exit (int rc)
+{
+	  _swi_exit (rc);
+	  while (1);
+}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c third_party/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/fcntl.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,55 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <stdarg.h>
+
+
+/*
+ * fcntl();
+ */
+int fcntl(int fd, int cmd, ...)
+{
+    va_list ap;
+    int arg;
+    int rc;
+
+    va_start(ap, cmd);
+
+    switch (cmd) {
+	      case F_DUPFD:
+	      case F_SETFD:
+	      case F_SETFL:
+	      case F_SETOWN:
+		        arg = va_arg(ap, int);
+		        rc = _swi_fcntl(fd, cmd, arg);
+		
+		        if (rc < 0) {
+		          errno = -rc;
+		          rc = -1;
+		        }
+		
+		        break;
+
+	      case F_GETFD:
+	      case F_GETFL:
+	      case F_GETOWN:
+		        rc = _swi_fcntl(fd, cmd, 0);
+
+		        if (rc < 0) {
+		          errno = -rc;
+		          rc = -1;
+		        }
+
+		        break;
+
+	      default:
+		        errno = EINVAL;
+		        rc = -1;
+    }
+
+    va_end(ap);
+    return rc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/fork.c third_party/newlib-3.2.0/newlib/libc/sys/arm/fork.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/fork.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/fork.c	2022-06-30 11:02:55.605180184 +0100
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int fork(void)
+{
+    int pid;
+    
+    pid = _swi_fork();
+    
+    if (pid < 0) {
+        errno = -pid;
+        return -1;
+    }
+    
+    return pid;    
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/format.c third_party/newlib-3.2.0/newlib/libc/sys/arm/format.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/format.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/format.c	2022-06-30 12:13:30.404814364 +0100
@@ -0,0 +1,16 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscall.h>
+
+
+/*
+ *
+ */
+int kos_format (char *mount, char *label, unsigned long flags, unsigned long cluster_size)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/fstat.c third_party/newlib-3.2.0/newlib/libc/sys/arm/fstat.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/fstat.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/fstat.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,11 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <stdio.h>
+
+
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/getpid.c third_party/newlib-3.2.0/newlib/libc/sys/arm/getpid.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/getpid.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/getpid.c	2022-06-29 14:50:02.725941105 +0100
@@ -0,0 +1,33 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+pid_t getpid(void)
+{
+    pid_t pid;
+    
+    pid = _swi_getpid();
+
+    return pid;
+}
+
+
+/*
+ *
+ */
+pid_t getppid(void)
+{
+    pid_t ppid;
+    
+    ppid = _swi_getppid();
+    
+    return ppid;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/gettod.c third_party/newlib-3.2.0/newlib/libc/sys/arm/gettod.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/gettod.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/gettod.c	2022-06-30 11:04:47.358662631 +0100
@@ -0,0 +1,48 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int gettimeofday (struct timeval *tp, void *tzp)
+{
+    int sc;
+
+    sc = _swi_gettimeofday(tp);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ *
+ */
+int settimeofday(const struct timeval *tp, const struct timezone *tzp)
+{
+    int sc;
+
+    sc = _swi_settimeofday(tp);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+
+
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/id.c third_party/newlib-3.2.0/newlib/libc/sys/arm/id.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/id.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/id.c	2022-06-30 11:07:54.632530760 +0100
@@ -0,0 +1,125 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <pwd.h>
+
+
+/*
+ *
+ */
+int getpgrp(void)
+{
+  return _swi_getpgrp();
+}
+
+
+/*
+ * 
+ */
+int setpgrp(void)
+{
+  int sc;
+  
+  sc = _swi_setpgrp();
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+uid_t geteuid(void)
+{
+  uid_t euid;
+  
+  euid = _swi_geteuid();
+
+  return euid;
+}
+
+
+/*
+ *
+ */
+uid_t getuid(void)
+{
+  uid_t uid;
+  
+  uid = _swi_getuid();
+
+  return uid;
+}
+
+
+/*
+ *
+ */
+gid_t getgid(void)
+{
+    gid_t gid;
+    
+    gid = _swi_getgid();
+
+    return gid;
+}
+
+
+/*
+ *
+ */
+gid_t getegid(void)
+{
+  
+    gid_t egid;
+    
+    egid = _swi_getegid();
+
+    return egid;
+}
+
+
+/*
+ *
+ */
+int setuid(uid_t uid)
+{
+  int sc;
+  
+  sc = _swi_setuid(uid);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
+/*
+ *
+ */
+int setgid(gid_t gid)
+{
+  int sc;
+  
+  sc = _swi_setgid(gid);
+  
+  if (sc < 0) {
+    errno = -sc;
+    return -1;
+  }
+  
+  return 0;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h third_party/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/include/limits.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,173 @@
+/*
+ *  This file lists the minimums for the limits set by each of
+ *  the POSIX features subsets.
+ *
+ *  XXX: Careful attention needs to be paid to section 2.8 in 1003.1b-1993
+ *       to segregrate the variables below based on their "class" according
+ *       to our implementation.  We also need to set the Run-Time Invariant
+ *       and other related values.
+ *
+ *  $Id: limits.h,v 1.2 1999/09/07 21:18:36 ranjith Exp $
+ */
+
+#ifndef _GCC_LIMITS_H_  /* if we have not seen gcc's limits.h yet */
+#include_next <limits.h>
+#endif
+
+#include <sys/syslimits.h>
+
+#ifndef __POSIX_LIMITS_h
+#define __POSIX_LIMITS_h
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.1b-1993 defines the constants below this comment.          *
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_AIO_LISTIO_MAX   2
+#define _POSIX_AIO_MAX          1
+#define _POSIX_ARG_MAX          4096
+#define _POSIX_CHILD_MAX        6
+#define _POSIX_DELAYTIMER_MAX   32
+#define _POSIX_LINK_MAX         8
+#define _POSIX_MAX_CANON        255
+#define _POSIX_MAX_INPUT        255
+#define _POSIX_MQ_OPEN_MAX      8
+#define _POSIX_MQ_PRIO_MAX      32
+#define _POSIX_NAME_MAX         255
+#define _POSIX_NGROUPS_MAX      0
+#define _POSIX_OPEN_MAX         64
+#define _POSIX_PATH_MAX         1024
+#define _POSIX_PIPE_BUF         512
+#define _POSIX_RTSIG_MAX        8
+#define _POSIX_SEM_NSEMS_MAX    256
+#define _POSIX_SEM_VALUE_MAX    32767
+#define _POSIX_SIGQUEUE_MAX     32
+#define _POSIX_SSIZE_MAX        32767
+#define _POSIX_STREAM_MAX       8
+#define _POSIX_TIMER_MAX        32
+#define _POSIX_TZNAME_MAX       3
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ */
+
+#define AIO_LISTIO_MAX          2
+#define AIO_MAX                 1
+#define AIO_PRIO_DELTA_MAX      0
+#define DELAYTIMER_MAX          32
+#define MQ_OPEN_MAX             8
+#define MQ_PRIO_MAX             32
+#define PAGESIZE                4096
+#define RTSIG_MAX               8
+#define SEM_NSEMS_MAX           256
+#define SEM_VALUE_MAX           32767
+#define SIGQUEUE_MAX            32
+#define STREAM_MAX              8
+#define TIMER_MAX               32
+#define TZNAME_MAX              3
+#define SYMLOOP_MAX				8
+
+/*
+ *  Invariant values
+ */
+
+#define SSIZE_MAX               32767
+
+/*
+ *  Maximum Values
+ */
+
+#define _POSIX_CLOCKRES_MIN      0   /* in nanoseconds */
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.1c/D10 defines the constants below this comment.           *
+ *
+ *  XXX: doc seems to have printing problems in this table :(
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_LOGIN_NAME_MAX                9
+#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS  4
+#define _POSIX_THREAD_KEYS_MAX               128
+#define _POSIX_THREAD_THREADS_MAX            64
+#define _POSIX_TTY_NAME_MAX                  9
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ *
+ *  NOTE:  LOGIN_NAME_MAX is named LOGNAME_MAX under Solaris 2.x.  Perhaps
+ *         the draft specification will be changing.  jrs 05/24/96
+ */
+
+#define LOGIN_NAME_MAX                      _POSIX_LOGIN_NAME_MAX
+#define TTY_NAME_MAX                        _POSIX_TTY_NAME_MAX
+#define PTHREAD_DESTRUCTOR_ITERATIONS       _POSIX_THREAD_DESTRUCTOR_ITERATIONS
+
+/*
+ *  RTEMS is smart enough to give us the minimum stack size if we ask
+ *  for too little.  Because the real RTEMS limit for this is cpu dependent
+ *  AND rtems header files are not installed yet, we cannot use the cpu
+ *  dependent constant CPU_STACK_MINIMUM_SIZE.  Moreover, we do not want
+ *  to duplicate that information here so we will just let RTEMS magically
+ *  give us its minimum stack size.
+ *
+ *  NOTE:  The other alternative is to have this be a macro for a 
+ *         routine in RTEMS which returns the constant.
+ */
+
+#define PTHREAD_STACK_MIN                   0
+
+/*
+ *  The maximum number of keys (PTHREAD_KEYS_MAX) and threads
+ *  (PTHREAD_THREADS_MAX) are configurable and may exceed the minimum.
+ *
+#define PTHREAD_KEYS_MAX                    _POSIX_THREAD_KEYS_MAX
+#define PTHREAD_THREADS_MAX                 _POSIX_THREAD_THREADS_MAX
+*/
+
+
+/****************************************************************************
+ ****************************************************************************
+ *                                                                          *
+ *         P1003.4b/D8 defines the constants below this comment.            *
+ *                                                                          *
+ **************************************************************************** 
+ ****************************************************************************/
+
+#define _POSIX_INTERRUPT_OVERRUN_MAX        32
+
+/*
+ *  Definitions of the following may be omitted if the value is >= stated
+ *  minimum but is indeterminate.
+ */
+
+#define INTERRUPT_OVERRUN_MAX               32
+
+/*
+ *  Pathname Variables
+ */
+
+#define MIN_ALLOC_SIZE      				0
+#define REC_MIN_XFER_SIZE   
+#define REC_MAX_XFER_SIZE   
+#define REC_INCR_XFER_SIZE  
+#define REC_XFER_ALIGN      
+#define MAX_ATOMIC_SIZE
+
+#define NAME_MAX							_POSIX_NAME_MAX
+#define PATH_MAX							_POSIX_PATH_MAX
+#define SYMLINK_MAX							_POSIX_SYMLINK_MAX
+
+
+
+#endif
+/* end of include file */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h third_party/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/include/mntent.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,87 @@
+#ifndef	_MNTENT_H
+#define	_MNTENT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+
+
+
+/*
+ *
+ */
+
+struct mntent
+{
+	char    *mnt_fsname;
+	char    *mnt_dir;
+	char    *mnt_type;
+	char    *mnt_opts;
+	int     mnt_freq;
+	int     mnt_passno;
+};
+
+
+
+
+/*
+ *
+ */
+
+#define MNT_CHECKLIST  "/etc/fstab" 
+#define	MNTTAB		"/etc/mnttab"
+#define	VFSTAB		"/etc/vfstab"
+#define	MNTMAXSTR	128
+
+
+/*
+ *
+ */
+ 
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+
+
+/*
+ * Generic mount options
+ */
+
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+
+
+/*
+ * Prototypes
+ */
+
+FILE *setmntent(const char *filename, const char *type);
+struct mntent *getmntent(FILE *filep);
+int addmntent(FILE *filep, const struct mntent *mnt);
+int endmntent(FILE *filep);
+char *hasmntopt(const struct mntent *mnt, const char *opt);
+struct mntent *getmntent_r (FILE *stream, struct mntent *result, char *buffer, int bufsize);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h third_party/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/include/netdb.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,169 @@
+/* 
+ */
+
+
+
+#ifndef _NETDB_H_
+#define _NETDB_H_
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/cdefs.h>
+#include <netinet/in.h>
+
+
+
+/* The <netdb.h> header may define the in_port_t type and the in_addr_t type
+ *  as described in <netinet/in.h>.
+ */
+
+
+
+struct hostent
+{
+	char   *h_name;
+	char  **h_aliases;
+	int     h_addrtype;
+	int     h_length;
+	char  **h_addr_list;
+}; 
+   
+
+
+struct netent
+{
+	char     *n_name;
+	char    **n_aliases;
+	int       n_addrtype;
+	uint32_t n_net;
+};
+
+
+
+
+struct protoent
+{
+	char   *p_name;
+	char  **p_aliases;
+	int     p_proto;
+};
+
+
+
+struct servent
+{
+	char   *s_name;
+	char  **s_aliases;
+	int     s_port;
+	char   *s_proto;
+};
+
+
+
+
+#define IPPORT_RESERVED   1
+
+extern int h_errno;
+
+
+
+
+#define HOST_NOT_FOUND 1
+#define NO_DATA 2
+#define NO_RECOVERY 3
+#define TRY_AGAIN 4
+
+
+
+struct addrinfo
+{
+	int               ai_flags;
+	int               ai_family;
+	int               ai_socktype;
+	int               ai_protocol;
+	socklen_t         ai_addrlen;
+	struct sockaddr  *ai_addr;
+	char             *ai_canonname;
+	struct addrinfo  *ai_next;
+};
+
+
+
+
+#define AI_PASSIVE			(1<<0)
+#define AI_CANONNAME		(1<<1)
+#define AI_NUMERICHOST		(1<<2)
+#define AI_NUMERICSERV		(1<<3)
+#define AI_V4MAPPED			(1<<4)
+#define AI_ALL				(1<<5)
+#define AI_ADDRCONFIG		(1<<6)
+
+
+
+
+#define NI_NOFQDN			(1<<0)
+#define NI_NUMERICHOST		(1<<1)
+#define NI_NAMEREQD			(1<<2)
+#define NI_NUMERICSERV		(1<<3)
+#define NI_NUMERICSCOPE		(1<<4)
+#define NI_DGRAM			(1<<5)
+
+
+
+
+#define EAI_AGAIN			1
+#define EAI_BADFLAGS		2
+#define EAI_FAIL			3
+#define EAI_FAMILY			4
+#define EAI_MEMORY			5
+#define EAI_NONAME			6
+#define EAI_SERVICE			7
+#define EAI_SOCKTYPE		8
+#define EAI_SYSTEM			9
+#define EAI_OVERFLOW		10
+#define EAI_NODATA          11
+
+#define EAI_ADDRFAMILY      12
+
+
+
+
+
+
+void endhostent (void);
+void endnetent (void);
+void endprotoent (void);
+void endservent (void);
+void freeaddrinfo (struct addrinfo *);
+const char *gai_strerror (int);
+int getaddrinfo (const char *restrict, const char *restrict, const struct addrinfo *restrict, struct addrinfo **restrict);
+struct hostent *gethostbyaddr (const void *, socklen_t, int);
+struct hostent *gethostbyname (const char *);
+struct hostent *gethostent (void);
+int getnameinfo (const struct sockaddr *restrict, socklen_t, char *restrict, socklen_t, char *restrict, socklen_t, int);
+struct netent *getnetbyaddr (uint32_t, int);
+struct netent *getnetbyname (const char *);
+struct netent *getnetent (void);
+struct protoent *getprotobyname (const char *);
+struct protoent *getprotobynumber (int);
+struct protoent *getprotoent (void);
+struct servent *getservbyname (const char *, const char *);
+struct servent *getservbyport (int, const char *);
+struct servent *getservent (void);
+void sethostent (int);
+void setnetent (int);
+void setprotoent (int);
+void setservent (int);
+
+
+
+
+
+
+
+
+
+
+#endif /* !_NETDB_ */
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h third_party/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/include/poll.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,30 @@
+#ifndef _POLL_H
+#define _POLL_H
+
+#include <sys/types.h>
+#include <sys/time.h>
+
+
+#define POLLIN      (1<<0)
+#define POLLRDNORM  (1<<1)
+#define POLLRDBAND  (1<<2)
+#define POLLPRI     (1<<3)
+#define POLLOUT     (1<<4)
+#define POLLWRNORM  (1<<5)
+#define POLLWRBAND  (1<<6)
+#define POLLERR     (1<<7)
+#define POLLNVAL    (1<<8)
+
+typedef unsigned int  nfds_t;
+
+struct pollfd
+{
+  int fd;
+  short events;
+  short revents;
+};
+
+
+int poll (struct pollfd[], nfds_t nfds, int timeout);
+		   
+#endif 
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h third_party/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/include/termios.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,11 @@
+/* termios.h
+ */
+
+#ifndef _TERMIOS_H_
+#define _TERMIOS_H_
+
+#include <sys/termios.h>
+
+
+#endif /* !_TERMIOS_H_ */
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h third_party/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/include/ucontext.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,93 @@
+#ifndef	_UCONTEXT_H
+#define	_UCONTEXT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <signal.h>
+#include <sys/signal.h>
+
+typedef struct mcontext {
+  uint32_t sp;
+  uint32_t lr;
+  uint32_t cpsr; // Should be svc_mode spsr
+  uint32_t r1;
+  uint32_t r2;
+  uint32_t r3;
+  uint32_t r4;
+  uint32_t r5;
+  uint32_t r6;
+  uint32_t r7;
+  uint32_t r8;
+  uint32_t r9;
+  uint32_t r10;
+  uint32_t r11;
+  uint32_t r12;
+  uint32_t r0;
+  uint32_t pc; // Should be xyz_ svc_mode LR register.
+  uint32_t pad;
+} mcontext_t __attribute__((packed));
+
+
+
+/*
+ * ucontext_t
+ */
+
+#define UCF_SWAPPED     0x00000001      /* Used by swapcontext(3). */
+
+typedef struct __ucontext
+{
+	mcontext_t	uc_mcontext;
+	
+	sigset_t	uc_sigmask;
+	stack_t		uc_stack;
+	int			uc_flags;
+	struct __ucontext *uc_link;
+
+} ucontext_t;
+ 
+ 
+
+/*
+ *
+ */
+ 
+typedef void __sighandler_t (int);
+typedef	void __siginfohandler_t (int, siginfo_t *, void *);
+
+
+
+
+/*
+ * struct sigframe
+ */
+
+struct sigframe
+{
+  int          sf_signum;
+  siginfo_t    *sf_siginfo;     /* pointer to sf_si */
+  ucontext_t   *sf_ucontext;    /* pointer to sf_uc */
+
+  union
+  {
+		__siginfohandler_t      *sf_action;
+		__sighandler_t          *sf_handler;
+	} sf_ahu;
+    
+  ucontext_t      sf_uc;          /* = *sf_ucontext */
+  siginfo_t       sf_si;          /* = *sf_siginfo (SA_SIGINFO case) */
+};
+
+
+ 
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/interrupt.c third_party/newlib-3.2.0/newlib/libc/sys/arm/interrupt.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/interrupt.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/interrupt.c	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,58 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int createinterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api))
+{
+    int sc;
+    
+    sc = _swi_createinterrupt(irq, interrupt_handler);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+
+/*
+ *
+ */
+int maskinterrupt (int irq)
+{
+    int sc;
+    
+    sc = _swi_maskinterrupt(irq);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int unmaskinterrupt (int irq)
+{
+    int sc;
+    
+    sc = _swi_unmaskinterrupt(irq);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c third_party/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/ioctl.c	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,27 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+#include <stdarg.h>
+
+
+int ioctl (int fd, int request, ... )
+{
+    va_list ap;
+    int sc;
+
+    va_start(ap, request);
+    sc = _swi_ioctl(fd, request, va_arg(ap, void *));
+    va_end(ap);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c third_party/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/libcfunc.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,15 +0,0 @@
-/* Support files for GNU libc.  Files in the C namespace go here.
-   Files in the system namespace (ie those that start with an underscore)
-   go in syscalls.c.
-   
-   Note: These functions are in a seperate file so that OS providers can
-   overrride the system call stubs (defined in syscalls.c) without having
-   to provide libc funcitons as well.  */
-#include "swi.h"
-
-
-
-void
-alarm (void)
-{
-}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/link.c third_party/newlib-3.2.0/newlib/libc/sys/arm/link.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/link.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/link.c	2022-06-30 12:12:05.022654952 +0100
@@ -0,0 +1,52 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+int link (const char *existing, const char *new)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+/*
+ *
+ */
+int readlink(const char *path, char *buf, size_t bufsize)
+{
+    int sc;
+    
+    sc = _swi_readlink(path, buf, bufsize);
+    
+    if (sc < 0) {
+      errno = -sc;
+      return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int symlink(const char *path1, const char *path2)
+{
+    int sc;
+    
+    sc = _swi_symlink(path1, path2);
+    
+    if (sc < 0) {
+      errno = -sc;
+      return -1;
+    }
+    
+    return 0;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/lseek.c third_party/newlib-3.2.0/newlib/libc/sys/arm/lseek.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/lseek.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/lseek.c	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,41 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+off_t lseek (int fd, off_t offset, int whence)
+{
+    int sc;
+    
+    sc = _swi_lseek(fd, offset, whence);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+
+/*
+ *
+ */
+off64_t lseek64 (int fd, off64_t offset, int whence)
+{
+    int sc;
+    
+    sc = _swi_lseek64(fd, &offset, whence);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return offset;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/limits.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,6 @@
+/*
+ *  $Id: limits.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+/* intentionally empty file */
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/param.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,92 @@
+/*
+ *  $Id: param.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef _MACHINE_PARAM_H_
+#define	_MACHINE_PARAM_H_
+
+/*
+ * These aren't really machine-dependent for RTEMS.....
+ */
+
+/*
+#define MACHINE		"i386"
+#define MID_MACHINE	MID_I386
+*/
+
+/*
+ * Round p (pointer or byte index) up to a correctly-aligned value
+ * for all data types (int, long, ...).   The result is unsigned int
+ * and must be cast to any desired pointer type.
+ */
+#define ALIGNBYTES	(sizeof(int) - 1)
+#define ALIGN(p)	(((unsigned)(p) + ALIGNBYTES) & ~ALIGNBYTES)
+
+#define PAGE_SHIFT	12		/* LOG2(PAGE_SIZE) */
+#define PAGE_SIZE	(1<<PAGE_SHIFT)	/* bytes/page */
+#define PAGE_MASK	(PAGE_SIZE-1)
+#define NPTEPG		(PAGE_SIZE/(sizeof (pt_entry_t)))
+
+#define NPDEPG		(PAGE_SIZE/(sizeof (pd_entry_t)))
+#define PDRSHIFT	22		/* LOG2(NBPDR) */
+#define NBPDR		(1<<PDRSHIFT)	/* bytes/page dir */
+
+#define DEV_BSHIFT	9		/* log2(DEV_BSIZE) */
+#define DEV_BSIZE	(1<<DEV_BSHIFT)
+
+#define BLKDEV_IOSIZE	2048
+#define MAXPHYS		(64 * 1024)	/* max raw I/O transfer size */
+
+#define UPAGES	2		/* pages of u-area */
+
+/*
+ * Constants related to network buffer management.
+ * MCLBYTES must be no larger than CLBYTES (the software page size), and,
+ * on machines that exchange pages of input or output buffers with mbuf
+ * clusters (MAPPED_MBUFS), MCLBYTES must also be an integral multiple
+ * of the hardware page size.
+ */
+#ifndef	MSIZE
+#define MSIZE		128		/* size of an mbuf */
+#endif	/* MSIZE */
+
+#ifndef	MCLSHIFT
+#define MCLSHIFT	11		/* convert bytes to m_buf clusters */
+#endif	/* MCLSHIFT */
+#define MCLBYTES	(1 << MCLSHIFT)	/* size of an m_buf cluster */
+#define MCLOFSET	(MCLBYTES - 1)	/* offset within an m_buf cluster */
+
+/*
+ * Some macros for units conversion
+ */
+
+/* clicks to bytes */
+#define ctob(x)	((x)<<PAGE_SHIFT)
+
+/* bytes to clicks */
+#define btoc(x)	(((unsigned)(x)+PAGE_MASK)>>PAGE_SHIFT)
+
+/*
+ * btodb() is messy and perhaps slow because `bytes' may be an off_t.  We
+ * want to shift an unsigned type to avoid sign extension and we don't
+ * want to widen `bytes' unnecessarily.  Assume that the result fits in
+ * a daddr_t.
+ */
+#define btodb(bytes)	 		/* calculates (bytes / DEV_BSIZE) */ \
+	(sizeof (bytes) > sizeof(long) \
+	 ? (daddr_t)((unsigned long long)(bytes) >> DEV_BSHIFT) \
+	 : (daddr_t)((unsigned long)(bytes) >> DEV_BSHIFT))
+
+#define dbtob(db)			/* calculates (db * DEV_BSIZE) */ \
+	((off_t)(db) << DEV_BSHIFT)
+
+/*
+ * Mach derived conversion macros
+ */
+#define trunc_page(x)		((unsigned)(x) & ~PAGE_MASK)
+#define round_page(x)		((((unsigned)(x)) + PAGE_MASK) & ~PAGE_MASK)
+
+#define atop(x)			((unsigned)(x) >> PAGE_SHIFT)
+#define ptoa(x)			((unsigned)(x) << PAGE_SHIFT)
+
+#endif /* !_MACHINE_PARAM_H_ */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/machine/types.h	2022-06-29 14:50:02.729941202 +0100
@@ -0,0 +1,32 @@
+#ifndef	_MACHTYPES_H_
+#define	_MACHTYPES_H_
+
+/*
+ *  The following section is RTEMS specific and is needed to more
+ *  closely match the types defined in the BSD machine/types.h.
+ *  This is needed to let the RTEMS/BSD TCP/IP stack compile.
+ */
+#if defined(__rtems__)
+#include <machine/_types.h>
+#endif
+
+#define	_CLOCK_T_	unsigned long		/* clock() */
+#define	_TIME_T_	long long			/* time() */
+#define _CLOCKID_T_ 	unsigned long
+#define _TIMER_T_   	unsigned long
+
+#ifndef _HAVE_SYSTYPES
+typedef long int __off_t;
+typedef int __pid_t;
+#ifdef __GNUC__
+__extension__ typedef long long int __loff_t;
+#else
+typedef long int __loff_t;
+#endif
+#endif
+
+typedef long long int off64_t;
+
+#endif	/* _MACHTYPES_H_ */
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.am	2022-06-29 14:50:02.729941202 +0100
@@ -2,28 +2,80 @@
 
 AUTOMAKE_OPTIONS = cygnus
 
-INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
+INCLUDES = -I$(srcdir)/include $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
 
 AM_CCASFLAGS = $(INCLUDES)
 
 noinst_LIBRARIES = lib.a
 
-if MAY_SUPPLY_SYSCALLS
-extra_objs = $(lpfx)libcfunc.o $(lpfx)trap.o $(lpfx)syscalls.o
-else
-extra_objs =
-endif
-
-lib_a_SOURCES = access.c aeabi_atexit.c
-lib_a_LIBADD = $(extra_objs)
-EXTRA_lib_a_SOURCES = trap.S syscalls.c libcfunc.c
-lib_a_DEPENDENCIES = $(extra_objs)
+lib_a_SOURCES = \
+  _exit.c \
+  access.c \
+	alarm.c \
+	chmod.c \
+	close.c \
+	closedir.c \
+	creat.c \
+	debug.c \
+	dir.c \
+	dup.c \
+	environ.c \
+	execl.c \
+	execle.c \
+	execlp.c \
+	execv.c \
+	execve.c \
+	execvp.c \
+	fcntl.c \
+	fork.c \
+	fstat.c \
+	getpid.c \
+	gettod.c \
+	id.c \
+	interrupt.c \
+	ioctl.c \
+	link.c \
+	lseek.c \
+	malloc.c \
+	mknod.c \
+	mntent.c \
+	mount.c \
+	msg.c \
+	open.c \
+	opendir.c \
+	pathconf.c \
+	pipe.c \
+	popen.c \
+	pwd.c \
+	read.c \
+	readdir.c \
+	rename.c \
+	resource.c \
+	rewinddir.c \
+	select.c \
+	siglist.c \
+	signal.c \
+	syscall.S \
+	sleep.c \
+	stat.c \
+	statvfs.c \
+	sync.c \
+	sysconf.c \
+	termios.c \
+	time.c \
+	times.c \
+	truncate.c \
+	unlink.c \
+	user_strerror.c \
+  virtualalloc.c \
+	wait.c \
+	write.c
+	
+	
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 
-if MAY_SUPPLY_SYSCALLS
 all-local: crt0.o
-endif
 
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
 CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/Makefile.in	2022-06-29 14:50:02.733941303 +0100
@@ -1,4 +1,4 @@
-# Makefile.in generated by automake 1.11.6 from Makefile.am.
+# Makefile.in generated by automake 1.12 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
@@ -53,8 +53,8 @@
 host_triplet = @host@
 subdir = .
 DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/configure $(am__configure_deps) \
-	$(srcdir)/../../../../mkinstalldirs
+	$(top_srcdir)/configure $(am__configure_deps) acconfig.h \
+	$(top_srcdir)/../../../../mkinstalldirs
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../../../acinclude.m4 \
 	$(top_srcdir)/configure.in
@@ -68,9 +68,37 @@
 LIBRARIES = $(noinst_LIBRARIES)
 ARFLAGS = cru
 lib_a_AR = $(AR) $(ARFLAGS)
-@MAY_SUPPLY_SYSCALLS_TRUE@am__DEPENDENCIES_1 = $(lpfx)libcfunc.o \
-@MAY_SUPPLY_SYSCALLS_TRUE@	$(lpfx)trap.o $(lpfx)syscalls.o
-am_lib_a_OBJECTS = lib_a-access.$(OBJEXT) lib_a-aeabi_atexit.$(OBJEXT)
+lib_a_LIBADD =
+am_lib_a_OBJECTS = lib_a-_exit.$(OBJEXT) lib_a-access.$(OBJEXT) \
+	lib_a-alarm.$(OBJEXT) lib_a-chmod.$(OBJEXT) \
+	lib_a-close.$(OBJEXT) lib_a-closedir.$(OBJEXT) \
+	lib_a-creat.$(OBJEXT) lib_a-debug.$(OBJEXT) \
+	lib_a-dir.$(OBJEXT) lib_a-dup.$(OBJEXT) \
+	lib_a-environ.$(OBJEXT) lib_a-execl.$(OBJEXT) \
+	lib_a-execle.$(OBJEXT) lib_a-execlp.$(OBJEXT) \
+	lib_a-execv.$(OBJEXT) lib_a-execve.$(OBJEXT) \
+	lib_a-execvp.$(OBJEXT) lib_a-fcntl.$(OBJEXT) \
+	lib_a-fork.$(OBJEXT) lib_a-fstat.$(OBJEXT) \
+	lib_a-getpid.$(OBJEXT) lib_a-gettod.$(OBJEXT) \
+	lib_a-id.$(OBJEXT) lib_a-interrupt.$(OBJEXT) \
+	lib_a-ioctl.$(OBJEXT) lib_a-link.$(OBJEXT) \
+	lib_a-lseek.$(OBJEXT) lib_a-malloc.$(OBJEXT) \
+	lib_a-mknod.$(OBJEXT) lib_a-mntent.$(OBJEXT) \
+	lib_a-mount.$(OBJEXT) lib_a-msg.$(OBJEXT) lib_a-open.$(OBJEXT) \
+	lib_a-opendir.$(OBJEXT) lib_a-pathconf.$(OBJEXT) \
+	lib_a-pipe.$(OBJEXT) lib_a-popen.$(OBJEXT) lib_a-pwd.$(OBJEXT) \
+	lib_a-read.$(OBJEXT) lib_a-readdir.$(OBJEXT) \
+	lib_a-rename.$(OBJEXT) lib_a-resource.$(OBJEXT) \
+	lib_a-rewinddir.$(OBJEXT) lib_a-select.$(OBJEXT) \
+	lib_a-siglist.$(OBJEXT) lib_a-signal.$(OBJEXT) \
+	lib_a-syscall.$(OBJEXT) lib_a-sleep.$(OBJEXT) \
+	lib_a-stat.$(OBJEXT) lib_a-statvfs.$(OBJEXT) \
+	lib_a-sync.$(OBJEXT) lib_a-sysconf.$(OBJEXT) \
+	lib_a-termios.$(OBJEXT) lib_a-time.$(OBJEXT) \
+	lib_a-times.$(OBJEXT) lib_a-truncate.$(OBJEXT) \
+	lib_a-unlink.$(OBJEXT) lib_a-user_strerror.$(OBJEXT) \
+	lib_a-virtualalloc.$(OBJEXT) lib_a-wait.$(OBJEXT) \
+	lib_a-write.$(OBJEXT)
 lib_a_OBJECTS = $(am_lib_a_OBJECTS)
 DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
@@ -81,7 +109,7 @@
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
 LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@
-SOURCES = $(lib_a_SOURCES) $(EXTRA_lib_a_SOURCES)
+SOURCES = $(lib_a_SOURCES)
 am__can_run_installinfo = \
   case $$AM_UPDATE_INFO_DIR in \
     n|no|NO) false;; \
@@ -89,6 +117,8 @@
   esac
 ETAGS = etags
 CTAGS = ctags
+CSCOPE = cscope
+AM_RECURSIVE_TARGETS = cscope
 ACLOCAL = @ACLOCAL@
 AMTAR = @AMTAR@
 AR = @AR@
@@ -193,15 +223,72 @@
 top_builddir = @top_builddir@
 top_srcdir = @top_srcdir@
 AUTOMAKE_OPTIONS = cygnus
-INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
+INCLUDES = -I$(srcdir)/include $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS) -I$(newlib_basedir)/libc/machine/arm
 AM_CCASFLAGS = $(INCLUDES)
 noinst_LIBRARIES = lib.a
-@MAY_SUPPLY_SYSCALLS_FALSE@extra_objs = 
-@MAY_SUPPLY_SYSCALLS_TRUE@extra_objs = $(lpfx)libcfunc.o $(lpfx)trap.o $(lpfx)syscalls.o
-lib_a_SOURCES = access.c aeabi_atexit.c
-lib_a_LIBADD = $(extra_objs)
-EXTRA_lib_a_SOURCES = trap.S syscalls.c libcfunc.c
-lib_a_DEPENDENCIES = $(extra_objs)
+lib_a_SOURCES = \
+  _exit.c \
+  access.c \
+	alarm.c \
+	chmod.c \
+	close.c \
+	closedir.c \
+	creat.c \
+	debug.c \
+	dir.c \
+	dup.c \
+	environ.c \
+	execl.c \
+	execle.c \
+	execlp.c \
+	execv.c \
+	execve.c \
+	execvp.c \
+	fcntl.c \
+	fork.c \
+	fstat.c \
+	getpid.c \
+	gettod.c \
+	id.c \
+	interrupt.c \
+	ioctl.c \
+	link.c \
+	lseek.c \
+	malloc.c \
+	mknod.c \
+	mntent.c \
+	mount.c \
+	msg.c \
+	open.c \
+	opendir.c \
+	pathconf.c \
+	pipe.c \
+	popen.c \
+	pwd.c \
+	read.c \
+	readdir.c \
+	rename.c \
+	resource.c \
+	rewinddir.c \
+	select.c \
+	siglist.c \
+	signal.c \
+	syscall.S \
+	sleep.c \
+	stat.c \
+	statvfs.c \
+	sync.c \
+	sysconf.c \
+	termios.c \
+	time.c \
+	times.c \
+	truncate.c \
+	unlink.c \
+	user_strerror.c \
+  virtualalloc.c \
+	wait.c \
+	write.c
+
 lib_a_CCASFLAGS = $(AM_CCASFLAGS)
 lib_a_CFLAGS = $(AM_CFLAGS)
 ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
@@ -264,11 +351,11 @@
 .S.obj:
 	$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
 
-lib_a-trap.o: trap.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-trap.o `test -f 'trap.S' || echo '$(srcdir)/'`trap.S
+lib_a-syscall.o: syscall.S
+	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-syscall.o `test -f 'syscall.S' || echo '$(srcdir)/'`syscall.S
 
-lib_a-trap.obj: trap.S
-	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-trap.obj `if test -f 'trap.S'; then $(CYGPATH_W) 'trap.S'; else $(CYGPATH_W) '$(srcdir)/trap.S'; fi`
+lib_a-syscall.obj: syscall.S
+	$(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CCASFLAGS) $(CCASFLAGS) -c -o lib_a-syscall.obj `if test -f 'syscall.S'; then $(CYGPATH_W) 'syscall.S'; else $(CYGPATH_W) '$(srcdir)/syscall.S'; fi`
 
 .c.o:
 	$(COMPILE) -c $<
@@ -276,29 +363,365 @@
 .c.obj:
 	$(COMPILE) -c `$(CYGPATH_W) '$<'`
 
+lib_a-_exit.o: _exit.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-_exit.o `test -f '_exit.c' || echo '$(srcdir)/'`_exit.c
+
+lib_a-_exit.obj: _exit.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-_exit.obj `if test -f '_exit.c'; then $(CYGPATH_W) '_exit.c'; else $(CYGPATH_W) '$(srcdir)/_exit.c'; fi`
+
 lib_a-access.o: access.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.o `test -f 'access.c' || echo '$(srcdir)/'`access.c
 
 lib_a-access.obj: access.c
 	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-access.obj `if test -f 'access.c'; then $(CYGPATH_W) 'access.c'; else $(CYGPATH_W) '$(srcdir)/access.c'; fi`
 
-lib_a-aeabi_atexit.o: aeabi_atexit.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_atexit.o `test -f 'aeabi_atexit.c' || echo '$(srcdir)/'`aeabi_atexit.c
+lib_a-alarm.o: alarm.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-alarm.o `test -f 'alarm.c' || echo '$(srcdir)/'`alarm.c
+
+lib_a-alarm.obj: alarm.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-alarm.obj `if test -f 'alarm.c'; then $(CYGPATH_W) 'alarm.c'; else $(CYGPATH_W) '$(srcdir)/alarm.c'; fi`
+
+lib_a-chmod.o: chmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-chmod.o `test -f 'chmod.c' || echo '$(srcdir)/'`chmod.c
+
+lib_a-chmod.obj: chmod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-chmod.obj `if test -f 'chmod.c'; then $(CYGPATH_W) 'chmod.c'; else $(CYGPATH_W) '$(srcdir)/chmod.c'; fi`
+
+lib_a-close.o: close.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-close.o `test -f 'close.c' || echo '$(srcdir)/'`close.c
+
+lib_a-close.obj: close.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-close.obj `if test -f 'close.c'; then $(CYGPATH_W) 'close.c'; else $(CYGPATH_W) '$(srcdir)/close.c'; fi`
+
+lib_a-closedir.o: closedir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-closedir.o `test -f 'closedir.c' || echo '$(srcdir)/'`closedir.c
+
+lib_a-closedir.obj: closedir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-closedir.obj `if test -f 'closedir.c'; then $(CYGPATH_W) 'closedir.c'; else $(CYGPATH_W) '$(srcdir)/closedir.c'; fi`
+
+lib_a-creat.o: creat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-creat.o `test -f 'creat.c' || echo '$(srcdir)/'`creat.c
+
+lib_a-creat.obj: creat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-creat.obj `if test -f 'creat.c'; then $(CYGPATH_W) 'creat.c'; else $(CYGPATH_W) '$(srcdir)/creat.c'; fi`
+
+lib_a-debug.o: debug.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-debug.o `test -f 'debug.c' || echo '$(srcdir)/'`debug.c
+
+lib_a-debug.obj: debug.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-debug.obj `if test -f 'debug.c'; then $(CYGPATH_W) 'debug.c'; else $(CYGPATH_W) '$(srcdir)/debug.c'; fi`
+
+lib_a-dir.o: dir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dir.o `test -f 'dir.c' || echo '$(srcdir)/'`dir.c
+
+lib_a-dir.obj: dir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dir.obj `if test -f 'dir.c'; then $(CYGPATH_W) 'dir.c'; else $(CYGPATH_W) '$(srcdir)/dir.c'; fi`
+
+lib_a-dup.o: dup.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dup.o `test -f 'dup.c' || echo '$(srcdir)/'`dup.c
+
+lib_a-dup.obj: dup.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-dup.obj `if test -f 'dup.c'; then $(CYGPATH_W) 'dup.c'; else $(CYGPATH_W) '$(srcdir)/dup.c'; fi`
+
+lib_a-environ.o: environ.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-environ.o `test -f 'environ.c' || echo '$(srcdir)/'`environ.c
+
+lib_a-environ.obj: environ.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-environ.obj `if test -f 'environ.c'; then $(CYGPATH_W) 'environ.c'; else $(CYGPATH_W) '$(srcdir)/environ.c'; fi`
+
+lib_a-execl.o: execl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execl.o `test -f 'execl.c' || echo '$(srcdir)/'`execl.c
+
+lib_a-execl.obj: execl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execl.obj `if test -f 'execl.c'; then $(CYGPATH_W) 'execl.c'; else $(CYGPATH_W) '$(srcdir)/execl.c'; fi`
+
+lib_a-execle.o: execle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execle.o `test -f 'execle.c' || echo '$(srcdir)/'`execle.c
+
+lib_a-execle.obj: execle.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execle.obj `if test -f 'execle.c'; then $(CYGPATH_W) 'execle.c'; else $(CYGPATH_W) '$(srcdir)/execle.c'; fi`
+
+lib_a-execlp.o: execlp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execlp.o `test -f 'execlp.c' || echo '$(srcdir)/'`execlp.c
+
+lib_a-execlp.obj: execlp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execlp.obj `if test -f 'execlp.c'; then $(CYGPATH_W) 'execlp.c'; else $(CYGPATH_W) '$(srcdir)/execlp.c'; fi`
+
+lib_a-execv.o: execv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execv.o `test -f 'execv.c' || echo '$(srcdir)/'`execv.c
+
+lib_a-execv.obj: execv.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execv.obj `if test -f 'execv.c'; then $(CYGPATH_W) 'execv.c'; else $(CYGPATH_W) '$(srcdir)/execv.c'; fi`
+
+lib_a-execve.o: execve.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execve.o `test -f 'execve.c' || echo '$(srcdir)/'`execve.c
+
+lib_a-execve.obj: execve.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execve.obj `if test -f 'execve.c'; then $(CYGPATH_W) 'execve.c'; else $(CYGPATH_W) '$(srcdir)/execve.c'; fi`
+
+lib_a-execvp.o: execvp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execvp.o `test -f 'execvp.c' || echo '$(srcdir)/'`execvp.c
+
+lib_a-execvp.obj: execvp.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-execvp.obj `if test -f 'execvp.c'; then $(CYGPATH_W) 'execvp.c'; else $(CYGPATH_W) '$(srcdir)/execvp.c'; fi`
+
+lib_a-fcntl.o: fcntl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fcntl.o `test -f 'fcntl.c' || echo '$(srcdir)/'`fcntl.c
+
+lib_a-fcntl.obj: fcntl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fcntl.obj `if test -f 'fcntl.c'; then $(CYGPATH_W) 'fcntl.c'; else $(CYGPATH_W) '$(srcdir)/fcntl.c'; fi`
+
+lib_a-fork.o: fork.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fork.o `test -f 'fork.c' || echo '$(srcdir)/'`fork.c
+
+lib_a-fork.obj: fork.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fork.obj `if test -f 'fork.c'; then $(CYGPATH_W) 'fork.c'; else $(CYGPATH_W) '$(srcdir)/fork.c'; fi`
+
+lib_a-fstat.o: fstat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fstat.o `test -f 'fstat.c' || echo '$(srcdir)/'`fstat.c
+
+lib_a-fstat.obj: fstat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-fstat.obj `if test -f 'fstat.c'; then $(CYGPATH_W) 'fstat.c'; else $(CYGPATH_W) '$(srcdir)/fstat.c'; fi`
+
+lib_a-getpid.o: getpid.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpid.o `test -f 'getpid.c' || echo '$(srcdir)/'`getpid.c
+
+lib_a-getpid.obj: getpid.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-getpid.obj `if test -f 'getpid.c'; then $(CYGPATH_W) 'getpid.c'; else $(CYGPATH_W) '$(srcdir)/getpid.c'; fi`
+
+lib_a-gettod.o: gettod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettod.o `test -f 'gettod.c' || echo '$(srcdir)/'`gettod.c
+
+lib_a-gettod.obj: gettod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-gettod.obj `if test -f 'gettod.c'; then $(CYGPATH_W) 'gettod.c'; else $(CYGPATH_W) '$(srcdir)/gettod.c'; fi`
+
+lib_a-id.o: id.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-id.o `test -f 'id.c' || echo '$(srcdir)/'`id.c
+
+lib_a-id.obj: id.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-id.obj `if test -f 'id.c'; then $(CYGPATH_W) 'id.c'; else $(CYGPATH_W) '$(srcdir)/id.c'; fi`
+
+lib_a-interrupt.o: interrupt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-interrupt.o `test -f 'interrupt.c' || echo '$(srcdir)/'`interrupt.c
+
+lib_a-interrupt.obj: interrupt.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-interrupt.obj `if test -f 'interrupt.c'; then $(CYGPATH_W) 'interrupt.c'; else $(CYGPATH_W) '$(srcdir)/interrupt.c'; fi`
+
+lib_a-ioctl.o: ioctl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ioctl.o `test -f 'ioctl.c' || echo '$(srcdir)/'`ioctl.c
+
+lib_a-ioctl.obj: ioctl.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-ioctl.obj `if test -f 'ioctl.c'; then $(CYGPATH_W) 'ioctl.c'; else $(CYGPATH_W) '$(srcdir)/ioctl.c'; fi`
+
+lib_a-link.o: link.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-link.o `test -f 'link.c' || echo '$(srcdir)/'`link.c
+
+lib_a-link.obj: link.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-link.obj `if test -f 'link.c'; then $(CYGPATH_W) 'link.c'; else $(CYGPATH_W) '$(srcdir)/link.c'; fi`
+
+lib_a-lseek.o: lseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-lseek.o `test -f 'lseek.c' || echo '$(srcdir)/'`lseek.c
+
+lib_a-lseek.obj: lseek.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-lseek.obj `if test -f 'lseek.c'; then $(CYGPATH_W) 'lseek.c'; else $(CYGPATH_W) '$(srcdir)/lseek.c'; fi`
+
+lib_a-malloc.o: malloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-malloc.o `test -f 'malloc.c' || echo '$(srcdir)/'`malloc.c
+
+lib_a-malloc.obj: malloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-malloc.obj `if test -f 'malloc.c'; then $(CYGPATH_W) 'malloc.c'; else $(CYGPATH_W) '$(srcdir)/malloc.c'; fi`
+
+lib_a-mknod.o: mknod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mknod.o `test -f 'mknod.c' || echo '$(srcdir)/'`mknod.c
+
+lib_a-mknod.obj: mknod.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mknod.obj `if test -f 'mknod.c'; then $(CYGPATH_W) 'mknod.c'; else $(CYGPATH_W) '$(srcdir)/mknod.c'; fi`
+
+lib_a-mntent.o: mntent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mntent.o `test -f 'mntent.c' || echo '$(srcdir)/'`mntent.c
+
+lib_a-mntent.obj: mntent.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mntent.obj `if test -f 'mntent.c'; then $(CYGPATH_W) 'mntent.c'; else $(CYGPATH_W) '$(srcdir)/mntent.c'; fi`
 
-lib_a-aeabi_atexit.obj: aeabi_atexit.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-aeabi_atexit.obj `if test -f 'aeabi_atexit.c'; then $(CYGPATH_W) 'aeabi_atexit.c'; else $(CYGPATH_W) '$(srcdir)/aeabi_atexit.c'; fi`
+lib_a-mount.o: mount.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mount.o `test -f 'mount.c' || echo '$(srcdir)/'`mount.c
 
-lib_a-syscalls.o: syscalls.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-syscalls.o `test -f 'syscalls.c' || echo '$(srcdir)/'`syscalls.c
+lib_a-mount.obj: mount.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-mount.obj `if test -f 'mount.c'; then $(CYGPATH_W) 'mount.c'; else $(CYGPATH_W) '$(srcdir)/mount.c'; fi`
 
-lib_a-syscalls.obj: syscalls.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-syscalls.obj `if test -f 'syscalls.c'; then $(CYGPATH_W) 'syscalls.c'; else $(CYGPATH_W) '$(srcdir)/syscalls.c'; fi`
+lib_a-msg.o: msg.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-msg.o `test -f 'msg.c' || echo '$(srcdir)/'`msg.c
 
-lib_a-libcfunc.o: libcfunc.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-libcfunc.o `test -f 'libcfunc.c' || echo '$(srcdir)/'`libcfunc.c
+lib_a-msg.obj: msg.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-msg.obj `if test -f 'msg.c'; then $(CYGPATH_W) 'msg.c'; else $(CYGPATH_W) '$(srcdir)/msg.c'; fi`
 
-lib_a-libcfunc.obj: libcfunc.c
-	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-libcfunc.obj `if test -f 'libcfunc.c'; then $(CYGPATH_W) 'libcfunc.c'; else $(CYGPATH_W) '$(srcdir)/libcfunc.c'; fi`
+lib_a-open.o: open.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-open.o `test -f 'open.c' || echo '$(srcdir)/'`open.c
+
+lib_a-open.obj: open.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-open.obj `if test -f 'open.c'; then $(CYGPATH_W) 'open.c'; else $(CYGPATH_W) '$(srcdir)/open.c'; fi`
+
+lib_a-opendir.o: opendir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-opendir.o `test -f 'opendir.c' || echo '$(srcdir)/'`opendir.c
+
+lib_a-opendir.obj: opendir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-opendir.obj `if test -f 'opendir.c'; then $(CYGPATH_W) 'opendir.c'; else $(CYGPATH_W) '$(srcdir)/opendir.c'; fi`
+
+lib_a-pathconf.o: pathconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pathconf.o `test -f 'pathconf.c' || echo '$(srcdir)/'`pathconf.c
+
+lib_a-pathconf.obj: pathconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pathconf.obj `if test -f 'pathconf.c'; then $(CYGPATH_W) 'pathconf.c'; else $(CYGPATH_W) '$(srcdir)/pathconf.c'; fi`
+
+lib_a-pipe.o: pipe.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pipe.o `test -f 'pipe.c' || echo '$(srcdir)/'`pipe.c
+
+lib_a-pipe.obj: pipe.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pipe.obj `if test -f 'pipe.c'; then $(CYGPATH_W) 'pipe.c'; else $(CYGPATH_W) '$(srcdir)/pipe.c'; fi`
+
+lib_a-popen.o: popen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-popen.o `test -f 'popen.c' || echo '$(srcdir)/'`popen.c
+
+lib_a-popen.obj: popen.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-popen.obj `if test -f 'popen.c'; then $(CYGPATH_W) 'popen.c'; else $(CYGPATH_W) '$(srcdir)/popen.c'; fi`
+
+lib_a-pwd.o: pwd.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pwd.o `test -f 'pwd.c' || echo '$(srcdir)/'`pwd.c
+
+lib_a-pwd.obj: pwd.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-pwd.obj `if test -f 'pwd.c'; then $(CYGPATH_W) 'pwd.c'; else $(CYGPATH_W) '$(srcdir)/pwd.c'; fi`
+
+lib_a-read.o: read.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-read.o `test -f 'read.c' || echo '$(srcdir)/'`read.c
+
+lib_a-read.obj: read.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-read.obj `if test -f 'read.c'; then $(CYGPATH_W) 'read.c'; else $(CYGPATH_W) '$(srcdir)/read.c'; fi`
+
+lib_a-readdir.o: readdir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-readdir.o `test -f 'readdir.c' || echo '$(srcdir)/'`readdir.c
+
+lib_a-readdir.obj: readdir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-readdir.obj `if test -f 'readdir.c'; then $(CYGPATH_W) 'readdir.c'; else $(CYGPATH_W) '$(srcdir)/readdir.c'; fi`
+
+lib_a-rename.o: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.o `test -f 'rename.c' || echo '$(srcdir)/'`rename.c
+
+lib_a-rename.obj: rename.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rename.obj `if test -f 'rename.c'; then $(CYGPATH_W) 'rename.c'; else $(CYGPATH_W) '$(srcdir)/rename.c'; fi`
+
+lib_a-resource.o: resource.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-resource.o `test -f 'resource.c' || echo '$(srcdir)/'`resource.c
+
+lib_a-resource.obj: resource.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-resource.obj `if test -f 'resource.c'; then $(CYGPATH_W) 'resource.c'; else $(CYGPATH_W) '$(srcdir)/resource.c'; fi`
+
+lib_a-rewinddir.o: rewinddir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewinddir.o `test -f 'rewinddir.c' || echo '$(srcdir)/'`rewinddir.c
+
+lib_a-rewinddir.obj: rewinddir.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-rewinddir.obj `if test -f 'rewinddir.c'; then $(CYGPATH_W) 'rewinddir.c'; else $(CYGPATH_W) '$(srcdir)/rewinddir.c'; fi`
+
+lib_a-select.o: select.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-select.o `test -f 'select.c' || echo '$(srcdir)/'`select.c
+
+lib_a-select.obj: select.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-select.obj `if test -f 'select.c'; then $(CYGPATH_W) 'select.c'; else $(CYGPATH_W) '$(srcdir)/select.c'; fi`
+
+lib_a-siglist.o: siglist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-siglist.o `test -f 'siglist.c' || echo '$(srcdir)/'`siglist.c
+
+lib_a-siglist.obj: siglist.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-siglist.obj `if test -f 'siglist.c'; then $(CYGPATH_W) 'siglist.c'; else $(CYGPATH_W) '$(srcdir)/siglist.c'; fi`
+
+lib_a-signal.o: signal.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signal.o `test -f 'signal.c' || echo '$(srcdir)/'`signal.c
+
+lib_a-signal.obj: signal.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-signal.obj `if test -f 'signal.c'; then $(CYGPATH_W) 'signal.c'; else $(CYGPATH_W) '$(srcdir)/signal.c'; fi`
+
+lib_a-sleep.o: sleep.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sleep.o `test -f 'sleep.c' || echo '$(srcdir)/'`sleep.c
+
+lib_a-sleep.obj: sleep.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sleep.obj `if test -f 'sleep.c'; then $(CYGPATH_W) 'sleep.c'; else $(CYGPATH_W) '$(srcdir)/sleep.c'; fi`
+
+lib_a-stat.o: stat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stat.o `test -f 'stat.c' || echo '$(srcdir)/'`stat.c
+
+lib_a-stat.obj: stat.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-stat.obj `if test -f 'stat.c'; then $(CYGPATH_W) 'stat.c'; else $(CYGPATH_W) '$(srcdir)/stat.c'; fi`
+
+lib_a-statvfs.o: statvfs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statvfs.o `test -f 'statvfs.c' || echo '$(srcdir)/'`statvfs.c
+
+lib_a-statvfs.obj: statvfs.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-statvfs.obj `if test -f 'statvfs.c'; then $(CYGPATH_W) 'statvfs.c'; else $(CYGPATH_W) '$(srcdir)/statvfs.c'; fi`
+
+lib_a-sync.o: sync.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync.o `test -f 'sync.c' || echo '$(srcdir)/'`sync.c
+
+lib_a-sync.obj: sync.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sync.obj `if test -f 'sync.c'; then $(CYGPATH_W) 'sync.c'; else $(CYGPATH_W) '$(srcdir)/sync.c'; fi`
+
+lib_a-sysconf.o: sysconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sysconf.o `test -f 'sysconf.c' || echo '$(srcdir)/'`sysconf.c
+
+lib_a-sysconf.obj: sysconf.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-sysconf.obj `if test -f 'sysconf.c'; then $(CYGPATH_W) 'sysconf.c'; else $(CYGPATH_W) '$(srcdir)/sysconf.c'; fi`
+
+lib_a-termios.o: termios.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-termios.o `test -f 'termios.c' || echo '$(srcdir)/'`termios.c
+
+lib_a-termios.obj: termios.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-termios.obj `if test -f 'termios.c'; then $(CYGPATH_W) 'termios.c'; else $(CYGPATH_W) '$(srcdir)/termios.c'; fi`
+
+lib_a-time.o: time.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-time.o `test -f 'time.c' || echo '$(srcdir)/'`time.c
+
+lib_a-time.obj: time.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-time.obj `if test -f 'time.c'; then $(CYGPATH_W) 'time.c'; else $(CYGPATH_W) '$(srcdir)/time.c'; fi`
+
+lib_a-times.o: times.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.o `test -f 'times.c' || echo '$(srcdir)/'`times.c
+
+lib_a-times.obj: times.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-times.obj `if test -f 'times.c'; then $(CYGPATH_W) 'times.c'; else $(CYGPATH_W) '$(srcdir)/times.c'; fi`
+
+lib_a-truncate.o: truncate.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-truncate.o `test -f 'truncate.c' || echo '$(srcdir)/'`truncate.c
+
+lib_a-truncate.obj: truncate.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-truncate.obj `if test -f 'truncate.c'; then $(CYGPATH_W) 'truncate.c'; else $(CYGPATH_W) '$(srcdir)/truncate.c'; fi`
+
+lib_a-unlink.o: unlink.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlink.o `test -f 'unlink.c' || echo '$(srcdir)/'`unlink.c
+
+lib_a-unlink.obj: unlink.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-unlink.obj `if test -f 'unlink.c'; then $(CYGPATH_W) 'unlink.c'; else $(CYGPATH_W) '$(srcdir)/unlink.c'; fi`
+
+lib_a-user_strerror.o: user_strerror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-user_strerror.o `test -f 'user_strerror.c' || echo '$(srcdir)/'`user_strerror.c
+
+lib_a-user_strerror.obj: user_strerror.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-user_strerror.obj `if test -f 'user_strerror.c'; then $(CYGPATH_W) 'user_strerror.c'; else $(CYGPATH_W) '$(srcdir)/user_strerror.c'; fi`
+
+lib_a-virtualalloc.o: virtualalloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-virtualalloc.o `test -f 'virtualalloc.c' || echo '$(srcdir)/'`virtualalloc.c
+
+lib_a-virtualalloc.obj: virtualalloc.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-virtualalloc.obj `if test -f 'virtualalloc.c'; then $(CYGPATH_W) 'virtualalloc.c'; else $(CYGPATH_W) '$(srcdir)/virtualalloc.c'; fi`
+
+lib_a-wait.o: wait.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wait.o `test -f 'wait.c' || echo '$(srcdir)/'`wait.c
+
+lib_a-wait.obj: wait.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-wait.obj `if test -f 'wait.c'; then $(CYGPATH_W) 'wait.c'; else $(CYGPATH_W) '$(srcdir)/wait.c'; fi`
+
+lib_a-write.o: write.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-write.o `test -f 'write.c' || echo '$(srcdir)/'`write.c
+
+lib_a-write.obj: write.c
+	$(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(lib_a_CFLAGS) $(CFLAGS) -c -o lib_a-write.obj `if test -f 'write.c'; then $(CYGPATH_W) 'write.c'; else $(CYGPATH_W) '$(srcdir)/write.c'; fi`
 
 ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
 	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
@@ -349,11 +772,34 @@
 	  && $(am__cd) $(top_srcdir) \
 	  && gtags -i $(GTAGS_ARGS) "$$here"
 
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+
+clean-cscope:
+	-rm -f cscope.files
+
+cscope.files: clean-cscope  cscopelist
+
+cscopelist:  $(HEADERS) $(SOURCES) $(LISP)
+	list='$(SOURCES) $(HEADERS) $(LISP)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
 check-am:
 check: check-am
-@MAY_SUPPLY_SYSCALLS_FALSE@all-local:
 all-am: Makefile $(LIBRARIES) all-local
 installdirs:
 install: install-am
@@ -459,20 +905,20 @@
 .MAKE: install-am install-strip
 
 .PHONY: CTAGS GTAGS all all-am all-local am--refresh check check-am \
-	clean clean-generic clean-noinstLIBRARIES ctags distclean \
-	distclean-compile distclean-generic distclean-tags dvi dvi-am \
-	html html-am info info-am install install-am install-data \
-	install-data-am install-dvi install-dvi-am install-exec \
-	install-exec-am install-html install-html-am install-info \
-	install-info-am install-man install-pdf install-pdf-am \
-	install-ps install-ps-am install-strip installcheck \
-	installcheck-am installdirs maintainer-clean \
-	maintainer-clean-generic mostlyclean mostlyclean-compile \
-	mostlyclean-generic pdf pdf-am ps ps-am tags uninstall \
-	uninstall-am
+	clean clean-cscope clean-generic clean-noinstLIBRARIES cscope \
+	cscopelist ctags distclean distclean-compile distclean-generic \
+	distclean-tags dvi dvi-am html html-am info info-am install \
+	install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am
 
 
-@MAY_SUPPLY_SYSCALLS_TRUE@all-local: crt0.o
+all-local: crt0.o
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/malloc.c third_party/newlib-3.2.0/newlib/libc/sys/arm/malloc.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/malloc.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/malloc.c	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,6406 @@
+/*
+  This is a version (aka dlmalloc) of malloc/free/realloc written by
+  Doug Lea and released to the public domain, as explained at
+  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
+  comments, complaints, performance data, etc to dl@cs.oswego.edu
+* Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
+   Note: There may be an updated version of this malloc obtainable at
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+         Check before installing!
+ */
+/*
+ * PackageLicenseDeclared: CC0-1.0
+ */
+
+/* configuration */
+#include <stdint.h>
+#include <stddef.h>
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/syscalls.h>
+#include <sys/debug.h>
+
+
+/* @brief Simple sbrk implementation, not guaranteed to be contiguous.
+ * 
+ */
+static void *cheviot_sbrk(ssize_t sz)
+{
+    void *mem;
+    static void *sbrk_end = (void *)0x60000000;
+
+    if (sz < 0) {
+        return (void *)-1;    
+    } else if (sz == 0) {
+        return sbrk_end;  
+    }
+    
+    mem = _swi_virtualalloc (0x60000000, sz, PROT_READWRITE);
+    sbrk_end = mem + sz;
+    return mem;
+}
+
+
+#define LACKS_UNISTD_H
+#define LACKS_FCNTL_H
+#define LACKS_SYS_PARAM_H
+#define stderr 0
+#define HAVE_MORECORE 1
+#define MORECORE cheviot_sbrk
+#define MORECORE_CONTIGUOUS 0
+#define MORECORE_CANNOT_TRIM 1
+#define USE_DL_PREFIX
+#define LACKS_TIME_H
+
+#if defined(__ARMCC_VERSION)
+#define LACKS_SYS_TYPES_H
+#include <string.h>
+#endif
+
+#define HAVE_MMAP 0
+#define HAVE_MREMAP 0
+
+#define NO_MALLINFO 1
+#define NO_MALLOC_STATS 1
+
+#define DEFAULT_GRANULARITY 64
+
+/* end configuration*/
+/*
+  This is a version (aka dlmalloc) of malloc/free/realloc written by
+  Doug Lea and released to the public domain, as explained at
+  http://creativecommons.org/publicdomain/zero/1.0/ Send questions,
+  comments, complaints, performance data, etc to dl@cs.oswego.edu
+
+* Version 2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
+   Note: There may be an updated version of this malloc obtainable at
+           ftp://gee.cs.oswego.edu/pub/misc/malloc.c
+         Check before installing!
+
+* Quickstart
+
+  This library is all in one file to simplify the most common usage:
+  ftp it, compile it (-O3), and link it into another program. All of
+  the compile-time options default to reasonable values for use on
+  most platforms.  You might later want to step through various
+  compile-time and dynamic tuning options.
+
+  For convenience, an include file for code using this malloc is at:
+     ftp://gee.cs.oswego.edu/pub/misc/malloc-2.8.6.h
+  You don't really need this .h file unless you call functions not
+  defined in your system include files.  The .h file contains only the
+  excerpts from this file needed for using this malloc on ANSI C/C++
+  systems, so long as you haven't changed compile-time options about
+  naming and tuning parameters.  If you do, then you can create your
+  own malloc.h that does include all settings by cutting at the point
+  indicated below. Note that you may already by default be using a C
+  library containing a malloc that is based on some version of this
+  malloc (for example in linux). You might still want to use the one
+  in this file to customize settings or to avoid overheads associated
+  with library versions.
+
+* Vital statistics:
+
+  Supported pointer/size_t representation:       4 or 8 bytes
+       size_t MUST be an unsigned type of the same width as
+       pointers. (If you are using an ancient system that declares
+       size_t as a signed type, or need it to be a different width
+       than pointers, you can use a previous release of this malloc
+       (e.g. 2.7.2) supporting these.)
+
+  Alignment:                                     8 bytes (minimum)
+       This suffices for nearly all current machines and C compilers.
+       However, you can define MALLOC_ALIGNMENT to be wider than this
+       if necessary (up to 128bytes), at the expense of using more space.
+
+  Minimum overhead per allocated chunk:   4 or  8 bytes (if 4byte sizes)
+                                          8 or 16 bytes (if 8byte sizes)
+       Each malloced chunk has a hidden word of overhead holding size
+       and status information, and additional cross-check word
+       if FOOTERS is defined.
+
+  Minimum allocated size: 4-byte ptrs:  16 bytes    (including overhead)
+                          8-byte ptrs:  32 bytes    (including overhead)
+
+       Even a request for zero bytes (i.e., malloc(0)) returns a
+       pointer to something of the minimum allocatable size.
+       The maximum overhead wastage (i.e., number of extra bytes
+       allocated than were requested in malloc) is less than or equal
+       to the minimum size, except for requests >= mmap_threshold that
+       are serviced via mmap(), where the worst case wastage is about
+       32 bytes plus the remainder from a system page (the minimal
+       mmap unit); typically 4096 or 8192 bytes.
+
+  Security: static-safe; optionally more or less
+       The "security" of malloc refers to the ability of malicious
+       code to accentuate the effects of errors (for example, freeing
+       space that is not currently malloc'ed or overwriting past the
+       ends of chunks) in code that calls malloc.  This malloc
+       guarantees not to modify any memory locations below the base of
+       heap, i.e., static variables, even in the presence of usage
+       errors.  The routines additionally detect most improper frees
+       and reallocs.  All this holds as long as the static bookkeeping
+       for malloc itself is not corrupted by some other means.  This
+       is only one aspect of security -- these checks do not, and
+       cannot, detect all possible programming errors.
+
+       If FOOTERS is defined nonzero, then each allocated chunk
+       carries an additional check word to verify that it was malloced
+       from its space.  These check words are the same within each
+       execution of a program using malloc, but differ across
+       executions, so externally crafted fake chunks cannot be
+       freed. This improves security by rejecting frees/reallocs that
+       could corrupt heap memory, in addition to the checks preventing
+       writes to statics that are always on.  This may further improve
+       security at the expense of time and space overhead.  (Note that
+       FOOTERS may also be worth using with MSPACES.)
+
+       By default detected errors cause the program to abort (calling
+       "abort()"). You can override this to instead proceed past
+       errors by defining PROCEED_ON_ERROR.  In this case, a bad free
+       has no effect, and a malloc that encounters a bad address
+       caused by user overwrites will ignore the bad address by
+       dropping pointers and indices to all known memory. This may
+       be appropriate for programs that should continue if at all
+       possible in the face of programming errors, although they may
+       run out of memory because dropped memory is never reclaimed.
+
+       If you don't like either of these options, you can define
+       CORRUPTION_ERROR_ACTION and USAGE_ERROR_ACTION to do anything
+       else. And if if you are sure that your program using malloc has
+       no errors or vulnerabilities, you can define INSECURE to 1,
+       which might (or might not) provide a small performance improvement.
+
+       It is also possible to limit the maximum total allocatable
+       space, using malloc_set_footprint_limit. This is not
+       designed as a security feature in itself (calls to set limits
+       are not screened or privileged), but may be useful as one
+       aspect of a secure implementation.
+
+  Thread-safety: NOT thread-safe unless USE_LOCKS defined non-zero
+       When USE_LOCKS is defined, each public call to malloc, free,
+       etc is surrounded with a lock. By default, this uses a plain
+       pthread mutex, win32 critical section, or a spin-lock if if
+       available for the platform and not disabled by setting
+       USE_SPIN_LOCKS=0.  However, if USE_RECURSIVE_LOCKS is defined,
+       recursive versions are used instead (which are not required for
+       base functionality but may be needed in layered extensions).
+       Using a global lock is not especially fast, and can be a major
+       bottleneck.  It is designed only to provide minimal protection
+       in concurrent environments, and to provide a basis for
+       extensions.  If you are using malloc in a concurrent program,
+       consider instead using nedmalloc
+       (http://www.nedprod.com/programs/portable/nedmalloc/) or
+       ptmalloc (See http://www.malloc.de), which are derived from
+       versions of this malloc.
+
+  System requirements: Any combination of MORECORE and/or MMAP/MUNMAP
+       This malloc can use unix sbrk or any emulation (invoked using
+       the CALL_MORECORE macro) and/or mmap/munmap or any emulation
+       (invoked using CALL_MMAP/CALL_MUNMAP) to get and release system
+       memory.  On most unix systems, it tends to work best if both
+       MORECORE and MMAP are enabled.  On Win32, it uses emulations
+       based on VirtualAlloc. It also uses common C library functions
+       like memset.
+
+  Compliance: I believe it is compliant with the Single Unix Specification
+       (See http://www.unix.org). Also SVID/XPG, ANSI C, and probably
+       others as well.
+
+* Overview of algorithms
+
+  This is not the fastest, most space-conserving, most portable, or
+  most tunable malloc ever written. However it is among the fastest
+  while also being among the most space-conserving, portable and
+  tunable.  Consistent balance across these factors results in a good
+  general-purpose allocator for malloc-intensive programs.
+
+  In most ways, this malloc is a best-fit allocator. Generally, it
+  chooses the best-fitting existing chunk for a request, with ties
+  broken in approximately least-recently-used order. (This strategy
+  normally maintains low fragmentation.) However, for requests less
+  than 256bytes, it deviates from best-fit when there is not an
+  exactly fitting available chunk by preferring to use space adjacent
+  to that used for the previous small request, as well as by breaking
+  ties in approximately most-recently-used order. (These enhance
+  locality of series of small allocations.)  And for very large requests
+  (>= 256Kb by default), it relies on system memory mapping
+  facilities, if supported.  (This helps avoid carrying around and
+  possibly fragmenting memory used only for large chunks.)
+
+  All operations (except malloc_stats and mallinfo) have execution
+  times that are bounded by a constant factor of the number of bits in
+  a size_t, not counting any clearing in calloc or copying in realloc,
+  or actions surrounding MORECORE and MMAP that have times
+  proportional to the number of non-contiguous regions returned by
+  system allocation routines, which is often just 1. In real-time
+  applications, you can optionally suppress segment traversals using
+  NO_SEGMENT_TRAVERSAL, which assures bounded execution even when
+  system allocators return non-contiguous spaces, at the typical
+  expense of carrying around more memory and increased fragmentation.
+
+  The implementation is not very modular and seriously overuses
+  macros. Perhaps someday all C compilers will do as good a job
+  inlining modular code as can now be done by brute-force expansion,
+  but now, enough of them seem not to.
+
+  Some compilers issue a lot of warnings about code that is
+  dead/unreachable only on some platforms, and also about intentional
+  uses of negation on unsigned types. All known cases of each can be
+  ignored.
+
+  For a longer but out of date high-level description, see
+     http://gee.cs.oswego.edu/dl/html/malloc.html
+
+* MSPACES
+  If MSPACES is defined, then in addition to malloc, free, etc.,
+  this file also defines mspace_malloc, mspace_free, etc. These
+  are versions of malloc routines that take an "mspace" argument
+  obtained using create_mspace, to control all internal bookkeeping.
+  If ONLY_MSPACES is defined, only these versions are compiled.
+  So if you would like to use this allocator for only some allocations,
+  and your system malloc for others, you can compile with
+  ONLY_MSPACES and then do something like...
+    static mspace mymspace = create_mspace(0,0); // for example
+    #define mymalloc(bytes)  mspace_malloc(mymspace, bytes)
+
+  (Note: If you only need one instance of an mspace, you can instead
+  use "USE_DL_PREFIX" to relabel the global malloc.)
+
+  You can similarly create thread-local allocators by storing
+  mspaces as thread-locals. For example:
+    static __thread mspace tlms = 0;
+    void*  tlmalloc(size_t bytes) {
+      if (tlms == 0) tlms = create_mspace(0, 0);
+      return mspace_malloc(tlms, bytes);
+    }
+    void  tlfree(void* mem) { mspace_free(tlms, mem); }
+
+  Unless FOOTERS is defined, each mspace is completely independent.
+  You cannot allocate from one and free to another (although
+  conformance is only weakly checked, so usage errors are not always
+  caught). If FOOTERS is defined, then each chunk carries around a tag
+  indicating its originating mspace, and frees are directed to their
+  originating spaces. Normally, this requires use of locks.
+
+ -------------------------  Compile-time options ---------------------------
+
+Be careful in setting #define values for numerical constants of type
+size_t. On some systems, literal values are not automatically extended
+to size_t precision unless they are explicitly casted. You can also
+use the symbolic values MAX_SIZE_T, SIZE_T_ONE, etc below.
+
+WIN32                    default: defined if _WIN32 defined
+  Defining WIN32 sets up defaults for MS environment and compilers.
+  Otherwise defaults are for unix. Beware that there seem to be some
+  cases where this malloc might not be a pure drop-in replacement for
+  Win32 malloc: Random-looking failures from Win32 GDI API's (eg;
+  SetDIBits()) may be due to bugs in some video driver implementations
+  when pixel buffers are malloc()ed, and the region spans more than
+  one VirtualAlloc()ed region. Because dlmalloc uses a small (64Kb)
+  default granularity, pixel buffers may straddle virtual allocation
+  regions more often than when using the Microsoft allocator.  You can
+  avoid this by using VirtualAlloc() and VirtualFree() for all pixel
+  buffers rather than using malloc().  If this is not possible,
+  recompile this malloc with a larger DEFAULT_GRANULARITY. Note:
+  in cases where MSC and gcc (cygwin) are known to differ on WIN32,
+  conditions use _MSC_VER to distinguish them.
+
+DLMALLOC_EXPORT       default: extern
+  Defines how public APIs are declared. If you want to export via a
+  Windows DLL, you might define this as
+    #define DLMALLOC_EXPORT extern  __declspec(dllexport)
+  If you want a POSIX ELF shared object, you might use
+    #define DLMALLOC_EXPORT extern __attribute__((visibility("default")))
+
+MALLOC_ALIGNMENT         default: (size_t)(2 * sizeof(void *))
+  Controls the minimum alignment for malloc'ed chunks.  It must be a
+  power of two and at least 8, even on machines for which smaller
+  alignments would suffice. It may be defined as larger than this
+  though. Note however that code and data structures are optimized for
+  the case of 8-byte alignment.
+
+MSPACES                  default: 0 (false)
+  If true, compile in support for independent allocation spaces.
+  This is only supported if HAVE_MMAP is true.
+
+ONLY_MSPACES             default: 0 (false)
+  If true, only compile in mspace versions, not regular versions.
+
+USE_LOCKS                default: 0 (false)
+  Causes each call to each public routine to be surrounded with
+  pthread or WIN32 mutex lock/unlock. (If set true, this can be
+  overridden on a per-mspace basis for mspace versions.) If set to a
+  non-zero value other than 1, locks are used, but their
+  implementation is left out, so lock functions must be supplied manually,
+  as described below.
+
+USE_SPIN_LOCKS           default: 1 iff USE_LOCKS and spin locks available
+  If true, uses custom spin locks for locking. This is currently
+  supported only gcc >= 4.1, older gccs on x86 platforms, and recent
+  MS compilers.  Otherwise, posix locks or win32 critical sections are
+  used.
+
+USE_RECURSIVE_LOCKS      default: not defined
+  If defined nonzero, uses recursive (aka reentrant) locks, otherwise
+  uses plain mutexes. This is not required for malloc proper, but may
+  be needed for layered allocators such as nedmalloc.
+
+LOCK_AT_FORK            default: not defined
+  If defined nonzero, performs pthread_atfork upon initialization
+  to initialize child lock while holding parent lock. The implementation
+  assumes that pthread locks (not custom locks) are being used. In other
+  cases, you may need to customize the implementation.
+
+FOOTERS                  default: 0
+  If true, provide extra checking and dispatching by placing
+  information in the footers of allocated chunks. This adds
+  space and time overhead.
+
+INSECURE                 default: 0
+  If true, omit checks for usage errors and heap space overwrites.
+
+USE_DL_PREFIX            default: NOT defined
+  Causes compiler to prefix all public routines with the string 'dl'.
+  This can be useful when you only want to use this malloc in one part
+  of a program, using your regular system malloc elsewhere.
+
+MALLOC_INSPECT_ALL       default: NOT defined
+  If defined, compiles malloc_inspect_all and mspace_inspect_all, that
+  perform traversal of all heap space.  Unless access to these
+  functions is otherwise restricted, you probably do not want to
+  include them in secure implementations.
+
+ABORT                    default: defined as abort()
+  Defines how to abort on failed checks.  On most systems, a failed
+  check cannot die with an "assert" or even print an informative
+  message, because the underlying print routines in turn call malloc,
+  which will fail again.  Generally, the best policy is to simply call
+  abort(). It's not very useful to do more than this because many
+  errors due to overwriting will show up as address faults (null, odd
+  addresses etc) rather than malloc-triggered checks, so will also
+  abort.  Also, most compilers know that abort() does not return, so
+  can better optimize code conditionally calling it.
+
+PROCEED_ON_ERROR           default: defined as 0 (false)
+  Controls whether detected bad addresses cause them to bypassed
+  rather than aborting. If set, detected bad arguments to free and
+  realloc are ignored. And all bookkeeping information is zeroed out
+  upon a detected overwrite of freed heap space, thus losing the
+  ability to ever return it from malloc again, but enabling the
+  application to proceed. If PROCEED_ON_ERROR is defined, the
+  static variable malloc_corruption_error_count is compiled in
+  and can be examined to see if errors have occurred. This option
+  generates slower code than the default abort policy.
+
+DEBUG                    default: NOT defined
+  The DEBUG setting is mainly intended for people trying to modify
+  this code or diagnose problems when porting to new platforms.
+  However, it may also be able to better isolate user errors than just
+  using runtime checks.  The assertions in the check routines spell
+  out in more detail the assumptions and invariants underlying the
+  algorithms.  The checking is fairly extensive, and will slow down
+  execution noticeably. Calling malloc_stats or mallinfo with DEBUG
+  set will attempt to check every non-mmapped allocated and free chunk
+  in the course of computing the summaries.
+
+ABORT_ON_ASSERT_FAILURE   default: defined as 1 (true)
+  Debugging assertion failures can be nearly impossible if your
+  version of the assert macro causes malloc to be called, which will
+  lead to a cascade of further failures, blowing the runtime stack.
+  ABORT_ON_ASSERT_FAILURE cause assertions failures to call abort(),
+  which will usually make debugging easier.
+
+MALLOC_FAILURE_ACTION     default: sets errno to ENOMEM, or no-op on win32
+  The action to take before "return 0" when malloc fails to be able to
+  return memory because there is none available.
+
+HAVE_MORECORE             default: 1 (true) unless win32 or ONLY_MSPACES
+  True if this system supports sbrk or an emulation of it.
+
+MORECORE                  default: sbrk
+  The name of the sbrk-style system routine to call to obtain more
+  memory.  See below for guidance on writing custom MORECORE
+  functions. The type of the argument to sbrk/MORECORE varies across
+  systems.  It cannot be size_t, because it supports negative
+  arguments, so it is normally the signed type of the same width as
+  size_t (sometimes declared as "intptr_t").  It doesn't much matter
+  though. Internally, we only call it with arguments less than half
+  the max value of a size_t, which should work across all reasonable
+  possibilities, although sometimes generating compiler warnings.
+
+MORECORE_CONTIGUOUS       default: 1 (true) if HAVE_MORECORE
+  If true, take advantage of fact that consecutive calls to MORECORE
+  with positive arguments always return contiguous increasing
+  addresses.  This is true of unix sbrk. It does not hurt too much to
+  set it true anyway, since malloc copes with non-contiguities.
+  Setting it false when definitely non-contiguous saves time
+  and possibly wasted space it would take to discover this though.
+
+MORECORE_CANNOT_TRIM      default: NOT defined
+  True if MORECORE cannot release space back to the system when given
+  negative arguments. This is generally necessary only if you are
+  using a hand-crafted MORECORE function that cannot handle negative
+  arguments.
+
+NO_SEGMENT_TRAVERSAL       default: 0
+  If non-zero, suppresses traversals of memory segments
+  returned by either MORECORE or CALL_MMAP. This disables
+  merging of segments that are contiguous, and selectively
+  releasing them to the OS if unused, but bounds execution times.
+
+HAVE_MMAP                 default: 1 (true)
+  True if this system supports mmap or an emulation of it.  If so, and
+  HAVE_MORECORE is not true, MMAP is used for all system
+  allocation. If set and HAVE_MORECORE is true as well, MMAP is
+  primarily used to directly allocate very large blocks. It is also
+  used as a backup strategy in cases where MORECORE fails to provide
+  space from system. Note: A single call to MUNMAP is assumed to be
+  able to unmap memory that may have be allocated using multiple calls
+  to MMAP, so long as they are adjacent.
+
+HAVE_MREMAP               default: 1 on linux, else 0
+  If true realloc() uses mremap() to re-allocate large blocks and
+  extend or shrink allocation spaces.
+
+MMAP_CLEARS               default: 1 except on WINCE.
+  True if mmap clears memory so calloc doesn't need to. This is true
+  for standard unix mmap using /dev/zero and on WIN32 except for WINCE.
+
+USE_BUILTIN_FFS            default: 0 (i.e., not used)
+  Causes malloc to use the builtin ffs() function to compute indices.
+  Some compilers may recognize and intrinsify ffs to be faster than the
+  supplied C version. Also, the case of x86 using gcc is special-cased
+  to an asm instruction, so is already as fast as it can be, and so
+  this setting has no effect. Similarly for Win32 under recent MS compilers.
+  (On most x86s, the asm version is only slightly faster than the C version.)
+
+malloc_getpagesize         default: derive from system includes, or 4096.
+  The system page size. To the extent possible, this malloc manages
+  memory from the system in page-size units.  This may be (and
+  usually is) a function rather than a constant. This is ignored
+  if WIN32, where page size is determined using getSystemInfo during
+  initialization.
+
+USE_DEV_RANDOM             default: 0 (i.e., not used)
+  Causes malloc to use /dev/random to initialize secure magic seed for
+  stamping footers. Otherwise, the current time is used.
+
+NO_MALLINFO                default: 0
+  If defined, don't compile "mallinfo". This can be a simple way
+  of dealing with mismatches between system declarations and
+  those in this file.
+
+MALLINFO_FIELD_TYPE        default: size_t
+  The type of the fields in the mallinfo struct. This was originally
+  defined as "int" in SVID etc, but is more usefully defined as
+  size_t. The value is used only if  HAVE_USR_INCLUDE_MALLOC_H is not set
+
+NO_MALLOC_STATS            default: 0
+  If defined, don't compile "malloc_stats". This avoids calls to
+  fprintf and bringing in stdio dependencies you might not want.
+
+REALLOC_ZERO_BYTES_FREES    default: not defined
+  This should be set if a call to realloc with zero bytes should
+  be the same as a call to free. Some people think it should. Otherwise,
+  since this malloc returns a unique pointer for malloc(0), so does
+  realloc(p, 0).
+
+LACKS_UNISTD_H, LACKS_FCNTL_H, LACKS_SYS_PARAM_H, LACKS_SYS_MMAN_H
+LACKS_STRINGS_H, LACKS_STRING_H, LACKS_SYS_TYPES_H,  LACKS_ERRNO_H
+LACKS_STDLIB_H LACKS_SCHED_H LACKS_TIME_H  default: NOT defined unless on WIN32
+  Define these if your system does not have these header files.
+  You might need to manually insert some of the declarations they provide.
+
+DEFAULT_GRANULARITY        default: page size if MORECORE_CONTIGUOUS,
+                                system_info.dwAllocationGranularity in WIN32,
+                                otherwise 64K.
+      Also settable using mallopt(M_GRANULARITY, x)
+  The unit for allocating and deallocating memory from the system.  On
+  most systems with contiguous MORECORE, there is no reason to
+  make this more than a page. However, systems with MMAP tend to
+  either require or encourage larger granularities.  You can increase
+  this value to prevent system allocation functions to be called so
+  often, especially if they are slow.  The value must be at least one
+  page and must be a power of two.  Setting to 0 causes initialization
+  to either page size or win32 region size.  (Note: In previous
+  versions of malloc, the equivalent of this option was called
+  "TOP_PAD")
+
+DEFAULT_TRIM_THRESHOLD    default: 2MB
+      Also settable using mallopt(M_TRIM_THRESHOLD, x)
+  The maximum amount of unused top-most memory to keep before
+  releasing via malloc_trim in free().  Automatic trimming is mainly
+  useful in long-lived programs using contiguous MORECORE.  Because
+  trimming via sbrk can be slow on some systems, and can sometimes be
+  wasteful (in cases where programs immediately afterward allocate
+  more large chunks) the value should be high enough so that your
+  overall system performance would improve by releasing this much
+  memory.  As a rough guide, you might set to a value close to the
+  average size of a process (program) running on your system.
+  Releasing this much memory would allow such a process to run in
+  memory.  Generally, it is worth tuning trim thresholds when a
+  program undergoes phases where several large chunks are allocated
+  and released in ways that can reuse each other's storage, perhaps
+  mixed with phases where there are no such chunks at all. The trim
+  value must be greater than page size to have any useful effect.  To
+  disable trimming completely, you can set to MAX_SIZE_T. Note that the trick
+  some people use of mallocing a huge space and then freeing it at
+  program startup, in an attempt to reserve system memory, doesn't
+  have the intended effect under automatic trimming, since that memory
+  will immediately be returned to the system.
+
+DEFAULT_MMAP_THRESHOLD       default: 256K
+      Also settable using mallopt(M_MMAP_THRESHOLD, x)
+  The request size threshold for using MMAP to directly service a
+  request. Requests of at least this size that cannot be allocated
+  using already-existing space will be serviced via mmap.  (If enough
+  normal freed space already exists it is used instead.)  Using mmap
+  segregates relatively large chunks of memory so that they can be
+  individually obtained and released from the host system. A request
+  serviced through mmap is never reused by any other request (at least
+  not directly; the system may just so happen to remap successive
+  requests to the same locations).  Segregating space in this way has
+  the benefits that: Mmapped space can always be individually released
+  back to the system, which helps keep the system level memory demands
+  of a long-lived program low.  Also, mapped memory doesn't become
+  `locked' between other chunks, as can happen with normally allocated
+  chunks, which means that even trimming via malloc_trim would not
+  release them.  However, it has the disadvantage that the space
+  cannot be reclaimed, consolidated, and then used to service later
+  requests, as happens with normal chunks.  The advantages of mmap
+  nearly always outweigh disadvantages for "large" chunks, but the
+  value of "large" may vary across systems.  The default is an
+  empirically derived value that works well in most systems. You can
+  disable mmap by setting to MAX_SIZE_T.
+
+MAX_RELEASE_CHECK_RATE   default: 4095 unless not HAVE_MMAP
+  The number of consolidated frees between checks to release
+  unused segments when freeing. When using non-contiguous segments,
+  especially with multiple mspaces, checking only for topmost space
+  doesn't always suffice to trigger trimming. To compensate for this,
+  free() will, with a period of MAX_RELEASE_CHECK_RATE (or the
+  current number of segments, if greater) try to release unused
+  segments to the OS when freeing chunks that result in
+  consolidation. The best value for this parameter is a compromise
+  between slowing down frees with relatively costly checks that
+  rarely trigger versus holding on to unused memory. To effectively
+  disable, set to MAX_SIZE_T. This may lead to a very slight speed
+  improvement at the expense of carrying around more memory.
+*/
+
+/* Version identifier to allow people to support multiple versions */
+#ifndef DLMALLOC_VERSION
+#define DLMALLOC_VERSION 20806
+#endif /* DLMALLOC_VERSION */
+
+#ifndef DLMALLOC_EXPORT
+#define DLMALLOC_EXPORT extern
+#endif
+
+#ifndef WIN32
+#ifdef _WIN32
+#define WIN32 1
+#endif  /* _WIN32 */
+#ifdef _WIN32_WCE
+#define LACKS_FCNTL_H
+#define WIN32 1
+#endif /* _WIN32_WCE */
+#endif  /* WIN32 */
+#ifdef WIN32
+#define WIN32_LEAN_AND_MEAN
+#include <windows.h>
+#include <tchar.h>
+#define HAVE_MMAP 1
+#define HAVE_MORECORE 0
+#define LACKS_UNISTD_H
+#define LACKS_SYS_PARAM_H
+#define LACKS_SYS_MMAN_H
+#define LACKS_STRING_H
+#define LACKS_STRINGS_H
+#define LACKS_SYS_TYPES_H
+#define LACKS_ERRNO_H
+#define LACKS_SCHED_H
+#ifndef MALLOC_FAILURE_ACTION
+#define MALLOC_FAILURE_ACTION
+#endif /* MALLOC_FAILURE_ACTION */
+#ifndef MMAP_CLEARS
+#ifdef _WIN32_WCE /* WINCE reportedly does not clear */
+#define MMAP_CLEARS 0
+#else
+#define MMAP_CLEARS 1
+#endif /* _WIN32_WCE */
+#endif /*MMAP_CLEARS */
+#endif  /* WIN32 */
+
+#if defined(DARWIN) || defined(_DARWIN)
+/* Mac OSX docs advise not to use sbrk; it seems better to use mmap */
+#ifndef HAVE_MORECORE
+#define HAVE_MORECORE 0
+#define HAVE_MMAP 1
+/* OSX allocators provide 16 byte alignment */
+#ifndef MALLOC_ALIGNMENT
+#define MALLOC_ALIGNMENT ((size_t)16U)
+#endif
+#endif  /* HAVE_MORECORE */
+#endif  /* DARWIN */
+
+#ifndef LACKS_SYS_TYPES_H
+#include <sys/types.h>  /* For size_t */
+#endif  /* LACKS_SYS_TYPES_H */
+
+/* The maximum possible size_t value has all bits set */
+#define MAX_SIZE_T           (~(size_t)0)
+
+#ifndef USE_LOCKS /* ensure true if spin or recursive locks set */
+#define USE_LOCKS  ((defined(USE_SPIN_LOCKS) && USE_SPIN_LOCKS != 0) || \
+                    (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0))
+#endif /* USE_LOCKS */
+
+#if USE_LOCKS /* Spin locks for gcc >= 4.1, older gcc on x86, MSC >= 1310 */
+#if ((defined(__GNUC__) &&                                              \
+      ((__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1)) ||      \
+       defined(__i386__) || defined(__x86_64__))) ||                    \
+     (defined(_MSC_VER) && _MSC_VER>=1310))
+#ifndef USE_SPIN_LOCKS
+#define USE_SPIN_LOCKS 1
+#endif /* USE_SPIN_LOCKS */
+#elif USE_SPIN_LOCKS
+#error "USE_SPIN_LOCKS defined without implementation"
+#endif /* ... locks available... */
+#elif !defined(USE_SPIN_LOCKS)
+#define USE_SPIN_LOCKS 0
+#endif /* USE_LOCKS */
+
+#ifndef ONLY_MSPACES
+#define ONLY_MSPACES 0
+#endif  /* ONLY_MSPACES */
+#ifndef MSPACES
+#if ONLY_MSPACES
+#define MSPACES 1
+#else   /* ONLY_MSPACES */
+#define MSPACES 0
+#endif  /* ONLY_MSPACES */
+#endif  /* MSPACES */
+#ifndef MALLOC_ALIGNMENT
+#define MALLOC_ALIGNMENT ((size_t)(2 * sizeof(void *)))
+#endif  /* MALLOC_ALIGNMENT */
+#ifndef FOOTERS
+#define FOOTERS 0
+#endif  /* FOOTERS */
+#ifndef ABORT
+#define ABORT  abort()
+#endif  /* ABORT */
+#ifndef ABORT_ON_ASSERT_FAILURE
+#define ABORT_ON_ASSERT_FAILURE 1
+#endif  /* ABORT_ON_ASSERT_FAILURE */
+#ifndef PROCEED_ON_ERROR
+#define PROCEED_ON_ERROR 0
+#endif  /* PROCEED_ON_ERROR */
+
+#ifndef INSECURE
+#define INSECURE 0
+#endif  /* INSECURE */
+#ifndef MALLOC_INSPECT_ALL
+#define MALLOC_INSPECT_ALL 0
+#endif  /* MALLOC_INSPECT_ALL */
+#ifndef HAVE_MMAP
+#define HAVE_MMAP 1
+#endif  /* HAVE_MMAP */
+#ifndef MMAP_CLEARS
+#define MMAP_CLEARS 1
+#endif  /* MMAP_CLEARS */
+#ifndef HAVE_MREMAP
+#ifdef linux
+#define HAVE_MREMAP 1
+#define _GNU_SOURCE /* Turns on mremap() definition */
+#else   /* linux */
+#define HAVE_MREMAP 0
+#endif  /* linux */
+#endif  /* HAVE_MREMAP */
+#ifndef MALLOC_FAILURE_ACTION
+#define MALLOC_FAILURE_ACTION  errno = ENOMEM;
+#endif  /* MALLOC_FAILURE_ACTION */
+#ifndef HAVE_MORECORE
+#if ONLY_MSPACES
+#define HAVE_MORECORE 0
+#else   /* ONLY_MSPACES */
+#define HAVE_MORECORE 1
+#endif  /* ONLY_MSPACES */
+#endif  /* HAVE_MORECORE */
+#if !HAVE_MORECORE
+#define MORECORE_CONTIGUOUS 0
+#else   /* !HAVE_MORECORE */
+#define MORECORE_DEFAULT sbrk
+#ifndef MORECORE_CONTIGUOUS
+#define MORECORE_CONTIGUOUS 1
+#endif  /* MORECORE_CONTIGUOUS */
+#endif  /* HAVE_MORECORE */
+#ifndef DEFAULT_GRANULARITY
+#if (MORECORE_CONTIGUOUS || defined(WIN32))
+#define DEFAULT_GRANULARITY (0)  /* 0 means to compute in init_mparams */
+#else   /* MORECORE_CONTIGUOUS */
+#define DEFAULT_GRANULARITY ((size_t)64U * (size_t)1024U)
+#endif  /* MORECORE_CONTIGUOUS */
+#endif  /* DEFAULT_GRANULARITY */
+#ifndef DEFAULT_TRIM_THRESHOLD
+#ifndef MORECORE_CANNOT_TRIM
+#define DEFAULT_TRIM_THRESHOLD ((size_t)2U * (size_t)1024U * (size_t)1024U)
+#else   /* MORECORE_CANNOT_TRIM */
+#define DEFAULT_TRIM_THRESHOLD MAX_SIZE_T
+#endif  /* MORECORE_CANNOT_TRIM */
+#endif  /* DEFAULT_TRIM_THRESHOLD */
+#ifndef DEFAULT_MMAP_THRESHOLD
+#if HAVE_MMAP
+#define DEFAULT_MMAP_THRESHOLD ((size_t)256U * (size_t)1024U)
+#else   /* HAVE_MMAP */
+#define DEFAULT_MMAP_THRESHOLD MAX_SIZE_T
+#endif  /* HAVE_MMAP */
+#endif  /* DEFAULT_MMAP_THRESHOLD */
+#ifndef MAX_RELEASE_CHECK_RATE
+#if HAVE_MMAP
+#define MAX_RELEASE_CHECK_RATE 4095
+#else
+#define MAX_RELEASE_CHECK_RATE MAX_SIZE_T
+#endif /* HAVE_MMAP */
+#endif /* MAX_RELEASE_CHECK_RATE */
+#ifndef USE_BUILTIN_FFS
+#define USE_BUILTIN_FFS 0
+#endif  /* USE_BUILTIN_FFS */
+#ifndef USE_DEV_RANDOM
+#define USE_DEV_RANDOM 0
+#endif  /* USE_DEV_RANDOM */
+#ifndef NO_MALLINFO
+#define NO_MALLINFO 0
+#endif  /* NO_MALLINFO */
+#ifndef MALLINFO_FIELD_TYPE
+#define MALLINFO_FIELD_TYPE size_t
+#endif  /* MALLINFO_FIELD_TYPE */
+#ifndef NO_MALLOC_STATS
+#define NO_MALLOC_STATS 0
+#endif  /* NO_MALLOC_STATS */
+#ifndef NO_SEGMENT_TRAVERSAL
+#define NO_SEGMENT_TRAVERSAL 0
+#endif /* NO_SEGMENT_TRAVERSAL */
+
+/*
+  mallopt tuning options.  SVID/XPG defines four standard parameter
+  numbers for mallopt, normally defined in malloc.h.  None of these
+  are used in this malloc, so setting them has no effect. But this
+  malloc does support the following options.
+*/
+
+#define M_TRIM_THRESHOLD     (-1)
+#define M_GRANULARITY        (-2)
+#define M_MMAP_THRESHOLD     (-3)
+
+/* ------------------------ Mallinfo declarations ------------------------ */
+
+#if !NO_MALLINFO
+/*
+  This version of malloc supports the standard SVID/XPG mallinfo
+  routine that returns a struct containing usage properties and
+  statistics. It should work on any system that has a
+  /usr/include/malloc.h defining struct mallinfo.  The main
+  declaration needed is the mallinfo struct that is returned (by-copy)
+  by mallinfo().  The malloinfo struct contains a bunch of fields that
+  are not even meaningful in this version of malloc.  These fields are
+  are instead filled by mallinfo() with other numbers that might be of
+  interest.
+
+  HAVE_USR_INCLUDE_MALLOC_H should be set if you have a
+  /usr/include/malloc.h file that includes a declaration of struct
+  mallinfo.  If so, it is included; else a compliant version is
+  declared below.  These must be precisely the same for mallinfo() to
+  work.  The original SVID version of this struct, defined on most
+  systems with mallinfo, declares all fields as ints. But some others
+  define as unsigned long. If your system defines the fields using a
+  type of different width than listed here, you MUST #include your
+  system version and #define HAVE_USR_INCLUDE_MALLOC_H.
+*/
+
+/* #define HAVE_USR_INCLUDE_MALLOC_H */
+
+#ifdef HAVE_USR_INCLUDE_MALLOC_H
+#include "/usr/include/malloc.h"
+#else /* HAVE_USR_INCLUDE_MALLOC_H */
+#ifndef STRUCT_MALLINFO_DECLARED
+/* HP-UX (and others?) redefines mallinfo unless _STRUCT_MALLINFO is defined */
+#define _STRUCT_MALLINFO
+#define STRUCT_MALLINFO_DECLARED 1
+struct mallinfo {
+  MALLINFO_FIELD_TYPE arena;    /* non-mmapped space allocated from system */
+  MALLINFO_FIELD_TYPE ordblks;  /* number of free chunks */
+  MALLINFO_FIELD_TYPE smblks;   /* always 0 */
+  MALLINFO_FIELD_TYPE hblks;    /* always 0 */
+  MALLINFO_FIELD_TYPE hblkhd;   /* space in mmapped regions */
+  MALLINFO_FIELD_TYPE usmblks;  /* maximum total allocated space */
+  MALLINFO_FIELD_TYPE fsmblks;  /* always 0 */
+  MALLINFO_FIELD_TYPE uordblks; /* total allocated space */
+  MALLINFO_FIELD_TYPE fordblks; /* total free space */
+  MALLINFO_FIELD_TYPE keepcost; /* releasable (via malloc_trim) space */
+};
+#endif /* STRUCT_MALLINFO_DECLARED */
+#endif /* HAVE_USR_INCLUDE_MALLOC_H */
+#endif /* NO_MALLINFO */
+
+/*
+  Try to persuade compilers to inline. The most critical functions for
+  inlining are defined as macros, so these aren't used for them.
+*/
+
+#ifndef FORCEINLINE
+  #if defined(__GNUC__)
+#define FORCEINLINE __inline __attribute__ ((always_inline))
+  #elif defined(_MSC_VER)
+    #define FORCEINLINE __forceinline
+  #endif
+#endif
+#ifndef NOINLINE
+  #if defined(__GNUC__)
+    #define NOINLINE __attribute__ ((noinline))
+  #elif defined(_MSC_VER)
+    #define NOINLINE __declspec(noinline)
+  #else
+    #define NOINLINE
+  #endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#ifndef FORCEINLINE
+ #define FORCEINLINE inline
+#endif
+#endif /* __cplusplus */
+#ifndef FORCEINLINE
+ #define FORCEINLINE
+#endif
+
+#if !ONLY_MSPACES
+
+/* ------------------- Declarations of public routines ------------------- */
+
+#ifndef USE_DL_PREFIX
+#define dlcalloc               calloc
+#define dlfree                 free
+#define dlmalloc               malloc
+#define dlmemalign             memalign
+#define dlposix_memalign       posix_memalign
+#define dlrealloc              realloc
+#define dlrealloc_in_place     realloc_in_place
+#define dlvalloc               valloc
+#define dlpvalloc              pvalloc
+#define dlmallinfo             mallinfo
+#define dlmallopt              mallopt
+#define dlmalloc_trim          malloc_trim
+#define dlmalloc_stats         malloc_stats
+#define dlmalloc_usable_size   malloc_usable_size
+#define dlmalloc_footprint     malloc_footprint
+#define dlmalloc_max_footprint malloc_max_footprint
+#define dlmalloc_footprint_limit malloc_footprint_limit
+#define dlmalloc_set_footprint_limit malloc_set_footprint_limit
+#define dlmalloc_inspect_all   malloc_inspect_all
+#define dlindependent_calloc   independent_calloc
+#define dlindependent_comalloc independent_comalloc
+#define dlbulk_free            bulk_free
+#endif /* USE_DL_PREFIX */
+
+/*
+  malloc(size_t n)
+  Returns a pointer to a newly allocated chunk of at least n bytes, or
+  null if no space is available, in which case errno is set to ENOMEM
+  on ANSI C systems.
+
+  If n is zero, malloc returns a minimum-sized chunk. (The minimum
+  size is 16 bytes on most 32bit systems, and 32 bytes on 64bit
+  systems.)  Note that size_t is an unsigned type, so calls with
+  arguments that would be negative if signed are interpreted as
+  requests for huge amounts of space, which will often fail. The
+  maximum supported value of n differs across systems, but is in all
+  cases less than the maximum representable value of a size_t.
+*/
+DLMALLOC_EXPORT void* dlmalloc(size_t);
+
+/*
+  free(void* p)
+  Releases the chunk of memory pointed to by p, that had been previously
+  allocated using malloc or a related routine such as realloc.
+  It has no effect if p is null. If p was not malloced or already
+  freed, free(p) will by default cause the current program to abort.
+*/
+DLMALLOC_EXPORT void  dlfree(void*);
+
+/*
+  calloc(size_t n_elements, size_t element_size);
+  Returns a pointer to n_elements * element_size bytes, with all locations
+  set to zero.
+*/
+DLMALLOC_EXPORT void* dlcalloc(size_t, size_t);
+
+/*
+  realloc(void* p, size_t n)
+  Returns a pointer to a chunk of size n that contains the same data
+  as does chunk p up to the minimum of (n, p's size) bytes, or null
+  if no space is available.
+
+  The returned pointer may or may not be the same as p. The algorithm
+  prefers extending p in most cases when possible, otherwise it
+  employs the equivalent of a malloc-copy-free sequence.
+
+  If p is null, realloc is equivalent to malloc.
+
+  If space is not available, realloc returns null, errno is set (if on
+  ANSI) and p is NOT freed.
+
+  if n is for fewer bytes than already held by p, the newly unused
+  space is lopped off and freed if possible.  realloc with a size
+  argument of zero (re)allocates a minimum-sized chunk.
+
+  The old unix realloc convention of allowing the last-free'd chunk
+  to be used as an argument to realloc is not supported.
+*/
+DLMALLOC_EXPORT void* dlrealloc(void*, size_t);
+
+/*
+  realloc_in_place(void* p, size_t n)
+  Resizes the space allocated for p to size n, only if this can be
+  done without moving p (i.e., only if there is adjacent space
+  available if n is greater than p's current allocated size, or n is
+  less than or equal to p's size). This may be used instead of plain
+  realloc if an alternative allocation strategy is needed upon failure
+  to expand space; for example, reallocation of a buffer that must be
+  memory-aligned or cleared. You can use realloc_in_place to trigger
+  these alternatives only when needed.
+
+  Returns p if successful; otherwise null.
+*/
+DLMALLOC_EXPORT void* dlrealloc_in_place(void*, size_t);
+
+/*
+  memalign(size_t alignment, size_t n);
+  Returns a pointer to a newly allocated chunk of n bytes, aligned
+  in accord with the alignment argument.
+
+  The alignment argument should be a power of two. If the argument is
+  not a power of two, the nearest greater power is used.
+  8-byte alignment is guaranteed by normal malloc calls, so don't
+  bother calling memalign with an argument of 8 or less.
+
+  Overreliance on memalign is a sure way to fragment space.
+*/
+DLMALLOC_EXPORT void* dlmemalign(size_t, size_t);
+
+/*
+  int posix_memalign(void** pp, size_t alignment, size_t n);
+  Allocates a chunk of n bytes, aligned in accord with the alignment
+  argument. Differs from memalign only in that it (1) assigns the
+  allocated memory to *pp rather than returning it, (2) fails and
+  returns EINVAL if the alignment is not a power of two (3) fails and
+  returns ENOMEM if memory cannot be allocated.
+*/
+DLMALLOC_EXPORT int dlposix_memalign(void**, size_t, size_t);
+
+/*
+  valloc(size_t n);
+  Equivalent to memalign(pagesize, n), where pagesize is the page
+  size of the system. If the pagesize is unknown, 4096 is used.
+*/
+DLMALLOC_EXPORT void* dlvalloc(size_t);
+
+/*
+  mallopt(int parameter_number, int parameter_value)
+  Sets tunable parameters The format is to provide a
+  (parameter-number, parameter-value) pair.  mallopt then sets the
+  corresponding parameter to the argument value if it can (i.e., so
+  long as the value is meaningful), and returns 1 if successful else
+  0.  To workaround the fact that mallopt is specified to use int,
+  not size_t parameters, the value -1 is specially treated as the
+  maximum unsigned size_t value.
+
+  SVID/XPG/ANSI defines four standard param numbers for mallopt,
+  normally defined in malloc.h.  None of these are use in this malloc,
+  so setting them has no effect. But this malloc also supports other
+  options in mallopt. See below for details.  Briefly, supported
+  parameters are as follows (listed defaults are for "typical"
+  configurations).
+
+  Symbol            param #  default    allowed param values
+  M_TRIM_THRESHOLD     -1   2*1024*1024   any   (-1 disables)
+  M_GRANULARITY        -2     page size   any power of 2 >= page size
+  M_MMAP_THRESHOLD     -3      256*1024   any   (or 0 if no MMAP support)
+*/
+DLMALLOC_EXPORT int dlmallopt(int, int);
+
+/*
+  malloc_footprint();
+  Returns the number of bytes obtained from the system.  The total
+  number of bytes allocated by malloc, realloc etc., is less than this
+  value. Unlike mallinfo, this function returns only a precomputed
+  result, so can be called frequently to monitor memory consumption.
+  Even if locks are otherwise defined, this function does not use them,
+  so results might not be up to date.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_footprint(void);
+
+/*
+  malloc_max_footprint();
+  Returns the maximum number of bytes obtained from the system. This
+  value will be greater than current footprint if deallocated space
+  has been reclaimed by the system. The peak number of bytes allocated
+  by malloc, realloc etc., is less than this value. Unlike mallinfo,
+  this function returns only a precomputed result, so can be called
+  frequently to monitor memory consumption.  Even if locks are
+  otherwise defined, this function does not use them, so results might
+  not be up to date.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_max_footprint(void);
+
+/*
+  malloc_footprint_limit();
+  Returns the number of bytes that the heap is allowed to obtain from
+  the system, returning the last value returned by
+  malloc_set_footprint_limit, or the maximum size_t value if
+  never set. The returned value reflects a permission. There is no
+  guarantee that this number of bytes can actually be obtained from
+  the system.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_footprint_limit(void);
+
+/*
+  malloc_set_footprint_limit();
+  Sets the maximum number of bytes to obtain from the system, causing
+  failure returns from malloc and related functions upon attempts to
+  exceed this value. The argument value may be subject to page
+  rounding to an enforceable limit; this actual value is returned.
+  Using an argument of the maximum possible size_t effectively
+  disables checks. If the argument is less than or equal to the
+  current malloc_footprint, then all future allocations that require
+  additional system memory will fail. However, invocation cannot
+  retroactively deallocate existing used memory.
+*/
+DLMALLOC_EXPORT size_t dlmalloc_set_footprint_limit(size_t bytes);
+
+#if MALLOC_INSPECT_ALL
+/*
+  malloc_inspect_all(void(*handler)(void *start,
+                                    void *end,
+                                    size_t used_bytes,
+                                    void* callback_arg),
+                      void* arg);
+  Traverses the heap and calls the given handler for each managed
+  region, skipping all bytes that are (or may be) used for bookkeeping
+  purposes.  Traversal does not include include chunks that have been
+  directly memory mapped. Each reported region begins at the start
+  address, and continues up to but not including the end address.  The
+  first used_bytes of the region contain allocated data. If
+  used_bytes is zero, the region is unallocated. The handler is
+  invoked with the given callback argument. If locks are defined, they
+  are held during the entire traversal. It is a bad idea to invoke
+  other malloc functions from within the handler.
+
+  For example, to count the number of in-use chunks with size greater
+  than 1000, you could write:
+  static int count = 0;
+  void count_chunks(void* start, void* end, size_t used, void* arg) {
+    if (used >= 1000) ++count;
+  }
+  then:
+    malloc_inspect_all(count_chunks, NULL);
+
+  malloc_inspect_all is compiled only if MALLOC_INSPECT_ALL is defined.
+*/
+DLMALLOC_EXPORT void dlmalloc_inspect_all(void(*handler)(void*, void *, size_t, void*),
+                           void* arg);
+
+#endif /* MALLOC_INSPECT_ALL */
+
+#if !NO_MALLINFO
+/*
+  mallinfo()
+  Returns (by copy) a struct containing various summary statistics:
+
+  arena:     current total non-mmapped bytes allocated from system
+  ordblks:   the number of free chunks
+  smblks:    always zero.
+  hblks:     current number of mmapped regions
+  hblkhd:    total bytes held in mmapped regions
+  usmblks:   the maximum total allocated space. This will be greater
+                than current total if trimming has occurred.
+  fsmblks:   always zero
+  uordblks:  current total allocated space (normal or mmapped)
+  fordblks:  total free space
+  keepcost:  the maximum number of bytes that could ideally be released
+               back to system via malloc_trim. ("ideally" means that
+               it ignores page restrictions etc.)
+
+  Because these fields are ints, but internal bookkeeping may
+  be kept as longs, the reported values may wrap around zero and
+  thus be inaccurate.
+*/
+DLMALLOC_EXPORT struct mallinfo dlmallinfo(void);
+#endif /* NO_MALLINFO */
+
+/*
+  independent_calloc(size_t n_elements, size_t element_size, void* chunks[]);
+
+  independent_calloc is similar to calloc, but instead of returning a
+  single cleared space, it returns an array of pointers to n_elements
+  independent elements that can hold contents of size elem_size, each
+  of which starts out cleared, and can be independently freed,
+  realloc'ed etc. The elements are guaranteed to be adjacently
+  allocated (this is not guaranteed to occur with multiple callocs or
+  mallocs), which may also improve cache locality in some
+  applications.
+
+  The "chunks" argument is optional (i.e., may be null, which is
+  probably the most typical usage). If it is null, the returned array
+  is itself dynamically allocated and should also be freed when it is
+  no longer needed. Otherwise, the chunks array must be of at least
+  n_elements in length. It is filled in with the pointers to the
+  chunks.
+
+  In either case, independent_calloc returns this pointer array, or
+  null if the allocation failed.  If n_elements is zero and "chunks"
+  is null, it returns a chunk representing an array with zero elements
+  (which should be freed if not wanted).
+
+  Each element must be freed when it is no longer needed. This can be
+  done all at once using bulk_free.
+
+  independent_calloc simplifies and speeds up implementations of many
+  kinds of pools.  It may also be useful when constructing large data
+  structures that initially have a fixed number of fixed-sized nodes,
+  but the number is not known at compile time, and some of the nodes
+  may later need to be freed. For example:
+
+  struct Node { int item; struct Node* next; };
+
+  struct Node* build_list() {
+    struct Node** pool;
+    int n = read_number_of_nodes_needed();
+    if (n <= 0) return 0;
+    pool = (struct Node**)(independent_calloc(n, sizeof(struct Node), 0);
+    if (pool == 0) die();
+    // organize into a linked list...
+    struct Node* first = pool[0];
+    for (i = 0; i < n-1; ++i)
+      pool[i]->next = pool[i+1];
+    free(pool);     // Can now free the array (or not, if it is needed later)
+    return first;
+  }
+*/
+DLMALLOC_EXPORT void** dlindependent_calloc(size_t, size_t, void**);
+
+/*
+  independent_comalloc(size_t n_elements, size_t sizes[], void* chunks[]);
+
+  independent_comalloc allocates, all at once, a set of n_elements
+  chunks with sizes indicated in the "sizes" array.    It returns
+  an array of pointers to these elements, each of which can be
+  independently freed, realloc'ed etc. The elements are guaranteed to
+  be adjacently allocated (this is not guaranteed to occur with
+  multiple callocs or mallocs), which may also improve cache locality
+  in some applications.
+
+  The "chunks" argument is optional (i.e., may be null). If it is null
+  the returned array is itself dynamically allocated and should also
+  be freed when it is no longer needed. Otherwise, the chunks array
+  must be of at least n_elements in length. It is filled in with the
+  pointers to the chunks.
+
+  In either case, independent_comalloc returns this pointer array, or
+  null if the allocation failed.  If n_elements is zero and chunks is
+  null, it returns a chunk representing an array with zero elements
+  (which should be freed if not wanted).
+
+  Each element must be freed when it is no longer needed. This can be
+  done all at once using bulk_free.
+
+  independent_comallac differs from independent_calloc in that each
+  element may have a different size, and also that it does not
+  automatically clear elements.
+
+  independent_comalloc can be used to speed up allocation in cases
+  where several structs or objects must always be allocated at the
+  same time.  For example:
+
+  struct Head { ... }
+  struct Foot { ... }
+
+  void send_message(char* msg) {
+    int msglen = strlen(msg);
+    size_t sizes[3] = { sizeof(struct Head), msglen, sizeof(struct Foot) };
+    void* chunks[3];
+    if (independent_comalloc(3, sizes, chunks) == 0)
+      die();
+    struct Head* head = (struct Head*)(chunks[0]);
+    char*        body = (char*)(chunks[1]);
+    struct Foot* foot = (struct Foot*)(chunks[2]);
+    // ...
+  }
+
+  In general though, independent_comalloc is worth using only for
+  larger values of n_elements. For small values, you probably won't
+  detect enough difference from series of malloc calls to bother.
+
+  Overuse of independent_comalloc can increase overall memory usage,
+  since it cannot reuse existing noncontiguous small chunks that
+  might be available for some of the elements.
+*/
+DLMALLOC_EXPORT void** dlindependent_comalloc(size_t, size_t*, void**);
+
+/*
+  bulk_free(void* array[], size_t n_elements)
+  Frees and clears (sets to null) each non-null pointer in the given
+  array.  This is likely to be faster than freeing them one-by-one.
+  If footers are used, pointers that have been allocated in different
+  mspaces are not freed or cleared, and the count of all such pointers
+  is returned.  For large arrays of pointers with poor locality, it
+  may be worthwhile to sort this array before calling bulk_free.
+*/
+DLMALLOC_EXPORT size_t  dlbulk_free(void**, size_t n_elements);
+
+/*
+  pvalloc(size_t n);
+  Equivalent to valloc(minimum-page-that-holds(n)), that is,
+  round up n to nearest pagesize.
+ */
+DLMALLOC_EXPORT void*  dlpvalloc(size_t);
+
+/*
+  malloc_trim(size_t pad);
+
+  If possible, gives memory back to the system (via negative arguments
+  to sbrk) if there is unused memory at the `high' end of the malloc
+  pool or in unused MMAP segments. You can call this after freeing
+  large blocks of memory to potentially reduce the system-level memory
+  requirements of a program. However, it cannot guarantee to reduce
+  memory. Under some allocation patterns, some large free blocks of
+  memory will be locked between two used chunks, so they cannot be
+  given back to the system.
+
+  The `pad' argument to malloc_trim represents the amount of free
+  trailing space to leave untrimmed. If this argument is zero, only
+  the minimum amount of memory to maintain internal data structures
+  will be left. Non-zero arguments can be supplied to maintain enough
+  trailing space to service future expected allocations without having
+  to re-obtain memory from the system.
+
+  Malloc_trim returns 1 if it actually released any memory, else 0.
+*/
+DLMALLOC_EXPORT int  dlmalloc_trim(size_t);
+
+/*
+  malloc_stats();
+  Prints on stderr the amount of space obtained from the system (both
+  via sbrk and mmap), the maximum amount (which may be more than
+  current if malloc_trim and/or munmap got called), and the current
+  number of bytes allocated via malloc (or realloc, etc) but not yet
+  freed. Note that this is the number of bytes allocated, not the
+  number requested. It will be larger than the number requested
+  because of alignment and bookkeeping overhead. Because it includes
+  alignment wastage as being in use, this figure may be greater than
+  zero even when no user-level chunks are allocated.
+
+  The reported current and maximum system memory can be inaccurate if
+  a program makes other calls to system memory allocation functions
+  (normally sbrk) outside of malloc.
+
+  malloc_stats prints only the most commonly interesting statistics.
+  More information can be obtained by calling mallinfo.
+*/
+DLMALLOC_EXPORT void  dlmalloc_stats(void);
+
+/*
+  malloc_usable_size(void* p);
+
+  Returns the number of bytes you can actually use in
+  an allocated chunk, which may be more than you requested (although
+  often not) due to alignment and minimum size constraints.
+  You can use this many bytes without worrying about
+  overwriting other allocated objects. This is not a particularly great
+  programming practice. malloc_usable_size can be more useful in
+  debugging and assertions, for example:
+
+  p = malloc(n);
+  assert(malloc_usable_size(p) >= 256);
+*/
+size_t dlmalloc_usable_size(void*);
+
+#endif /* ONLY_MSPACES */
+
+#if MSPACES
+
+/*
+  mspace is an opaque type representing an independent
+  region of space that supports mspace_malloc, etc.
+*/
+typedef void* mspace;
+
+/*
+  create_mspace creates and returns a new independent space with the
+  given initial capacity, or, if 0, the default granularity size.  It
+  returns null if there is no system memory available to create the
+  space.  If argument locked is non-zero, the space uses a separate
+  lock to control access. The capacity of the space will grow
+  dynamically as needed to service mspace_malloc requests.  You can
+  control the sizes of incremental increases of this space by
+  compiling with a different DEFAULT_GRANULARITY or dynamically
+  setting with mallopt(M_GRANULARITY, value).
+*/
+DLMALLOC_EXPORT mspace create_mspace(size_t capacity, int locked);
+
+/*
+  destroy_mspace destroys the given space, and attempts to return all
+  of its memory back to the system, returning the total number of
+  bytes freed. After destruction, the results of access to all memory
+  used by the space become undefined.
+*/
+DLMALLOC_EXPORT size_t destroy_mspace(mspace msp);
+
+/*
+  create_mspace_with_base uses the memory supplied as the initial base
+  of a new mspace. Part (less than 128*sizeof(size_t) bytes) of this
+  space is used for bookkeeping, so the capacity must be at least this
+  large. (Otherwise 0 is returned.) When this initial space is
+  exhausted, additional memory will be obtained from the system.
+  Destroying this space will deallocate all additionally allocated
+  space (if possible) but not the initial base.
+*/
+DLMALLOC_EXPORT mspace create_mspace_with_base(void* base, size_t capacity, int locked);
+
+/*
+  mspace_track_large_chunks controls whether requests for large chunks
+  are allocated in their own untracked mmapped regions, separate from
+  others in this mspace. By default large chunks are not tracked,
+  which reduces fragmentation. However, such chunks are not
+  necessarily released to the system upon destroy_mspace.  Enabling
+  tracking by setting to true may increase fragmentation, but avoids
+  leakage when relying on destroy_mspace to release all memory
+  allocated using this space.  The function returns the previous
+  setting.
+*/
+DLMALLOC_EXPORT int mspace_track_large_chunks(mspace msp, int enable);
+
+
+/*
+  mspace_malloc behaves as malloc, but operates within
+  the given space.
+*/
+DLMALLOC_EXPORT void* mspace_malloc(mspace msp, size_t bytes);
+
+/*
+  mspace_free behaves as free, but operates within
+  the given space.
+
+  If compiled with FOOTERS==1, mspace_free is not actually needed.
+  free may be called instead of mspace_free because freed chunks from
+  any space are handled by their originating spaces.
+*/
+DLMALLOC_EXPORT void mspace_free(mspace msp, void* mem);
+
+/*
+  mspace_realloc behaves as realloc, but operates within
+  the given space.
+
+  If compiled with FOOTERS==1, mspace_realloc is not actually
+  needed.  realloc may be called instead of mspace_realloc because
+  realloced chunks from any space are handled by their originating
+  spaces.
+*/
+DLMALLOC_EXPORT void* mspace_realloc(mspace msp, void* mem, size_t newsize);
+
+/*
+  mspace_calloc behaves as calloc, but operates within
+  the given space.
+*/
+DLMALLOC_EXPORT void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size);
+
+/*
+  mspace_memalign behaves as memalign, but operates within
+  the given space.
+*/
+DLMALLOC_EXPORT void* mspace_memalign(mspace msp, size_t alignment, size_t bytes);
+
+/*
+  mspace_independent_calloc behaves as independent_calloc, but
+  operates within the given space.
+*/
+DLMALLOC_EXPORT void** mspace_independent_calloc(mspace msp, size_t n_elements,
+                                 size_t elem_size, void* chunks[]);
+
+/*
+  mspace_independent_comalloc behaves as independent_comalloc, but
+  operates within the given space.
+*/
+DLMALLOC_EXPORT void** mspace_independent_comalloc(mspace msp, size_t n_elements,
+                                   size_t sizes[], void* chunks[]);
+
+/*
+  mspace_footprint() returns the number of bytes obtained from the
+  system for this space.
+*/
+DLMALLOC_EXPORT size_t mspace_footprint(mspace msp);
+
+/*
+  mspace_max_footprint() returns the peak number of bytes obtained from the
+  system for this space.
+*/
+DLMALLOC_EXPORT size_t mspace_max_footprint(mspace msp);
+
+
+#if !NO_MALLINFO
+/*
+  mspace_mallinfo behaves as mallinfo, but reports properties of
+  the given space.
+*/
+DLMALLOC_EXPORT struct mallinfo mspace_mallinfo(mspace msp);
+#endif /* NO_MALLINFO */
+
+/*
+  malloc_usable_size(void* p) behaves the same as malloc_usable_size;
+*/
+DLMALLOC_EXPORT size_t mspace_usable_size(const void* mem);
+
+/*
+  mspace_malloc_stats behaves as malloc_stats, but reports
+  properties of the given space.
+*/
+DLMALLOC_EXPORT void mspace_malloc_stats(mspace msp);
+
+/*
+  mspace_trim behaves as malloc_trim, but
+  operates within the given space.
+*/
+DLMALLOC_EXPORT int mspace_trim(mspace msp, size_t pad);
+
+/*
+  An alias for mallopt.
+*/
+DLMALLOC_EXPORT int mspace_mallopt(int, int);
+
+#endif /* MSPACES */
+
+#ifdef __cplusplus
+}  /* end of extern "C" */
+#endif /* __cplusplus */
+
+/*
+  ========================================================================
+  To make a fully customizable malloc.h header file, cut everything
+  above this line, put into file malloc.h, edit to suit, and #include it
+  on the next line, as well as in programs that use this malloc.
+  ========================================================================
+*/
+
+/* #include "malloc.h" */
+
+/*------------------------------ internal #includes ---------------------- */
+
+#ifdef _MSC_VER
+#pragma warning( disable : 4146 ) /* no "unsigned" warnings */
+#endif /* _MSC_VER */
+#if !NO_MALLOC_STATS
+#include <stdio.h>       /* for printing in malloc_stats */
+#endif /* NO_MALLOC_STATS */
+#ifndef LACKS_ERRNO_H
+#include <errno.h>       /* for MALLOC_FAILURE_ACTION */
+#endif /* LACKS_ERRNO_H */
+#ifdef DEBUG
+#if ABORT_ON_ASSERT_FAILURE
+#undef assert
+#define assert(x) if(!(x)) ABORT
+#else /* ABORT_ON_ASSERT_FAILURE */
+#include <assert.h>
+#endif /* ABORT_ON_ASSERT_FAILURE */
+#else  /* DEBUG */
+#ifndef assert
+#define assert(x)
+#endif
+#define DEBUG 0
+#endif /* DEBUG */
+#if !defined(WIN32) && !defined(LACKS_TIME_H)
+#include <time.h>        /* for magic initialization */
+#endif /* WIN32 */
+#ifndef LACKS_STDLIB_H
+#include <stdlib.h>      /* for abort() */
+#endif /* LACKS_STDLIB_H */
+#ifndef LACKS_STRING_H
+#include <string.h>      /* for memset etc */
+#endif  /* LACKS_STRING_H */
+#if USE_BUILTIN_FFS
+#ifndef LACKS_STRINGS_H
+#include <strings.h>     /* for ffs */
+#endif /* LACKS_STRINGS_H */
+#endif /* USE_BUILTIN_FFS */
+#if HAVE_MMAP
+#ifndef LACKS_SYS_MMAN_H
+/* On some versions of linux, mremap decl in mman.h needs __USE_GNU set */
+#if (defined(linux) && !defined(__USE_GNU))
+#define __USE_GNU 1
+#include <sys/mman.h>    /* for mmap */
+#undef __USE_GNU
+#else
+#include <sys/mman.h>    /* for mmap */
+#endif /* linux */
+#endif /* LACKS_SYS_MMAN_H */
+#ifndef LACKS_FCNTL_H
+#include <fcntl.h>
+#endif /* LACKS_FCNTL_H */
+#endif /* HAVE_MMAP */
+#ifndef LACKS_UNISTD_H
+#include <unistd.h>     /* for sbrk, sysconf */
+#else /* LACKS_UNISTD_H */
+#if !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)
+extern void*     sbrk(ptrdiff_t);
+#endif /* FreeBSD etc */
+#endif /* LACKS_UNISTD_H */
+
+/* Declarations for locking */
+#if USE_LOCKS
+#ifndef WIN32
+#if defined (__SVR4) && defined (__sun)  /* solaris */
+#include <thread.h>
+#elif !defined(LACKS_SCHED_H)
+#include <sched.h>
+#endif /* solaris or LACKS_SCHED_H */
+#if (defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0) || !USE_SPIN_LOCKS
+#include <pthread.h>
+#endif /* USE_RECURSIVE_LOCKS ... */
+#elif defined(_MSC_VER)
+#ifndef _M_AMD64
+/* These are already defined on AMD64 builds */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+LONG __cdecl _InterlockedCompareExchange(LONG volatile *Dest, LONG Exchange, LONG Comp);
+LONG __cdecl _InterlockedExchange(LONG volatile *Target, LONG Value);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+#endif /* _M_AMD64 */
+#pragma intrinsic (_InterlockedCompareExchange)
+#pragma intrinsic (_InterlockedExchange)
+#define interlockedcompareexchange _InterlockedCompareExchange
+#define interlockedexchange _InterlockedExchange
+#elif defined(WIN32) && defined(__GNUC__)
+#define interlockedcompareexchange(a, b, c) __sync_val_compare_and_swap(a, c, b)
+#define interlockedexchange __sync_lock_test_and_set
+#endif /* Win32 */
+#else /* USE_LOCKS */
+#endif /* USE_LOCKS */
+
+#ifndef LOCK_AT_FORK
+#define LOCK_AT_FORK 0
+#endif
+
+/* Declarations for bit scanning on win32 */
+#if defined(_MSC_VER) && _MSC_VER>=1300
+#ifndef BitScanForward /* Try to avoid pulling in WinNT.h */
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+unsigned char _BitScanForward(unsigned long *index, unsigned long mask);
+unsigned char _BitScanReverse(unsigned long *index, unsigned long mask);
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#define BitScanForward _BitScanForward
+#define BitScanReverse _BitScanReverse
+#pragma intrinsic(_BitScanForward)
+#pragma intrinsic(_BitScanReverse)
+#endif /* BitScanForward */
+#endif /* defined(_MSC_VER) && _MSC_VER>=1300 */
+
+#ifndef WIN32
+#ifndef malloc_getpagesize
+#  ifdef _SC_PAGESIZE         /* some SVR4 systems omit an underscore */
+#    ifndef _SC_PAGE_SIZE
+#      define _SC_PAGE_SIZE _SC_PAGESIZE
+#    endif
+#  endif
+#  ifdef _SC_PAGE_SIZE
+#    define malloc_getpagesize sysconf(_SC_PAGE_SIZE)
+#  else
+#    if defined(BSD) || defined(DGUX) || defined(HAVE_GETPAGESIZE)
+       extern size_t getpagesize();
+#      define malloc_getpagesize getpagesize()
+#    else
+#      ifdef WIN32 /* use supplied emulation of getpagesize */
+#        define malloc_getpagesize getpagesize()
+#      else
+#        ifndef LACKS_SYS_PARAM_H
+#          include <sys/param.h>
+#        endif
+#        ifdef EXEC_PAGESIZE
+#          define malloc_getpagesize EXEC_PAGESIZE
+#        else
+#          ifdef NBPG
+#            ifndef CLSIZE
+#              define malloc_getpagesize NBPG
+#            else
+#              define malloc_getpagesize (NBPG * CLSIZE)
+#            endif
+#          else
+#            ifdef NBPC
+#              define malloc_getpagesize NBPC
+#            else
+#              ifdef PAGESIZE
+#                define malloc_getpagesize PAGESIZE
+#              else /* just guess */
+#                define malloc_getpagesize ((size_t)4096U)
+#              endif
+#            endif
+#          endif
+#        endif
+#      endif
+#    endif
+#  endif
+#endif
+#endif
+
+/* ------------------- size_t and alignment properties -------------------- */
+
+/* The byte and bit size of a size_t */
+#define SIZE_T_SIZE         (sizeof(size_t))
+#define SIZE_T_BITSIZE      (sizeof(size_t) << 3)
+
+/* Some constants coerced to size_t */
+/* Annoying but necessary to avoid errors on some platforms */
+#define SIZE_T_ZERO         ((size_t)0)
+#define SIZE_T_ONE          ((size_t)1)
+#define SIZE_T_TWO          ((size_t)2)
+#define SIZE_T_FOUR         ((size_t)4)
+#define TWO_SIZE_T_SIZES    (SIZE_T_SIZE<<1)
+#define FOUR_SIZE_T_SIZES   (SIZE_T_SIZE<<2)
+#define SIX_SIZE_T_SIZES    (FOUR_SIZE_T_SIZES+TWO_SIZE_T_SIZES)
+#define HALF_MAX_SIZE_T     (MAX_SIZE_T / 2U)
+
+/* The bit mask value corresponding to MALLOC_ALIGNMENT */
+#define CHUNK_ALIGN_MASK    (MALLOC_ALIGNMENT - SIZE_T_ONE)
+
+/* True if address a has acceptable alignment */
+#define is_aligned(A)       (((size_t)((A)) & (CHUNK_ALIGN_MASK)) == 0)
+
+/* the number of bytes to offset an address to align it */
+#define align_offset(A)\
+ ((((size_t)(A) & CHUNK_ALIGN_MASK) == 0)? 0 :\
+  ((MALLOC_ALIGNMENT - ((size_t)(A) & CHUNK_ALIGN_MASK)) & CHUNK_ALIGN_MASK))
+
+/* -------------------------- MMAP preliminaries ------------------------- */
+
+/*
+   If HAVE_MORECORE or HAVE_MMAP are false, we just define calls and
+   checks to fail so compiler optimizer can delete code rather than
+   using so many "#if"s.
+*/
+
+
+/* MORECORE and MMAP must return MFAIL on failure */
+#define MFAIL                ((void*)(MAX_SIZE_T))
+#define CMFAIL               ((char*)(MFAIL)) /* defined for convenience */
+
+#if HAVE_MMAP
+
+#ifndef WIN32
+#define MUNMAP_DEFAULT(a, s)  munmap((a), (s))
+#define MMAP_PROT            (PROT_READ|PROT_WRITE)
+#if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
+#define MAP_ANONYMOUS        MAP_ANON
+#endif /* MAP_ANON */
+#ifdef MAP_ANONYMOUS
+#define MMAP_FLAGS           (MAP_PRIVATE|MAP_ANONYMOUS)
+#define MMAP_DEFAULT(s)       mmap(0, (s), MMAP_PROT, MMAP_FLAGS, -1, 0)
+#else /* MAP_ANONYMOUS */
+/*
+   Nearly all versions of mmap support MAP_ANONYMOUS, so the following
+   is unlikely to be needed, but is supplied just in case.
+*/
+#define MMAP_FLAGS           (MAP_PRIVATE)
+static int dev_zero_fd = -1; /* Cached file descriptor for /dev/zero. */
+#define MMAP_DEFAULT(s) ((dev_zero_fd < 0) ? \
+           (dev_zero_fd = open("/dev/zero", O_RDWR), \
+            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0)) : \
+            mmap(0, (s), MMAP_PROT, MMAP_FLAGS, dev_zero_fd, 0))
+#endif /* MAP_ANONYMOUS */
+
+#define DIRECT_MMAP_DEFAULT(s) MMAP_DEFAULT(s)
+
+#else /* WIN32 */
+
+/* Win32 MMAP via VirtualAlloc */
+static FORCEINLINE void* win32mmap(size_t size) {
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT, PAGE_READWRITE);
+  return (ptr != 0)? ptr: MFAIL;
+}
+
+/* For direct MMAP, use MEM_TOP_DOWN to minimize interference */
+static FORCEINLINE void* win32direct_mmap(size_t size) {
+  void* ptr = VirtualAlloc(0, size, MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,
+                           PAGE_READWRITE);
+  return (ptr != 0)? ptr: MFAIL;
+}
+
+/* This function supports releasing coalesed segments */
+static FORCEINLINE int win32munmap(void* ptr, size_t size) {
+  MEMORY_BASIC_INFORMATION minfo;
+  char* cptr = (char*)ptr;
+  while (size) {
+    if (VirtualQuery(cptr, &minfo, sizeof(minfo)) == 0)
+      return -1;
+    if (minfo.BaseAddress != cptr || minfo.AllocationBase != cptr ||
+        minfo.State != MEM_COMMIT || minfo.RegionSize > size)
+      return -1;
+    if (VirtualFree(cptr, 0, MEM_RELEASE) == 0)
+      return -1;
+    cptr += minfo.RegionSize;
+    size -= minfo.RegionSize;
+  }
+  return 0;
+}
+
+#define MMAP_DEFAULT(s)             win32mmap(s)
+#define MUNMAP_DEFAULT(a, s)        win32munmap((a), (s))
+#define DIRECT_MMAP_DEFAULT(s)      win32direct_mmap(s)
+#endif /* WIN32 */
+#endif /* HAVE_MMAP */
+
+#if HAVE_MREMAP
+#ifndef WIN32
+#define MREMAP_DEFAULT(addr, osz, nsz, mv) mremap((addr), (osz), (nsz), (mv))
+#endif /* WIN32 */
+#endif /* HAVE_MREMAP */
+
+/**
+ * Define CALL_MORECORE
+ */
+#if HAVE_MORECORE
+    #ifdef MORECORE
+        #define CALL_MORECORE(S)    MORECORE(S)
+    #else  /* MORECORE */
+        #define CALL_MORECORE(S)    MORECORE_DEFAULT(S)
+    #endif /* MORECORE */
+#else  /* HAVE_MORECORE */
+    #define CALL_MORECORE(S)        MFAIL
+#endif /* HAVE_MORECORE */
+
+/**
+ * Define CALL_MMAP/CALL_MUNMAP/CALL_DIRECT_MMAP
+ */
+#if HAVE_MMAP
+    #define USE_MMAP_BIT            (SIZE_T_ONE)
+
+    #ifdef MMAP
+        #define CALL_MMAP(s)        MMAP(s)
+    #else /* MMAP */
+        #define CALL_MMAP(s)        MMAP_DEFAULT(s)
+    #endif /* MMAP */
+    #ifdef MUNMAP
+        #define CALL_MUNMAP(a, s)   MUNMAP((a), (s))
+    #else /* MUNMAP */
+        #define CALL_MUNMAP(a, s)   MUNMAP_DEFAULT((a), (s))
+    #endif /* MUNMAP */
+    #ifdef DIRECT_MMAP
+        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP(s)
+    #else /* DIRECT_MMAP */
+        #define CALL_DIRECT_MMAP(s) DIRECT_MMAP_DEFAULT(s)
+    #endif /* DIRECT_MMAP */
+#else  /* HAVE_MMAP */
+    #define USE_MMAP_BIT            (SIZE_T_ZERO)
+
+    #define MMAP(s)                 MFAIL
+    #define MUNMAP(a, s)            (-1)
+    #define DIRECT_MMAP(s)          MFAIL
+    #define CALL_DIRECT_MMAP(s)     DIRECT_MMAP(s)
+    #define CALL_MMAP(s)            MMAP(s)
+    #define CALL_MUNMAP(a, s)       MUNMAP((a), (s))
+#endif /* HAVE_MMAP */
+
+/**
+ * Define CALL_MREMAP
+ */
+#if HAVE_MMAP && HAVE_MREMAP
+    #ifdef MREMAP
+        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP((addr), (osz), (nsz), (mv))
+    #else /* MREMAP */
+        #define CALL_MREMAP(addr, osz, nsz, mv) MREMAP_DEFAULT((addr), (osz), (nsz), (mv))
+    #endif /* MREMAP */
+#else  /* HAVE_MMAP && HAVE_MREMAP */
+    #define CALL_MREMAP(addr, osz, nsz, mv)     MFAIL
+#endif /* HAVE_MMAP && HAVE_MREMAP */
+
+/* mstate bit set if continguous morecore disabled or failed */
+#define USE_NONCONTIGUOUS_BIT (4U)
+
+/* segment bit set in create_mspace_with_base */
+#define EXTERN_BIT            (8U)
+
+
+/* --------------------------- Lock preliminaries ------------------------ */
+
+/*
+  When locks are defined, there is one global lock, plus
+  one per-mspace lock.
+
+  The global lock_ensures that mparams.magic and other unique
+  mparams values are initialized only once. It also protects
+  sequences of calls to MORECORE.  In many cases sys_alloc requires
+  two calls, that should not be interleaved with calls by other
+  threads.  This does not protect against direct calls to MORECORE
+  by other threads not using this lock, so there is still code to
+  cope the best we can on interference.
+
+  Per-mspace locks surround calls to malloc, free, etc.
+  By default, locks are simple non-reentrant mutexes.
+
+  Because lock-protected regions generally have bounded times, it is
+  OK to use the supplied simple spinlocks. Spinlocks are likely to
+  improve performance for lightly contended applications, but worsen
+  performance under heavy contention.
+
+  If USE_LOCKS is > 1, the definitions of lock routines here are
+  bypassed, in which case you will need to define the type MLOCK_T,
+  and at least INITIAL_LOCK, DESTROY_LOCK, ACQUIRE_LOCK, RELEASE_LOCK
+  and TRY_LOCK.  You must also declare a
+    static MLOCK_T malloc_global_mutex = { initialization values };.
+
+*/
+
+#if !USE_LOCKS
+#define USE_LOCK_BIT               (0U)
+#define INITIAL_LOCK(l)            (0)
+#define DESTROY_LOCK(l)            (0)
+#define ACQUIRE_MALLOC_GLOBAL_LOCK()
+#define RELEASE_MALLOC_GLOBAL_LOCK()
+
+#else
+#if USE_LOCKS > 1
+/* -----------------------  User-defined locks ------------------------ */
+/* Define your own lock implementation here */
+/* #define INITIAL_LOCK(lk)  ... */
+/* #define DESTROY_LOCK(lk)  ... */
+/* #define ACQUIRE_LOCK(lk)  ... */
+/* #define RELEASE_LOCK(lk)  ... */
+/* #define TRY_LOCK(lk) ... */
+/* static MLOCK_T malloc_global_mutex = ... */
+
+#elif USE_SPIN_LOCKS
+
+/* First, define CAS_LOCK and CLEAR_LOCK on ints */
+/* Note CAS_LOCK defined to return 0 on success */
+
+#if defined(__GNUC__)&& (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 1))
+#define CAS_LOCK(sl)     __sync_lock_test_and_set(sl, 1)
+#define CLEAR_LOCK(sl)   __sync_lock_release(sl)
+
+#elif (defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__)))
+/* Custom spin locks for older gcc on x86 */
+static FORCEINLINE int x86_cas_lock(int *sl) {
+  int ret;
+  int val = 1;
+  int cmp = 0;
+  __asm__ __volatile__  ("lock; cmpxchgl %1, %2"
+                         : "=a" (ret)
+                         : "r" (val), "m" (*(sl)), "0"(cmp)
+                         : "memory", "cc");
+  return ret;
+}
+
+static FORCEINLINE void x86_clear_lock(int* sl) {
+  assert(*sl != 0);
+  int prev = 0;
+  int ret;
+  __asm__ __volatile__ ("lock; xchgl %0, %1"
+                        : "=r" (ret)
+                        : "m" (*(sl)), "0"(prev)
+                        : "memory");
+}
+
+#define CAS_LOCK(sl)     x86_cas_lock(sl)
+#define CLEAR_LOCK(sl)   x86_clear_lock(sl)
+
+#else /* Win32 MSC */
+#define CAS_LOCK(sl)     interlockedexchange(sl, (LONG)1)
+#define CLEAR_LOCK(sl)   interlockedexchange (sl, (LONG)0)
+
+#endif /* ... gcc spins locks ... */
+
+/* How to yield for a spin lock */
+#define SPINS_PER_YIELD       63
+#if defined(_MSC_VER)
+#define SLEEP_EX_DURATION     50 /* delay for yield/sleep */
+#define SPIN_LOCK_YIELD  SleepEx(SLEEP_EX_DURATION, FALSE)
+#elif defined (__SVR4) && defined (__sun) /* solaris */
+#define SPIN_LOCK_YIELD   thr_yield();
+#elif !defined(LACKS_SCHED_H)
+#define SPIN_LOCK_YIELD   sched_yield();
+#else
+#define SPIN_LOCK_YIELD
+#endif /* ... yield ... */
+
+#if !defined(USE_RECURSIVE_LOCKS) || USE_RECURSIVE_LOCKS == 0
+/* Plain spin locks use single word (embedded in malloc_states) */
+static int spin_acquire_lock(int *sl) {
+  int spins = 0;
+  while (*(volatile int *)sl != 0 || CAS_LOCK(sl)) {
+    if ((++spins & SPINS_PER_YIELD) == 0) {
+      SPIN_LOCK_YIELD;
+    }
+  }
+  return 0;
+}
+
+#define MLOCK_T               int
+#define TRY_LOCK(sl)          !CAS_LOCK(sl)
+#define RELEASE_LOCK(sl)      CLEAR_LOCK(sl)
+#define ACQUIRE_LOCK(sl)      (CAS_LOCK(sl)? spin_acquire_lock(sl) : 0)
+#define INITIAL_LOCK(sl)      (*sl = 0)
+#define DESTROY_LOCK(sl)      (0)
+static MLOCK_T malloc_global_mutex = 0;
+
+#else /* USE_RECURSIVE_LOCKS */
+/* types for lock owners */
+#ifdef WIN32
+#define THREAD_ID_T           DWORD
+#define CURRENT_THREAD        GetCurrentThreadId()
+#define EQ_OWNER(X,Y)         ((X) == (Y))
+#else
+/*
+  Note: the following assume that pthread_t is a type that can be
+  initialized to (casted) zero. If this is not the case, you will need to
+  somehow redefine these or not use spin locks.
+*/
+#define THREAD_ID_T           pthread_t
+#define CURRENT_THREAD        pthread_self()
+#define EQ_OWNER(X,Y)         pthread_equal(X, Y)
+#endif
+
+struct malloc_recursive_lock {
+  int sl;
+  unsigned int c;
+  THREAD_ID_T threadid;
+};
+
+#define MLOCK_T  struct malloc_recursive_lock
+static MLOCK_T malloc_global_mutex = { 0, 0, (THREAD_ID_T)0};
+
+static FORCEINLINE void recursive_release_lock(MLOCK_T *lk) {
+  assert(lk->sl != 0);
+  if (--lk->c == 0) {
+    CLEAR_LOCK(&lk->sl);
+  }
+}
+
+static FORCEINLINE int recursive_acquire_lock(MLOCK_T *lk) {
+  THREAD_ID_T mythreadid = CURRENT_THREAD;
+  int spins = 0;
+  for (;;) {
+    if (*((volatile int *)(&lk->sl)) == 0) {
+      if (!CAS_LOCK(&lk->sl)) {
+        lk->threadid = mythreadid;
+        lk->c = 1;
+        return 0;
+      }
+    }
+    else if (EQ_OWNER(lk->threadid, mythreadid)) {
+      ++lk->c;
+      return 0;
+    }
+    if ((++spins & SPINS_PER_YIELD) == 0) {
+      SPIN_LOCK_YIELD;
+    }
+  }
+}
+
+static FORCEINLINE int recursive_try_lock(MLOCK_T *lk) {
+  THREAD_ID_T mythreadid = CURRENT_THREAD;
+  if (*((volatile int *)(&lk->sl)) == 0) {
+    if (!CAS_LOCK(&lk->sl)) {
+      lk->threadid = mythreadid;
+      lk->c = 1;
+      return 1;
+    }
+  }
+  else if (EQ_OWNER(lk->threadid, mythreadid)) {
+    ++lk->c;
+    return 1;
+  }
+  return 0;
+}
+
+#define RELEASE_LOCK(lk)      recursive_release_lock(lk)
+#define TRY_LOCK(lk)          recursive_try_lock(lk)
+#define ACQUIRE_LOCK(lk)      recursive_acquire_lock(lk)
+#define INITIAL_LOCK(lk)      ((lk)->threadid = (THREAD_ID_T)0, (lk)->sl = 0, (lk)->c = 0)
+#define DESTROY_LOCK(lk)      (0)
+#endif /* USE_RECURSIVE_LOCKS */
+
+#elif defined(WIN32) /* Win32 critical sections */
+#define MLOCK_T               CRITICAL_SECTION
+#define ACQUIRE_LOCK(lk)      (EnterCriticalSection(lk), 0)
+#define RELEASE_LOCK(lk)      LeaveCriticalSection(lk)
+#define TRY_LOCK(lk)          TryEnterCriticalSection(lk)
+#define INITIAL_LOCK(lk)      (!InitializeCriticalSectionAndSpinCount((lk), 0x80000000|4000))
+#define DESTROY_LOCK(lk)      (DeleteCriticalSection(lk), 0)
+#define NEED_GLOBAL_LOCK_INIT
+
+static MLOCK_T malloc_global_mutex;
+static volatile LONG malloc_global_mutex_status;
+
+/* Use spin loop to initialize global lock */
+static void init_malloc_global_mutex() {
+  for (;;) {
+    long stat = malloc_global_mutex_status;
+    if (stat > 0)
+      return;
+    /* transition to < 0 while initializing, then to > 0) */
+    if (stat == 0 &&
+        interlockedcompareexchange(&malloc_global_mutex_status, (LONG)-1, (LONG)0) == 0) {
+      InitializeCriticalSection(&malloc_global_mutex);
+      interlockedexchange(&malloc_global_mutex_status, (LONG)1);
+      return;
+    }
+    SleepEx(0, FALSE);
+  }
+}
+
+#else /* pthreads-based locks */
+#define MLOCK_T               pthread_mutex_t
+#define ACQUIRE_LOCK(lk)      pthread_mutex_lock(lk)
+#define RELEASE_LOCK(lk)      pthread_mutex_unlock(lk)
+#define TRY_LOCK(lk)          (!pthread_mutex_trylock(lk))
+#define INITIAL_LOCK(lk)      pthread_init_lock(lk)
+#define DESTROY_LOCK(lk)      pthread_mutex_destroy(lk)
+
+#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0 && defined(linux) && !defined(PTHREAD_MUTEX_RECURSIVE)
+/* Cope with old-style linux recursive lock initialization by adding */
+/* skipped internal declaration from pthread.h */
+extern int pthread_mutexattr_setkind_np __P ((pthread_mutexattr_t *__attr,
+                                              int __kind));
+#define PTHREAD_MUTEX_RECURSIVE PTHREAD_MUTEX_RECURSIVE_NP
+#define pthread_mutexattr_settype(x,y) pthread_mutexattr_setkind_np(x,y)
+#endif /* USE_RECURSIVE_LOCKS ... */
+
+static MLOCK_T malloc_global_mutex = PTHREAD_MUTEX_INITIALIZER;
+
+static int pthread_init_lock (MLOCK_T *lk) {
+  pthread_mutexattr_t attr;
+  if (pthread_mutexattr_init(&attr)) return 1;
+#if defined(USE_RECURSIVE_LOCKS) && USE_RECURSIVE_LOCKS != 0
+  if (pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE)) return 1;
+#endif
+  if (pthread_mutex_init(lk, &attr)) return 1;
+  if (pthread_mutexattr_destroy(&attr)) return 1;
+  return 0;
+}
+
+#endif /* ... lock types ... */
+
+/* Common code for all lock types */
+#define USE_LOCK_BIT               (2U)
+
+#ifndef ACQUIRE_MALLOC_GLOBAL_LOCK
+#define ACQUIRE_MALLOC_GLOBAL_LOCK()  ACQUIRE_LOCK(&malloc_global_mutex);
+#endif
+
+#ifndef RELEASE_MALLOC_GLOBAL_LOCK
+#define RELEASE_MALLOC_GLOBAL_LOCK()  RELEASE_LOCK(&malloc_global_mutex);
+#endif
+
+#endif /* USE_LOCKS */
+
+/* -----------------------  Chunk representations ------------------------ */
+
+/*
+  (The following includes lightly edited explanations by Colin Plumb.)
+
+  The malloc_chunk declaration below is misleading (but accurate and
+  necessary).  It declares a "view" into memory allowing access to
+  necessary fields at known offsets from a given base.
+
+  Chunks of memory are maintained using a `boundary tag' method as
+  originally described by Knuth.  (See the paper by Paul Wilson
+  ftp://ftp.cs.utexas.edu/pub/garbage/allocsrv.ps for a survey of such
+  techniques.)  Sizes of free chunks are stored both in the front of
+  each chunk and at the end.  This makes consolidating fragmented
+  chunks into bigger chunks fast.  The head fields also hold bits
+  representing whether chunks are free or in use.
+
+  Here are some pictures to make it clearer.  They are "exploded" to
+  show that the state of a chunk can be thought of as extending from
+  the high 31 bits of the head field of its header through the
+  prev_foot and PINUSE_BIT bit of the following chunk header.
+
+  A chunk that's in use looks like:
+
+   chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+           | Size of previous chunk (if P = 0)                             |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
+         | Size of this chunk                                         1| +-+
+   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         |                                                               |
+         +-                                                             -+
+         |                                                               |
+         +-                                                             -+
+         |                                                               :
+         +-      size - sizeof(size_t) available payload bytes          -+
+         :                                                               |
+ chunk-> +-                                                             -+
+         |                                                               |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |1|
+       | Size of next chunk (may or may not be in use)               | +-+
+ mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+    And if it's free, it looks like this:
+
+   chunk-> +-                                                             -+
+           | User payload (must be in use, or we would have merged!)       |
+           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |P|
+         | Size of this chunk                                         0| +-+
+   mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Next pointer                                                  |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Prev pointer                                                  |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         |                                                               :
+         +-      size - sizeof(struct chunk) unused bytes               -+
+         :                                                               |
+ chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+         | Size of this chunk                                            |
+         +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ |0|
+       | Size of next chunk (must be in use, or we would have merged)| +-+
+ mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+       |                                                               :
+       +- User payload                                                -+
+       :                                                               |
+       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+                                                                     |0|
+                                                                     +-+
+  Note that since we always merge adjacent free chunks, the chunks
+  adjacent to a free chunk must be in use.
+
+  Given a pointer to a chunk (which can be derived trivially from the
+  payload pointer) we can, in O(1) time, find out whether the adjacent
+  chunks are free, and if so, unlink them from the lists that they
+  are on and merge them with the current chunk.
+
+  Chunks always begin on even word boundaries, so the mem portion
+  (which is returned to the user) is also on an even word boundary, and
+  thus at least double-word aligned.
+
+  The P (PINUSE_BIT) bit, stored in the unused low-order bit of the
+  chunk size (which is always a multiple of two words), is an in-use
+  bit for the *previous* chunk.  If that bit is *clear*, then the
+  word before the current chunk size contains the previous chunk
+  size, and can be used to find the front of the previous chunk.
+  The very first chunk allocated always has this bit set, preventing
+  access to non-existent (or non-owned) memory. If pinuse is set for
+  any given chunk, then you CANNOT determine the size of the
+  previous chunk, and might even get a memory addressing fault when
+  trying to do so.
+
+  The C (CINUSE_BIT) bit, stored in the unused second-lowest bit of
+  the chunk size redundantly records whether the current chunk is
+  inuse (unless the chunk is mmapped). This redundancy enables usage
+  checks within free and realloc, and reduces indirection when freeing
+  and consolidating chunks.
+
+  Each freshly allocated chunk must have both cinuse and pinuse set.
+  That is, each allocated chunk borders either a previously allocated
+  and still in-use chunk, or the base of its memory arena. This is
+  ensured by making all allocations from the `lowest' part of any
+  found chunk.  Further, no free chunk physically borders another one,
+  so each free chunk is known to be preceded and followed by either
+  inuse chunks or the ends of memory.
+
+  Note that the `foot' of the current chunk is actually represented
+  as the prev_foot of the NEXT chunk. This makes it easier to
+  deal with alignments etc but can be very confusing when trying
+  to extend or adapt this code.
+
+  The exceptions to all this are
+
+     1. The special chunk `top' is the top-most available chunk (i.e.,
+        the one bordering the end of available memory). It is treated
+        specially.  Top is never included in any bin, is used only if
+        no other chunk is available, and is released back to the
+        system if it is very large (see M_TRIM_THRESHOLD).  In effect,
+        the top chunk is treated as larger (and thus less well
+        fitting) than any other available chunk.  The top chunk
+        doesn't update its trailing size field since there is no next
+        contiguous chunk that would have to index off it. However,
+        space is still allocated for it (TOP_FOOT_SIZE) to enable
+        separation or merging when space is extended.
+
+     3. Chunks allocated via mmap, have both cinuse and pinuse bits
+        cleared in their head fields.  Because they are allocated
+        one-by-one, each must carry its own prev_foot field, which is
+        also used to hold the offset this chunk has within its mmapped
+        region, which is needed to preserve alignment. Each mmapped
+        chunk is trailed by the first two fields of a fake next-chunk
+        for sake of usage checks.
+
+*/
+
+struct malloc_chunk {
+  size_t               prev_foot;  /* Size of previous chunk (if free).  */
+  size_t               head;       /* Size and inuse bits. */
+  struct malloc_chunk* fd;         /* double links -- used only if free. */
+  struct malloc_chunk* bk;
+};
+
+typedef struct malloc_chunk  mchunk;
+typedef struct malloc_chunk* mchunkptr;
+typedef struct malloc_chunk* sbinptr;  /* The type of bins of chunks */
+typedef unsigned int bindex_t;         /* Described below */
+typedef unsigned int binmap_t;         /* Described below */
+typedef unsigned int flag_t;           /* The type of various bit flag sets */
+
+/* ------------------- Chunks sizes and alignments ----------------------- */
+
+#define MCHUNK_SIZE         (sizeof(mchunk))
+
+#if FOOTERS
+#define CHUNK_OVERHEAD      (TWO_SIZE_T_SIZES)
+#else /* FOOTERS */
+#define CHUNK_OVERHEAD      (SIZE_T_SIZE)
+#endif /* FOOTERS */
+
+/* MMapped chunks need a second word of overhead ... */
+#define MMAP_CHUNK_OVERHEAD (TWO_SIZE_T_SIZES)
+/* ... and additional padding for fake next-chunk at foot */
+#define MMAP_FOOT_PAD       (FOUR_SIZE_T_SIZES)
+
+/* The smallest size we can malloc is an aligned minimal chunk */
+#define MIN_CHUNK_SIZE\
+  ((MCHUNK_SIZE + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
+
+/* conversion from malloc headers to user pointers, and back */
+#define chunk2mem(p)        ((void*)((char*)(p)       + TWO_SIZE_T_SIZES))
+#define mem2chunk(mem)      ((mchunkptr)((char*)(mem) - TWO_SIZE_T_SIZES))
+/* chunk associated with aligned address A */
+#define align_as_chunk(A)   (mchunkptr)((A) + align_offset(chunk2mem(A)))
+
+/* Bounds on request (not chunk) sizes. */
+#define MAX_REQUEST         ((-MIN_CHUNK_SIZE) << 2)
+#define MIN_REQUEST         (MIN_CHUNK_SIZE - CHUNK_OVERHEAD - SIZE_T_ONE)
+
+/* pad request bytes into a usable size */
+#define pad_request(req) \
+   (((req) + CHUNK_OVERHEAD + CHUNK_ALIGN_MASK) & ~CHUNK_ALIGN_MASK)
+
+/* pad request, checking for minimum (but not maximum) */
+#define request2size(req) \
+  (((req) < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(req))
+
+
+/* ------------------ Operations on head and foot fields ----------------- */
+
+/*
+  The head field of a chunk is or'ed with PINUSE_BIT when previous
+  adjacent chunk in use, and or'ed with CINUSE_BIT if this chunk is in
+  use, unless mmapped, in which case both bits are cleared.
+
+  FLAG4_BIT is not used by this malloc, but might be useful in extensions.
+*/
+
+#define PINUSE_BIT          (SIZE_T_ONE)
+#define CINUSE_BIT          (SIZE_T_TWO)
+#define FLAG4_BIT           (SIZE_T_FOUR)
+#define INUSE_BITS          (PINUSE_BIT|CINUSE_BIT)
+#define FLAG_BITS           (PINUSE_BIT|CINUSE_BIT|FLAG4_BIT)
+
+/* Head value for fenceposts */
+#define FENCEPOST_HEAD      (INUSE_BITS|SIZE_T_SIZE)
+
+/* extraction of fields from head words */
+#define cinuse(p)           ((p)->head & CINUSE_BIT)
+#define pinuse(p)           ((p)->head & PINUSE_BIT)
+#define flag4inuse(p)       ((p)->head & FLAG4_BIT)
+#define is_inuse(p)         (((p)->head & INUSE_BITS) != PINUSE_BIT)
+#define is_mmapped(p)       (((p)->head & INUSE_BITS) == 0)
+
+#define chunksize(p)        ((p)->head & ~(FLAG_BITS))
+
+#define clear_pinuse(p)     ((p)->head &= ~PINUSE_BIT)
+#define set_flag4(p)        ((p)->head |= FLAG4_BIT)
+#define clear_flag4(p)      ((p)->head &= ~FLAG4_BIT)
+
+/* Treat space at ptr +/- offset as a chunk */
+#define chunk_plus_offset(p, s)  ((mchunkptr)(((char*)(p)) + (s)))
+#define chunk_minus_offset(p, s) ((mchunkptr)(((char*)(p)) - (s)))
+
+/* Ptr to next or previous physical malloc_chunk. */
+#define next_chunk(p) ((mchunkptr)( ((char*)(p)) + ((p)->head & ~FLAG_BITS)))
+#define prev_chunk(p) ((mchunkptr)( ((char*)(p)) - ((p)->prev_foot) ))
+
+/* extract next chunk's pinuse bit */
+#define next_pinuse(p)  ((next_chunk(p)->head) & PINUSE_BIT)
+
+/* Get/set size at footer */
+#define get_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot)
+#define set_foot(p, s)  (((mchunkptr)((char*)(p) + (s)))->prev_foot = (s))
+
+/* Set size, pinuse bit, and foot */
+#define set_size_and_pinuse_of_free_chunk(p, s)\
+  ((p)->head = (s|PINUSE_BIT), set_foot(p, s))
+
+/* Set size, pinuse bit, foot, and clear next pinuse */
+#define set_free_with_pinuse(p, s, n)\
+  (clear_pinuse(n), set_size_and_pinuse_of_free_chunk(p, s))
+
+/* Get the internal overhead associated with chunk p */
+#define overhead_for(p)\
+ (is_mmapped(p)? MMAP_CHUNK_OVERHEAD : CHUNK_OVERHEAD)
+
+/* Return true if malloced space is not necessarily cleared */
+#if MMAP_CLEARS
+#define calloc_must_clear(p) (!is_mmapped(p))
+#else /* MMAP_CLEARS */
+#define calloc_must_clear(p) (1)
+#endif /* MMAP_CLEARS */
+
+/* ---------------------- Overlaid data structures ----------------------- */
+
+/*
+  When chunks are not in use, they are treated as nodes of either
+  lists or trees.
+
+  "Small"  chunks are stored in circular doubly-linked lists, and look
+  like this:
+
+    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Size of previous chunk                            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `head:' |             Size of chunk, in bytes                         |P|
+      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Forward pointer to next chunk in list             |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Back pointer to previous chunk in list            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Unused space (may be 0 bytes long)                .
+            .                                                               .
+            .                                                               |
+nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `foot:' |             Size of chunk, in bytes                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+  Larger chunks are kept in a form of bitwise digital trees (aka
+  tries) keyed on chunksizes.  Because malloc_tree_chunks are only for
+  free chunks greater than 256 bytes, their size doesn't impose any
+  constraints on user chunk sizes.  Each node looks like:
+
+    chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Size of previous chunk                            |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `head:' |             Size of chunk, in bytes                         |P|
+      mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Forward pointer to next chunk of same size        |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Back pointer to previous chunk of same size       |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to left child (child[0])                  |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to right child (child[1])                 |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Pointer to parent                                 |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             bin index of this chunk                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+            |             Unused space                                      .
+            .                                                               |
+nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+    `foot:' |             Size of chunk, in bytes                           |
+            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
+
+  Each tree holding treenodes is a tree of unique chunk sizes.  Chunks
+  of the same size are arranged in a circularly-linked list, with only
+  the oldest chunk (the next to be used, in our FIFO ordering)
+  actually in the tree.  (Tree members are distinguished by a non-null
+  parent pointer.)  If a chunk with the same size an an existing node
+  is inserted, it is linked off the existing node using pointers that
+  work in the same way as fd/bk pointers of small chunks.
+
+  Each tree contains a power of 2 sized range of chunk sizes (the
+  smallest is 0x100 <= x < 0x180), which is is divided in half at each
+  tree level, with the chunks in the smaller half of the range (0x100
+  <= x < 0x140 for the top nose) in the left subtree and the larger
+  half (0x140 <= x < 0x180) in the right subtree.  This is, of course,
+  done by inspecting individual bits.
+
+  Using these rules, each node's left subtree contains all smaller
+  sizes than its right subtree.  However, the node at the root of each
+  subtree has no particular ordering relationship to either.  (The
+  dividing line between the subtree sizes is based on trie relation.)
+  If we remove the last chunk of a given size from the interior of the
+  tree, we need to replace it with a leaf node.  The tree ordering
+  rules permit a node to be replaced by any leaf below it.
+
+  The smallest chunk in a tree (a common operation in a best-fit
+  allocator) can be found by walking a path to the leftmost leaf in
+  the tree.  Unlike a usual binary tree, where we follow left child
+  pointers until we reach a null, here we follow the right child
+  pointer any time the left one is null, until we reach a leaf with
+  both child pointers null. The smallest chunk in the tree will be
+  somewhere along that path.
+
+  The worst case number of steps to add, find, or remove a node is
+  bounded by the number of bits differentiating chunks within
+  bins. Under current bin calculations, this ranges from 6 up to 21
+  (for 32 bit sizes) or up to 53 (for 64 bit sizes). The typical case
+  is of course much better.
+*/
+
+struct malloc_tree_chunk {
+  /* The first four fields must be compatible with malloc_chunk */
+  size_t                    prev_foot;
+  size_t                    head;
+  struct malloc_tree_chunk* fd;
+  struct malloc_tree_chunk* bk;
+
+  struct malloc_tree_chunk* child[2];
+  struct malloc_tree_chunk* parent;
+  bindex_t                  index;
+};
+
+typedef struct malloc_tree_chunk  tchunk;
+typedef struct malloc_tree_chunk* tchunkptr;
+typedef struct malloc_tree_chunk* tbinptr; /* The type of bins of trees */
+
+/* A little helper macro for trees */
+#define leftmost_child(t) ((t)->child[0] != 0? (t)->child[0] : (t)->child[1])
+
+/* ----------------------------- Segments -------------------------------- */
+
+/*
+  Each malloc space may include non-contiguous segments, held in a
+  list headed by an embedded malloc_segment record representing the
+  top-most space. Segments also include flags holding properties of
+  the space. Large chunks that are directly allocated by mmap are not
+  included in this list. They are instead independently created and
+  destroyed without otherwise keeping track of them.
+
+  Segment management mainly comes into play for spaces allocated by
+  MMAP.  Any call to MMAP might or might not return memory that is
+  adjacent to an existing segment.  MORECORE normally contiguously
+  extends the current space, so this space is almost always adjacent,
+  which is simpler and faster to deal with. (This is why MORECORE is
+  used preferentially to MMAP when both are available -- see
+  sys_alloc.)  When allocating using MMAP, we don't use any of the
+  hinting mechanisms (inconsistently) supported in various
+  implementations of unix mmap, or distinguish reserving from
+  committing memory. Instead, we just ask for space, and exploit
+  contiguity when we get it.  It is probably possible to do
+  better than this on some systems, but no general scheme seems
+  to be significantly better.
+
+  Management entails a simpler variant of the consolidation scheme
+  used for chunks to reduce fragmentation -- new adjacent memory is
+  normally prepended or appended to an existing segment. However,
+  there are limitations compared to chunk consolidation that mostly
+  reflect the fact that segment processing is relatively infrequent
+  (occurring only when getting memory from system) and that we
+  don't expect to have huge numbers of segments:
+
+  * Segments are not indexed, so traversal requires linear scans.  (It
+    would be possible to index these, but is not worth the extra
+    overhead and complexity for most programs on most platforms.)
+  * New segments are only appended to old ones when holding top-most
+    memory; if they cannot be prepended to others, they are held in
+    different segments.
+
+  Except for the top-most segment of an mstate, each segment record
+  is kept at the tail of its segment. Segments are added by pushing
+  segment records onto the list headed by &mstate.seg for the
+  containing mstate.
+
+  Segment flags control allocation/merge/deallocation policies:
+  * If EXTERN_BIT set, then we did not allocate this segment,
+    and so should not try to deallocate or merge with others.
+    (This currently holds only for the initial segment passed
+    into create_mspace_with_base.)
+  * If USE_MMAP_BIT set, the segment may be merged with
+    other surrounding mmapped segments and trimmed/de-allocated
+    using munmap.
+  * If neither bit is set, then the segment was obtained using
+    MORECORE so can be merged with surrounding MORECORE'd segments
+    and deallocated/trimmed using MORECORE with negative arguments.
+*/
+
+struct malloc_segment {
+  char*        base;             /* base address */
+  size_t       size;             /* allocated size */
+  struct malloc_segment* next;   /* ptr to next segment */
+  flag_t       sflags;           /* mmap and extern flag */
+};
+
+#define is_mmapped_segment(S)  ((S)->sflags & USE_MMAP_BIT)
+#define is_extern_segment(S)   ((S)->sflags & EXTERN_BIT)
+
+typedef struct malloc_segment  msegment;
+typedef struct malloc_segment* msegmentptr;
+
+/* ---------------------------- malloc_state ----------------------------- */
+
+/*
+   A malloc_state holds all of the bookkeeping for a space.
+   The main fields are:
+
+  Top
+    The topmost chunk of the currently active segment. Its size is
+    cached in topsize.  The actual size of topmost space is
+    topsize+TOP_FOOT_SIZE, which includes space reserved for adding
+    fenceposts and segment records if necessary when getting more
+    space from the system.  The size at which to autotrim top is
+    cached from mparams in trim_check, except that it is disabled if
+    an autotrim fails.
+
+  Designated victim (dv)
+    This is the preferred chunk for servicing small requests that
+    don't have exact fits.  It is normally the chunk split off most
+    recently to service another small request.  Its size is cached in
+    dvsize. The link fields of this chunk are not maintained since it
+    is not kept in a bin.
+
+  SmallBins
+    An array of bin headers for free chunks.  These bins hold chunks
+    with sizes less than MIN_LARGE_SIZE bytes. Each bin contains
+    chunks of all the same size, spaced 8 bytes apart.  To simplify
+    use in double-linked lists, each bin header acts as a malloc_chunk
+    pointing to the real first node, if it exists (else pointing to
+    itself).  This avoids special-casing for headers.  But to avoid
+    waste, we allocate only the fd/bk pointers of bins, and then use
+    repositioning tricks to treat these as the fields of a chunk.
+
+  TreeBins
+    Treebins are pointers to the roots of trees holding a range of
+    sizes. There are 2 equally spaced treebins for each power of two
+    from TREE_SHIFT to TREE_SHIFT+16. The last bin holds anything
+    larger.
+
+  Bin maps
+    There is one bit map for small bins ("smallmap") and one for
+    treebins ("treemap).  Each bin sets its bit when non-empty, and
+    clears the bit when empty.  Bit operations are then used to avoid
+    bin-by-bin searching -- nearly all "search" is done without ever
+    looking at bins that won't be selected.  The bit maps
+    conservatively use 32 bits per map word, even if on 64bit system.
+    For a good description of some of the bit-based techniques used
+    here, see Henry S. Warren Jr's book "Hacker's Delight" (and
+    supplement at http://hackersdelight.org/). Many of these are
+    intended to reduce the branchiness of paths through malloc etc, as
+    well as to reduce the number of memory locations read or written.
+
+  Segments
+    A list of segments headed by an embedded malloc_segment record
+    representing the initial space.
+
+  Address check support
+    The least_addr field is the least address ever obtained from
+    MORECORE or MMAP. Attempted frees and reallocs of any address less
+    than this are trapped (unless INSECURE is defined).
+
+  Magic tag
+    A cross-check field that should always hold same value as mparams.magic.
+
+  Max allowed footprint
+    The maximum allowed bytes to allocate from system (zero means no limit)
+
+  Flags
+    Bits recording whether to use MMAP, locks, or contiguous MORECORE
+
+  Statistics
+    Each space keeps track of current and maximum system memory
+    obtained via MORECORE or MMAP.
+
+  Trim support
+    Fields holding the amount of unused topmost memory that should trigger
+    trimming, and a counter to force periodic scanning to release unused
+    non-topmost segments.
+
+  Locking
+    If USE_LOCKS is defined, the "mutex" lock is acquired and released
+    around every public call using this mspace.
+
+  Extension support
+    A void* pointer and a size_t field that can be used to help implement
+    extensions to this malloc.
+*/
+
+/* Bin types, widths and sizes */
+#define NSMALLBINS        (32U)
+#define NTREEBINS         (32U)
+#define SMALLBIN_SHIFT    (3U)
+#define SMALLBIN_WIDTH    (SIZE_T_ONE << SMALLBIN_SHIFT)
+#define TREEBIN_SHIFT     (8U)
+#define MIN_LARGE_SIZE    (SIZE_T_ONE << TREEBIN_SHIFT)
+#define MAX_SMALL_SIZE    (MIN_LARGE_SIZE - SIZE_T_ONE)
+#define MAX_SMALL_REQUEST (MAX_SMALL_SIZE - CHUNK_ALIGN_MASK - CHUNK_OVERHEAD)
+
+struct malloc_state {
+  binmap_t   smallmap;
+  binmap_t   treemap;
+  size_t     dvsize;
+  size_t     topsize;
+  char*      least_addr;
+  mchunkptr  dv;
+  mchunkptr  top;
+  size_t     trim_check;
+  size_t     release_checks;
+  size_t     magic;
+  mchunkptr  smallbins[(NSMALLBINS+1)*2];
+  tbinptr    treebins[NTREEBINS];
+  size_t     footprint;
+  size_t     max_footprint;
+  size_t     footprint_limit; /* zero means no limit */
+  flag_t     mflags;
+#if USE_LOCKS
+  MLOCK_T    mutex;     /* locate lock among fields that rarely change */
+#endif /* USE_LOCKS */
+  msegment   seg;
+  void*      extp;      /* Unused but available for extensions */
+  size_t     exts;
+};
+
+typedef struct malloc_state*    mstate;
+
+/* ------------- Global malloc_state and malloc_params ------------------- */
+
+/*
+  malloc_params holds global properties, including those that can be
+  dynamically set using mallopt. There is a single instance, mparams,
+  initialized in init_mparams. Note that the non-zeroness of "magic"
+  also serves as an initialization flag.
+*/
+
+struct malloc_params {
+  size_t magic;
+  size_t page_size;
+  size_t granularity;
+  size_t mmap_threshold;
+  size_t trim_threshold;
+  flag_t default_mflags;
+};
+
+static struct malloc_params mparams;
+
+/* Ensure mparams initialized */
+#define ensure_initialization() (void)(mparams.magic != 0 || init_mparams())
+
+#if !ONLY_MSPACES
+
+/* The global malloc_state used for all non-"mspace" calls */
+static struct malloc_state _gm_;
+#define gm                 (&_gm_)
+#define is_global(M)       ((M) == &_gm_)
+
+#endif /* !ONLY_MSPACES */
+
+#define is_initialized(M)  ((M)->top != 0)
+
+/* -------------------------- system alloc setup ------------------------- */
+
+/* Operations on mflags */
+
+#define use_lock(M)           ((M)->mflags &   USE_LOCK_BIT)
+#define enable_lock(M)        ((M)->mflags |=  USE_LOCK_BIT)
+#if USE_LOCKS
+#define disable_lock(M)       ((M)->mflags &= ~USE_LOCK_BIT)
+#else
+#define disable_lock(M)
+#endif
+
+#define use_mmap(M)           ((M)->mflags &   USE_MMAP_BIT)
+#define enable_mmap(M)        ((M)->mflags |=  USE_MMAP_BIT)
+#if HAVE_MMAP
+#define disable_mmap(M)       ((M)->mflags &= ~USE_MMAP_BIT)
+#else
+#define disable_mmap(M)
+#endif
+
+#define use_noncontiguous(M)  ((M)->mflags &   USE_NONCONTIGUOUS_BIT)
+#define disable_contiguous(M) ((M)->mflags |=  USE_NONCONTIGUOUS_BIT)
+
+#define set_lock(M,L)\
+ ((M)->mflags = (L)?\
+  ((M)->mflags | USE_LOCK_BIT) :\
+  ((M)->mflags & ~USE_LOCK_BIT))
+
+/* page-align a size */
+#define page_align(S)\
+ (((S) + (mparams.page_size - SIZE_T_ONE)) & ~(mparams.page_size - SIZE_T_ONE))
+
+/* granularity-align a size */
+#define granularity_align(S)\
+  (((S) + (mparams.granularity - SIZE_T_ONE))\
+   & ~(mparams.granularity - SIZE_T_ONE))
+
+
+/* For mmap, use granularity alignment on windows, else page-align */
+#ifdef WIN32
+#define mmap_align(S) granularity_align(S)
+#else
+#define mmap_align(S) page_align(S)
+#endif
+
+/* For sys_alloc, enough padding to ensure can malloc request on success */
+#define SYS_ALLOC_PADDING (TOP_FOOT_SIZE + MALLOC_ALIGNMENT)
+
+#define is_page_aligned(S)\
+   (((size_t)(S) & (mparams.page_size - SIZE_T_ONE)) == 0)
+#define is_granularity_aligned(S)\
+   (((size_t)(S) & (mparams.granularity - SIZE_T_ONE)) == 0)
+
+/*  True if segment S holds address A */
+#define segment_holds(S, A)\
+  ((char*)(A) >= S->base && (char*)(A) < S->base + S->size)
+
+/* Return segment holding given address */
+static msegmentptr segment_holding(mstate m, char* addr) {
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if (addr >= sp->base && addr < sp->base + sp->size)
+      return sp;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+
+/* Return true if segment contains a segment link */
+static int has_segment_link(mstate m, msegmentptr ss) {
+  msegmentptr sp = &m->seg;
+  for (;;) {
+    if ((char*)sp >= ss->base && (char*)sp < ss->base + ss->size)
+      return 1;
+    if ((sp = sp->next) == 0)
+      return 0;
+  }
+}
+
+#ifndef MORECORE_CANNOT_TRIM
+#define should_trim(M,s)  ((s) > (M)->trim_check)
+#else  /* MORECORE_CANNOT_TRIM */
+#define should_trim(M,s)  (0)
+#endif /* MORECORE_CANNOT_TRIM */
+
+/*
+  TOP_FOOT_SIZE is padding at the end of a segment, including space
+  that may be needed to place segment records and fenceposts when new
+  noncontiguous segments are added.
+*/
+#define TOP_FOOT_SIZE\
+  (align_offset(chunk2mem(0))+pad_request(sizeof(struct malloc_segment))+MIN_CHUNK_SIZE)
+
+
+/* -------------------------------  Hooks -------------------------------- */
+
+/*
+  PREACTION should be defined to return 0 on success, and nonzero on
+  failure. If you are not using locking, you can redefine these to do
+  anything you like.
+*/
+
+#if USE_LOCKS
+#define PREACTION(M)  ((use_lock(M))? ACQUIRE_LOCK(&(M)->mutex) : 0)
+#define POSTACTION(M) { if (use_lock(M)) RELEASE_LOCK(&(M)->mutex); }
+#else /* USE_LOCKS */
+
+#ifndef PREACTION
+#define PREACTION(M) (0)
+#endif  /* PREACTION */
+
+#ifndef POSTACTION
+#define POSTACTION(M)
+#endif  /* POSTACTION */
+
+#endif /* USE_LOCKS */
+
+/*
+  CORRUPTION_ERROR_ACTION is triggered upon detected bad addresses.
+  USAGE_ERROR_ACTION is triggered on detected bad frees and
+  reallocs. The argument p is an address that might have triggered the
+  fault. It is ignored by the two predefined actions, but might be
+  useful in custom actions that try to help diagnose errors.
+*/
+
+#if PROCEED_ON_ERROR
+
+/* A count of the number of corruption errors causing resets */
+int malloc_corruption_error_count;
+
+/* default corruption action */
+static void reset_on_error(mstate m);
+
+#define CORRUPTION_ERROR_ACTION(m)  reset_on_error(m)
+#define USAGE_ERROR_ACTION(m, p)
+
+#else /* PROCEED_ON_ERROR */
+
+#ifndef CORRUPTION_ERROR_ACTION
+#define CORRUPTION_ERROR_ACTION(m) ABORT
+#endif /* CORRUPTION_ERROR_ACTION */
+
+#ifndef USAGE_ERROR_ACTION
+#define USAGE_ERROR_ACTION(m,p) ABORT
+#endif /* USAGE_ERROR_ACTION */
+
+#endif /* PROCEED_ON_ERROR */
+
+
+/* -------------------------- Debugging setup ---------------------------- */
+
+#if ! DEBUG
+
+#define check_free_chunk(M,P)
+#define check_inuse_chunk(M,P)
+#define check_malloced_chunk(M,P,N)
+#define check_mmapped_chunk(M,P)
+#define check_malloc_state(M)
+#define check_top_chunk(M,P)
+
+#else /* DEBUG */
+#define check_free_chunk(M,P)       do_check_free_chunk(M,P)
+#define check_inuse_chunk(M,P)      do_check_inuse_chunk(M,P)
+#define check_top_chunk(M,P)        do_check_top_chunk(M,P)
+#define check_malloced_chunk(M,P,N) do_check_malloced_chunk(M,P,N)
+#define check_mmapped_chunk(M,P)    do_check_mmapped_chunk(M,P)
+#define check_malloc_state(M)       do_check_malloc_state(M)
+
+static void   do_check_any_chunk(mstate m, mchunkptr p);
+static void   do_check_top_chunk(mstate m, mchunkptr p);
+static void   do_check_mmapped_chunk(mstate m, mchunkptr p);
+static void   do_check_inuse_chunk(mstate m, mchunkptr p);
+static void   do_check_free_chunk(mstate m, mchunkptr p);
+static void   do_check_malloced_chunk(mstate m, void* mem, size_t s);
+static void   do_check_tree(mstate m, tchunkptr t);
+static void   do_check_treebin(mstate m, bindex_t i);
+static void   do_check_smallbin(mstate m, bindex_t i);
+static void   do_check_malloc_state(mstate m);
+static int    bin_find(mstate m, mchunkptr x);
+static size_t traverse_and_check(mstate m);
+#endif /* DEBUG */
+
+/* ---------------------------- Indexing Bins ---------------------------- */
+
+#define is_small(s)         (((s) >> SMALLBIN_SHIFT) < NSMALLBINS)
+#define small_index(s)      (bindex_t)((s)  >> SMALLBIN_SHIFT)
+#define small_index2size(i) ((i)  << SMALLBIN_SHIFT)
+#define MIN_SMALL_INDEX     (small_index(MIN_CHUNK_SIZE))
+
+/* addressing by index. See above about smallbin repositioning */
+#define smallbin_at(M, i)   ((sbinptr)((char*)&((M)->smallbins[(i)<<1])))
+#define treebin_at(M,i)     (&((M)->treebins[i]))
+
+/* assign tree index for size S to variable I. Use x86 asm if possible  */
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+#define compute_tree_index(S, I)\
+{\
+  unsigned int X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K = (unsigned) sizeof(X)*__CHAR_BIT__ - 1 - (unsigned) __builtin_clz(X); \
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+
+#elif defined (__INTEL_COMPILER)
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K = _bit_scan_reverse (X); \
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+
+#elif defined(_MSC_VER) && _MSC_VER>=1300
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int K;\
+    _BitScanReverse((DWORD *) &K, (DWORD) X);\
+    I =  (bindex_t)((K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1)));\
+  }\
+}
+
+#else /* GNUC */
+#define compute_tree_index(S, I)\
+{\
+  size_t X = S >> TREEBIN_SHIFT;\
+  if (X == 0)\
+    I = 0;\
+  else if (X > 0xFFFF)\
+    I = NTREEBINS-1;\
+  else {\
+    unsigned int Y = (unsigned int)X;\
+    unsigned int N = ((Y - 0x100) >> 16) & 8;\
+    unsigned int K = (((Y <<= N) - 0x1000) >> 16) & 4;\
+    N += K;\
+    N += K = (((Y <<= K) - 0x4000) >> 16) & 2;\
+    K = 14 - N + ((Y <<= K) >> 15);\
+    I = (K << 1) + ((S >> (K + (TREEBIN_SHIFT-1)) & 1));\
+  }\
+}
+#endif /* GNUC */
+
+/* Bit representing maximum resolved size in a treebin at i */
+#define bit_for_tree_index(i) \
+   (i == NTREEBINS-1)? (SIZE_T_BITSIZE-1) : (((i) >> 1) + TREEBIN_SHIFT - 2)
+
+/* Shift placing maximum resolved bit in a treebin at i as sign bit */
+#define leftshift_for_tree_index(i) \
+   ((i == NTREEBINS-1)? 0 : \
+    ((SIZE_T_BITSIZE-SIZE_T_ONE) - (((i) >> 1) + TREEBIN_SHIFT - 2)))
+
+/* The size of the smallest chunk held in bin with index i */
+#define minsize_for_tree_index(i) \
+   ((SIZE_T_ONE << (((i) >> 1) + TREEBIN_SHIFT)) |  \
+   (((size_t)((i) & SIZE_T_ONE)) << (((i) >> 1) + TREEBIN_SHIFT - 1)))
+
+
+/* ------------------------ Operations on bin maps ----------------------- */
+
+/* bit corresponding to given index */
+#define idx2bit(i)              ((binmap_t)(1) << (i))
+
+/* Mark/Clear bits with given index */
+#define mark_smallmap(M,i)      ((M)->smallmap |=  idx2bit(i))
+#define clear_smallmap(M,i)     ((M)->smallmap &= ~idx2bit(i))
+#define smallmap_is_marked(M,i) ((M)->smallmap &   idx2bit(i))
+
+#define mark_treemap(M,i)       ((M)->treemap  |=  idx2bit(i))
+#define clear_treemap(M,i)      ((M)->treemap  &= ~idx2bit(i))
+#define treemap_is_marked(M,i)  ((M)->treemap  &   idx2bit(i))
+
+/* isolate the least set bit of a bitmap */
+#define least_bit(x)         ((x) & -(x))
+
+/* mask with all bits to left of least bit of x on */
+#define left_bits(x)         ((x<<1) | -(x<<1))
+
+/* mask with all bits to left of or equal to least bit of x on */
+#define same_or_left_bits(x) ((x) | -(x))
+
+/* index corresponding to given bit. Use x86 asm if possible */
+
+#if defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  J = __builtin_ctz(X); \
+  I = (bindex_t)J;\
+}
+
+#elif defined (__INTEL_COMPILER)
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  J = _bit_scan_forward (X); \
+  I = (bindex_t)J;\
+}
+
+#elif defined(_MSC_VER) && _MSC_VER>=1300
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int J;\
+  _BitScanForward((DWORD *) &J, X);\
+  I = (bindex_t)J;\
+}
+
+#elif USE_BUILTIN_FFS
+#define compute_bit2idx(X, I) I = ffs(X)-1
+
+#else
+#define compute_bit2idx(X, I)\
+{\
+  unsigned int Y = X - 1;\
+  unsigned int K = Y >> (16-4) & 16;\
+  unsigned int N = K;        Y >>= K;\
+  N += K = Y >> (8-3) &  8;  Y >>= K;\
+  N += K = Y >> (4-2) &  4;  Y >>= K;\
+  N += K = Y >> (2-1) &  2;  Y >>= K;\
+  N += K = Y >> (1-0) &  1;  Y >>= K;\
+  I = (bindex_t)(N + Y);\
+}
+#endif /* GNUC */
+
+
+/* ----------------------- Runtime Check Support ------------------------- */
+
+/*
+  For security, the main invariant is that malloc/free/etc never
+  writes to a static address other than malloc_state, unless static
+  malloc_state itself has been corrupted, which cannot occur via
+  malloc (because of these checks). In essence this means that we
+  believe all pointers, sizes, maps etc held in malloc_state, but
+  check all of those linked or offsetted from other embedded data
+  structures.  These checks are interspersed with main code in a way
+  that tends to minimize their run-time cost.
+
+  When FOOTERS is defined, in addition to range checking, we also
+  verify footer fields of inuse chunks, which can be used guarantee
+  that the mstate controlling malloc/free is intact.  This is a
+  streamlined version of the approach described by William Robertson
+  et al in "Run-time Detection of Heap-based Overflows" LISA'03
+  http://www.usenix.org/events/lisa03/tech/robertson.html The footer
+  of an inuse chunk holds the xor of its mstate and a random seed,
+  that is checked upon calls to free() and realloc().  This is
+  (probabalistically) unguessable from outside the program, but can be
+  computed by any code successfully malloc'ing any chunk, so does not
+  itself provide protection against code that has already broken
+  security through some other means.  Unlike Robertson et al, we
+  always dynamically check addresses of all offset chunks (previous,
+  next, etc). This turns out to be cheaper than relying on hashes.
+*/
+
+#if !INSECURE
+/* Check if address a is at least as high as any from MORECORE or MMAP */
+#define ok_address(M, a) ((char*)(a) >= (M)->least_addr)
+/* Check if address of next chunk n is higher than base chunk p */
+#define ok_next(p, n)    ((char*)(p) < (char*)(n))
+/* Check if p has inuse status */
+#define ok_inuse(p)     is_inuse(p)
+/* Check if p has its pinuse bit on */
+#define ok_pinuse(p)     pinuse(p)
+
+#else /* !INSECURE */
+#define ok_address(M, a) (1)
+#define ok_next(b, n)    (1)
+#define ok_inuse(p)      (1)
+#define ok_pinuse(p)     (1)
+#endif /* !INSECURE */
+
+#if (FOOTERS && !INSECURE)
+/* Check if (alleged) mstate m has expected magic field */
+#define ok_magic(M)      ((M)->magic == mparams.magic)
+#else  /* (FOOTERS && !INSECURE) */
+#define ok_magic(M)      (1)
+#endif /* (FOOTERS && !INSECURE) */
+
+/* In gcc, use __builtin_expect to minimize impact of checks */
+#if !INSECURE
+#if defined(__GNUC__) && __GNUC__ >= 3
+#define RTCHECK(e)  __builtin_expect(e, 1)
+#else /* GNUC */
+#define RTCHECK(e)  (e)
+#endif /* GNUC */
+#else /* !INSECURE */
+#define RTCHECK(e)  (1)
+#endif /* !INSECURE */
+
+/* macros to set up inuse chunks with or without footers */
+
+#if !FOOTERS
+
+#define mark_inuse_foot(M,p,s)
+
+/* Macros for setting head/foot of non-mmapped chunks */
+
+/* Set cinuse bit and pinuse bit of next chunk */
+#define set_inuse(M,p,s)\
+  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
+  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
+
+/* Set cinuse and pinuse of this chunk and pinuse of next chunk */
+#define set_inuse_and_pinuse(M,p,s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  ((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT)
+
+/* Set size, cinuse and pinuse bit of this chunk */
+#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT))
+
+#else /* FOOTERS */
+
+/* Set foot of inuse chunk to be xor of mstate and seed */
+#define mark_inuse_foot(M,p,s)\
+  (((mchunkptr)((char*)(p) + (s)))->prev_foot = ((size_t)(M) ^ mparams.magic))
+
+#define get_mstate_for(p)\
+  ((mstate)(((mchunkptr)((char*)(p) +\
+    (chunksize(p))))->prev_foot ^ mparams.magic))
+
+#define set_inuse(M,p,s)\
+  ((p)->head = (((p)->head & PINUSE_BIT)|s|CINUSE_BIT),\
+  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT), \
+  mark_inuse_foot(M,p,s))
+
+#define set_inuse_and_pinuse(M,p,s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  (((mchunkptr)(((char*)(p)) + (s)))->head |= PINUSE_BIT),\
+ mark_inuse_foot(M,p,s))
+
+#define set_size_and_pinuse_of_inuse_chunk(M, p, s)\
+  ((p)->head = (s|PINUSE_BIT|CINUSE_BIT),\
+  mark_inuse_foot(M, p, s))
+
+#endif /* !FOOTERS */
+
+/* ---------------------------- setting mparams -------------------------- */
+
+#if LOCK_AT_FORK
+static void pre_fork(void)         { ACQUIRE_LOCK(&(gm)->mutex); }
+static void post_fork_parent(void) { RELEASE_LOCK(&(gm)->mutex); }
+static void post_fork_child(void)  { INITIAL_LOCK(&(gm)->mutex); }
+#endif /* LOCK_AT_FORK */
+
+/* Initialize mparams */
+static int init_mparams(void) {
+#ifdef NEED_GLOBAL_LOCK_INIT
+  if (malloc_global_mutex_status <= 0)
+    init_malloc_global_mutex();
+#endif
+
+  ACQUIRE_MALLOC_GLOBAL_LOCK();
+  if (mparams.magic == 0) {
+    size_t magic;
+    size_t psize;
+    size_t gsize;
+
+#ifndef WIN32
+    psize = malloc_getpagesize;
+    gsize = ((DEFAULT_GRANULARITY != 0)? DEFAULT_GRANULARITY : psize);
+#else /* WIN32 */
+    {
+      SYSTEM_INFO system_info;
+      GetSystemInfo(&system_info);
+      psize = system_info.dwPageSize;
+      gsize = ((DEFAULT_GRANULARITY != 0)?
+               DEFAULT_GRANULARITY : system_info.dwAllocationGranularity);
+    }
+#endif /* WIN32 */
+
+    /* Sanity-check configuration:
+       size_t must be unsigned and as wide as pointer type.
+       ints must be at least 4 bytes.
+       alignment must be at least 8.
+       Alignment, min chunk size, and page size must all be powers of 2.
+    */
+    if ((sizeof(size_t) != sizeof(char*)) ||
+        (MAX_SIZE_T < MIN_CHUNK_SIZE)  ||
+        (sizeof(int) < 4)  ||
+        (MALLOC_ALIGNMENT < (size_t)8U) ||
+        ((MALLOC_ALIGNMENT & (MALLOC_ALIGNMENT-SIZE_T_ONE)) != 0) ||
+        ((MCHUNK_SIZE      & (MCHUNK_SIZE-SIZE_T_ONE))      != 0) ||
+        ((gsize            & (gsize-SIZE_T_ONE))            != 0) ||
+        ((psize            & (psize-SIZE_T_ONE))            != 0))
+      ABORT;
+    mparams.granularity = gsize;
+    mparams.page_size = psize;
+    mparams.mmap_threshold = DEFAULT_MMAP_THRESHOLD;
+    mparams.trim_threshold = DEFAULT_TRIM_THRESHOLD;
+#if MORECORE_CONTIGUOUS
+    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT;
+#else  /* MORECORE_CONTIGUOUS */
+    mparams.default_mflags = USE_LOCK_BIT|USE_MMAP_BIT|USE_NONCONTIGUOUS_BIT;
+#endif /* MORECORE_CONTIGUOUS */
+
+#if !ONLY_MSPACES
+    /* Set up lock for main malloc area */
+    gm->mflags = mparams.default_mflags;
+    (void)INITIAL_LOCK(&gm->mutex);
+#endif
+#if LOCK_AT_FORK
+    pthread_atfork(&pre_fork, &post_fork_parent, &post_fork_child);
+#endif
+
+    {
+#if USE_DEV_RANDOM
+      int fd;
+      unsigned char buf[sizeof(size_t)];
+      /* Try to use /dev/urandom, else fall back on using time */
+      if ((fd = open("/dev/urandom", O_RDONLY)) >= 0 &&
+          read(fd, buf, sizeof(buf)) == sizeof(buf)) {
+        magic = *((size_t *) buf);
+        close(fd);
+      }
+      else
+#endif /* USE_DEV_RANDOM */
+#ifdef WIN32
+      magic = (size_t)(GetTickCount() ^ (size_t)0x55555555U);
+#elif defined(LACKS_TIME_H)
+      magic = (size_t)&magic ^ (size_t)0x55555555U;
+#else
+      magic = (size_t)(time(0) ^ (size_t)0x55555555U);
+#endif
+      magic |= (size_t)8U;    /* ensure nonzero */
+      magic &= ~(size_t)7U;   /* improve chances of fault for bad values */
+      /* Until memory modes commonly available, use volatile-write */
+      (*(volatile size_t *)(&(mparams.magic))) = magic;
+    }
+  }
+
+  RELEASE_MALLOC_GLOBAL_LOCK();
+  return 1;
+}
+
+/* support for mallopt */
+static int change_mparam(int param_number, int value) {
+  size_t val;
+  ensure_initialization();
+  val = (value == -1)? MAX_SIZE_T : (size_t)value;
+  switch(param_number) {
+  case M_TRIM_THRESHOLD:
+    mparams.trim_threshold = val;
+    return 1;
+  case M_GRANULARITY:
+    if (val >= mparams.page_size && ((val & (val-1)) == 0)) {
+      mparams.granularity = val;
+      return 1;
+    }
+    else
+      return 0;
+  case M_MMAP_THRESHOLD:
+    mparams.mmap_threshold = val;
+    return 1;
+  default:
+    return 0;
+  }
+}
+
+#if DEBUG
+/* ------------------------- Debugging Support --------------------------- */
+
+/* Check properties of any chunk, whether free, inuse, mmapped etc  */
+static void do_check_any_chunk(mstate m, mchunkptr p) {
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+}
+
+/* Check properties of top chunk */
+static void do_check_top_chunk(mstate m, mchunkptr p) {
+  msegmentptr sp = segment_holding(m, (char*)p);
+  size_t  sz = p->head & ~INUSE_BITS; /* third-lowest bit can be set! */
+  assert(sp != 0);
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+  assert(sz == m->topsize);
+  assert(sz > 0);
+  assert(sz == ((sp->base + sp->size) - (char*)p) - TOP_FOOT_SIZE);
+  assert(pinuse(p));
+  assert(!pinuse(chunk_plus_offset(p, sz)));
+}
+
+/* Check properties of (inuse) mmapped chunks */
+static void do_check_mmapped_chunk(mstate m, mchunkptr p) {
+  size_t  sz = chunksize(p);
+  size_t len = (sz + (p->prev_foot) + MMAP_FOOT_PAD);
+  assert(is_mmapped(p));
+  assert(use_mmap(m));
+  assert((is_aligned(chunk2mem(p))) || (p->head == FENCEPOST_HEAD));
+  assert(ok_address(m, p));
+  assert(!is_small(sz));
+  assert((len & (mparams.page_size-SIZE_T_ONE)) == 0);
+  assert(chunk_plus_offset(p, sz)->head == FENCEPOST_HEAD);
+  assert(chunk_plus_offset(p, sz+SIZE_T_SIZE)->head == 0);
+}
+
+/* Check properties of inuse chunks */
+static void do_check_inuse_chunk(mstate m, mchunkptr p) {
+  do_check_any_chunk(m, p);
+  assert(is_inuse(p));
+  assert(next_pinuse(p));
+  /* If not pinuse and not mmapped, previous chunk has OK offset */
+  assert(is_mmapped(p) || pinuse(p) || next_chunk(prev_chunk(p)) == p);
+  if (is_mmapped(p))
+    do_check_mmapped_chunk(m, p);
+}
+
+/* Check properties of free chunks */
+static void do_check_free_chunk(mstate m, mchunkptr p) {
+  size_t sz = chunksize(p);
+  mchunkptr next = chunk_plus_offset(p, sz);
+  do_check_any_chunk(m, p);
+  assert(!is_inuse(p));
+  assert(!next_pinuse(p));
+  assert (!is_mmapped(p));
+  if (p != m->dv && p != m->top) {
+    if (sz >= MIN_CHUNK_SIZE) {
+      assert((sz & CHUNK_ALIGN_MASK) == 0);
+      assert(is_aligned(chunk2mem(p)));
+      assert(next->prev_foot == sz);
+      assert(pinuse(p));
+      assert (next == m->top || is_inuse(next));
+      assert(p->fd->bk == p);
+      assert(p->bk->fd == p);
+    }
+    else  /* markers are always of size SIZE_T_SIZE */
+      assert(sz == SIZE_T_SIZE);
+  }
+}
+
+/* Check properties of malloced chunks at the point they are malloced */
+static void do_check_malloced_chunk(mstate m, void* mem, size_t s) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    size_t sz = p->head & ~INUSE_BITS;
+    do_check_inuse_chunk(m, p);
+    assert((sz & CHUNK_ALIGN_MASK) == 0);
+    assert(sz >= MIN_CHUNK_SIZE);
+    assert(sz >= s);
+    /* unless mmapped, size is less than MIN_CHUNK_SIZE more than request */
+    assert(is_mmapped(p) || sz < (s + MIN_CHUNK_SIZE));
+  }
+}
+
+/* Check a tree and its subtrees.  */
+static void do_check_tree(mstate m, tchunkptr t) {
+  tchunkptr head = 0;
+  tchunkptr u = t;
+  bindex_t tindex = t->index;
+  size_t tsize = chunksize(t);
+  bindex_t idx;
+  compute_tree_index(tsize, idx);
+  assert(tindex == idx);
+  assert(tsize >= MIN_LARGE_SIZE);
+  assert(tsize >= minsize_for_tree_index(idx));
+  assert((idx == NTREEBINS-1) || (tsize < minsize_for_tree_index((idx+1))));
+
+  do { /* traverse through chain of same-sized nodes */
+    do_check_any_chunk(m, ((mchunkptr)u));
+    assert(u->index == tindex);
+    assert(chunksize(u) == tsize);
+    assert(!is_inuse(u));
+    assert(!next_pinuse(u));
+    assert(u->fd->bk == u);
+    assert(u->bk->fd == u);
+    if (u->parent == 0) {
+      assert(u->child[0] == 0);
+      assert(u->child[1] == 0);
+    }
+    else {
+      assert(head == 0); /* only one node on chain has parent */
+      head = u;
+      assert(u->parent != u);
+      assert (u->parent->child[0] == u ||
+              u->parent->child[1] == u ||
+              *((tbinptr*)(u->parent)) == u);
+      if (u->child[0] != 0) {
+        assert(u->child[0]->parent == u);
+        assert(u->child[0] != u);
+        do_check_tree(m, u->child[0]);
+      }
+      if (u->child[1] != 0) {
+        assert(u->child[1]->parent == u);
+        assert(u->child[1] != u);
+        do_check_tree(m, u->child[1]);
+      }
+      if (u->child[0] != 0 && u->child[1] != 0) {
+        assert(chunksize(u->child[0]) < chunksize(u->child[1]));
+      }
+    }
+    u = u->fd;
+  } while (u != t);
+  assert(head != 0);
+}
+
+/*  Check all the chunks in a treebin.  */
+static void do_check_treebin(mstate m, bindex_t i) {
+  tbinptr* tb = treebin_at(m, i);
+  tchunkptr t = *tb;
+  int empty = (m->treemap & (1U << i)) == 0;
+  if (t == 0)
+    assert(empty);
+  if (!empty)
+    do_check_tree(m, t);
+}
+
+/*  Check all the chunks in a smallbin.  */
+static void do_check_smallbin(mstate m, bindex_t i) {
+  sbinptr b = smallbin_at(m, i);
+  mchunkptr p = b->bk;
+  unsigned int empty = (m->smallmap & (1U << i)) == 0;
+  if (p == b)
+    assert(empty);
+  if (!empty) {
+    for (; p != b; p = p->bk) {
+      size_t size = chunksize(p);
+      mchunkptr q;
+      /* each chunk claims to be free */
+      do_check_free_chunk(m, p);
+      /* chunk belongs in bin */
+      assert(small_index(size) == i);
+      assert(p->bk == b || chunksize(p->bk) == chunksize(p));
+      /* chunk is followed by an inuse chunk */
+      q = next_chunk(p);
+      if (q->head != FENCEPOST_HEAD)
+        do_check_inuse_chunk(m, q);
+    }
+  }
+}
+
+/* Find x in a bin. Used in other check functions. */
+static int bin_find(mstate m, mchunkptr x) {
+  size_t size = chunksize(x);
+  if (is_small(size)) {
+    bindex_t sidx = small_index(size);
+    sbinptr b = smallbin_at(m, sidx);
+    if (smallmap_is_marked(m, sidx)) {
+      mchunkptr p = b;
+      do {
+        if (p == x)
+          return 1;
+      } while ((p = p->fd) != b);
+    }
+  }
+  else {
+    bindex_t tidx;
+    compute_tree_index(size, tidx);
+    if (treemap_is_marked(m, tidx)) {
+      tchunkptr t = *treebin_at(m, tidx);
+      size_t sizebits = size << leftshift_for_tree_index(tidx);
+      while (t != 0 && chunksize(t) != size) {
+        t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
+        sizebits <<= 1;
+      }
+      if (t != 0) {
+        tchunkptr u = t;
+        do {
+          if (u == (tchunkptr)x)
+            return 1;
+        } while ((u = u->fd) != t);
+      }
+    }
+  }
+  return 0;
+}
+
+/* Traverse each chunk and check it; return total */
+static size_t traverse_and_check(mstate m) {
+  size_t sum = 0;
+  if (is_initialized(m)) {
+    msegmentptr s = &m->seg;
+    sum += m->topsize + TOP_FOOT_SIZE;
+    while (s != 0) {
+      mchunkptr q = align_as_chunk(s->base);
+      mchunkptr lastq = 0;
+      assert(pinuse(q));
+      while (segment_holds(s, q) &&
+             q != m->top && q->head != FENCEPOST_HEAD) {
+        sum += chunksize(q);
+        if (is_inuse(q)) {
+          assert(!bin_find(m, q));
+          do_check_inuse_chunk(m, q);
+        }
+        else {
+          assert(q == m->dv || bin_find(m, q));
+          assert(lastq == 0 || is_inuse(lastq)); /* Not 2 consecutive free */
+          do_check_free_chunk(m, q);
+        }
+        lastq = q;
+        q = next_chunk(q);
+      }
+      s = s->next;
+    }
+  }
+  return sum;
+}
+
+
+/* Check all properties of malloc_state. */
+static void do_check_malloc_state(mstate m) {
+  bindex_t i;
+  size_t total;
+  /* check bins */
+  for (i = 0; i < NSMALLBINS; ++i)
+    do_check_smallbin(m, i);
+  for (i = 0; i < NTREEBINS; ++i)
+    do_check_treebin(m, i);
+
+  if (m->dvsize != 0) { /* check dv chunk */
+    do_check_any_chunk(m, m->dv);
+    assert(m->dvsize == chunksize(m->dv));
+    assert(m->dvsize >= MIN_CHUNK_SIZE);
+    assert(bin_find(m, m->dv) == 0);
+  }
+
+  if (m->top != 0) {   /* check top chunk */
+    do_check_top_chunk(m, m->top);
+    /*assert(m->topsize == chunksize(m->top)); redundant */
+    assert(m->topsize > 0);
+    assert(bin_find(m, m->top) == 0);
+  }
+
+  total = traverse_and_check(m);
+  assert(total <= m->footprint);
+  assert(m->footprint <= m->max_footprint);
+}
+#endif /* DEBUG */
+
+/* ----------------------------- statistics ------------------------------ */
+
+#if !NO_MALLINFO
+static struct mallinfo internal_mallinfo(mstate m) {
+  struct mallinfo nm = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+  ensure_initialization();
+  if (!PREACTION(m)) {
+    check_malloc_state(m);
+    if (is_initialized(m)) {
+      size_t nfree = SIZE_T_ONE; /* top always free */
+      size_t mfree = m->topsize + TOP_FOOT_SIZE;
+      size_t sum = mfree;
+      msegmentptr s = &m->seg;
+      while (s != 0) {
+        mchunkptr q = align_as_chunk(s->base);
+        while (segment_holds(s, q) &&
+               q != m->top && q->head != FENCEPOST_HEAD) {
+          size_t sz = chunksize(q);
+          sum += sz;
+          if (!is_inuse(q)) {
+            mfree += sz;
+            ++nfree;
+          }
+          q = next_chunk(q);
+        }
+        s = s->next;
+      }
+
+      nm.arena    = sum;
+      nm.ordblks  = nfree;
+      nm.hblkhd   = m->footprint - sum;
+      nm.usmblks  = m->max_footprint;
+      nm.uordblks = m->footprint - mfree;
+      nm.fordblks = mfree;
+      nm.keepcost = m->topsize;
+    }
+
+    POSTACTION(m);
+  }
+  return nm;
+}
+#endif /* !NO_MALLINFO */
+
+#if !NO_MALLOC_STATS
+static void internal_malloc_stats(mstate m) {
+  ensure_initialization();
+  if (!PREACTION(m)) {
+    size_t maxfp = 0;
+    size_t fp = 0;
+    size_t used = 0;
+    check_malloc_state(m);
+    if (is_initialized(m)) {
+      msegmentptr s = &m->seg;
+      maxfp = m->max_footprint;
+      fp = m->footprint;
+      used = fp - (m->topsize + TOP_FOOT_SIZE);
+
+      while (s != 0) {
+        mchunkptr q = align_as_chunk(s->base);
+        while (segment_holds(s, q) &&
+               q != m->top && q->head != FENCEPOST_HEAD) {
+          if (!is_inuse(q))
+            used -= chunksize(q);
+          q = next_chunk(q);
+        }
+        s = s->next;
+      }
+    }
+    POSTACTION(m); /* drop lock */
+    fprintf(stderr, "max system bytes = %10lu\n", (unsigned long)(maxfp));
+    fprintf(stderr, "system bytes     = %10lu\n", (unsigned long)(fp));
+    fprintf(stderr, "in use bytes     = %10lu\n", (unsigned long)(used));
+  }
+}
+#endif /* NO_MALLOC_STATS */
+
+/* ----------------------- Operations on smallbins ----------------------- */
+
+/*
+  Various forms of linking and unlinking are defined as macros.  Even
+  the ones for trees, which are very long but have very short typical
+  paths.  This is ugly but reduces reliance on inlining support of
+  compilers.
+*/
+
+/* Link a free chunk into a smallbin  */
+#define insert_small_chunk(M, P, S) {\
+  bindex_t I  = small_index(S);\
+  mchunkptr B = smallbin_at(M, I);\
+  mchunkptr F = B;\
+  assert(S >= MIN_CHUNK_SIZE);\
+  if (!smallmap_is_marked(M, I))\
+    mark_smallmap(M, I);\
+  else if (RTCHECK(ok_address(M, B->fd)))\
+    F = B->fd;\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+  B->fd = P;\
+  F->bk = P;\
+  P->fd = F;\
+  P->bk = B;\
+}
+
+/* Unlink a chunk from a smallbin  */
+#define unlink_small_chunk(M, P, S) {\
+  mchunkptr F = P->fd;\
+  mchunkptr B = P->bk;\
+  bindex_t I = small_index(S);\
+  assert(P != B);\
+  assert(P != F);\
+  assert(chunksize(P) == small_index2size(I));\
+  if (RTCHECK(F == smallbin_at(M,I) || (ok_address(M, F) && F->bk == P))) { \
+    if (B == F) {\
+      clear_smallmap(M, I);\
+    }\
+    else if (RTCHECK(B == smallbin_at(M,I) ||\
+                     (ok_address(M, B) && B->fd == P))) {\
+      F->bk = B;\
+      B->fd = F;\
+    }\
+    else {\
+      CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+}
+
+/* Unlink the first chunk from a smallbin */
+#define unlink_first_small_chunk(M, B, P, I) {\
+  mchunkptr F = P->fd;\
+  assert(P != B);\
+  assert(P != F);\
+  assert(chunksize(P) == small_index2size(I));\
+  if (B == F) {\
+    clear_smallmap(M, I);\
+  }\
+  else if (RTCHECK(ok_address(M, F) && F->bk == P)) {\
+    F->bk = B;\
+    B->fd = F;\
+  }\
+  else {\
+    CORRUPTION_ERROR_ACTION(M);\
+  }\
+}
+
+/* Replace dv node, binning the old one */
+/* Used only when dvsize known to be small */
+#define replace_dv(M, P, S) {\
+  size_t DVS = M->dvsize;\
+  assert(is_small(DVS));\
+  if (DVS != 0) {\
+    mchunkptr DV = M->dv;\
+    insert_small_chunk(M, DV, DVS);\
+  }\
+  M->dvsize = S;\
+  M->dv = P;\
+}
+
+/* ------------------------- Operations on trees ------------------------- */
+
+/* Insert chunk into tree */
+#define insert_large_chunk(M, X, S) {\
+  tbinptr* H;\
+  bindex_t I;\
+  compute_tree_index(S, I);\
+  H = treebin_at(M, I);\
+  X->index = I;\
+  X->child[0] = X->child[1] = 0;\
+  if (!treemap_is_marked(M, I)) {\
+    mark_treemap(M, I);\
+    *H = X;\
+    X->parent = (tchunkptr)H;\
+    X->fd = X->bk = X;\
+  }\
+  else {\
+    tchunkptr T = *H;\
+    size_t K = S << leftshift_for_tree_index(I);\
+    for (;;) {\
+      if (chunksize(T) != S) {\
+        tchunkptr* C = &(T->child[(K >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1]);\
+        K <<= 1;\
+        if (*C != 0)\
+          T = *C;\
+        else if (RTCHECK(ok_address(M, C))) {\
+          *C = X;\
+          X->parent = T;\
+          X->fd = X->bk = X;\
+          break;\
+        }\
+        else {\
+          CORRUPTION_ERROR_ACTION(M);\
+          break;\
+        }\
+      }\
+      else {\
+        tchunkptr F = T->fd;\
+        if (RTCHECK(ok_address(M, T) && ok_address(M, F))) {\
+          T->fd = F->bk = X;\
+          X->fd = F;\
+          X->bk = T;\
+          X->parent = 0;\
+          break;\
+        }\
+        else {\
+          CORRUPTION_ERROR_ACTION(M);\
+          break;\
+        }\
+      }\
+    }\
+  }\
+}
+
+/*
+  Unlink steps:
+
+  1. If x is a chained node, unlink it from its same-sized fd/bk links
+     and choose its bk node as its replacement.
+  2. If x was the last node of its size, but not a leaf node, it must
+     be replaced with a leaf node (not merely one with an open left or
+     right), to make sure that lefts and rights of descendents
+     correspond properly to bit masks.  We use the rightmost descendent
+     of x.  We could use any other leaf, but this is easy to locate and
+     tends to counteract removal of leftmosts elsewhere, and so keeps
+     paths shorter than minimally guaranteed.  This doesn't loop much
+     because on average a node in a tree is near the bottom.
+  3. If x is the base of a chain (i.e., has parent links) relink
+     x's parent and children to x's replacement (or null if none).
+*/
+
+#define unlink_large_chunk(M, X) {\
+  tchunkptr XP = X->parent;\
+  tchunkptr R;\
+  if (X->bk != X) {\
+    tchunkptr F = X->fd;\
+    R = X->bk;\
+    if (RTCHECK(ok_address(M, F) && F->bk == X && R->fd == X)) {\
+      F->bk = R;\
+      R->fd = F;\
+    }\
+    else {\
+      CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+  else {\
+    tchunkptr* RP;\
+    if (((R = *(RP = &(X->child[1]))) != 0) ||\
+        ((R = *(RP = &(X->child[0]))) != 0)) {\
+      tchunkptr* CP;\
+      while ((*(CP = &(R->child[1])) != 0) ||\
+             (*(CP = &(R->child[0])) != 0)) {\
+        R = *(RP = CP);\
+      }\
+      if (RTCHECK(ok_address(M, RP)))\
+        *RP = 0;\
+      else {\
+        CORRUPTION_ERROR_ACTION(M);\
+      }\
+    }\
+  }\
+  if (XP != 0) {\
+    tbinptr* H = treebin_at(M, X->index);\
+    if (X == *H) {\
+      if ((*H = R) == 0) \
+        clear_treemap(M, X->index);\
+    }\
+    else if (RTCHECK(ok_address(M, XP))) {\
+      if (XP->child[0] == X) \
+        XP->child[0] = R;\
+      else \
+        XP->child[1] = R;\
+    }\
+    else\
+      CORRUPTION_ERROR_ACTION(M);\
+    if (R != 0) {\
+      if (RTCHECK(ok_address(M, R))) {\
+        tchunkptr C0, C1;\
+        R->parent = XP;\
+        if ((C0 = X->child[0]) != 0) {\
+          if (RTCHECK(ok_address(M, C0))) {\
+            R->child[0] = C0;\
+            C0->parent = R;\
+          }\
+          else\
+            CORRUPTION_ERROR_ACTION(M);\
+        }\
+        if ((C1 = X->child[1]) != 0) {\
+          if (RTCHECK(ok_address(M, C1))) {\
+            R->child[1] = C1;\
+            C1->parent = R;\
+          }\
+          else\
+            CORRUPTION_ERROR_ACTION(M);\
+        }\
+      }\
+      else\
+        CORRUPTION_ERROR_ACTION(M);\
+    }\
+  }\
+}
+
+/* Relays to large vs small bin operations */
+
+#define insert_chunk(M, P, S)\
+  if (is_small(S)) insert_small_chunk(M, P, S)\
+  else { tchunkptr TP = (tchunkptr)(P); insert_large_chunk(M, TP, S); }
+
+#define unlink_chunk(M, P, S)\
+  if (is_small(S)) unlink_small_chunk(M, P, S)\
+  else { tchunkptr TP = (tchunkptr)(P); unlink_large_chunk(M, TP); }
+
+
+/* Relays to internal calls to malloc/free from realloc, memalign etc */
+
+#if ONLY_MSPACES
+#define internal_malloc(m, b) mspace_malloc(m, b)
+#define internal_free(m, mem) mspace_free(m,mem);
+#else /* ONLY_MSPACES */
+#if MSPACES
+#define internal_malloc(m, b)\
+  ((m == gm)? dlmalloc(b) : mspace_malloc(m, b))
+#define internal_free(m, mem)\
+   if (m == gm) dlfree(mem); else mspace_free(m,mem);
+#else /* MSPACES */
+#define internal_malloc(m, b) dlmalloc(b)
+#define internal_free(m, mem) dlfree(mem)
+#endif /* MSPACES */
+#endif /* ONLY_MSPACES */
+
+/* -----------------------  Direct-mmapping chunks ----------------------- */
+
+/*
+  Directly mmapped chunks are set up with an offset to the start of
+  the mmapped region stored in the prev_foot field of the chunk. This
+  allows reconstruction of the required argument to MUNMAP when freed,
+  and also allows adjustment of the returned chunk to meet alignment
+  requirements (especially in memalign).
+*/
+
+/* Malloc using mmap */
+static void* mmap_alloc(mstate m, size_t nb) {
+  size_t mmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+  if (m->footprint_limit != 0) {
+    size_t fp = m->footprint + mmsize;
+    if (fp <= m->footprint || fp > m->footprint_limit)
+      return 0;
+  }
+  if (mmsize > nb) {     /* Check for wrap around 0 */
+    char* mm = (char*)(CALL_DIRECT_MMAP(mmsize));
+    if (mm != CMFAIL) {
+      size_t offset = align_offset(chunk2mem(mm));
+      size_t psize = mmsize - offset - MMAP_FOOT_PAD;
+      mchunkptr p = (mchunkptr)(mm + offset);
+      p->prev_foot = offset;
+      p->head = psize;
+      mark_inuse_foot(m, p, psize);
+      chunk_plus_offset(p, psize)->head = FENCEPOST_HEAD;
+      chunk_plus_offset(p, psize+SIZE_T_SIZE)->head = 0;
+
+      if (m->least_addr == 0 || mm < m->least_addr)
+        m->least_addr = mm;
+      if ((m->footprint += mmsize) > m->max_footprint)
+        m->max_footprint = m->footprint;
+      assert(is_aligned(chunk2mem(p)));
+      check_mmapped_chunk(m, p);
+      return chunk2mem(p);
+    }
+  }
+  return 0;
+}
+
+/* Realloc using mmap */
+static mchunkptr mmap_resize(mstate m, mchunkptr oldp, size_t nb, int flags) {
+  size_t oldsize = chunksize(oldp);
+  (void)flags; /* placate people compiling -Wunused */
+  if (is_small(nb)) /* Can't shrink mmap regions below small size */
+    return 0;
+  /* Keep old chunk if big enough but not too big */
+  if (oldsize >= nb + SIZE_T_SIZE &&
+      (oldsize - nb) <= (mparams.granularity << 1))
+    return oldp;
+  else {
+    size_t offset = oldp->prev_foot;
+    size_t oldmmsize = oldsize + offset + MMAP_FOOT_PAD;
+    size_t newmmsize = mmap_align(nb + SIX_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+    char* cp = (char*)CALL_MREMAP((char*)oldp - offset,
+                                  oldmmsize, newmmsize, flags);
+    if (cp != CMFAIL) {
+      mchunkptr newp = (mchunkptr)(cp + offset);
+      size_t psize = newmmsize - offset - MMAP_FOOT_PAD;
+      newp->head = psize;
+      mark_inuse_foot(m, newp, psize);
+      chunk_plus_offset(newp, psize)->head = FENCEPOST_HEAD;
+      chunk_plus_offset(newp, psize+SIZE_T_SIZE)->head = 0;
+
+      if (cp < m->least_addr)
+        m->least_addr = cp;
+      if ((m->footprint += newmmsize - oldmmsize) > m->max_footprint)
+        m->max_footprint = m->footprint;
+      check_mmapped_chunk(m, newp);
+      return newp;
+    }
+  }
+  return 0;
+}
+
+
+/* -------------------------- mspace management -------------------------- */
+
+/* Initialize top chunk and its size */
+static void init_top(mstate m, mchunkptr p, size_t psize) {
+  /* Ensure alignment */
+  size_t offset = align_offset(chunk2mem(p));
+  p = (mchunkptr)((char*)p + offset);
+  psize -= offset;
+
+  m->top = p;
+  m->topsize = psize;
+  p->head = psize | PINUSE_BIT;
+  /* set size of fake trailing chunk holding overhead space only once */
+  chunk_plus_offset(p, psize)->head = TOP_FOOT_SIZE;
+  m->trim_check = mparams.trim_threshold; /* reset on each update */
+}
+
+/* Initialize bins for a new mstate that is otherwise zeroed out */
+static void init_bins(mstate m) {
+  /* Establish circular links for smallbins */
+  bindex_t i;
+  for (i = 0; i < NSMALLBINS; ++i) {
+    sbinptr bin = smallbin_at(m,i);
+    bin->fd = bin->bk = bin;
+  }
+}
+
+#if PROCEED_ON_ERROR
+
+/* default corruption action */
+static void reset_on_error(mstate m) {
+  int i;
+  ++malloc_corruption_error_count;
+  /* Reinitialize fields to forget about all memory */
+  m->smallmap = m->treemap = 0;
+  m->dvsize = m->topsize = 0;
+  m->seg.base = 0;
+  m->seg.size = 0;
+  m->seg.next = 0;
+  m->top = m->dv = 0;
+  for (i = 0; i < NTREEBINS; ++i)
+    *treebin_at(m, i) = 0;
+  init_bins(m);
+}
+#endif /* PROCEED_ON_ERROR */
+
+/* Allocate chunk and prepend remainder with chunk in successor base. */
+static void* prepend_alloc(mstate m, char* newbase, char* oldbase,
+                           size_t nb) {
+  mchunkptr p = align_as_chunk(newbase);
+  mchunkptr oldfirst = align_as_chunk(oldbase);
+  size_t psize = (char*)oldfirst - (char*)p;
+  mchunkptr q = chunk_plus_offset(p, nb);
+  size_t qsize = psize - nb;
+  set_size_and_pinuse_of_inuse_chunk(m, p, nb);
+
+  assert((char*)oldfirst > (char*)q);
+  assert(pinuse(oldfirst));
+  assert(qsize >= MIN_CHUNK_SIZE);
+
+  /* consolidate remainder with first chunk of old base */
+  if (oldfirst == m->top) {
+    size_t tsize = m->topsize += qsize;
+    m->top = q;
+    q->head = tsize | PINUSE_BIT;
+    check_top_chunk(m, q);
+  }
+  else if (oldfirst == m->dv) {
+    size_t dsize = m->dvsize += qsize;
+    m->dv = q;
+    set_size_and_pinuse_of_free_chunk(q, dsize);
+  }
+  else {
+    if (!is_inuse(oldfirst)) {
+      size_t nsize = chunksize(oldfirst);
+      unlink_chunk(m, oldfirst, nsize);
+      oldfirst = chunk_plus_offset(oldfirst, nsize);
+      qsize += nsize;
+    }
+    set_free_with_pinuse(q, qsize, oldfirst);
+    insert_chunk(m, q, qsize);
+    check_free_chunk(m, q);
+  }
+
+  check_malloced_chunk(m, chunk2mem(p), nb);
+  return chunk2mem(p);
+}
+
+/* Add a segment to hold a new noncontiguous region */
+static void add_segment(mstate m, char* tbase, size_t tsize, flag_t mmapped) {
+  /* Determine locations and sizes of segment, fenceposts, old top */
+  char* old_top = (char*)m->top;
+  msegmentptr oldsp = segment_holding(m, old_top);
+  char* old_end = oldsp->base + oldsp->size;
+  size_t ssize = pad_request(sizeof(struct malloc_segment));
+  char* rawsp = old_end - (ssize + FOUR_SIZE_T_SIZES + CHUNK_ALIGN_MASK);
+  size_t offset = align_offset(chunk2mem(rawsp));
+  char* asp = rawsp + offset;
+  char* csp = (asp < (old_top + MIN_CHUNK_SIZE))? old_top : asp;
+  mchunkptr sp = (mchunkptr)csp;
+  msegmentptr ss = (msegmentptr)(chunk2mem(sp));
+  mchunkptr tnext = chunk_plus_offset(sp, ssize);
+  mchunkptr p = tnext;
+  int nfences = 0;
+
+  /* reset top to new space */
+  init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
+
+  /* Set up segment record */
+  assert(is_aligned(ss));
+  set_size_and_pinuse_of_inuse_chunk(m, sp, ssize);
+  *ss = m->seg; /* Push current record */
+  m->seg.base = tbase;
+  m->seg.size = tsize;
+  m->seg.sflags = mmapped;
+  m->seg.next = ss;
+
+  /* Insert trailing fenceposts */
+  for (;;) {
+    mchunkptr nextp = chunk_plus_offset(p, SIZE_T_SIZE);
+    p->head = FENCEPOST_HEAD;
+    ++nfences;
+    if ((char*)(&(nextp->head)) < old_end)
+      p = nextp;
+    else
+      break;
+  }
+  assert(nfences >= 2);
+
+  /* Insert the rest of old top into a bin as an ordinary free chunk */
+  if (csp != old_top) {
+    mchunkptr q = (mchunkptr)old_top;
+    size_t psize = csp - old_top;
+    mchunkptr tn = chunk_plus_offset(q, psize);
+    set_free_with_pinuse(q, psize, tn);
+    insert_chunk(m, q, psize);
+  }
+
+  check_top_chunk(m, m->top);
+}
+
+/* -------------------------- System allocation -------------------------- */
+
+/* Get memory from system using MORECORE or MMAP */
+static void* sys_alloc(mstate m, size_t nb) {
+  char* tbase = CMFAIL;
+  size_t tsize = 0;
+  flag_t mmap_flag = 0;
+  size_t asize; /* allocation size */
+
+  ensure_initialization();
+
+  /* Directly map large chunks, but only if already initialized */
+  if (use_mmap(m) && nb >= mparams.mmap_threshold && m->topsize != 0) {
+    void* mem = mmap_alloc(m, nb);
+    if (mem != 0)
+      return mem;
+  }
+
+  asize = granularity_align(nb + SYS_ALLOC_PADDING);
+  if (asize <= nb)
+    return 0; /* wraparound */
+  if (m->footprint_limit != 0) {
+    size_t fp = m->footprint + asize;
+    if (fp <= m->footprint || fp > m->footprint_limit)
+      return 0;
+  }
+
+  /*
+    Try getting memory in any of three ways (in most-preferred to
+    least-preferred order):
+    1. A call to MORECORE that can normally contiguously extend memory.
+       (disabled if not MORECORE_CONTIGUOUS or not HAVE_MORECORE or
+       or main space is mmapped or a previous contiguous call failed)
+    2. A call to MMAP new space (disabled if not HAVE_MMAP).
+       Note that under the default settings, if MORECORE is unable to
+       fulfill a request, and HAVE_MMAP is true, then mmap is
+       used as a noncontiguous system allocator. This is a useful backup
+       strategy for systems with holes in address spaces -- in this case
+       sbrk cannot contiguously expand the heap, but mmap may be able to
+       find space.
+    3. A call to MORECORE that cannot usually contiguously extend memory.
+       (disabled if not HAVE_MORECORE)
+
+   In all cases, we need to request enough bytes from system to ensure
+   we can malloc nb bytes upon success, so pad with enough space for
+   top_foot, plus alignment-pad to make sure we don't lose bytes if
+   not on boundary, and round this up to a granularity unit.
+  */
+
+  if (MORECORE_CONTIGUOUS && !use_noncontiguous(m)) {
+    char* br = CMFAIL;
+    size_t ssize = asize; /* sbrk call size */
+    msegmentptr ss = (m->top == 0)? 0 : segment_holding(m, (char*)m->top);
+    ACQUIRE_MALLOC_GLOBAL_LOCK();
+
+    if (ss == 0) {  /* First time through or recovery */
+      char* base = (char*)CALL_MORECORE(0);      
+      if (base != CMFAIL) {
+        size_t fp;
+        /* Adjust to end on a page boundary */
+        if (!is_page_aligned(base))
+          ssize += (page_align((size_t)base) - (size_t)base);
+        fp = m->footprint + ssize; /* recheck limits */
+        if (ssize > nb && ssize < HALF_MAX_SIZE_T &&
+            (m->footprint_limit == 0 ||
+             (fp > m->footprint && fp <= m->footprint_limit)) &&
+            (br = (char*)(CALL_MORECORE(ssize))) == base) {
+          tbase = base;
+          tsize = ssize;
+        }
+      }
+    }
+    else {
+      /* Subtract out existing available top space from MORECORE request. */
+      ssize = granularity_align(nb - m->topsize + SYS_ALLOC_PADDING);
+      /* Use mem here only if it did continuously extend old space */
+      if (ssize < HALF_MAX_SIZE_T &&
+          (br = (char*)(CALL_MORECORE(ssize))) == ss->base+ss->size) {
+        tbase = br;
+        tsize = ssize;
+      }
+    }
+
+    if (tbase == CMFAIL) {    /* Cope with partial failure */
+      if (br != CMFAIL) {    /* Try to use/extend the space we did get */
+        if (ssize < HALF_MAX_SIZE_T &&
+            ssize < nb + SYS_ALLOC_PADDING) {
+          size_t esize = granularity_align(nb + SYS_ALLOC_PADDING - ssize);
+          if (esize < HALF_MAX_SIZE_T) {
+            char* end = (char*)CALL_MORECORE(esize);
+            if (end != CMFAIL)
+              ssize += esize;
+            else {            /* Can't use; try to release */
+              (void) CALL_MORECORE(-ssize);
+              br = CMFAIL;
+            }
+          }
+        }
+      }
+      if (br != CMFAIL) {    /* Use the space we did get */
+        tbase = br;
+        tsize = ssize;
+      }
+      else
+        disable_contiguous(m); /* Don't try contiguous path in the future */
+    }
+
+    RELEASE_MALLOC_GLOBAL_LOCK();
+  }
+
+  if (HAVE_MMAP && tbase == CMFAIL) {  /* Try MMAP */
+    char* mp = (char*)(CALL_MMAP(asize));
+    if (mp != CMFAIL) {
+      tbase = mp;
+      tsize = asize;
+      mmap_flag = USE_MMAP_BIT;
+    }
+  }
+
+  if (HAVE_MORECORE && tbase == CMFAIL) { /* Try noncontiguous MORECORE */
+    if (asize < HALF_MAX_SIZE_T) {
+      char* br = CMFAIL;
+      char* end = CMFAIL;
+      ACQUIRE_MALLOC_GLOBAL_LOCK();
+      br = (char*)(CALL_MORECORE(asize));
+      end = (char*)(CALL_MORECORE(0));
+      RELEASE_MALLOC_GLOBAL_LOCK();
+      if (br != CMFAIL && end != CMFAIL && br < end) {
+        size_t ssize = end - br;
+        if (ssize > nb + TOP_FOOT_SIZE) {
+          tbase = br;
+          tsize = ssize;
+        }
+      }
+    }
+  }
+
+  if (tbase != CMFAIL) {
+    if ((m->footprint += tsize) > m->max_footprint)
+      m->max_footprint = m->footprint;
+
+    if (!is_initialized(m)) { /* first-time initialization */
+      if (m->least_addr == 0 || tbase < m->least_addr)
+        m->least_addr = tbase;
+      m->seg.base = tbase;
+      m->seg.size = tsize;
+      m->seg.sflags = mmap_flag;
+      m->magic = mparams.magic;
+      m->release_checks = MAX_RELEASE_CHECK_RATE;
+      init_bins(m);
+#if !ONLY_MSPACES
+      if (is_global(m))
+        init_top(m, (mchunkptr)tbase, tsize - TOP_FOOT_SIZE);
+      else
+#endif
+      {
+        /* Offset top by embedded malloc_state */
+        mchunkptr mn = next_chunk(mem2chunk(m));
+        init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) -TOP_FOOT_SIZE);
+      }
+    }
+
+    else {
+      /* Try to merge with an existing segment */
+      msegmentptr sp = &m->seg;
+      /* Only consider most recent segment if traversal suppressed */
+      while (sp != 0 && tbase != sp->base + sp->size)
+        sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
+      if (sp != 0 &&
+          !is_extern_segment(sp) &&
+          (sp->sflags & USE_MMAP_BIT) == mmap_flag &&
+          segment_holds(sp, m->top)) { /* append */
+        sp->size += tsize;
+        init_top(m, m->top, m->topsize + tsize);
+      }
+      else {
+        if (tbase < m->least_addr)
+          m->least_addr = tbase;
+        sp = &m->seg;
+        while (sp != 0 && sp->base != tbase + tsize)
+          sp = (NO_SEGMENT_TRAVERSAL) ? 0 : sp->next;
+        if (sp != 0 &&
+            !is_extern_segment(sp) &&
+            (sp->sflags & USE_MMAP_BIT) == mmap_flag) {
+          char* oldbase = sp->base;
+          sp->base = tbase;
+          sp->size += tsize;
+          return prepend_alloc(m, tbase, oldbase, nb);
+        }
+        else
+          add_segment(m, tbase, tsize, mmap_flag);
+      }
+    }
+
+    if (nb < m->topsize) { /* Allocate from new or extended top space */
+      size_t rsize = m->topsize -= nb;
+      mchunkptr p = m->top;
+      mchunkptr r = m->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(m, p, nb);
+      check_top_chunk(m, m->top);
+      check_malloced_chunk(m, chunk2mem(p), nb);
+      return chunk2mem(p);
+    }
+  }
+
+  MALLOC_FAILURE_ACTION;
+  return 0;
+}
+
+/* -----------------------  system deallocation -------------------------- */
+
+/* Unmap and unlink any mmapped segments that don't contain used chunks */
+static size_t release_unused_segments(mstate m) {
+  size_t released = 0;
+  int nsegs = 0;
+  msegmentptr pred = &m->seg;
+  msegmentptr sp = pred->next;
+  while (sp != 0) {
+    char* base = sp->base;
+    size_t size = sp->size;
+    msegmentptr next = sp->next;
+    ++nsegs;
+    if (is_mmapped_segment(sp) && !is_extern_segment(sp)) {
+      mchunkptr p = align_as_chunk(base);
+      size_t psize = chunksize(p);
+      /* Can unmap if first chunk holds entire segment and not pinned */
+      if (!is_inuse(p) && (char*)p + psize >= base + size - TOP_FOOT_SIZE) {
+        tchunkptr tp = (tchunkptr)p;
+        assert(segment_holds(sp, (char*)sp));
+        if (p == m->dv) {
+          m->dv = 0;
+          m->dvsize = 0;
+        }
+        else {
+          unlink_large_chunk(m, tp);
+        }
+        if (CALL_MUNMAP(base, size) == 0) {
+          released += size;
+          m->footprint -= size;
+          /* unlink obsoleted record */
+          sp = pred;
+          sp->next = next;
+        }
+        else { /* back out if cannot unmap */
+          insert_large_chunk(m, tp, psize);
+        }
+      }
+    }
+    if (NO_SEGMENT_TRAVERSAL) /* scan only first segment */
+      break;
+    pred = sp;
+    sp = next;
+  }
+  /* Reset check counter */
+  m->release_checks = (((size_t) nsegs > (size_t) MAX_RELEASE_CHECK_RATE)?
+                       (size_t) nsegs : (size_t) MAX_RELEASE_CHECK_RATE);
+  return released;
+}
+
+static int sys_trim(mstate m, size_t pad) {
+  size_t released = 0;
+  ensure_initialization();
+  if (pad < MAX_REQUEST && is_initialized(m)) {
+    pad += TOP_FOOT_SIZE; /* ensure enough room for segment overhead */
+
+    if (m->topsize > pad) {
+      /* Shrink top space in granularity-size units, keeping at least one */
+      size_t unit = mparams.granularity;
+      size_t extra = ((m->topsize - pad + (unit - SIZE_T_ONE)) / unit -
+                      SIZE_T_ONE) * unit;
+      msegmentptr sp = segment_holding(m, (char*)m->top);
+
+      if (!is_extern_segment(sp)) {
+        if (is_mmapped_segment(sp)) {
+          if (HAVE_MMAP &&
+              sp->size >= extra &&
+              !has_segment_link(m, sp)) { /* can't shrink if pinned */
+            size_t newsize = sp->size - extra;
+            (void)newsize; /* placate people compiling -Wunused-variable */
+            /* Prefer mremap, fall back to munmap */
+            if ((CALL_MREMAP(sp->base, sp->size, newsize, 0) != MFAIL) ||
+                (CALL_MUNMAP(sp->base + newsize, extra) == 0)) {
+              released = extra;
+            }
+          }
+        }
+        else if (HAVE_MORECORE) {
+          if (extra >= HALF_MAX_SIZE_T) /* Avoid wrapping negative */
+            extra = (HALF_MAX_SIZE_T) + SIZE_T_ONE - unit;
+          ACQUIRE_MALLOC_GLOBAL_LOCK();
+          {
+            /* Make sure end of memory is where we last set it. */
+            char* old_br = (char*)(CALL_MORECORE(0));
+            if (old_br == sp->base + sp->size) {
+              char* rel_br = (char*)(CALL_MORECORE(-extra));
+              char* new_br = (char*)(CALL_MORECORE(0));
+              if (rel_br != CMFAIL && new_br < old_br)
+                released = old_br - new_br;
+            }
+          }
+          RELEASE_MALLOC_GLOBAL_LOCK();
+        }
+      }
+
+      if (released != 0) {
+        sp->size -= released;
+        m->footprint -= released;
+        init_top(m, m->top, m->topsize - released);
+        check_top_chunk(m, m->top);
+      }
+    }
+
+    /* Unmap any unused mmapped segments */
+    if (HAVE_MMAP)
+      released += release_unused_segments(m);
+
+    /* On failure, disable autotrim to avoid repeated failed future calls */
+    if (released == 0 && m->topsize > m->trim_check)
+      m->trim_check = MAX_SIZE_T;
+  }
+
+  return (released != 0)? 1 : 0;
+}
+
+/* Consolidate and bin a chunk. Differs from exported versions
+   of free mainly in that the chunk need not be marked as inuse.
+*/
+static void dispose_chunk(mstate m, mchunkptr p, size_t psize) {
+  mchunkptr next = chunk_plus_offset(p, psize);
+  if (!pinuse(p)) {
+    mchunkptr prev;
+    size_t prevsize = p->prev_foot;
+    if (is_mmapped(p)) {
+      psize += prevsize + MMAP_FOOT_PAD;
+      if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+        m->footprint -= psize;
+      return;
+    }
+    prev = chunk_minus_offset(p, prevsize);
+    psize += prevsize;
+    p = prev;
+    if (RTCHECK(ok_address(m, prev))) { /* consolidate backward */
+      if (p != m->dv) {
+        unlink_chunk(m, p, prevsize);
+      }
+      else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+        m->dvsize = psize;
+        set_free_with_pinuse(p, psize, next);
+        return;
+      }
+    }
+    else {
+      CORRUPTION_ERROR_ACTION(m);
+      return;
+    }
+  }
+  if (RTCHECK(ok_address(m, next))) {
+    if (!cinuse(next)) {  /* consolidate forward */
+      if (next == m->top) {
+        size_t tsize = m->topsize += psize;
+        m->top = p;
+        p->head = tsize | PINUSE_BIT;
+        if (p == m->dv) {
+          m->dv = 0;
+          m->dvsize = 0;
+        }
+        return;
+      }
+      else if (next == m->dv) {
+        size_t dsize = m->dvsize += psize;
+        m->dv = p;
+        set_size_and_pinuse_of_free_chunk(p, dsize);
+        return;
+      }
+      else {
+        size_t nsize = chunksize(next);
+        psize += nsize;
+        unlink_chunk(m, next, nsize);
+        set_size_and_pinuse_of_free_chunk(p, psize);
+        if (p == m->dv) {
+          m->dvsize = psize;
+          return;
+        }
+      }
+    }
+    else {
+      set_free_with_pinuse(p, psize, next);
+    }
+    insert_chunk(m, p, psize);
+  }
+  else {
+    CORRUPTION_ERROR_ACTION(m);
+  }
+}
+
+/* ---------------------------- malloc --------------------------- */
+
+/* allocate a large request from the best fitting chunk in a treebin */
+static void* tmalloc_large(mstate m, size_t nb) {
+  tchunkptr v = 0;
+  size_t rsize = -nb; /* Unsigned negation */
+  tchunkptr t;
+  bindex_t idx;
+  compute_tree_index(nb, idx);
+  if ((t = *treebin_at(m, idx)) != 0) {
+    /* Traverse tree for this bin looking for node with size == nb */
+    size_t sizebits = nb << leftshift_for_tree_index(idx);
+    tchunkptr rst = 0;  /* The deepest untaken right subtree */
+    for (;;) {
+      tchunkptr rt;
+      size_t trem = chunksize(t) - nb;
+      if (trem < rsize) {
+        v = t;
+        if ((rsize = trem) == 0)
+          break;
+      }
+      rt = t->child[1];
+      t = t->child[(sizebits >> (SIZE_T_BITSIZE-SIZE_T_ONE)) & 1];
+      if (rt != 0 && rt != t)
+        rst = rt;
+      if (t == 0) {
+        t = rst; /* set t to least subtree holding sizes > nb */
+        break;
+      }
+      sizebits <<= 1;
+    }
+  }
+  if (t == 0 && v == 0) { /* set t to root of next non-empty treebin */
+    binmap_t leftbits = left_bits(idx2bit(idx)) & m->treemap;
+    if (leftbits != 0) {
+      bindex_t i;
+      binmap_t leastbit = least_bit(leftbits);
+      compute_bit2idx(leastbit, i);
+      t = *treebin_at(m, i);
+    }
+  }
+
+  while (t != 0) { /* find smallest of tree or subtree */
+    size_t trem = chunksize(t) - nb;
+    if (trem < rsize) {
+      rsize = trem;
+      v = t;
+    }
+    t = leftmost_child(t);
+  }
+
+  /*  If dv is a better fit, return 0 so malloc will use it */
+  if (v != 0 && rsize < (size_t)(m->dvsize - nb)) {
+    if (RTCHECK(ok_address(m, v))) { /* split */
+      mchunkptr r = chunk_plus_offset(v, nb);
+      assert(chunksize(v) == rsize + nb);
+      if (RTCHECK(ok_next(v, r))) {
+        unlink_large_chunk(m, v);
+        if (rsize < MIN_CHUNK_SIZE)
+          set_inuse_and_pinuse(m, v, (rsize + nb));
+        else {
+          set_size_and_pinuse_of_inuse_chunk(m, v, nb);
+          set_size_and_pinuse_of_free_chunk(r, rsize);
+          insert_chunk(m, r, rsize);
+        }
+        return chunk2mem(v);
+      }
+    }
+    CORRUPTION_ERROR_ACTION(m);
+  }
+  return 0;
+}
+
+/* allocate a small request from the best fitting chunk in a treebin */
+static void* tmalloc_small(mstate m, size_t nb) {
+  tchunkptr t, v;
+  size_t rsize;
+  bindex_t i;
+  binmap_t leastbit = least_bit(m->treemap);
+  compute_bit2idx(leastbit, i);
+  v = t = *treebin_at(m, i);
+  rsize = chunksize(t) - nb;
+
+  while ((t = leftmost_child(t)) != 0) {
+    size_t trem = chunksize(t) - nb;
+    if (trem < rsize) {
+      rsize = trem;
+      v = t;
+    }
+  }
+
+  if (RTCHECK(ok_address(m, v))) {
+    mchunkptr r = chunk_plus_offset(v, nb);
+    assert(chunksize(v) == rsize + nb);
+    if (RTCHECK(ok_next(v, r))) {
+      unlink_large_chunk(m, v);
+      if (rsize < MIN_CHUNK_SIZE)
+        set_inuse_and_pinuse(m, v, (rsize + nb));
+      else {
+        set_size_and_pinuse_of_inuse_chunk(m, v, nb);
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        replace_dv(m, r, rsize);
+      }
+      return chunk2mem(v);
+    }
+  }
+
+  CORRUPTION_ERROR_ACTION(m);
+  return 0;
+}
+
+#if !ONLY_MSPACES
+
+void* dlmalloc(size_t bytes) {
+  /*
+     Basic algorithm:
+     If a small request (< 256 bytes minus per-chunk overhead):
+       1. If one exists, use a remainderless chunk in associated smallbin.
+          (Remainderless means that there are too few excess bytes to
+          represent as a chunk.)
+       2. If it is big enough, use the dv chunk, which is normally the
+          chunk adjacent to the one used for the most recent small request.
+       3. If one exists, split the smallest available chunk in a bin,
+          saving remainder in dv.
+       4. If it is big enough, use the top chunk.
+       5. If available, get memory from system and use it
+     Otherwise, for a large request:
+       1. Find the smallest available binned chunk that fits, and use it
+          if it is better fitting than dv chunk, splitting if necessary.
+       2. If better fitting than any binned chunk, use the dv chunk.
+       3. If it is big enough, use the top chunk.
+       4. If request size >= mmap threshold, try to directly mmap this chunk.
+       5. If available, get memory from system and use it
+
+     The ugly goto's here ensure that postaction occurs along all paths.
+  */
+
+#if USE_LOCKS
+  ensure_initialization(); /* initialize in sys_alloc if not using locks */
+#endif
+
+  if (!PREACTION(gm)) {
+    void* mem;
+    size_t nb;
+    if (bytes <= MAX_SMALL_REQUEST) {
+      bindex_t idx;
+      binmap_t smallbits;
+      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
+      idx = small_index(nb);
+      smallbits = gm->smallmap >> idx;
+
+      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
+        mchunkptr b, p;
+        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
+        b = smallbin_at(gm, idx);
+        p = b->fd;
+        assert(chunksize(p) == small_index2size(idx));
+        unlink_first_small_chunk(gm, b, p, idx);
+        set_inuse_and_pinuse(gm, p, small_index2size(idx));
+        mem = chunk2mem(p);
+        check_malloced_chunk(gm, mem, nb);
+        goto postaction;
+      }
+
+      else if (nb > gm->dvsize) {
+        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
+          mchunkptr b, p, r;
+          size_t rsize;
+          bindex_t i;
+          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
+          binmap_t leastbit = least_bit(leftbits);
+          compute_bit2idx(leastbit, i);
+          b = smallbin_at(gm, i);
+          p = b->fd;
+          assert(chunksize(p) == small_index2size(i));
+          unlink_first_small_chunk(gm, b, p, i);
+          rsize = small_index2size(i) - nb;
+          /* Fit here cannot be remainderless if 4byte sizes */
+          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
+            set_inuse_and_pinuse(gm, p, small_index2size(i));
+          else {
+            set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+            r = chunk_plus_offset(p, nb);
+            set_size_and_pinuse_of_free_chunk(r, rsize);
+            replace_dv(gm, r, rsize);
+          }
+          mem = chunk2mem(p);
+          check_malloced_chunk(gm, mem, nb);
+          goto postaction;
+        }
+
+        else if (gm->treemap != 0 && (mem = tmalloc_small(gm, nb)) != 0) {
+          check_malloced_chunk(gm, mem, nb);
+          goto postaction;
+        }
+      }
+    }
+    else if (bytes >= MAX_REQUEST)
+      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
+    else {
+      nb = pad_request(bytes);
+      if (gm->treemap != 0 && (mem = tmalloc_large(gm, nb)) != 0) {
+        check_malloced_chunk(gm, mem, nb);
+        goto postaction;
+      }
+    }
+
+    if (nb <= gm->dvsize) {
+      size_t rsize = gm->dvsize - nb;
+      mchunkptr p = gm->dv;
+      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
+        mchunkptr r = gm->dv = chunk_plus_offset(p, nb);
+        gm->dvsize = rsize;
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+      }
+      else { /* exhaust dv */
+        size_t dvs = gm->dvsize;
+        gm->dvsize = 0;
+        gm->dv = 0;
+        set_inuse_and_pinuse(gm, p, dvs);
+      }
+      mem = chunk2mem(p);
+      check_malloced_chunk(gm, mem, nb);
+      goto postaction;
+    }
+
+    else if (nb < gm->topsize) { /* Split top */
+      size_t rsize = gm->topsize -= nb;
+      mchunkptr p = gm->top;
+      mchunkptr r = gm->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(gm, p, nb);
+      mem = chunk2mem(p);
+      check_top_chunk(gm, gm->top);
+      check_malloced_chunk(gm, mem, nb);
+      goto postaction;
+    }
+
+    mem = sys_alloc(gm, nb);
+
+  postaction:
+    POSTACTION(gm);
+    return mem;
+  }
+
+  return 0;
+}
+
+/* ---------------------------- free --------------------------- */
+
+void dlfree(void* mem) {
+  /*
+     Consolidate freed chunks with preceeding or succeeding bordering
+     free chunks, if they exist, and then place in a bin.  Intermixed
+     with special cases for top, dv, mmapped chunks, and usage errors.
+  */
+
+  if (mem != 0) {
+    mchunkptr p  = mem2chunk(mem);
+#if FOOTERS
+    mstate fm = get_mstate_for(p);
+    if (!ok_magic(fm)) {
+      USAGE_ERROR_ACTION(fm, p);
+      return;
+    }
+#else /* FOOTERS */
+#define fm gm
+#endif /* FOOTERS */
+    if (!PREACTION(fm)) {
+      check_inuse_chunk(fm, p);
+      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
+        size_t psize = chunksize(p);
+        mchunkptr next = chunk_plus_offset(p, psize);
+        if (!pinuse(p)) {
+          size_t prevsize = p->prev_foot;
+          if (is_mmapped(p)) {
+            psize += prevsize + MMAP_FOOT_PAD;
+            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+              fm->footprint -= psize;
+            goto postaction;
+          }
+          else {
+            mchunkptr prev = chunk_minus_offset(p, prevsize);
+            psize += prevsize;
+            p = prev;
+            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
+              if (p != fm->dv) {
+                unlink_chunk(fm, p, prevsize);
+              }
+              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+                fm->dvsize = psize;
+                set_free_with_pinuse(p, psize, next);
+                goto postaction;
+              }
+            }
+            else
+              goto erroraction;
+          }
+        }
+
+        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
+          if (!cinuse(next)) {  /* consolidate forward */
+            if (next == fm->top) {
+              size_t tsize = fm->topsize += psize;
+              fm->top = p;
+              p->head = tsize | PINUSE_BIT;
+              if (p == fm->dv) {
+                fm->dv = 0;
+                fm->dvsize = 0;
+              }
+              if (should_trim(fm, tsize))
+                sys_trim(fm, 0);
+              goto postaction;
+            }
+            else if (next == fm->dv) {
+              size_t dsize = fm->dvsize += psize;
+              fm->dv = p;
+              set_size_and_pinuse_of_free_chunk(p, dsize);
+              goto postaction;
+            }
+            else {
+              size_t nsize = chunksize(next);
+              psize += nsize;
+              unlink_chunk(fm, next, nsize);
+              set_size_and_pinuse_of_free_chunk(p, psize);
+              if (p == fm->dv) {
+                fm->dvsize = psize;
+                goto postaction;
+              }
+            }
+          }
+          else
+            set_free_with_pinuse(p, psize, next);
+
+          if (is_small(psize)) {
+            insert_small_chunk(fm, p, psize);
+            check_free_chunk(fm, p);
+          }
+          else {
+            tchunkptr tp = (tchunkptr)p;
+            insert_large_chunk(fm, tp, psize);
+            check_free_chunk(fm, p);
+            if (--fm->release_checks == 0)
+              release_unused_segments(fm);
+          }
+          goto postaction;
+        }
+      }
+    erroraction:
+      USAGE_ERROR_ACTION(fm, p);
+    postaction:
+      POSTACTION(fm);
+    }
+  }
+#if !FOOTERS
+#undef fm
+#endif /* FOOTERS */
+}
+
+void* dlcalloc(size_t n_elements, size_t elem_size) {
+  void* mem;
+  size_t req = 0;
+  if (n_elements != 0) {
+    req = n_elements * elem_size;
+    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
+        (req / n_elements != elem_size))
+      req = MAX_SIZE_T; /* force downstream failure on overflow */
+  }
+  mem = dlmalloc(req);
+  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
+    memset(mem, 0, req);
+  return mem;
+}
+
+#endif /* !ONLY_MSPACES */
+
+/* ------------ Internal support for realloc, memalign, etc -------------- */
+
+/* Try to realloc; only in-place unless can_move true */
+static mchunkptr try_realloc_chunk(mstate m, mchunkptr p, size_t nb,
+                                   int can_move) {
+  mchunkptr newp = 0;
+  size_t oldsize = chunksize(p);
+  mchunkptr next = chunk_plus_offset(p, oldsize);
+  if (RTCHECK(ok_address(m, p) && ok_inuse(p) &&
+              ok_next(p, next) && ok_pinuse(next))) {
+    if (is_mmapped(p)) {
+      newp = mmap_resize(m, p, nb, can_move);
+    }
+    else if (oldsize >= nb) {             /* already big enough */
+      size_t rsize = oldsize - nb;
+      if (rsize >= MIN_CHUNK_SIZE) {      /* split off remainder */
+        mchunkptr r = chunk_plus_offset(p, nb);
+        set_inuse(m, p, nb);
+        set_inuse(m, r, rsize);
+        dispose_chunk(m, r, rsize);
+      }
+      newp = p;
+    }
+    else if (next == m->top) {  /* extend into top */
+      if (oldsize + m->topsize > nb) {
+        size_t newsize = oldsize + m->topsize;
+        size_t newtopsize = newsize - nb;
+        mchunkptr newtop = chunk_plus_offset(p, nb);
+        set_inuse(m, p, nb);
+        newtop->head = newtopsize |PINUSE_BIT;
+        m->top = newtop;
+        m->topsize = newtopsize;
+        newp = p;
+      }
+    }
+    else if (next == m->dv) { /* extend into dv */
+      size_t dvs = m->dvsize;
+      if (oldsize + dvs >= nb) {
+        size_t dsize = oldsize + dvs - nb;
+        if (dsize >= MIN_CHUNK_SIZE) {
+          mchunkptr r = chunk_plus_offset(p, nb);
+          mchunkptr n = chunk_plus_offset(r, dsize);
+          set_inuse(m, p, nb);
+          set_size_and_pinuse_of_free_chunk(r, dsize);
+          clear_pinuse(n);
+          m->dvsize = dsize;
+          m->dv = r;
+        }
+        else { /* exhaust dv */
+          size_t newsize = oldsize + dvs;
+          set_inuse(m, p, newsize);
+          m->dvsize = 0;
+          m->dv = 0;
+        }
+        newp = p;
+      }
+    }
+    else if (!cinuse(next)) { /* extend into next free chunk */
+      size_t nextsize = chunksize(next);
+      if (oldsize + nextsize >= nb) {
+        size_t rsize = oldsize + nextsize - nb;
+        unlink_chunk(m, next, nextsize);
+        if (rsize < MIN_CHUNK_SIZE) {
+          size_t newsize = oldsize + nextsize;
+          set_inuse(m, p, newsize);
+        }
+        else {
+          mchunkptr r = chunk_plus_offset(p, nb);
+          set_inuse(m, p, nb);
+          set_inuse(m, r, rsize);
+          dispose_chunk(m, r, rsize);
+        }
+        newp = p;
+      }
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(m, chunk2mem(p));
+  }
+  return newp;
+}
+
+static void* internal_memalign(mstate m, size_t alignment, size_t bytes) {
+  void* mem = 0;
+  if (alignment <  MIN_CHUNK_SIZE) /* must be at least a minimum chunk size */
+    alignment = MIN_CHUNK_SIZE;
+  if ((alignment & (alignment-SIZE_T_ONE)) != 0) {/* Ensure a power of 2 */
+    size_t a = MALLOC_ALIGNMENT << 1;
+    while (a < alignment) a <<= 1;
+    alignment = a;
+  }
+  if (bytes >= MAX_REQUEST - alignment) {
+    if (m != 0)  { /* Test isn't needed but avoids compiler warning */
+      MALLOC_FAILURE_ACTION;
+    }
+  }
+  else {
+    size_t nb = request2size(bytes);
+    size_t req = nb + alignment + MIN_CHUNK_SIZE - CHUNK_OVERHEAD;
+    mem = internal_malloc(m, req);
+    if (mem != 0) {
+      mchunkptr p = mem2chunk(mem);
+      if (PREACTION(m))
+        return 0;
+      if ((((size_t)(mem)) & (alignment - 1)) != 0) { /* misaligned */
+        /*
+          Find an aligned spot inside chunk.  Since we need to give
+          back leading space in a chunk of at least MIN_CHUNK_SIZE, if
+          the first calculation places us at a spot with less than
+          MIN_CHUNK_SIZE leader, we can move to the next aligned spot.
+          We've allocated enough total room so that this is always
+          possible.
+        */
+        char* br = (char*)mem2chunk((size_t)(((size_t)((char*)mem + alignment -
+                                                       SIZE_T_ONE)) &
+                                             -alignment));
+        char* pos = ((size_t)(br - (char*)(p)) >= MIN_CHUNK_SIZE)?
+          br : br+alignment;
+        mchunkptr newp = (mchunkptr)pos;
+        size_t leadsize = pos - (char*)(p);
+        size_t newsize = chunksize(p) - leadsize;
+
+        if (is_mmapped(p)) { /* For mmapped chunks, just adjust offset */
+          newp->prev_foot = p->prev_foot + leadsize;
+          newp->head = newsize;
+        }
+        else { /* Otherwise, give back leader, use the rest */
+          set_inuse(m, newp, newsize);
+          set_inuse(m, p, leadsize);
+          dispose_chunk(m, p, leadsize);
+        }
+        p = newp;
+      }
+
+      /* Give back spare room at the end */
+      if (!is_mmapped(p)) {
+        size_t size = chunksize(p);
+        if (size > nb + MIN_CHUNK_SIZE) {
+          size_t remainder_size = size - nb;
+          mchunkptr remainder = chunk_plus_offset(p, nb);
+          set_inuse(m, p, nb);
+          set_inuse(m, remainder, remainder_size);
+          dispose_chunk(m, remainder, remainder_size);
+        }
+      }
+
+      mem = chunk2mem(p);
+      assert (chunksize(p) >= nb);
+      assert(((size_t)mem & (alignment - 1)) == 0);
+      check_inuse_chunk(m, p);
+      POSTACTION(m);
+    }
+  }
+  return mem;
+}
+
+/*
+  Common support for independent_X routines, handling
+    all of the combinations that can result.
+  The opts arg has:
+    bit 0 set if all elements are same size (using sizes[0])
+    bit 1 set if elements should be zeroed
+*/
+static void** ialloc(mstate m,
+                     size_t n_elements,
+                     size_t* sizes,
+                     int opts,
+                     void* chunks[]) {
+
+  size_t    element_size;   /* chunksize of each element, if all same */
+  size_t    contents_size;  /* total size of elements */
+  size_t    array_size;     /* request size of pointer array */
+  void*     mem;            /* malloced aggregate space */
+  mchunkptr p;              /* corresponding chunk */
+  size_t    remainder_size; /* remaining bytes while splitting */
+  void**    marray;         /* either "chunks" or malloced ptr array */
+  mchunkptr array_chunk;    /* chunk for malloced ptr array */
+  flag_t    was_enabled;    /* to disable mmap */
+  size_t    size;
+  size_t    i;
+
+  ensure_initialization();
+  /* compute array length, if needed */
+  if (chunks != 0) {
+    if (n_elements == 0)
+      return chunks; /* nothing to do */
+    marray = chunks;
+    array_size = 0;
+  }
+  else {
+    /* if empty req, must still return chunk representing empty array */
+    if (n_elements == 0)
+      return (void**)internal_malloc(m, 0);
+    marray = 0;
+    array_size = request2size(n_elements * (sizeof(void*)));
+  }
+
+  /* compute total element size */
+  if (opts & 0x1) { /* all-same-size */
+    element_size = request2size(*sizes);
+    contents_size = n_elements * element_size;
+  }
+  else { /* add up all the sizes */
+    element_size = 0;
+    contents_size = 0;
+    for (i = 0; i != n_elements; ++i)
+      contents_size += request2size(sizes[i]);
+  }
+
+  size = contents_size + array_size;
+
+  /*
+     Allocate the aggregate chunk.  First disable direct-mmapping so
+     malloc won't use it, since we would not be able to later
+     free/realloc space internal to a segregated mmap region.
+  */
+  was_enabled = use_mmap(m);
+  disable_mmap(m);
+  mem = internal_malloc(m, size - CHUNK_OVERHEAD);
+  if (was_enabled)
+    enable_mmap(m);
+  if (mem == 0)
+    return 0;
+
+  if (PREACTION(m)) return 0;
+  p = mem2chunk(mem);
+  remainder_size = chunksize(p);
+
+  assert(!is_mmapped(p));
+
+  if (opts & 0x2) {       /* optionally clear the elements */
+    memset((size_t*)mem, 0, remainder_size - SIZE_T_SIZE - array_size);
+  }
+
+  /* If not provided, allocate the pointer array as final part of chunk */
+  if (marray == 0) {
+    size_t  array_chunk_size;
+    array_chunk = chunk_plus_offset(p, contents_size);
+    array_chunk_size = remainder_size - contents_size;
+    marray = (void**) (chunk2mem(array_chunk));
+    set_size_and_pinuse_of_inuse_chunk(m, array_chunk, array_chunk_size);
+    remainder_size = contents_size;
+  }
+
+  /* split out elements */
+  for (i = 0; ; ++i) {
+    marray[i] = chunk2mem(p);
+    if (i != n_elements-1) {
+      if (element_size != 0)
+        size = element_size;
+      else
+        size = request2size(sizes[i]);
+      remainder_size -= size;
+      set_size_and_pinuse_of_inuse_chunk(m, p, size);
+      p = chunk_plus_offset(p, size);
+    }
+    else { /* the final element absorbs any overallocation slop */
+      set_size_and_pinuse_of_inuse_chunk(m, p, remainder_size);
+      break;
+    }
+  }
+
+#if DEBUG
+  if (marray != chunks) {
+    /* final element must have exactly exhausted chunk */
+    if (element_size != 0) {
+      assert(remainder_size == element_size);
+    }
+    else {
+      assert(remainder_size == request2size(sizes[i]));
+    }
+    check_inuse_chunk(m, mem2chunk(marray));
+  }
+  for (i = 0; i != n_elements; ++i)
+    check_inuse_chunk(m, mem2chunk(marray[i]));
+
+#endif /* DEBUG */
+
+  POSTACTION(m);
+  return marray;
+}
+
+/* Try to free all pointers in the given array.
+   Note: this could be made faster, by delaying consolidation,
+   at the price of disabling some user integrity checks, We
+   still optimize some consolidations by combining adjacent
+   chunks before freeing, which will occur often if allocated
+   with ialloc or the array is sorted.
+*/
+static size_t internal_bulk_free(mstate m, void* array[], size_t nelem) {
+  size_t unfreed = 0;
+  if (!PREACTION(m)) {
+    void** a;
+    void** fence = &(array[nelem]);
+    for (a = array; a != fence; ++a) {
+      void* mem = *a;
+      if (mem != 0) {
+        mchunkptr p = mem2chunk(mem);
+        size_t psize = chunksize(p);
+#if FOOTERS
+        if (get_mstate_for(p) != m) {
+          ++unfreed;
+          continue;
+        }
+#endif
+        check_inuse_chunk(m, p);
+        *a = 0;
+        if (RTCHECK(ok_address(m, p) && ok_inuse(p))) {
+          void ** b = a + 1; /* try to merge with next chunk */
+          mchunkptr next = next_chunk(p);
+          if (b != fence && *b == chunk2mem(next)) {
+            size_t newsize = chunksize(next) + psize;
+            set_inuse(m, p, newsize);
+            *b = chunk2mem(p);
+          }
+          else
+            dispose_chunk(m, p, psize);
+        }
+        else {
+          CORRUPTION_ERROR_ACTION(m);
+          break;
+        }
+      }
+    }
+    if (should_trim(m, m->topsize))
+      sys_trim(m, 0);
+    POSTACTION(m);
+  }
+  return unfreed;
+}
+
+/* Traversal */
+#if MALLOC_INSPECT_ALL
+static void internal_inspect_all(mstate m,
+                                 void(*handler)(void *start,
+                                                void *end,
+                                                size_t used_bytes,
+                                                void* callback_arg),
+                                 void* arg) {
+  if (is_initialized(m)) {
+    mchunkptr top = m->top;
+    msegmentptr s;
+    for (s = &m->seg; s != 0; s = s->next) {
+      mchunkptr q = align_as_chunk(s->base);
+      while (segment_holds(s, q) && q->head != FENCEPOST_HEAD) {
+        mchunkptr next = next_chunk(q);
+        size_t sz = chunksize(q);
+        size_t used;
+        void* start;
+        if (is_inuse(q)) {
+          used = sz - CHUNK_OVERHEAD; /* must not be mmapped */
+          start = chunk2mem(q);
+        }
+        else {
+          used = 0;
+          if (is_small(sz)) {     /* offset by possible bookkeeping */
+            start = (void*)((char*)q + sizeof(struct malloc_chunk));
+          }
+          else {
+            start = (void*)((char*)q + sizeof(struct malloc_tree_chunk));
+          }
+        }
+        if (start < (void*)next)  /* skip if all space is bookkeeping */
+          handler(start, next, used, arg);
+        if (q == top)
+          break;
+        q = next;
+      }
+    }
+  }
+}
+#endif /* MALLOC_INSPECT_ALL */
+
+/* ------------------ Exported realloc, memalign, etc -------------------- */
+
+#if !ONLY_MSPACES
+
+void* dlrealloc(void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem == 0) {
+    mem = dlmalloc(bytes);
+  }
+  else if (bytes >= MAX_REQUEST) {
+    MALLOC_FAILURE_ACTION;
+  }
+#ifdef REALLOC_ZERO_BYTES_FREES
+  else if (bytes == 0) {
+    dlfree(oldmem);
+  }
+#endif /* REALLOC_ZERO_BYTES_FREES */
+  else {
+    size_t nb = request2size(bytes);
+    mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+    mstate m = gm;
+#else /* FOOTERS */
+    mstate m = get_mstate_for(oldp);
+    if (!ok_magic(m)) {
+      USAGE_ERROR_ACTION(m, oldmem);
+      return 0;
+    }
+#endif /* FOOTERS */
+    if (!PREACTION(m)) {
+      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
+      POSTACTION(m);
+      if (newp != 0) {
+        check_inuse_chunk(m, newp);
+        mem = chunk2mem(newp);
+      }
+      else {
+        mem = internal_malloc(m, bytes);
+        if (mem != 0) {
+          size_t oc = chunksize(oldp) - overhead_for(oldp);
+          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
+          internal_free(m, oldmem);
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* dlrealloc_in_place(void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem != 0) {
+    if (bytes >= MAX_REQUEST) {
+      MALLOC_FAILURE_ACTION;
+    }
+    else {
+      size_t nb = request2size(bytes);
+      mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+      mstate m = gm;
+#else /* FOOTERS */
+      mstate m = get_mstate_for(oldp);
+      if (!ok_magic(m)) {
+        USAGE_ERROR_ACTION(m, oldmem);
+        return 0;
+      }
+#endif /* FOOTERS */
+      if (!PREACTION(m)) {
+        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
+        POSTACTION(m);
+        if (newp == oldp) {
+          check_inuse_chunk(m, newp);
+          mem = oldmem;
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* dlmemalign(size_t alignment, size_t bytes) {
+  if (alignment <= MALLOC_ALIGNMENT) {
+    return dlmalloc(bytes);
+  }
+  return internal_memalign(gm, alignment, bytes);
+}
+
+int dlposix_memalign(void** pp, size_t alignment, size_t bytes) {
+  void* mem = 0;
+  if (alignment == MALLOC_ALIGNMENT)
+    mem = dlmalloc(bytes);
+  else {
+    size_t d = alignment / sizeof(void*);
+    size_t r = alignment % sizeof(void*);
+    if (r != 0 || d == 0 || (d & (d-SIZE_T_ONE)) != 0)
+      return EINVAL;
+    else if (bytes <= MAX_REQUEST - alignment) {
+      if (alignment <  MIN_CHUNK_SIZE)
+        alignment = MIN_CHUNK_SIZE;
+      mem = internal_memalign(gm, alignment, bytes);
+    }
+  }
+  if (mem == 0)
+    return ENOMEM;
+  else {
+    *pp = mem;
+    return 0;
+  }
+}
+
+void* dlvalloc(size_t bytes) {
+  size_t pagesz;
+  ensure_initialization();
+  pagesz = mparams.page_size;
+  return dlmemalign(pagesz, bytes);
+}
+
+void* dlpvalloc(size_t bytes) {
+  size_t pagesz;
+  ensure_initialization();
+  pagesz = mparams.page_size;
+  return dlmemalign(pagesz, (bytes + pagesz - SIZE_T_ONE) & ~(pagesz - SIZE_T_ONE));
+}
+
+void** dlindependent_calloc(size_t n_elements, size_t elem_size,
+                            void* chunks[]) {
+  size_t sz = elem_size; /* serves as 1-element array */
+  return ialloc(gm, n_elements, &sz, 3, chunks);
+}
+
+void** dlindependent_comalloc(size_t n_elements, size_t sizes[],
+                              void* chunks[]) {
+  return ialloc(gm, n_elements, sizes, 0, chunks);
+}
+
+size_t dlbulk_free(void* array[], size_t nelem) {
+  return internal_bulk_free(gm, array, nelem);
+}
+
+#if MALLOC_INSPECT_ALL
+void dlmalloc_inspect_all(void(*handler)(void *start,
+                                         void *end,
+                                         size_t used_bytes,
+                                         void* callback_arg),
+                          void* arg) {
+  ensure_initialization();
+  if (!PREACTION(gm)) {
+    internal_inspect_all(gm, handler, arg);
+    POSTACTION(gm);
+  }
+}
+#endif /* MALLOC_INSPECT_ALL */
+
+int dlmalloc_trim(size_t pad) {
+  int result = 0;
+  ensure_initialization();
+  if (!PREACTION(gm)) {
+    result = sys_trim(gm, pad);
+    POSTACTION(gm);
+  }
+  return result;
+}
+
+size_t dlmalloc_footprint(void) {
+  return gm->footprint;
+}
+
+size_t dlmalloc_max_footprint(void) {
+  return gm->max_footprint;
+}
+
+size_t dlmalloc_footprint_limit(void) {
+  size_t maf = gm->footprint_limit;
+  return maf == 0 ? MAX_SIZE_T : maf;
+}
+
+size_t dlmalloc_set_footprint_limit(size_t bytes) {
+  size_t result;  /* invert sense of 0 */
+  if (bytes == 0)
+    result = granularity_align(1); /* Use minimal size */
+  if (bytes == MAX_SIZE_T)
+    result = 0;                    /* disable */
+  else
+    result = granularity_align(bytes);
+  return gm->footprint_limit = result;
+}
+
+#if !NO_MALLINFO
+struct mallinfo dlmallinfo(void) {
+  return internal_mallinfo(gm);
+}
+#endif /* NO_MALLINFO */
+
+#if !NO_MALLOC_STATS
+void dlmalloc_stats() {
+  internal_malloc_stats(gm);
+}
+#endif /* NO_MALLOC_STATS */
+
+int dlmallopt(int param_number, int value) {
+  return change_mparam(param_number, value);
+}
+
+size_t dlmalloc_usable_size(void* mem) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    if (is_inuse(p))
+      return chunksize(p) - overhead_for(p);
+  }
+  return 0;
+}
+
+#endif /* !ONLY_MSPACES */
+
+/* ----------------------------- user mspaces ---------------------------- */
+
+#if MSPACES
+
+static mstate init_user_mstate(char* tbase, size_t tsize) {
+  size_t msize = pad_request(sizeof(struct malloc_state));
+  mchunkptr mn;
+  mchunkptr msp = align_as_chunk(tbase);
+  mstate m = (mstate)(chunk2mem(msp));
+  memset(m, 0, msize);
+  (void)INITIAL_LOCK(&m->mutex);
+  msp->head = (msize|INUSE_BITS);
+  m->seg.base = m->least_addr = tbase;
+  m->seg.size = m->footprint = m->max_footprint = tsize;
+  m->magic = mparams.magic;
+  m->release_checks = MAX_RELEASE_CHECK_RATE;
+  m->mflags = mparams.default_mflags;
+  m->extp = 0;
+  m->exts = 0;
+  disable_contiguous(m);
+  init_bins(m);
+  mn = next_chunk(mem2chunk(m));
+  init_top(m, mn, (size_t)((tbase + tsize) - (char*)mn) - TOP_FOOT_SIZE);
+  check_top_chunk(m, m->top);
+  return m;
+}
+
+mspace create_mspace(size_t capacity, int locked) {
+  mstate m = 0;
+  size_t msize;
+  ensure_initialization();
+  msize = pad_request(sizeof(struct malloc_state));
+  if (capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
+    size_t rs = ((capacity == 0)? mparams.granularity :
+                 (capacity + TOP_FOOT_SIZE + msize));
+    size_t tsize = granularity_align(rs);
+    char* tbase = (char*)(CALL_MMAP(tsize));
+    if (tbase != CMFAIL) {
+      m = init_user_mstate(tbase, tsize);
+      m->seg.sflags = USE_MMAP_BIT;
+      set_lock(m, locked);
+    }
+  }
+  return (mspace)m;
+}
+
+mspace create_mspace_with_base(void* base, size_t capacity, int locked) {
+  mstate m = 0;
+  size_t msize;
+  ensure_initialization();
+  msize = pad_request(sizeof(struct malloc_state));
+  if (capacity > msize + TOP_FOOT_SIZE &&
+      capacity < (size_t) -(msize + TOP_FOOT_SIZE + mparams.page_size)) {
+    m = init_user_mstate((char*)base, capacity);
+    m->seg.sflags = EXTERN_BIT;
+    set_lock(m, locked);
+  }
+  return (mspace)m;
+}
+
+int mspace_track_large_chunks(mspace msp, int enable) {
+  int ret = 0;
+  mstate ms = (mstate)msp;
+  if (!PREACTION(ms)) {
+    if (!use_mmap(ms)) {
+      ret = 1;
+    }
+    if (!enable) {
+      enable_mmap(ms);
+    } else {
+      disable_mmap(ms);
+    }
+    POSTACTION(ms);
+  }
+  return ret;
+}
+
+size_t destroy_mspace(mspace msp) {
+  size_t freed = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    msegmentptr sp = &ms->seg;
+    (void)DESTROY_LOCK(&ms->mutex); /* destroy before unmapped */
+    while (sp != 0) {
+      char* base = sp->base;
+      size_t size = sp->size;
+      flag_t flag = sp->sflags;
+      (void)base; /* placate people compiling -Wunused-variable */
+      sp = sp->next;
+      if ((flag & USE_MMAP_BIT) && !(flag & EXTERN_BIT) &&
+          CALL_MUNMAP(base, size) == 0)
+        freed += size;
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return freed;
+}
+
+/*
+  mspace versions of routines are near-clones of the global
+  versions. This is not so nice but better than the alternatives.
+*/
+
+void* mspace_malloc(mspace msp, size_t bytes) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (!PREACTION(ms)) {
+    void* mem;
+    size_t nb;
+    if (bytes <= MAX_SMALL_REQUEST) {
+      bindex_t idx;
+      binmap_t smallbits;
+      nb = (bytes < MIN_REQUEST)? MIN_CHUNK_SIZE : pad_request(bytes);
+      idx = small_index(nb);
+      smallbits = ms->smallmap >> idx;
+
+      if ((smallbits & 0x3U) != 0) { /* Remainderless fit to a smallbin. */
+        mchunkptr b, p;
+        idx += ~smallbits & 1;       /* Uses next bin if idx empty */
+        b = smallbin_at(ms, idx);
+        p = b->fd;
+        assert(chunksize(p) == small_index2size(idx));
+        unlink_first_small_chunk(ms, b, p, idx);
+        set_inuse_and_pinuse(ms, p, small_index2size(idx));
+        mem = chunk2mem(p);
+        check_malloced_chunk(ms, mem, nb);
+        goto postaction;
+      }
+
+      else if (nb > ms->dvsize) {
+        if (smallbits != 0) { /* Use chunk in next nonempty smallbin */
+          mchunkptr b, p, r;
+          size_t rsize;
+          bindex_t i;
+          binmap_t leftbits = (smallbits << idx) & left_bits(idx2bit(idx));
+          binmap_t leastbit = least_bit(leftbits);
+          compute_bit2idx(leastbit, i);
+          b = smallbin_at(ms, i);
+          p = b->fd;
+          assert(chunksize(p) == small_index2size(i));
+          unlink_first_small_chunk(ms, b, p, i);
+          rsize = small_index2size(i) - nb;
+          /* Fit here cannot be remainderless if 4byte sizes */
+          if (SIZE_T_SIZE != 4 && rsize < MIN_CHUNK_SIZE)
+            set_inuse_and_pinuse(ms, p, small_index2size(i));
+          else {
+            set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+            r = chunk_plus_offset(p, nb);
+            set_size_and_pinuse_of_free_chunk(r, rsize);
+            replace_dv(ms, r, rsize);
+          }
+          mem = chunk2mem(p);
+          check_malloced_chunk(ms, mem, nb);
+          goto postaction;
+        }
+
+        else if (ms->treemap != 0 && (mem = tmalloc_small(ms, nb)) != 0) {
+          check_malloced_chunk(ms, mem, nb);
+          goto postaction;
+        }
+      }
+    }
+    else if (bytes >= MAX_REQUEST)
+      nb = MAX_SIZE_T; /* Too big to allocate. Force failure (in sys alloc) */
+    else {
+      nb = pad_request(bytes);
+      if (ms->treemap != 0 && (mem = tmalloc_large(ms, nb)) != 0) {
+        check_malloced_chunk(ms, mem, nb);
+        goto postaction;
+      }
+    }
+
+    if (nb <= ms->dvsize) {
+      size_t rsize = ms->dvsize - nb;
+      mchunkptr p = ms->dv;
+      if (rsize >= MIN_CHUNK_SIZE) { /* split dv */
+        mchunkptr r = ms->dv = chunk_plus_offset(p, nb);
+        ms->dvsize = rsize;
+        set_size_and_pinuse_of_free_chunk(r, rsize);
+        set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+      }
+      else { /* exhaust dv */
+        size_t dvs = ms->dvsize;
+        ms->dvsize = 0;
+        ms->dv = 0;
+        set_inuse_and_pinuse(ms, p, dvs);
+      }
+      mem = chunk2mem(p);
+      check_malloced_chunk(ms, mem, nb);
+      goto postaction;
+    }
+
+    else if (nb < ms->topsize) { /* Split top */
+      size_t rsize = ms->topsize -= nb;
+      mchunkptr p = ms->top;
+      mchunkptr r = ms->top = chunk_plus_offset(p, nb);
+      r->head = rsize | PINUSE_BIT;
+      set_size_and_pinuse_of_inuse_chunk(ms, p, nb);
+      mem = chunk2mem(p);
+      check_top_chunk(ms, ms->top);
+      check_malloced_chunk(ms, mem, nb);
+      goto postaction;
+    }
+
+    mem = sys_alloc(ms, nb);
+
+  postaction:
+    POSTACTION(ms);
+    return mem;
+  }
+
+  return 0;
+}
+
+void mspace_free(mspace msp, void* mem) {
+  if (mem != 0) {
+    mchunkptr p  = mem2chunk(mem);
+#if FOOTERS
+    mstate fm = get_mstate_for(p);
+    (void)msp; /* placate people compiling -Wunused */
+#else /* FOOTERS */
+    mstate fm = (mstate)msp;
+#endif /* FOOTERS */
+    if (!ok_magic(fm)) {
+      USAGE_ERROR_ACTION(fm, p);
+      return;
+    }
+    if (!PREACTION(fm)) {
+      check_inuse_chunk(fm, p);
+      if (RTCHECK(ok_address(fm, p) && ok_inuse(p))) {
+        size_t psize = chunksize(p);
+        mchunkptr next = chunk_plus_offset(p, psize);
+        if (!pinuse(p)) {
+          size_t prevsize = p->prev_foot;
+          if (is_mmapped(p)) {
+            psize += prevsize + MMAP_FOOT_PAD;
+            if (CALL_MUNMAP((char*)p - prevsize, psize) == 0)
+              fm->footprint -= psize;
+            goto postaction;
+          }
+          else {
+            mchunkptr prev = chunk_minus_offset(p, prevsize);
+            psize += prevsize;
+            p = prev;
+            if (RTCHECK(ok_address(fm, prev))) { /* consolidate backward */
+              if (p != fm->dv) {
+                unlink_chunk(fm, p, prevsize);
+              }
+              else if ((next->head & INUSE_BITS) == INUSE_BITS) {
+                fm->dvsize = psize;
+                set_free_with_pinuse(p, psize, next);
+                goto postaction;
+              }
+            }
+            else
+              goto erroraction;
+          }
+        }
+
+        if (RTCHECK(ok_next(p, next) && ok_pinuse(next))) {
+          if (!cinuse(next)) {  /* consolidate forward */
+            if (next == fm->top) {
+              size_t tsize = fm->topsize += psize;
+              fm->top = p;
+              p->head = tsize | PINUSE_BIT;
+              if (p == fm->dv) {
+                fm->dv = 0;
+                fm->dvsize = 0;
+              }
+              if (should_trim(fm, tsize))
+                sys_trim(fm, 0);
+              goto postaction;
+            }
+            else if (next == fm->dv) {
+              size_t dsize = fm->dvsize += psize;
+              fm->dv = p;
+              set_size_and_pinuse_of_free_chunk(p, dsize);
+              goto postaction;
+            }
+            else {
+              size_t nsize = chunksize(next);
+              psize += nsize;
+              unlink_chunk(fm, next, nsize);
+              set_size_and_pinuse_of_free_chunk(p, psize);
+              if (p == fm->dv) {
+                fm->dvsize = psize;
+                goto postaction;
+              }
+            }
+          }
+          else
+            set_free_with_pinuse(p, psize, next);
+
+          if (is_small(psize)) {
+            insert_small_chunk(fm, p, psize);
+            check_free_chunk(fm, p);
+          }
+          else {
+            tchunkptr tp = (tchunkptr)p;
+            insert_large_chunk(fm, tp, psize);
+            check_free_chunk(fm, p);
+            if (--fm->release_checks == 0)
+              release_unused_segments(fm);
+          }
+          goto postaction;
+        }
+      }
+    erroraction:
+      USAGE_ERROR_ACTION(fm, p);
+    postaction:
+      POSTACTION(fm);
+    }
+  }
+}
+
+void* mspace_calloc(mspace msp, size_t n_elements, size_t elem_size) {
+  void* mem;
+  size_t req = 0;
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (n_elements != 0) {
+    req = n_elements * elem_size;
+    if (((n_elements | elem_size) & ~(size_t)0xffff) &&
+        (req / n_elements != elem_size))
+      req = MAX_SIZE_T; /* force downstream failure on overflow */
+  }
+  mem = internal_malloc(ms, req);
+  if (mem != 0 && calloc_must_clear(mem2chunk(mem)))
+    memset(mem, 0, req);
+  return mem;
+}
+
+void* mspace_realloc(mspace msp, void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem == 0) {
+    mem = mspace_malloc(msp, bytes);
+  }
+  else if (bytes >= MAX_REQUEST) {
+    MALLOC_FAILURE_ACTION;
+  }
+#ifdef REALLOC_ZERO_BYTES_FREES
+  else if (bytes == 0) {
+    mspace_free(msp, oldmem);
+  }
+#endif /* REALLOC_ZERO_BYTES_FREES */
+  else {
+    size_t nb = request2size(bytes);
+    mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+    mstate m = (mstate)msp;
+#else /* FOOTERS */
+    mstate m = get_mstate_for(oldp);
+    if (!ok_magic(m)) {
+      USAGE_ERROR_ACTION(m, oldmem);
+      return 0;
+    }
+#endif /* FOOTERS */
+    if (!PREACTION(m)) {
+      mchunkptr newp = try_realloc_chunk(m, oldp, nb, 1);
+      POSTACTION(m);
+      if (newp != 0) {
+        check_inuse_chunk(m, newp);
+        mem = chunk2mem(newp);
+      }
+      else {
+        mem = mspace_malloc(m, bytes);
+        if (mem != 0) {
+          size_t oc = chunksize(oldp) - overhead_for(oldp);
+          memcpy(mem, oldmem, (oc < bytes)? oc : bytes);
+          mspace_free(m, oldmem);
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* mspace_realloc_in_place(mspace msp, void* oldmem, size_t bytes) {
+  void* mem = 0;
+  if (oldmem != 0) {
+    if (bytes >= MAX_REQUEST) {
+      MALLOC_FAILURE_ACTION;
+    }
+    else {
+      size_t nb = request2size(bytes);
+      mchunkptr oldp = mem2chunk(oldmem);
+#if ! FOOTERS
+      mstate m = (mstate)msp;
+#else /* FOOTERS */
+      mstate m = get_mstate_for(oldp);
+      (void)msp; /* placate people compiling -Wunused */
+      if (!ok_magic(m)) {
+        USAGE_ERROR_ACTION(m, oldmem);
+        return 0;
+      }
+#endif /* FOOTERS */
+      if (!PREACTION(m)) {
+        mchunkptr newp = try_realloc_chunk(m, oldp, nb, 0);
+        POSTACTION(m);
+        if (newp == oldp) {
+          check_inuse_chunk(m, newp);
+          mem = oldmem;
+        }
+      }
+    }
+  }
+  return mem;
+}
+
+void* mspace_memalign(mspace msp, size_t alignment, size_t bytes) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  if (alignment <= MALLOC_ALIGNMENT)
+    return mspace_malloc(msp, bytes);
+  return internal_memalign(ms, alignment, bytes);
+}
+
+void** mspace_independent_calloc(mspace msp, size_t n_elements,
+                                 size_t elem_size, void* chunks[]) {
+  size_t sz = elem_size; /* serves as 1-element array */
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return ialloc(ms, n_elements, &sz, 3, chunks);
+}
+
+void** mspace_independent_comalloc(mspace msp, size_t n_elements,
+                                   size_t sizes[], void* chunks[]) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+    return 0;
+  }
+  return ialloc(ms, n_elements, sizes, 0, chunks);
+}
+
+size_t mspace_bulk_free(mspace msp, void* array[], size_t nelem) {
+  return internal_bulk_free((mstate)msp, array, nelem);
+}
+
+#if MALLOC_INSPECT_ALL
+void mspace_inspect_all(mspace msp,
+                        void(*handler)(void *start,
+                                       void *end,
+                                       size_t used_bytes,
+                                       void* callback_arg),
+                        void* arg) {
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (!PREACTION(ms)) {
+      internal_inspect_all(ms, handler, arg);
+      POSTACTION(ms);
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+}
+#endif /* MALLOC_INSPECT_ALL */
+
+int mspace_trim(mspace msp, size_t pad) {
+  int result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (!PREACTION(ms)) {
+      result = sys_trim(ms, pad);
+      POSTACTION(ms);
+    }
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+#if !NO_MALLOC_STATS
+void mspace_malloc_stats(mspace msp) {
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    internal_malloc_stats(ms);
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+}
+#endif /* NO_MALLOC_STATS */
+
+size_t mspace_footprint(mspace msp) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    result = ms->footprint;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+size_t mspace_max_footprint(mspace msp) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    result = ms->max_footprint;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+size_t mspace_footprint_limit(mspace msp) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    size_t maf = ms->footprint_limit;
+    result = (maf == 0) ? MAX_SIZE_T : maf;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+size_t mspace_set_footprint_limit(mspace msp, size_t bytes) {
+  size_t result = 0;
+  mstate ms = (mstate)msp;
+  if (ok_magic(ms)) {
+    if (bytes == 0)
+      result = granularity_align(1); /* Use minimal size */
+    if (bytes == MAX_SIZE_T)
+      result = 0;                    /* disable */
+    else
+      result = granularity_align(bytes);
+    ms->footprint_limit = result;
+  }
+  else {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return result;
+}
+
+#if !NO_MALLINFO
+struct mallinfo mspace_mallinfo(mspace msp) {
+  mstate ms = (mstate)msp;
+  if (!ok_magic(ms)) {
+    USAGE_ERROR_ACTION(ms,ms);
+  }
+  return internal_mallinfo(ms);
+}
+#endif /* NO_MALLINFO */
+
+size_t mspace_usable_size(const void* mem) {
+  if (mem != 0) {
+    mchunkptr p = mem2chunk(mem);
+    if (is_inuse(p))
+      return chunksize(p) - overhead_for(p);
+  }
+  return 0;
+}
+
+int mspace_mallopt(int param_number, int value) {
+  return change_mparam(param_number, value);
+}
+
+#endif /* MSPACES */
+
+
+/* -------------------- Alternative MORECORE functions ------------------- */
+
+/*
+  Guidelines for creating a custom version of MORECORE:
+
+  * For best performance, MORECORE should allocate in multiples of pagesize.
+  * MORECORE may allocate more memory than requested. (Or even less,
+      but this will usually result in a malloc failure.)
+  * MORECORE must not allocate memory when given argument zero, but
+      instead return one past the end address of memory from previous
+      nonzero call.
+  * For best performance, consecutive calls to MORECORE with positive
+      arguments should return increasing addresses, indicating that
+      space has been contiguously extended.
+  * Even though consecutive calls to MORECORE need not return contiguous
+      addresses, it must be OK for malloc'ed chunks to span multiple
+      regions in those cases where they do happen to be contiguous.
+  * MORECORE need not handle negative arguments -- it may instead
+      just return MFAIL when given negative arguments.
+      Negative arguments are always multiples of pagesize. MORECORE
+      must not misinterpret negative args as large positive unsigned
+      args. You can suppress all such calls from even occurring by defining
+      MORECORE_CANNOT_TRIM,
+
+  As an example alternative MORECORE, here is a custom allocator
+  kindly contributed for pre-OSX macOS.  It uses virtually but not
+  necessarily physically contiguous non-paged memory (locked in,
+  present and won't get swapped out).  You can use it by uncommenting
+  this section, adding some #includes, and setting up the appropriate
+  defines above:
+
+      #define MORECORE osMoreCore
+
+  There is also a shutdown routine that should somehow be called for
+  cleanup upon program exit.
+
+  #define MAX_POOL_ENTRIES 100
+  #define MINIMUM_MORECORE_SIZE  (64 * 1024U)
+  static int next_os_pool;
+  void *our_os_pools[MAX_POOL_ENTRIES];
+
+  void *osMoreCore(int size)
+  {
+    void *ptr = 0;
+    static void *sbrk_top = 0;
+
+    if (size > 0)
+    {
+      if (size < MINIMUM_MORECORE_SIZE)
+         size = MINIMUM_MORECORE_SIZE;
+      if (CurrentExecutionLevel() == kTaskLevel)
+         ptr = PoolAllocateResident(size + RM_PAGE_SIZE, 0);
+      if (ptr == 0)
+      {
+        return (void *) MFAIL;
+      }
+      // save ptrs so they can be freed during cleanup
+      our_os_pools[next_os_pool] = ptr;
+      next_os_pool++;
+      ptr = (void *) ((((size_t) ptr) + RM_PAGE_MASK) & ~RM_PAGE_MASK);
+      sbrk_top = (char *) ptr + size;
+      return ptr;
+    }
+    else if (size < 0)
+    {
+      // we don't currently support shrink behavior
+      return (void *) MFAIL;
+    }
+    else
+    {
+      return sbrk_top;
+    }
+  }
+
+  // cleanup any allocated memory pools
+  // called as last thing before shutting down driver
+
+  void osCleanupMem(void)
+  {
+    void **ptr;
+
+    for (ptr = our_os_pools; ptr < &our_os_pools[MAX_POOL_ENTRIES]; ptr++)
+      if (*ptr)
+      {
+         PoolDeallocate(*ptr);
+         *ptr = 0;
+      }
+  }
+
+*/
+
+
+/* -----------------------------------------------------------------------
+History:
+    v2.8.6 Wed Aug 29 06:57:58 2012  Doug Lea
+      * fix bad comparison in dlposix_memalign
+      * don't reuse adjusted asize in sys_alloc
+      * add LOCK_AT_FORK -- thanks to Kirill Artamonov for the suggestion
+      * reduce compiler warnings -- thanks to all who reported/suggested these
+
+    v2.8.5 Sun May 22 10:26:02 2011  Doug Lea  (dl at gee)
+      * Always perform unlink checks unless INSECURE
+      * Add posix_memalign.
+      * Improve realloc to expand in more cases; expose realloc_in_place.
+        Thanks to Peter Buhr for the suggestion.
+      * Add footprint_limit, inspect_all, bulk_free. Thanks
+        to Barry Hayes and others for the suggestions.
+      * Internal refactorings to avoid calls while holding locks
+      * Use non-reentrant locks by default. Thanks to Roland McGrath
+        for the suggestion.
+      * Small fixes to mspace_destroy, reset_on_error.
+      * Various configuration extensions/changes. Thanks
+         to all who contributed these.
+
+    V2.8.4a Thu Apr 28 14:39:43 2011 (dl at gee.cs.oswego.edu)
+      * Update Creative Commons URL
+
+    V2.8.4 Wed May 27 09:56:23 2009  Doug Lea  (dl at gee)
+      * Use zeros instead of prev foot for is_mmapped
+      * Add mspace_track_large_chunks; thanks to Jean Brouwers
+      * Fix set_inuse in internal_realloc; thanks to Jean Brouwers
+      * Fix insufficient sys_alloc padding when using 16byte alignment
+      * Fix bad error check in mspace_footprint
+      * Adaptations for ptmalloc; thanks to Wolfram Gloger.
+      * Reentrant spin locks; thanks to Earl Chew and others
+      * Win32 improvements; thanks to Niall Douglas and Earl Chew
+      * Add NO_SEGMENT_TRAVERSAL and MAX_RELEASE_CHECK_RATE options
+      * Extension hook in malloc_state
+      * Various small adjustments to reduce warnings on some compilers
+      * Various configuration extensions/changes for more platforms. Thanks
+         to all who contributed these.
+
+    V2.8.3 Thu Sep 22 11:16:32 2005  Doug Lea  (dl at gee)
+      * Add max_footprint functions
+      * Ensure all appropriate literals are size_t
+      * Fix conditional compilation problem for some #define settings
+      * Avoid concatenating segments with the one provided
+        in create_mspace_with_base
+      * Rename some variables to avoid compiler shadowing warnings
+      * Use explicit lock initialization.
+      * Better handling of sbrk interference.
+      * Simplify and fix segment insertion, trimming and mspace_destroy
+      * Reinstate REALLOC_ZERO_BYTES_FREES option from 2.7.x
+      * Thanks especially to Dennis Flanagan for help on these.
+
+    V2.8.2 Sun Jun 12 16:01:10 2005  Doug Lea  (dl at gee)
+      * Fix memalign brace error.
+
+    V2.8.1 Wed Jun  8 16:11:46 2005  Doug Lea  (dl at gee)
+      * Fix improper #endif nesting in C++
+      * Add explicit casts needed for C++
+
+    V2.8.0 Mon May 30 14:09:02 2005  Doug Lea  (dl at gee)
+      * Use trees for large bins
+      * Support mspaces
+      * Use segments to unify sbrk-based and mmap-based system allocation,
+        removing need for emulation on most platforms without sbrk.
+      * Default safety checks
+      * Optional footer checks. Thanks to William Robertson for the idea.
+      * Internal code refactoring
+      * Incorporate suggestions and platform-specific changes.
+        Thanks to Dennis Flanagan, Colin Plumb, Niall Douglas,
+        Aaron Bachmann,  Emery Berger, and others.
+      * Speed up non-fastbin processing enough to remove fastbins.
+      * Remove useless cfree() to avoid conflicts with other apps.
+      * Remove internal memcpy, memset. Compilers handle builtins better.
+      * Remove some options that no one ever used and rename others.
+
+    V2.7.2 Sat Aug 17 09:07:30 2002  Doug Lea  (dl at gee)
+      * Fix malloc_state bitmap array misdeclaration
+
+    V2.7.1 Thu Jul 25 10:58:03 2002  Doug Lea  (dl at gee)
+      * Allow tuning of FIRST_SORTED_BIN_SIZE
+      * Use PTR_UINT as type for all ptr->int casts. Thanks to John Belmonte.
+      * Better detection and support for non-contiguousness of MORECORE.
+        Thanks to Andreas Mueller, Conal Walsh, and Wolfram Gloger
+      * Bypass most of malloc if no frees. Thanks To Emery Berger.
+      * Fix freeing of old top non-contiguous chunk im sysmalloc.
+      * Raised default trim and map thresholds to 256K.
+      * Fix mmap-related #defines. Thanks to Lubos Lunak.
+      * Fix copy macros; added LACKS_FCNTL_H. Thanks to Neal Walfield.
+      * Branch-free bin calculation
+      * Default trim and mmap thresholds now 256K.
+
+    V2.7.0 Sun Mar 11 14:14:06 2001  Doug Lea  (dl at gee)
+      * Introduce independent_comalloc and independent_calloc.
+        Thanks to Michael Pachos for motivation and help.
+      * Make optional .h file available
+      * Allow > 2GB requests on 32bit systems.
+      * new WIN32 sbrk, mmap, munmap, lock code from <Walter@GeNeSys-e.de>.
+        Thanks also to Andreas Mueller <a.mueller at paradatec.de>,
+        and Anonymous.
+      * Allow override of MALLOC_ALIGNMENT (Thanks to Ruud Waij for
+        helping test this.)
+      * memalign: check alignment arg
+      * realloc: don't try to shift chunks backwards, since this
+        leads to  more fragmentation in some programs and doesn't
+        seem to help in any others.
+      * Collect all cases in malloc requiring system memory into sysmalloc
+      * Use mmap as backup to sbrk
+      * Place all internal state in malloc_state
+      * Introduce fastbins (although similar to 2.5.1)
+      * Many minor tunings and cosmetic improvements
+      * Introduce USE_PUBLIC_MALLOC_WRAPPERS, USE_MALLOC_LOCK
+      * Introduce MALLOC_FAILURE_ACTION, MORECORE_CONTIGUOUS
+        Thanks to Tony E. Bennett <tbennett@nvidia.com> and others.
+      * Include errno.h to support default failure action.
+
+    V2.6.6 Sun Dec  5 07:42:19 1999  Doug Lea  (dl at gee)
+      * return null for negative arguments
+      * Added Several WIN32 cleanups from Martin C. Fong <mcfong at yahoo.com>
+         * Add 'LACKS_SYS_PARAM_H' for those systems without 'sys/param.h'
+          (e.g. WIN32 platforms)
+         * Cleanup header file inclusion for WIN32 platforms
+         * Cleanup code to avoid Microsoft Visual C++ compiler complaints
+         * Add 'USE_DL_PREFIX' to quickly allow co-existence with existing
+           memory allocation routines
+         * Set 'malloc_getpagesize' for WIN32 platforms (needs more work)
+         * Use 'assert' rather than 'ASSERT' in WIN32 code to conform to
+           usage of 'assert' in non-WIN32 code
+         * Improve WIN32 'sbrk()' emulation's 'findRegion()' routine to
+           avoid infinite loop
+      * Always call 'fREe()' rather than 'free()'
+
+    V2.6.5 Wed Jun 17 15:57:31 1998  Doug Lea  (dl at gee)
+      * Fixed ordering problem with boundary-stamping
+
+    V2.6.3 Sun May 19 08:17:58 1996  Doug Lea  (dl at gee)
+      * Added pvalloc, as recommended by H.J. Liu
+      * Added 64bit pointer support mainly from Wolfram Gloger
+      * Added anonymously donated WIN32 sbrk emulation
+      * Malloc, calloc, getpagesize: add optimizations from Raymond Nijssen
+      * malloc_extend_top: fix mask error that caused wastage after
+        foreign sbrks
+      * Add linux mremap support code from HJ Liu
+
+    V2.6.2 Tue Dec  5 06:52:55 1995  Doug Lea  (dl at gee)
+      * Integrated most documentation with the code.
+      * Add support for mmap, with help from
+        Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
+      * Use last_remainder in more cases.
+      * Pack bins using idea from  colin@nyx10.cs.du.edu
+      * Use ordered bins instead of best-fit threshhold
+      * Eliminate block-local decls to simplify tracing and debugging.
+      * Support another case of realloc via move into top
+      * Fix error occuring when initial sbrk_base not word-aligned.
+      * Rely on page size for units instead of SBRK_UNIT to
+        avoid surprises about sbrk alignment conventions.
+      * Add mallinfo, mallopt. Thanks to Raymond Nijssen
+        (raymond@es.ele.tue.nl) for the suggestion.
+      * Add `pad' argument to malloc_trim and top_pad mallopt parameter.
+      * More precautions for cases where other routines call sbrk,
+        courtesy of Wolfram Gloger (Gloger@lrz.uni-muenchen.de).
+      * Added macros etc., allowing use in linux libc from
+        H.J. Lu (hjl@gnu.ai.mit.edu)
+      * Inverted this history list
+
+    V2.6.1 Sat Dec  2 14:10:57 1995  Doug Lea  (dl at gee)
+      * Re-tuned and fixed to behave more nicely with V2.6.0 changes.
+      * Removed all preallocation code since under current scheme
+        the work required to undo bad preallocations exceeds
+        the work saved in good cases for most test programs.
+      * No longer use return list or unconsolidated bins since
+        no scheme using them consistently outperforms those that don't
+        given above changes.
+      * Use best fit for very large chunks to prevent some worst-cases.
+      * Added some support for debugging
+
+    V2.6.0 Sat Nov  4 07:05:23 1995  Doug Lea  (dl at gee)
+      * Removed footers when chunks are in use. Thanks to
+        Paul Wilson (wilson@cs.texas.edu) for the suggestion.
+
+    V2.5.4 Wed Nov  1 07:54:51 1995  Doug Lea  (dl at gee)
+      * Added malloc_trim, with help from Wolfram Gloger
+        (wmglo@Dent.MED.Uni-Muenchen.DE).
+
+    V2.5.3 Tue Apr 26 10:16:01 1994  Doug Lea  (dl at g)
+
+    V2.5.2 Tue Apr  5 16:20:40 1994  Doug Lea  (dl at g)
+      * realloc: try to expand in both directions
+      * malloc: swap order of clean-bin strategy;
+      * realloc: only conditionally expand backwards
+      * Try not to scavenge used bins
+      * Use bin counts as a guide to preallocation
+      * Occasionally bin return list chunks in first scan
+      * Add a few optimizations from colin@nyx10.cs.du.edu
+
+    V2.5.1 Sat Aug 14 15:40:43 1993  Doug Lea  (dl at g)
+      * faster bin computation & slightly different binning
+      * merged all consolidations to one part of malloc proper
+         (eliminating old malloc_find_space & malloc_clean_bin)
+      * Scan 2 returns chunks (not just 1)
+      * Propagate failure in realloc if malloc returns 0
+      * Add stuff to allow compilation on non-ANSI compilers
+          from kpv@research.att.com
+
+    V2.5 Sat Aug  7 07:41:59 1993  Doug Lea  (dl at g.oswego.edu)
+      * removed potential for odd address access in prev_chunk
+      * removed dependency on getpagesize.h
+      * misc cosmetics and a bit more internal documentation
+      * anticosmetics: mangled names in macros to evade debugger strangeness
+      * tested on sparc, hp-700, dec-mips, rs6000
+          with gcc & native cc (hp, dec only) allowing
+          Detlefs & Zorn comparison study (in SIGPLAN Notices.)
+
+    Trial version Fri Aug 28 13:14:29 1992  Doug Lea  (dl at g.oswego.edu)
+      * Based loosely on libg++-1.2X malloc. (It retains some of the overall
+         structure of old version,  but most details differ.)
+
+*/
+
+
+
+void *malloc(size_t bytes)
+{
+  return dlmalloc(bytes);
+}
+
+void free(void *ptr)
+{
+  return dlfree(ptr);
+}
+
+void* realloc(void* oldmem, size_t bytes)
+{
+  return dlrealloc(oldmem, bytes);
+}
+
+
+void* calloc(size_t nelem, size_t bytes)
+{
+  return dlcalloc(nelem, bytes);
+}
+
+/*
+ * Reentrant memory management functions needed by Newlib.
+ */
+
+void *_malloc_r (struct _reent *r, size_t size)
+{
+    return malloc (size);
+}
+
+
+void _free_r (struct _reent *r, void *ptr)
+{
+    free (ptr);
+}
+
+
+void *_calloc_r (struct _reent *r, size_t nelem, size_t elsize)
+{
+    return calloc (nelem, elsize);
+}
+
+
+void *_realloc_r (struct _reent *r, void *ptr, size_t size)
+{
+    return realloc (ptr, size);
+}
+
+
+void *__mempcpy(void *dst, void *src, size_t sz)
+{
+  return memcpy(dst, src, sz);
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mknod.c third_party/newlib-3.2.0/newlib/libc/sys/arm/mknod.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mknod.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/mknod.c	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,36 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/stat.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+int mknod (const char *path, mode_t mode, dev_t dev)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+
+/*
+ *
+ */
+int mknod2(char *path, uint32_t flags, struct stat *stat)
+{
+    int sc;
+    
+    sc = _swi_mknod(path, flags, stat);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mntent.c third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mntent.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.c	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,56 @@
+#include <stdio.h>
+#include <mntent.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+FILE *setmntent(const char *filename, const char *type)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+struct mntent *getmntent(FILE *filep)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+int addmntent(FILE *filep, const struct mntent *mnt)
+{
+    errno = ENOSYS;
+    return 0;
+}
+
+
+/*
+ *
+ */
+int endmntent(FILE *filep)
+{
+    errno = ENOSYS;
+    return 0;
+}
+
+
+/*
+ *
+ */
+char *hasmntopt(const struct mntent *mnt, const char *opt)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mntent.h third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mntent.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/mntent.h	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,65 @@
+#ifndef	_MNTENT_H
+#define	_MNTENT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+
+struct mntent
+{
+	char    *mnt_fsname;    /* name of mounted file system */
+	char    *mnt_dir;      /* file system path prefix */
+	char    *mnt_type;      /* mount type (see mntent.h) */
+	char    *mnt_opts;      /* mount options (see mntent.h) */
+	int     mnt_freq;      /* dump frequency in days */
+	int     mnt_passno;     /* pass number on parallel fsck */
+};
+
+
+
+
+#define MNT_CHECKLIST  "/etc/fstab" 
+#define	MNTTAB		"/etc/mnttab"
+#define	VFSTAB		"/etc/vfstab"
+#define	MNTMAXSTR	128
+
+#define MNTTYPE_IGNORE	"ignore"	/* Ignore this entry.  */
+#define MNTTYPE_NFS	"nfs"		/* Network file system.  */
+#define MNTTYPE_SWAP	"swap"		/* Swap device.  */
+
+
+/* Generic mount options.  */
+#define MNTOPT_DEFAULTS	"defaults"	/* Use all default options.  */
+#define MNTOPT_RO	"ro"		/* Read only.  */
+#define MNTOPT_RW	"rw"		/* Read/write.  */
+#define MNTOPT_SUID	"suid"		/* Set uid allowed.  */
+#define MNTOPT_NOSUID	"nosuid"	/* No set uid allowed.  */
+#define MNTOPT_NOAUTO	"noauto"	/* Do not auto mount.  */
+
+
+
+
+
+
+
+
+FILE *setmntent(const char *filename, const char *type);
+struct mntent *getmntent(FILE *filep);
+int addmntent(FILE *filep, const struct mntent *mnt);
+int endmntent(FILE *filep);
+char *hasmntopt(const struct mntent *mnt, const char *opt);
+struct mntent *getmntent_r (FILE *stream, struct mntent *result, char *buffer, int bufsize);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mount.c third_party/newlib-3.2.0/newlib/libc/sys/arm/mount.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/mount.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/mount.c	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,90 @@
+#include <_ansi.h>
+#include <errno.h>
+#include <sys/mount.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int mount(char *path, uint32_t flags, struct stat *stat)
+{
+    int sc;
+    
+    sc = _swi_mount(path, flags, stat);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int unmount(int fd, bool force)
+{
+    int sc;
+    
+    sc = _swi_unmount(fd, force);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int movemount(char *new_path, char *old_path)
+{
+    int sc;
+    
+    sc = _swi_movemount(new_path, old_path);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int pivotroot(char *new_root, char *old_root)
+{
+    int sc;
+    
+    sc = _swi_pivotroot(new_root, old_root);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+	
+	return sc;
+}
+
+/*
+ *
+ */
+int getfsstat (struct statfs *buf, int bufsize, int flags)
+{
+    return 0;
+}
+
+/*
+ *
+ */
+int getmntinfo (struct statfs **mntbufp, int flags)
+{
+    return 0;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/msg.c third_party/newlib-3.2.0/newlib/libc/sys/arm/msg.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/msg.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/msg.c	2022-06-30 11:16:52.472002684 +0100
@@ -0,0 +1,92 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+
+
+/*
+ *
+ */
+int receivemsg(int fd, int *ino, void *buf, size_t buf_sz)
+{
+    int sc;
+
+    sc = _swi_receivemsg(fd, ino, buf, buf_sz);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int replymsg(int fd, int ino, int status)
+{
+    int sc;
+
+    sc = _swi_replymsg(fd, ino, status);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int readmsg(int fd, int ino, void *buf, size_t buf_sz)
+{
+    int sc;
+
+    sc = _swi_readmsg(fd, ino, buf, buf_sz);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int writemsg(int fd, int ino, void *buf, size_t buf_sz)
+{
+    int sc;
+
+    sc = _swi_writemsg(fd, ino, buf, buf_sz);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+/*
+ *
+ */
+int seekmsg(int fd, int ino, off_t offset)
+{
+    int sc;
+
+    sc = _swi_seekmsg(fd, ino, offset);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h third_party/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/netinet/in.h	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,59 @@
+/* 
+ */
+
+
+
+#ifndef _NETINET_IN_H_
+#define _NETINET_IN_H_
+
+#include <inttypes.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <sys/cdefs.h>
+
+
+
+typedef uint16_t in_port_t;
+typedef uint32_t in_addr_t;
+
+
+
+struct in_addr
+{
+	in_addr_t s_addr;
+};
+
+
+struct sockaddr_in
+{
+	sa_family_t sin_family;
+	in_port_t sin_port;
+	struct in_addr sin_addr;
+};
+
+
+
+
+#define IPPROTO_IP			1
+#define IPPROTO_ICMP		2
+#define IPPROTO_RAW			3
+#define IPPROTO_TCP			4
+#define IPPROTO_UDP			5
+
+
+
+#define INADDR_ANY			1
+#define INADDR_BROADCAST	2
+
+
+#define INET_ADDRSTRLEN		16
+
+
+
+
+
+
+
+
+#endif /* !_NETINET_IN_ */
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/open.c third_party/newlib-3.2.0/newlib/libc/sys/arm/open.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/open.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/open.c	2022-06-29 14:50:02.769942261 +0100
@@ -0,0 +1,38 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <fcntl.h>
+#include <sys/stat.h>
+#include <stdarg.h>
+
+
+/*
+ *
+ */
+int open (const char *file, int flags, ...)
+{
+    int mode;
+    int fd;
+
+    va_list ap;
+
+    va_start(ap, flags);
+
+    if (flags & O_CREAT)
+        mode = va_arg(ap, int);
+    else
+        mode = S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH;
+
+    va_end(ap);
+
+    fd = _swi_open (file, flags, mode);
+
+    if (fd < 0) {
+        errno = -fd;
+        return -1;
+    }
+
+    return fd;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/opendir.c third_party/newlib-3.2.0/newlib/libc/sys/arm/opendir.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/opendir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/opendir.c	2022-06-30 11:11:45.126306361 +0100
@@ -0,0 +1,54 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+DIR *opendir (const char *path)
+{
+    DIR *dir;
+    void *buf;
+    int fd;
+
+    if ((dir = malloc (sizeof (DIR))) == NULL) {
+        return NULL;
+    }
+    
+    if ((buf = malloc (DIRENTS_BUF_SZ)) == NULL) {
+        free (dir);
+        return NULL;
+    }	
+      
+    fd = _swi_opendir (path);
+
+    if (fd < 0) {
+        free (buf);
+        free (dir);
+        errno = -fd;
+        return NULL;
+    }
+		
+    dir->fd = fd;
+    dir->buf = buf;
+    dir->buf_offset = 0; 
+    dir->buf_sz = 0;
+    dir->eof = false;
+    return dir;
+}
+
+
+/*
+ *
+ */
+int dirfd(DIR *dirp)
+{
+    return dirp->fd;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c third_party/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/pathconf.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,21 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+
+
+long fpathconf(int filedes, int name)
+{
+    return -1;
+}
+
+
+long pathconf(const char *path, int name)
+{
+    return -1;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/pipe.c third_party/newlib-3.2.0/newlib/libc/sys/arm/pipe.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/pipe.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/pipe.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,24 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ * pipe()
+ */ 
+int pipe (int fdp[2])
+{
+    int sc;
+
+    sc = _swi_pipe(fdp);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/popen.c third_party/newlib-3.2.0/newlib/libc/sys/arm/popen.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/popen.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/popen.c	2022-06-30 11:12:02.970680001 +0100
@@ -0,0 +1,28 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <stdio.h>
+
+
+/*
+ *
+ */
+FILE *popen (const char *command, const char *mode)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+int pclose (FILE *stream)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/pwd.c third_party/newlib-3.2.0/newlib/libc/sys/arm/pwd.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/pwd.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/pwd.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,128 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <pwd.h>
+
+
+/*
+ *
+ */
+struct passwd *getpwnam(const char *name)
+{
+    return NULL;
+}
+
+
+/*
+ *
+ */
+
+char *crypt(const char *key, const char *salt)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+char *getlogin(void)
+{
+    return NULL;
+}
+
+
+/*
+ *
+ */
+struct passwd *getpwuid(uid_t uid)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+struct group *getgrgid(gid_t gid)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+struct group *getgrnam(const char *name)
+{
+    errno = ENOSYS;
+    return NULL;
+}
+
+
+/*
+ *
+ */
+struct passwd *getpwent(void)
+{
+    return NULL;
+}
+
+
+/*
+ *
+ */
+void setpwent(void)
+{
+}
+
+
+/*
+ *
+ */
+void endpwent(void)
+{
+}
+
+
+/*
+ *
+ */
+void endgrent(void)
+{
+}
+
+
+/*
+ *
+ */
+struct group *getgrent(void)
+{
+    return NULL;
+}
+
+
+/*
+ *
+ */
+void setgrent(void)
+{
+}
+
+
+/*
+ *
+ */
+int setgroups (int ngroups, const gid_t *grouplist)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/read.c third_party/newlib-3.2.0/newlib/libc/sys/arm/read.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/read.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/read.c	2022-06-30 11:12:29.111214375 +0100
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+ssize_t read (int fd, void *buf, size_t nbyte)
+{
+    ssize_t sz;
+
+    sz = _swi_read(fd, buf, nbyte);
+
+    if (sz < 0) {
+        errno = -sz;
+        return -1;
+    }
+
+    return sz;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/readdir.c third_party/newlib-3.2.0/newlib/libc/sys/arm/readdir.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/readdir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/readdir.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,51 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+struct dirent *readdir(DIR *dir)
+{
+    struct dirent *dent;
+    int sz;
+    
+    if (dir == NULL) {
+        errno = EINVAL;
+        return NULL;
+    }
+
+    if (dir->eof == true) {
+        return NULL;
+    }
+    
+    // Check if any more dirents in buffer, else we read in new dirents
+    
+    if (dir->buf_offset >= dir->buf_sz)
+    {   
+        sz = _swi_readdir (dir->fd, dir->buf, DIRENTS_BUF_SZ);
+
+        if (sz < 0) {
+            errno = -sz;
+            dir->buf_sz = 0;
+            dir->eof = true;
+            return NULL;
+        } else if (sz == 0) {
+            dir->buf_sz = 0;
+            dir->eof = true;
+            return NULL;
+        } if (sz > DIRENTS_BUF_SZ) {
+            exit(-1);
+        }
+
+        dir->buf_sz = sz; 
+        dir->buf_offset = 0;
+    }
+        
+    dent = (struct dirent *)((uint8_t *)dir->buf + dir->buf_offset);
+    dir->buf_offset += dent->d_reclen;
+    return dent;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/readme.txt third_party/newlib-3.2.0/newlib/libc/sys/arm/readme.txt
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/readme.txt	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/readme.txt	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,9 @@
+
+When adding files to this directory, add the name
+of the object file to makefile.am then run the following
+commands in this directory.
+
+
+aclocal -I ../../..
+autoconf
+automake --cygnus --add-missing Makefile
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/rename.c third_party/newlib-3.2.0/newlib/libc/sys/arm/rename.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/rename.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/rename.c	2022-06-30 11:12:43.767507707 +0100
@@ -0,0 +1,26 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/*
+ * open();
+ *
+ * Needs fixing, to use the vararg 'mode' depending on flags.
+ */
+
+int rename (const char *oldname, const char *newname)
+{
+    int sc;
+
+    sc = _swi_rename(oldname, newname);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/resource.c third_party/newlib-3.2.0/newlib/libc/sys/arm/resource.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/resource.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/resource.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,33 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <sys/resource.h>
+
+
+
+
+/*
+ *
+ */
+
+int getrlimit(int resource, struct rlimit *rlp)
+{
+	  errno = ENOSYS;
+	  return -1;
+}
+
+
+
+
+/*
+ *
+ */
+
+int setrlimit(int resource, const struct rlimit *rlp)
+{
+	  errno = ENOSYS;
+	  return -1;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c third_party/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/rewinddir.c	2022-06-30 11:12:52.983690011 +0100
@@ -0,0 +1,31 @@
+#include <sys/types.h>
+#include <dirent.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+
+void rewinddir (DIR *dir)
+{    	
+    int sc;
+    
+    if (dir == NULL)
+    {
+        errno = EINVAL;
+        return;
+    }
+
+    sc = _swi_rewinddir(dir->fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return;
+    }
+
+    dir->buf_offset = 0;
+    dir->buf_sz = 0;
+    dir->eof = false;    
+    return;
+}
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/select.c third_party/newlib-3.2.0/newlib/libc/sys/arm/select.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/select.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/select.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,48 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+#include <sys/signal.h>
+
+
+/*
+ *
+ */
+int poll (struct pollfd *pfds, nfds_t nfds, int timeout)
+{
+    int sc;
+
+    sc = _swi_poll (pfds, nfds, timeout);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }  
+    return sc;
+}
+
+
+/*
+ *
+ */
+int pselect(int nfds, fd_set *readfds,
+       fd_set *writefds, fd_set *errorfds,
+       const struct timespec *timeout,
+       const sigset_t *sigmask)
+{
+	  errno = EINTR;
+	  return -1;
+}
+
+       
+/* 
+ *
+ */    
+int select(int nfds, fd_set *readfds,
+       fd_set *writefds, fd_set *errorfds,
+       struct timeval *timeout)
+{
+	  errno = EINTR;
+	  return -1;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/siglist.c third_party/newlib-3.2.0/newlib/libc/sys/arm/siglist.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/siglist.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/siglist.c	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,114 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <signal.h>
+
+
+/*
+ *
+ */ 
+const char * const sys_siglist[NSIG] =
+{
+	/*  0           */ "Unknown Signal",
+	/*  1 SIGHUP    */ "Hangup",
+	/*  2 SIGINT    */ "Interrupt",
+	/*  3 SIGQUIT   */ "Quit",
+	/*  4 SIGILL    */ "Illegal instruction",
+	/*  5 SIGTRAP   */ "BPT trace/trap",
+	/*  6 SIGABORT  */ "ABORT instruction",
+	/*  7 SIGEMT    */ "EMT instruction",
+	/*  8 SIGFPE    */ "Floating point exception",
+	/*  9 SIGKILL   */ "Killed",
+	/* 10 SIGBUS    */ "Bus error",
+	/* 11 SIGSEGV   */ "Segmentation fault",
+	/* 12 SIGSYS    */ "Bad system call",
+	/* 13 SIGPIPE   */ "Broken pipe",
+	/* 14 SIGALRM   */ "Alarm clock",
+	/* 15 SIGTERM   */ "Terminated",
+	/* 16 SIGURG    */ "Urgent IO condition",
+	/* 17 SIGSTOP   */ "Stopped (signal)",
+	/* 18 SIGTSTP   */ "Stopped",
+	/* 19 SIGCONT   */ "Continue",
+	/* 20 SIGCHLD   */ "Child death or stop",
+	/* 21 SIGTTIN   */ "Stopped (tty input)",
+	/* 22 SIGTTOU   */ "Stopped (tty output)",
+	/* 23 SIGIO     */ "I/O ready",
+	/* 24 SIGXCPU   */ "CPU limit",
+	/* 25 SIGXFSZ   */ "File limit",
+	/* 26 SIGVTALRM */ "Alarm (virtual)",
+	/* 27 SIGPROF   */ "Alarm (profile)",
+	/* 28 SIGWINCH  */ "Window changed",
+	/* 29 SIGLOST   */ "Record lock",
+	/* 30 SIGUSR1   */ "User signal 1",
+	/* 31 SIGUSR2   */ "User signal 2"
+};
+
+
+/*
+ *
+ */
+const char * const sys_signame[NSIG] =
+{
+	/*  0           */ "signal 0",
+	/*  1 SIGHUP    */ "hup",
+	/*  2 SIGINT    */ "int",
+	/*  3 SIGQUIT   */ "quit",
+	/*  4 SIGILL    */ "ill",
+	/*  5 SIGTRAP   */ "trap",
+	/*  6 SIGABORT  */ "abort",
+	/*  7 SIGEMT    */ "emt",
+	/*  8 SIGFPE    */ "fpe",
+	/*  9 SIGKILL   */ "kill",
+	/* 10 SIGBUS    */ "bus",
+	/* 11 SIGSEGV   */ "segv",
+	/* 12 SIGSYS    */ "sys",
+	/* 13 SIGPIPE   */ "pipe",
+	/* 14 SIGALRM   */ "alrm",
+	/* 15 SIGTERM   */ "term",
+	/* 16 SIGURG    */ "urg",
+	/* 17 SIGSTOP   */ "stop",
+	/* 18 SIGTSTP   */ "tstp",
+	/* 19 SIGCONT   */ "cont",
+	/* 20 SIGCHLD   */ "chld",
+	/* 21 SIGTTIN   */ "ttin",
+	/* 22 SIGTTOU   */ "ttou",
+	/* 23 SIGIO     */ "io",
+	/* 24 SIGXCPU   */ "xcpu",
+	/* 25 SIGXFSZ   */ "xfsz",
+	/* 26 SIGVTALRM */ "vtalrm",
+	/* 27 SIGPROF   */ "prof",
+	/* 28 SIGWINCH  */ "winch",
+	/* 29 SIGLOST   */ "lost",
+	/* 30 SIGUSR1   */ "usr1",
+	/* 31 SIGUSR2   */ "usr2"
+};
+
+
+/*
+ * 
+ */
+char *strsignal (int sig)
+{
+	if (sig > 0 && sig <NSIG)
+		return (char *) sys_siglist[sig];
+	else
+		return "Unknown signal";
+}
+
+
+/*
+ *
+ */
+void psignal (int sig, const char *s)
+{
+	const char *sig_str;
+	
+	if (sig > 0 && sig < NSIG)
+		sig_str = sys_siglist[sig];
+	else
+		sig_str = "Unknown signal";
+
+	printf ("%s: %s\n", s, sig_str);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/signal.c third_party/newlib-3.2.0/newlib/libc/sys/arm/signal.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/signal.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/signal.c	2022-06-30 11:14:10.169159268 +0100
@@ -0,0 +1,131 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <signal.h>
+#include <sys/signal.h>
+#include <unistd.h>
+
+
+/*
+ *
+ */
+_sig_func_ptr signal (int sig, _sig_func_ptr handler)
+{
+    struct sigaction act;
+
+    act.sa_flags = SA_RESETHAND;
+    act.sa_mask = 0;
+    act.sa_handler = handler;
+	
+    sigaction (sig, &act, NULL);
+}
+
+
+/*
+ *
+ */
+int kill (int pid, int sig)
+{
+    int sc;
+
+    sc = _swi_kill(pid, sig);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigaction (int sig, const struct sigaction *act, struct sigaction *oact)
+{
+    int sc;
+
+    sc = _swi_sigaction(sig, act, oact);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int raise (int sig)
+{
+    int sc;
+
+    sc = _swi_kill(getpid(), sig);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigprocmask (int how, const sigset_t *set, sigset_t *oset)
+{
+    int sc;
+
+    sc = _swi_sigprocmask(how, set, oset);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigsuspend (const sigset_t *sigmask)
+{
+    int sc;
+
+    sc = _swi_sigsuspend(sigmask);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/*
+ *
+ */
+int sigpending (sigset_t *set)
+{
+    int sc;
+
+    sc = _swi_sigpending(set);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s third_party/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sigtramp.s	2022-06-29 14:50:02.773942350 +0100
@@ -0,0 +1,66 @@
+.global __kielder_sigtramp
+.equ SF_SIGNUM,     0
+.equ SF_SIGINFO,    4
+.equ SF_UCONTEXT,   8
+.equ SF_SIGHANDLER, 12
+
+
+
+
+.text
+.align 16
+
+
+
+
+/ ****************************************************************************
+/ __kielder_sigtramp:
+/
+/ 
+/ Kernel passes control to __sigtramp to begin signal handling.
+/ A sigframe is placed on the stack by the kernel, stack pointer points to
+/ the sigframe structure.
+
+
+
+__kielder_sigtramp:
+	movl SF_SIGINFO(%esp), %eax
+	cmpl $0x00000000, %eax
+	jne Lcall_siginfohandler
+
+
+Lcall_sighandler:
+	movl SF_SIGNUM(%esp), %eax
+	movl SF_SIGHANDLER(%esp), %edx
+	
+	push %eax
+	call *%edx
+	
+	add $4, %esp
+	movl %esp, %ebx
+	movl $0xffffffff, %eax
+	int $0x30
+	
+	
+Lcall_siginfohandler:
+	movl SF_UCONTEXT(%esp), %eax
+	movl SF_SIGINFO(%esp), %ebx
+	movl SF_SIGNUM(%esp), %ecx
+	movl SF_SIGHANDLER(%esp), %edx
+		
+	push %eax
+	push %ebx
+	push %ecx
+	
+	call *%edx
+
+	add $4, %esp
+	movl %esp, %ebx
+	movl $0xffffffff, %eax
+	int $0x30
+
+
+
+
+	
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sleep.c third_party/newlib-3.2.0/newlib/libc/sys/arm/sleep.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sleep.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sleep.c	2022-06-30 11:14:31.181543782 +0100
@@ -0,0 +1,51 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/* @brief Sleep for a number of seconds
+ *
+ */
+unsigned int sleep (unsigned int seconds)
+{
+    int sc;
+
+    sc = _swi_sleep(seconds);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return 0;
+}
+
+
+/*
+ *
+ */
+int nanosleep (const struct timespec *rqtp, struct timespec *rmtp)
+{
+    int rc;
+
+    if (rqtp->tv_nsec < 1000000000) {
+        // TODO: call nanosleep syscall
+    
+        if (rmtp != NULL) {
+            rmtp->tv_nsec = 0;
+        }
+
+        rc = 0;
+    }
+    else
+    {
+        errno = EINVAL;
+        rc = -1;
+    }
+
+    return rc;	
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/stat.c third_party/newlib-3.2.0/newlib/libc/sys/arm/stat.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/stat.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/stat.c	2022-06-30 11:14:44.177778742 +0100
@@ -0,0 +1,77 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/mount.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int fstat(int fd, struct stat *buf)
+{
+    int sc;
+    
+    sc = _swi_fstat(fd, buf);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int stat (const char *path, struct stat *buf)
+{
+    int sc;
+
+    sc = _swi_stat(path, buf);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int lstat (const char *pathname, struct stat *st)
+{
+    return stat(pathname, st);
+}
+
+
+/*
+ *
+ */
+int statfs(const char *path, struct statfs *buf)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+/*
+ *
+ */
+int fstatfs(int fd, struct statfs *buf)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c third_party/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/statvfs.c	2022-06-30 12:15:19.923502304 +0100
@@ -0,0 +1,44 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/types.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+int fstatvfs (int fd, struct statvfs *st)
+{
+  errno = ENOSYS;
+	return -1;
+}
+
+
+/*
+ *
+ */
+int statvfs (const char *pathname, struct statvfs *st)
+{
+	int fd;
+	
+	
+	if ((fd = open (pathname, O_RDONLY)) < 0) {
+		return -1;
+	}
+	
+	if (fstatvfs (fd, st) < 0) {
+		return -1;
+  }
+  
+	if (close(fd) <	0) {
+		return -1;
+	}
+	
+	return 0;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/swi.h third_party/newlib-3.2.0/newlib/libc/sys/arm/swi.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/swi.h	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/swi.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,91 +0,0 @@
-#include "arm.h"
-
-/* SWI numbers for RDP (Demon) monitor.  */
-#define SWI_WriteC                 0x0
-#define SWI_Write0                 0x2
-#define SWI_ReadC                  0x4
-#define SWI_CLI                    0x5
-#define SWI_GetEnv                 0x10
-#define SWI_Exit                   0x11
-#define SWI_EnterOS                0x16
-
-#define SWI_GetErrno               0x60
-#define SWI_Clock                  0x61
-#define SWI_Time                   0x63
-#define SWI_Remove                 0x64
-#define SWI_Rename                 0x65
-#define SWI_Open                   0x66
-
-#define SWI_Close                  0x68
-#define SWI_Write                  0x69
-#define SWI_Read                   0x6a
-#define SWI_Seek                   0x6b
-#define SWI_Flen                   0x6c
-
-#define SWI_IsTTY                  0x6e
-#define SWI_TmpNam                 0x6f
-#define SWI_InstallHandler         0x70
-#define SWI_GenerateError          0x71
-
-
-/* Now the SWI numbers and reason codes for RDI (Angel) monitors.  */
-#define AngelSWI_ARM 			0x123456
-#ifdef __thumb__
-#define AngelSWI 			0xAB
-#else
-#define AngelSWI 			AngelSWI_ARM
-#endif
-/* For thumb only architectures use the BKPT instruction instead of SWI.  */
-#ifdef THUMB_VXM
-#define AngelSWIInsn			"bkpt"
-#define AngelSWIAsm			bkpt
-#else
-#define AngelSWIInsn			"swi"
-#define AngelSWIAsm			swi
-#endif
-
-/* The reason codes:  */
-#define AngelSWI_Reason_Open		0x01
-#define AngelSWI_Reason_Close		0x02
-#define AngelSWI_Reason_WriteC		0x03
-#define AngelSWI_Reason_Write0		0x04
-#define AngelSWI_Reason_Write		0x05
-#define AngelSWI_Reason_Read		0x06
-#define AngelSWI_Reason_ReadC		0x07
-#define AngelSWI_Reason_IsTTY		0x09
-#define AngelSWI_Reason_Seek		0x0A
-#define AngelSWI_Reason_FLen		0x0C
-#define AngelSWI_Reason_TmpNam		0x0D
-#define AngelSWI_Reason_Remove		0x0E
-#define AngelSWI_Reason_Rename		0x0F
-#define AngelSWI_Reason_Clock		0x10
-#define AngelSWI_Reason_Time		0x11
-#define AngelSWI_Reason_System		0x12
-#define AngelSWI_Reason_Errno		0x13
-#define AngelSWI_Reason_GetCmdLine 	0x15
-#define AngelSWI_Reason_HeapInfo 	0x16
-#define AngelSWI_Reason_EnterSVC 	0x17
-#define AngelSWI_Reason_ReportException 0x18
-#define ADP_Stopped_ApplicationExit 	((2 << 16) + 38)
-#define ADP_Stopped_RunTimeError 	((2 << 16) + 35)
-
-#if defined(ARM_RDI_MONITOR) && !defined(__ASSEMBLER__)
-
-static inline int
-do_AngelSWI (int reason, void * arg)
-{
-  int value;
-  asm volatile ("mov r0, %1; mov r1, %2; " AngelSWIInsn " %a3; mov %0, r0"
-       : "=r" (value) /* Outputs */
-       : "r" (reason), "r" (arg), "i" (AngelSWI) /* Inputs */
-       : "r0", "r1", "r2", "r3", "ip", "lr", "memory", "cc"
-		/* Clobbers r0 and r1, and lr if in supervisor mode */);
-                /* Accordingly to page 13-77 of ARM DUI 0040D other registers
-                   can also be clobbered.  Some memory positions may also be
-                   changed by a system call, so they should not be kept in
-                   registers. Note: we are assuming the manual is right and
-                   Angel is respecting the APCS.  */
-  return value;
-}
-
-#endif
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sync.c third_party/newlib-3.2.0/newlib/libc/sys/arm/sync.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sync.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sync.c	2022-06-29 14:50:02.777942447 +0100
@@ -0,0 +1,41 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/* @brief sync a specific file to non-volatile storage
+ *
+ */
+int fsync (int fd)
+{
+    int sc;
+
+    sc = _swi_fsync(fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
+
+/* @brief sync all files to non-volatile storage
+ *
+ */
+int sync (void)
+{
+    int sc;
+
+    sc = _swi_sync();
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+
+    return sc;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/debug.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,48 @@
+#ifndef _SYS_DEBUG_H
+#define _SYS_DEBUG_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <stdio.h>
+
+
+extern char __assertion_string[32];
+
+void KLogOut(const char *format, ...);
+
+#ifndef NDEBUG
+
+#define KLog(fmt, args...) KLogOut(fmt, ##args)
+
+#define KAssert(expr)                                                          \
+  {                                                                            \
+    if (!(expr)) {                                                             \
+      KLogOut("@ %s, %d, %s", __FILE__, __LINE__, __FUNCTION__);               \
+      KLogOut("KASSERT (" #expr ") failed");                                   \
+      snprintf(__assertion_string, 32, "@ %s, %d, %s", __FILE__, __LINE__,     \
+               __FUNCTION__);                                                  \
+      Exit(EXIT_ASSERTION, __assertion_string);                                \
+    }                                                                          \
+  }
+
+#else
+
+#define KLog(fmt, args...)
+
+#define KAssert(expr)
+
+#endif
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
+
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/dirent.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,56 @@
+/*
+ *  $Id: utime.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef __DIRENT_h__
+#define __DIRENT_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *
+ */
+
+#include <sys/types.h>
+#include <limits.h>
+#include <stdbool.h>
+
+#define DIRENTS_BUF_SZ 4096
+
+typedef struct _dir
+{
+	int	fd;
+	void *buf;
+	int buf_sz;
+  int buf_offset;
+  bool eof;
+} DIR;
+
+
+# define __dirfd(dp)	((dp)->fd)
+
+int closedir(DIR *);
+DIR *opendir(const char *);
+struct dirent *readdir(DIR *);
+
+
+
+struct dirent
+{
+    int d_cookie;
+    int d_reclen;  			/* Length of this dirent */
+	long d_ino;
+	char d_name[0];
+};
+
+
+#define DIRENT_ALIGN		32
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif
\ No newline at end of file
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/execargs.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,29 @@
+#ifndef _SYS_EXECARGS_H
+#define _SYS_EXECARGS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+
+
+struct execargs
+{
+    char **argv;
+    int argc;
+    char **envv;
+    int envc;
+    size_t total_size;   
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fcntl.h	2022-06-29 14:50:02.885945277 +0100
@@ -3,10 +3,4 @@
 
 #include <sys/_default_fcntl.h>
 
-/* We want to support O_BINARY for the open syscall.
-   For example, the Demon debug monitor has a separate
-   flag value for "rb" vs "r". */
-#define _FBINARY        0x10000
-#define O_BINARY        _FBINARY
-
 #endif /* _SYS_FCNTL_H_ */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/fsreq.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,302 @@
+#ifndef SYS_FSREQ_H
+#define SYS_FSREQ_H
+
+
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/types.h>
+#include <sys/dirent.h>
+#include <sys/stat.h>
+
+
+
+
+
+
+
+// TODO Move into newlib
+
+#define WSTAT_MODE  (1<<0)
+#define WSTAT_UID   (1<<1)
+#define WSTAT_GID   (1<<2)
+#define WSTAT_SIZE  (1<<3)
+#define WSTAT_ATIME (1<<4)
+#define WSTAT_MTIME (1<<5)
+#define WSTAT_CTIME (1<<6)
+
+#define CMD_LOOKUP          0
+#define CMD_CLOSE           1
+#define CMD_READ            2
+#define CMD_WRITE           3
+#define CMD_READDIR         4
+#define CMD_UNLINK          5
+#define CMD_RMDIR           6
+#define CMD_MKDIR           7
+#define CMD_MKNOD           8
+#define CMD_RENAME          9
+#define CMD_STAT            10
+#define CMD_MKLINK          11
+#define CMD_CREATE          12
+#define CMD_TRUNCATE        13
+#define CMD_CHOWN           14
+#define CMD_CHMOD           15
+#define CMD_ISATTY          16
+
+#define CMD_TCGETATTR       17
+#define CMD_TCSETATTR       18
+
+
+
+
+
+
+
+
+
+
+
+struct fsreq
+{
+    int cmd;    
+
+    // TODO: add timestamp here or should it be in each?
+
+    union
+    {
+        struct {
+            // TODO: Add flags to create, mode and uid/gid, date fields.
+            uint32_t dir_inode_nr;
+            int name_sz;
+        } lookup;
+
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            uint32_t oflags;
+            mode_t mode;
+            int uid;
+            int gid;
+        } create;
+        
+        struct {
+            uint32_t inode_nr;
+        } close;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;
+        } read;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;            
+        } write;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t offset;
+            uint32_t sz;
+        } readdir;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } mkdir;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } unlink;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+        } rmdir;
+        
+        struct {
+            uint32_t inode_nr;
+            int uid;
+            int gid;
+        } chown;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+        } chmod;
+        
+        struct {
+            uint32_t inode_nr;
+            off64_t size;
+        } truncate;
+
+        struct {
+            uint32_t inode_nr;
+        } stat;
+        
+        struct {
+           uint32_t src_dir_inode_nr;
+           uint32_t src_name_sz;
+           uint32_t dst_dir_inode_nr;
+           uint32_t dst_name_sz;
+        } rename;
+        
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            mode_t mode;
+            int uid;
+            int gid;
+        } mknod;
+
+        struct {
+            uint32_t dir_inode_nr;
+            uint32_t name_sz;
+            uint32_t link_sz;
+        } mklink;
+
+        struct {
+            uint32_t inode_nr;
+        } rdlink;
+        
+        struct {
+            uint32_t inode_nr;
+        } isatty;
+
+        struct
+        {
+          uint32_t inode_nr;
+        } tcgetattr;
+
+        struct
+        {
+          uint32_t inode_nr;
+        } tcsetattr;
+
+    } args;
+};
+
+
+struct fsreply
+{
+    int cmd;    
+
+    union
+    {
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+            int32_t status;
+        } lookup;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+            int32_t status;
+        } create;
+        
+        struct {
+            int32_t status;
+        } close;
+        
+        struct {
+            int32_t nbytes_read;
+        } read;
+        
+        struct {
+            int32_t nbytes_written;
+        } write;
+
+        struct {
+            int32_t nbytes_read;
+            off64_t offset;
+        } readdir;
+        
+        struct {
+            int32_t status;
+        } unlink;
+        
+        struct {
+            int32_t status;
+        } mkdir;
+        
+        struct {
+            int32_t status;
+        } rmdir;
+        
+        struct {
+            int32_t status;
+        } chown;
+
+        struct {
+            int32_t status;
+        } chmod;
+
+        struct {
+            int32_t status;
+        } truncate;
+
+        struct {
+            int32_t status;
+            struct stat stat;
+        } stat;
+           
+        struct {
+            int32_t status;
+        } rename;
+        
+        struct {
+            uint32_t inode_nr;
+            mode_t mode;
+            int uid;
+            int gid;
+            off64_t size;
+            time_t atime;
+            time_t mtime;
+            time_t ctime;
+            int32_t status;
+        } mknod;   
+
+        struct {
+            uint32_t inode_nr;
+            int32_t status;
+        } mklink;   
+
+        struct {
+            uint32_t inode_nr;
+            int32_t status;
+        } rdlink;   
+
+        struct {
+            bool isatty;
+            int32_t status;
+        } isatty;   
+
+        struct {
+            int32_t status;
+        } tcgetattr;   
+
+        struct {
+            int32_t status;
+        } tcsetattr;   
+
+
+    } args;
+};
+
+
+
+#endif
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/interrupts.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,24 @@
+#ifndef _SYS_INTERRUPTS_H
+#define _SYS_INTERRUPTS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+struct InterruptAPI
+{
+  int (*MaskInterrupt)(int irq);
+  int (*UnmaskInterrupt)(int irq);
+  int (*PollNotifyFromISR)(struct InterruptAPI *api, uint32_t mask, uint32_t events);
+
+  struct VNode *interrupt_vnode;
+};
+
+
+#ifdef __cplusplus
+}
+#endif 
+#endif
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/ioctl.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,21 @@
+#ifndef _SYS_IOCTL_H
+#define _SYS_IOCTL_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+
+
+#define  IOCTL_CON_SETMAP	0
+
+
+
+int ioctl (int fd, int request, ...);
+
+
+#ifdef __cplusplus
+}
+#endif 
+#endif
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/lists.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,648 @@
+#ifndef SYS_LISTS_H
+#define SYS_LISTS_H
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Double linked list with head and tail pointers in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+/* Could add a name, makes it easier for arrays */
+
+#define LIST_INITIALIZER	{NULL, NULL}
+
+#define LIST_TYPE(type)			 											\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+
+#define LIST(type)															\
+	struct																	\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+
+#define LIST_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+     
+#define LIST_DEFINE(name)													\
+		struct name
+     
+
+#define LIST_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+		struct type *prev;													\
+	}
+	
+
+#define LIST_INIT( header)													\
+	{																		\
+		(header)->head = NULL;												\
+		(header)->tail = NULL;												\
+	}
+	
+
+#define LIST_CONCAT( dest, src, field)										\
+	{																		\
+		if ((src)->head != NULL)											\
+		{																	\
+			if ((dest)->head != NULL)										\
+			{																\
+				((dest)->tail)->field.next = (src)->head;					\
+				((src)->head)->field.prev = (dest)->tail;					\
+				(dest)->tail = (src)->tail;									\
+			}																\
+			else															\
+			{																\
+				((src)->head)->field.prev = NULL;							\
+				(dest)->head = (src)->head;									\
+				(dest)->tail = (src)->tail;									\
+			}																\
+		}																	\
+	}
+
+
+#define LIST_EMPTY( header)													\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define LIST_HEAD( header)													\
+	((header)->head)
+
+
+#define LIST_TAIL( header)													\
+	((header)->tail)
+
+
+#define LIST_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define LIST_PREV( entry, field)											\
+	((entry)->field.prev)
+
+
+#define LIST_ADD_HEAD( header, new_head, field)								\
+	{																		\
+		(new_head)->field.next = (header)->head;							\
+		(new_head)->field.prev = NULL;										\
+																			\
+		if ((header)->head != NULL)											\
+			 (header)->head->field.prev = new_head;							\
+		else																\
+			(header)->tail = new_head;										\
+																			\
+		(header)->head = new_head;											\
+	}
+
+
+#define LIST_ADD_TAIL( header, new_tail, field)								\
+	{																	\
+		(new_tail)->field.next = NULL;										\
+		(new_tail)->field.prev = (header)->tail;							\
+		if ((header)->tail != NULL)											\
+			(header)->tail->field.next = new_tail;							\
+		else																\
+			(header)->head = new_tail;										\
+		(header)->tail = new_tail;											\
+	}
+
+
+#define LIST_REM_HEAD( header, field)										\
+	{																	\
+		(header)->head = (header)->head->field.next;						\
+		if ((header)->head != NULL)											\
+			(header)->head->field.prev = NULL;								\
+		else																\
+			(header)->tail = NULL;											\
+	}
+
+
+#define LIST_REM_TAIL( header, field)										\
+	{																		\
+		(header)->tail = (header)->tail->field.prev;						\
+		if ((header)->tail != NULL)											\
+			(header)->tail->field.next = NULL;								\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+#define LIST_INSERT_AFTER( header, prev_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(new_entry)->field.prev = prev_entry;								\
+		(prev_entry)->field.next = new_entry;								\
+		if ((new_entry)->field.next != NULL)								\
+			(new_entry)->field.next->field.prev = new_entry;				\
+		else																\
+			(header)->tail = new_entry;										\
+	}
+	
+
+#define LIST_INSERT_BEFORE( header, next_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.prev = (next_entry)->field.prev;					\
+		(new_entry)->field.next = next_entry;								\
+		(next_entry)->field.prev = new_entry;								\
+		if ((new_entry)->field.prev != NULL)								\
+			(new_entry)->field.prev->field.next = new_entry;				\
+		else																\
+			(header)->head = new_entry;										\
+	}
+	
+
+#define LIST_REM_ENTRY( header, entry, field)								\
+	{																		\
+		if ((entry)->field.prev != NULL)									\
+			(entry)->field.prev->field.next = (entry)->field.next;			\
+		else																\
+			(header)->head = (entry)->field.next;								\
+		if ((entry)->field.next != NULL)									\
+			(entry)->field.next->field.prev = (entry)->field.prev;			\
+		else																\
+			(header)->tail = (entry)->field.prev;								\
+	}
+
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Single linked queue with head and tail pointers in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define QUEUE_INITIALIZER	{NULL, NULL}
+
+#define QUEUE_TYPE(type)			 										\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+#define QUEUE( type)														\
+	struct																	\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+
+
+#define QUEUE_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+		struct type *tail;													\
+	}
+
+     
+#define QUEUE_DEFINE(name)													\
+		struct name
+
+
+#define QUEUE_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+	}
+
+
+#define QUEUE_INIT( header)													\
+	{																		\
+		(header)->head = NULL;												\
+		(header)->tail = NULL;												\
+	}
+
+
+#define QUEUE_EMPTY( header)												\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define QUEUE_HEAD( header)													\
+	((header)->head)
+
+
+#define QUEUE_TAIL( header)													\
+	((header)->tail)
+
+
+#define QUEUE_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define QUEUE_ADD_TAIL( header, new_tail, field)							\
+	{																		\
+		(new_tail)->field.next = NULL;										\
+		if ((header)->tail != NULL)											\
+			(header)->tail->field.next = new_tail;							\
+		else																\
+			(header)->head = new_tail;										\
+		(header)->tail = new_tail;											\
+	}
+
+
+#define QUEUE_REM_HEAD( header, field)										\
+	{																		\
+		(header)->head = (header)->head->field.next;						\
+		if ((header)->head == NULL)											\
+			(header)->tail = NULL;											\
+	}
+
+
+#define QUEUE_INSERT_AFTER( header, prec_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(prev_entry)->field.next = new_entry;								\
+		if ((new_entry)->field.next == NULL)								\
+			(header)->tail = new_entry;										\
+	}
+
+#define QUEUE_REM_AFTER( header, prec_entry, rem_entry, field)				\
+	{																		\
+		if (prec_entry != NULL)												\
+			(prec_entry)->field.next = (rem_entry)->field.next;				\
+		else																\
+		{																	\
+			(header)->head = (header)->head->field.next;					\
+			if ((header)->head == NULL)										\
+				(header)->tail = NULL;										\
+		}																	\
+	}
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Single linked list with only a head pointer in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define STACK_INITIALIZER		{NULL}
+
+#define STACK_TYPE(type)			 										\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+	}
+
+
+
+#define STACK( type)														\
+	struct																	\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define STACK_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+	}
+
+     
+#define STACK_DEFINE(name)													\
+		struct name
+
+
+#define STACK_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+	}
+
+
+#define STACK_INIT( header)													\
+	(header)->head = NULL;
+
+
+#define STACK_EMPTY( header)												\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define STACK_HEAD( header)													\
+	((header)->head)
+
+
+#define STACK_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define STACK_ADD_HEAD( header, new_head, field)							\
+	{																		\
+		(new_head)->field.next = (header)->head;							\
+		(header)->head = new_head;											\
+	}
+
+
+#define STACK_REM_HEAD( header, field)										\
+	(header)->head = (header)->head->field.next;
+	
+
+#define STACK_INSERT_AFTER( header, prec_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(prev_entry)->field.next = new_entry;								\
+	}
+
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Double linked list with only a head pointer in the header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define HEAP_INITIALIZER		{NULL}
+
+#define HEAP_TYPE(type)			 											\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define HEAP( type)															\
+	struct																	\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define HEAP_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+	}
+
+     
+#define HEAP_DEFINE(name)													\
+		struct name
+
+
+#define HEAP_ENTRY( type)													\
+	struct																	\
+	{																		\
+		struct type *next;													\
+		struct type *prev;													\
+	}
+
+
+#define HEAP_INIT( header)													\
+	(header)->head = NULL;
+
+
+#define HEAP_EMPTY( header)													\
+	(((header)->head == NULL) ? 1 : 0)
+
+	
+#define HEAP_HEAD( header)													\
+	((header)->head)
+
+
+#define HEAP_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define HEAP_PREV( entry, field)											\
+	((entry)->field.prev)
+
+
+#define HEAP_ADD_HEAD( header, new_head, field)								\
+	{																		\
+		(new_head)->field.next = (header)->head;							\
+		(new_head)->field.prev = NULL;										\
+		if ((header)->head != NULL)											\
+			(header)->head->field.prev = new_head;							\
+		(header)->head = new_head;											\
+	}
+
+
+#define HEAP_REM_HEAD( header, field)										\
+	{																		\
+		(header)->head = (header)->head->field.next;						\
+		if ((header)->head != NULL)											\
+			(header)->head->field.prev = NULL;								\
+	}
+
+
+#define HEAP_INSERT_AFTER( header, prev_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.next = (prev_entry)->field.next;					\
+		(new_entry)->field.prev = prev_entry;								\
+		(prev_entry)->field.next = new_entry;								\
+		if ((new_entry)->field.next != NULL)								\
+			(new_entry)->field.next->field.prev = new_entry;				\
+	}
+
+
+#define HEAP_INSERT_BEFORE( header, next_entry, new_entry, field)			\
+	{																		\
+		(new_entry)->field.prev = (next_entry)->field.prev;					\
+		(new_entry)->field.next = next_entry;								\
+		(next_entry)->field.prev = new_entry;								\
+		if ((new_entry)->field.prev != NULL)								\
+			(new_entry)->field.prev->field.next = new_entry;				\
+		else																\
+			(header)->head = new_entry;										\
+	}
+
+
+#define HEAP_REM_ENTRY( header, entry, field)								\
+	{																		\
+		if ((entry)->field.prev != NULL)									\
+			(entry)->field.prev->field.next = (entry)->field.next;			\
+		else																\
+			(header)->head = entry->field.next;								\
+		if ((entry)->field.next != NULL)									\
+			(entry)->field.next->field.prev = (entry)->field.prev;			\
+	}
+
+
+
+
+/* -----------------------------------------------------------------------------
+** SYNOPSIS
+**
+** Circular queue with pointer to current head in header.
+**
+** -----------------------------------------------------------------------------
+*/
+
+#define CIRCLEQ_INITIALIZER			{NULL}
+
+#define CIRCLEQ_TYPE(type)			 										\
+	typedef struct															\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define CIRCLEQ( type)														\
+	struct																	\
+	{																		\
+		struct type *head;													\
+	}
+
+
+#define CIRCLEQ_DECLARE(name, type)											\
+	struct name																\
+	{																		\
+		struct type *head;													\
+	}
+
+     
+#define CIRCLEQ_DEFINE(name)												\
+		struct name
+
+
+#define CIRCLEQ_ENTRY( type)												\
+	struct																	\
+	{																		\
+		struct type *next;													\
+		struct type *prev;													\
+	}
+
+
+#define CIRCLEQ_INIT( header)												\
+	(header)->head = NULL;
+
+#define CIRCLEQ_SET_HEAD( header, new_head)									\
+	(header)->head = new_head;
+
+#define CIRCLEQ_EMPTY( header)												\
+	(((header)->head == NULL) ? 1 : 0)
+
+
+#define CIRCLEQ_HEAD( header)												\
+	((header)->head)
+
+
+#define CIRCLEQ_TAIL( header, field)										\
+	 (((header)->head != NULL) ? (header)->head->field.prev : NULL)
+	 
+	 
+#define CIRCLEQ_NEXT( entry, field)											\
+	((entry)->field.next)
+
+
+#define CIRCLEQ_PREV( entry, field)											\
+	((entry)->field.prev)
+
+
+#define CIRCLEQ_FORWARD( header, field)										\
+	{																		\
+			(header)->head = (header)->head->field.next;					\
+	}
+
+
+#define CIRCLEQ_REVERSE( header, field)										\
+	{																		\
+		if ((header)->head != NULL)											\
+			(header)->head = (header)->head->field.next;					\
+	}
+
+
+#define CIRCLEQ_ADD_HEAD( header, new_head, field)							\
+	{																		\
+		if ((header)->head != NULL)											\
+		{																	\
+			(new_head)->field.next = (header)->head;						\
+			(new_head)->field.prev = (header)->head->field.prev;			\
+			(header)->head->field.prev = (new_head);						\
+			(new_head)->field.prev->field.next = (new_head);				\
+		}																	\
+		else																\
+		{																	\
+			(new_head)->field.next = (new_head);							\
+			(new_head)->field.prev = (new_head);							\
+		}																	\
+		(header)->head = (new_head);										\
+	}
+
+
+#define CIRCLEQ_ADD_TAIL( header, new_tail, field)							\
+	{																		\
+		if ((header)->head != NULL)											\
+		{																	\
+			(new_tail)->field.next = (header)->head;						\
+			(new_tail)->field.prev = (header)->head->field.prev;			\
+			(new_tail)->field.next->field.prev = (new_tail);				\
+			(new_tail)->field.prev->field.next = (new_tail);				\
+		}																	\
+		else																\
+		{																	\
+			(new_tail)->field.next = (new_tail);							\
+			(new_tail)->field.prev = (new_tail);							\
+			(header)->head = (new_tail);									\
+		}																	\
+	}
+
+
+#define CIRCLEQ_REM_HEAD( header, field)									\
+	{																		\
+		if ((header)->head->field.next != (header)->head)					\
+		{																	\
+			(header)->head->field.next->field.prev = (header)->head->field.prev;\
+			(header)->head->field.prev->field.next = (header)->head->field.next;\
+			(header)->head = (header)->head->field.next;					\
+		}																	\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+#define CIRCLEQ_REM_TAIL( header, field)									\
+	{																		\
+		if ((header)->head->field.next != (header)->head)					\
+		{																	\
+			(header)->head->field.prev->field.prev->field.next = (header)->head;\
+			(header)->head->field.prev = (header)->head->field.prev->field.prev;\
+		}																	\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+#define CIRCLEQ_REM_ENTRY( header, entry, field)							\
+	{																		\
+		if ((entry)->field.next != (entry))									\
+		{																	\
+			(entry)->field.next->field.prev = (entry)->field.prev;			\
+			(entry)->field.prev->field.next = (entry)->field.next;			\
+			if ((header)->head == (entry))									\
+				(header)->head = (entry)->field.next;						\
+		}																	\
+		else																\
+			(header)->head = NULL;											\
+	}
+
+
+
+
+#endif
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mntent.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,117 @@
+#ifndef	_SYS_MNTENT_H
+#define	_SYS_MNTENT_H
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <stdio.h>
+
+
+
+
+
+#define	MNTTYPE_ZFS			"zfs"		/* ZFS file system */
+#define	MNTTYPE_UFS			"ufs"		/* Unix file system */
+#define	MNTTYPE_NFS			"nfs"		/* NFS file system */
+#define	MNTTYPE_NFS3		"nfs3"		/* NFS Version 3 file system */
+#define	MNTTYPE_NFS4		"nfs4"		/* NFS Version 4 file system */
+#define	MNTTYPE_CACHEFS		"cachefs"	/* Cache File System */
+#define	MNTTYPE_PCFS		"pcfs"		/* PC (MSDOS) file system */
+#define	MNTTYPE_PC	MNTTYPE_PCFS		/* Deprecated name; use MNTTYPE_PCFS */
+#define	MNTTYPE_LOFS		"lofs"		/* Loop back file system */
+#define	MNTTYPE_LO	MNTTYPE_LOFS		/* Deprecated name; use MNTTYPE_LOFS */
+#define	MNTTYPE_HSFS		"hsfs"		/* High Sierra (9660) file system */
+#define	MNTTYPE_SWAP		"swap"		/* Swap file system */
+#define	MNTTYPE_TMPFS		"tmpfs"		/* Tmp volatile file system */
+#define	MNTTYPE_AUTOFS		"autofs"	/* Automounter ``file'' system */
+#define	MNTTYPE_MNTFS		"mntfs"		/* In-kernel mnttab */
+#define	MNTTYPE_XMEMFS		"xmemfs"	/* Extended memory FS, IA32 only */
+#define	MNTTYPE_DEV			"dev"		/* /dev file system */
+#define	MNTTYPE_CTFS		"ctfs"		/* Contract file system */
+#define	MNTTYPE_OBJFS		"objfs"		/* Kernel object file system */
+
+#define	MNTOPT_RO			"ro"		/* Read only */
+#define	MNTOPT_RW			"rw"		/* Read/write */
+#define	MNTOPT_RQ			"rq"		/* Read/write with quotas */
+#define	MNTOPT_QUOTA		"quota"		/* Check quotas */
+#define	MNTOPT_NOQUOTA		"noquota"	/* Don't check quotas */
+#define	MNTOPT_ONERROR		"onerror"	/* action to taken on error */
+#define	MNTOPT_SOFT			"soft"		/* Soft mount */
+#define	MNTOPT_SEMISOFT		"semisoft"	/* partial soft, uncommited interface */
+#define	MNTOPT_HARD			"hard"		/* Hard mount */
+#define	MNTOPT_SUID			"suid"		/* Both setuid and devices allowed */
+#define	MNTOPT_NOSUID		"nosuid"	/* Neither setuid nor devices allowed */
+#define	MNTOPT_DEVICES		"devices"	/* Device-special allowed */
+#define	MNTOPT_NODEVICES	"nodevices"	/* Device-special disallowed */
+#define	MNTOPT_SETUID		"setuid"	/* Set uid allowed */
+#define	MNTOPT_NOSETUID		"nosetuid"	/* Set uid not allowed */
+#define	MNTOPT_GRPID		"grpid"		/* SysV-compatible gid on create */
+#define	MNTOPT_REMOUNT		"remount"	/* Change mount options */
+#define	MNTOPT_NOSUB		"nosub"		/* Disallow mounts on subdirs */
+#define	MNTOPT_MULTI		"multi"		/* Do multi-component lookup */
+#define	MNTOPT_INTR			"intr"		/* Allow NFS ops to be interrupted */
+#define	MNTOPT_NOINTR		"nointr"	/* Don't allow interrupted ops */
+#define	MNTOPT_PORT			"port"		/* NFS server IP port number */
+#define	MNTOPT_SECURE		"secure"	/* Secure (AUTH_DES) mounting */
+#define	MNTOPT_RSIZE		"rsize"		/* Max NFS read size (bytes) */
+#define	MNTOPT_WSIZE		"wsize"		/* Max NFS write size (bytes) */
+#define	MNTOPT_TIMEO		"timeo"		/* NFS timeout (1/10 sec) */
+#define	MNTOPT_RETRANS		"retrans"	/* Max retransmissions (soft mnts) */
+#define	MNTOPT_ACTIMEO		"actimeo"	/* Attr cache timeout (sec) */
+#define	MNTOPT_ACREGMIN		"acregmin"	/* Min attr cache timeout (files) */
+#define	MNTOPT_ACREGMAX		"acregmax"	/* Max attr cache timeout (files) */
+#define	MNTOPT_ACDIRMIN		"acdirmin"	/* Min attr cache timeout (dirs) */
+#define	MNTOPT_ACDIRMAX		"acdirmax"	/* Max attr cache timeout (dirs) */
+#define	MNTOPT_NOAC			"noac"		/* Don't cache attributes at all */
+#define	MNTOPT_NOCTO		"nocto"		/* No close-to-open consistency */
+#define	MNTOPT_BG			"bg"		/* Do mount retries in background */
+#define	MNTOPT_FG			"fg"		/* Do mount retries in foreground */
+#define	MNTOPT_RETRY		"retry"		/* Number of mount retries */
+#define	MNTOPT_DEV			"dev"		/* Device id of mounted fs */
+#define	MNTOPT_POSIX		"posix"		/* Get static pathconf for mount */
+#define	MNTOPT_MAP			"map"		/* Automount map */
+#define	MNTOPT_DIRECT		"direct"	/* Automount   direct map mount */
+#define	MNTOPT_INDIRECT		"indirect"	/* Automount indirect map mount */
+#define	MNTOPT_LLOCK		"llock"		/* Local locking (no lock manager) */
+#define	MNTOPT_IGNORE		"ignore"	/* Ignore this entry */
+#define	MNTOPT_VERS			"vers"		/* protocol version number indicator */
+#define	MNTOPT_PROTO		"proto"		/* protocol network_id indicator */
+#define	MNTOPT_SEC			"sec"		/* Security flavor indicator */
+#define	MNTOPT_SYNCDIR		"syncdir"	/* Synchronous local directory ops */
+#define	MNTOPT_NOSETSEC		"nosec"		/* Do no allow setting sec attrs */
+#define	MNTOPT_NOPRINT		"noprint"	/* Do not print messages */
+#define	MNTOPT_LARGEFILES 	"largefiles"		/* allow large files */
+#define	MNTOPT_NOLARGEFILES "nolargefiles" 		/* don't allow large files */
+#define	MNTOPT_FORCEDIRECTIO 	"forcedirectio" /* Force DirectIO on all files */
+#define	MNTOPT_NOFORCEDIRECTIO	"noforcedirectio" /* No Force DirectIO */
+#define	MNTOPT_DISABLEDIRECTIO	"disabledirectio" /* Disable DirectIO ioctls */
+#define	MNTOPT_PUBLIC		"public"	/* Use NFS public file handlee */
+#define	MNTOPT_LOGGING 		"logging" 	/* enable logging */
+#define	MNTOPT_NOLOGGING	"nologging"	/* disable logging */
+#define	MNTOPT_ATIME		"atime"		/* update atime for files */
+#define	MNTOPT_NOATIME 	 	"noatime"	/* do not update atime for files */
+#define	MNTOPT_GLOBAL		"global"	/* Cluster-wide global mount */
+#define	MNTOPT_NOGLOBAL		"noglobal"	/* Mount local to single node */
+#define	MNTOPT_DFRATIME		"dfratime"	/* Deferred access time updates */
+#define	MNTOPT_NODFRATIME 	"nodfratime"/* No Deferred access time updates */
+#define	MNTOPT_NBMAND		"nbmand"	/* allow non-blocking mandatory locks */
+#define	MNTOPT_NONBMAND		"nonbmand"	/* deny non-blocking mandatory locks */
+#define	MNTOPT_XATTR		"xattr"		/* enable extended attributes */
+#define	MNTOPT_NOXATTR		"noxattr"	/* disable extended attributes */
+#define	MNTOPT_EXEC			"exec"		/* enable executables */
+#define	MNTOPT_NOEXEC		"noexec"	/* disable executables */
+#define	MNTOPT_RESTRICT		"restrict"	/* restricted autofs mount */
+#define	MNTOPT_BROWSE		"browse"	/* browsable autofs mount */
+#define	MNTOPT_NOBROWSE		"nobrowse"	/* non-browsable autofs mount */
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+#endif
\ No newline at end of file
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/mount.h	2022-06-29 14:50:02.885945277 +0100
@@ -0,0 +1,78 @@
+#ifndef _SYS_MOUNT_H
+#define _SYS_MOUNT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/statvfs.h>
+
+// mount flags
+#define MOUNTF_NOCACHE          (1<<0)
+#define MOUNTF_NODNLC           (1<<1)
+#define MOUNTF_DEFAULT_UID      (1<<2)
+#define MOUNTF_DEFAULT_GID      (1<<3)
+#define MOUNTF_DEFAULT_MODE     (1<<4)
+
+
+int mknod(char *path, uint32_t flags, struct stat *stat);
+int mount (char *_mountpoint, uint32_t flags, struct stat *stat);
+int unmount (int fd, bool force);
+int movemount(char *new_path, char *old_path);
+int pivotroot(char *new_root, char *old_root);
+
+
+
+typedef struct { long val[2]; } fsid_t;
+
+#define MFSNAMELEN   15 /* length of fs type name, not inc. nul */
+#define MNAMELEN     90 /* length of buffer for returned name */
+
+
+
+
+#define MNT_NOWAIT 0
+#define MNT_WAIT 1
+
+#define MNT_RDONLY 0x00000001 /* read only filesystem */
+#define MNT_SYNCHRONOUS 0x00000002 /* file system written 
+    synchronously */
+#define MNT_NOEXEC 0x00000004 /* can't exec from filesystem 
+    */
+#define MNT_NOSUID 0x00000008 /* don't honor setuid bits on 
+    fs */
+#define MNT_NODEV 0x00000010 /* don't interpret special 
+    files */
+#define MNT_UNION 0x00000020 /* union with underlying 
+    filesystem */
+#define MNT_ASYNC 0x00000040 /* file system written 
+    asynchronously */
+#define MNT_DONTBROWSE 0x00100000 /* file system is not 
+    appropriate path to user data */
+#define MNT_IGNORE_OWNERSHIP 0x00200000 /* VFS will ignore 
+    ownership information on filesystem objects */
+#define MNT_AUTOMOUNTED 0x00400000 /* filesystem was mounted
+    by automounter */
+#define MNT_JOURNALED 0x00800000 /* filesystem is journaled 
+    */
+#define MNT_NOUSERXATTR 0x01000000 /* Don't allow user 
+    extended attributes */
+#define MNT_DEFWRITE 0x02000000 /* filesystem should defer 
+    writes */
+
+
+int getfsstat (struct statfs *buf, int bufsize, int flags);
+int getmntinfo (struct statfs **mntbufp, int flags);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/param.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,241 @@
+/*-
+ * Copyright (c) 1982, 1986, 1989, 1993
+ *	The Regents of the University of California.  All rights reserved.
+ * (c) UNIX System Laboratories, Inc.
+ * All or some portions of this file are derived from material licensed
+ * to the University of California by American Telephone and Telegraph
+ * Co. or Unix System Laboratories, Inc. and are reproduced herein with
+ * the permission of UNIX System Laboratories, Inc.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ *
+ *	@(#)param.h	8.3 (Berkeley) 4/4/95
+ * $Id: param.h,v 1.3 2004/05/07 20:29:24 jjohnstn Exp $
+ */
+
+#ifndef _SYS_PARAM_H_
+#define _SYS_PARAM_H_
+
+/* from newlib's <sys/param.h> */
+
+#include <sys/config.h>
+#include <machine/endian.h>
+
+# define HZ (60)
+# define PATHSIZE (1024)
+
+/* end of from newlib's <sys/param.h> */
+
+#include <unistd.h>
+
+#define	BSD	199506		/* System version (year & month). */
+#define BSD4_3	1
+#define BSD4_4	1
+
+#ifndef NULL
+#define	NULL	0
+#endif
+
+#ifndef LOCORE
+#include <sys/types.h>
+#endif
+
+/*
+ * Machine-independent constants (some used in following include files).
+ * Redefined constants are from POSIX 1003.1 limits file.
+ *
+ * MAXCOMLEN should be >= sizeof(ac_comm) (see <acct.h>)
+ * MAXLOGNAME should be >= UT_NAMESIZE (see <utmp.h>)
+ */
+#include <sys/syslimits.h>
+
+#define	MAXCOMLEN	16		/* max command name remembered */
+#define	MAXINTERP	32		/* max interpreter file name length */
+#define	MAXLOGNAME	12		/* max login name length */
+#define	MAXUPRC		CHILD_MAX	/* max simultaneous processes */
+#define	NCARGS		ARG_MAX		/* max bytes for an exec function */
+#define	NGROUPS		NGROUPS_MAX	/* max number groups */
+#define	NOFILE		OPEN_MAX	/* max open files per process */
+#define	NOGROUP		65535		/* marker for empty group set member */
+#define MAXHOSTNAMELEN	256		/* max hostname size */
+
+/* More types and definitions used throughout the kernel. */
+#ifdef KERNEL
+#include <sys/cdefs.h>
+#include <sys/errno.h>
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/ucred.h>
+#include <sys/uio.h>
+#include <sys/rtprio.h>
+
+#ifndef FALSE
+#define	FALSE	0
+#endif
+#ifndef TRUE
+#define	TRUE	1
+#endif
+#endif
+
+/* Signals. */
+#include <sys/signal.h>
+
+/* Machine type dependent parameters. */
+#include <machine/param.h>
+#include <machine/limits.h>
+
+/*
+ * Priorities.  Note that with 32 run queues, differences less than 4 are
+ * insignificant.
+ */
+#define	PSWP	0
+#define	PVM	4
+#define	PINOD	8
+#define	PRIBIO	16
+#define	PVFS	20
+#define	PZERO	22		/* No longer magic, shouldn't be here.  XXX */
+#define	PSOCK	24
+#define	PWAIT	32
+#define	PLOCK	36
+#define	PPAUSE	40
+#define	PUSER	50
+#define	MAXPRI	127		/* Priorities range from 0 through MAXPRI. */
+
+#define	PRIMASK	0x0ff
+#define	PCATCH	0x100		/* OR'd with pri for tsleep to check signals */
+
+#define	NZERO	0		/* default "nice" */
+
+#define	NBPW	sizeof(int)	/* number of bytes per word (integer) */
+
+#define	CMASK	022		/* default file mask: S_IWGRP|S_IWOTH */
+#define	NODEV	(dev_t)(-1)	/* non-existent device */
+
+/*
+ * Clustering of hardware pages on machines with ridiculously small
+ * page sizes is done here.  The paging subsystem deals with units of
+ * CLSIZE pte's describing PAGE_SIZE (from machine/machparam.h) pages each.
+ */
+#if 0
+#define	CLBYTES		(CLSIZE*PAGE_SIZE)
+#endif
+
+#define	CBLOCK	128		/* Clist block size, must be a power of 2. */
+#define CBQSIZE	(CBLOCK/NBBY)	/* Quote bytes/cblock - can do better. */
+				/* Data chars/clist. */
+#define	CBSIZE	(CBLOCK - sizeof(struct cblock *) - CBQSIZE)
+#define	CROUND	(CBLOCK - 1)	/* Clist rounding. */
+
+/*
+ * File system parameters and macros.
+ *
+ * The file system is made out of blocks of at most MAXBSIZE units, with
+ * smaller units (fragments) only in the last direct block.  MAXBSIZE
+ * primarily determines the size of buffers in the buffer pool.  It may be
+ * made larger without any effect on existing file systems; however making
+ * it smaller make make some file systems unmountable.  Also, MAXBSIZE
+ * must be less than MAXPHYS!!!  DFLTBSIZE is the average amount of
+ * memory allocated by vfs_bio per nbuf.  BKVASIZE is the average amount
+ * of kernel virtual space allocated per nbuf.  BKVASIZE should be >=
+ * DFLTBSIZE.  If it is significantly bigger than DFLTBSIZE, then
+ * kva fragmentation causes fewer performance problems.
+ */
+#define	MAXBSIZE	65536
+#define BKVASIZE	8192
+#define DFLTBSIZE	4096
+#define MAXFRAG 	8
+
+/*
+ * MAXPATHLEN defines the longest permissible path length after expanding
+ * symbolic links. It is used to allocate a temporary buffer from the buffer
+ * pool in which to do the name expansion, hence should be a power of two,
+ * and must be less than or equal to MAXBSIZE.  MAXSYMLINKS defines the
+ * maximum number of symbolic links that may be expanded in a path name.
+ * It should be set high enough to allow all legitimate uses, but halt
+ * infinite loops reasonably quickly.
+ */
+#if !defined(__rtems__)
+#define	MAXPATHLEN	PATH_MAX
+#endif
+#define MAXSYMLINKS	32
+
+/* Bit map related macros. */
+#define	setbit(a,i)	((a)[(i)/NBBY] |= 1<<((i)%NBBY))
+#define	clrbit(a,i)	((a)[(i)/NBBY] &= ~(1<<((i)%NBBY)))
+#define	isset(a,i)	((a)[(i)/NBBY] & (1<<((i)%NBBY)))
+#define	isclr(a,i)	(((a)[(i)/NBBY] & (1<<((i)%NBBY))) == 0)
+
+/* Macros for counting and rounding. */
+#ifndef howmany
+#define	howmany(x, y)	(((x)+((y)-1))/(y))
+#endif
+#define	rounddown(x, y)	(((x)/(y))*(y))
+#define	roundup(x, y)	((((x)+((y)-1))/(y))*(y))  /* to any y */
+#define	roundup2(x, y)	(((x)+((y)-1))&(~((y)-1))) /* if y is powers of two */
+#define powerof2(x)	((((x)-1)&(x))==0)
+
+/* Macros for min/max. */
+#ifndef KERNEL
+#define	MIN(a,b) (((a)<(b))?(a):(b))
+#define	MAX(a,b) (((a)>(b))?(a):(b))
+#endif
+
+/*
+ * Constants for setting the parameters of the kernel memory allocator.
+ *
+ * 2 ** MINBUCKET is the smallest unit of memory that will be
+ * allocated. It must be at least large enough to hold a pointer.
+ *
+ * Units of memory less or equal to MAXALLOCSAVE will permanently
+ * allocate physical memory; requests for these size pieces of
+ * memory are quite fast. Allocations greater than MAXALLOCSAVE must
+ * always allocate and free physical memory; requests for these
+ * size allocations should be done infrequently as they will be slow.
+ *
+ * Constraints: PAGE_SIZE <= MAXALLOCSAVE <= 2 ** (MINBUCKET + 14), and
+ * MAXALLOCSIZE must be a power of two.
+ */
+#define MINBUCKET	4		/* 4 => min allocation of 16 bytes */
+#define MAXALLOCSAVE	(2 * PAGE_SIZE)
+
+/*
+ * Scale factor for scaled integers used to count %cpu time and load avgs.
+ *
+ * The number of CPU `tick's that map to a unique `%age' can be expressed
+ * by the formula (1 / (2 ^ (FSHIFT - 11))).  The maximum load average that
+ * can be calculated (assuming 32 bits) can be closely approximated using
+ * the formula (2 ^ (2 * (16 - FSHIFT))) for (FSHIFT < 15).
+ *
+ * For the scheduler to maintain a 1:1 mapping of CPU `tick' to `%age',
+ * FSHIFT must be at least 11; this gives us a maximum load avg of ~1024.
+ */
+#define	FSHIFT	11		/* bits to right of fixed binary point */
+#define FSCALE	(1<<FSHIFT)
+
+#endif	/* _SYS_PARAM_H_ */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/resource.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,42 @@
+#ifndef _SYS_RESOURCE_H_
+#define _SYS_RESOURCE_H_
+
+#include <sys/time.h>
+
+
+
+
+typedef unsigned long rlim_t;
+
+#define RLIM_INFINITY		0xffffffff
+#define RLIM_SAVED_MAX		0xfffffffe
+#define RLIM_SAVED_CUR		0xfffffffd
+
+
+
+#define RLIMIT_CORE			0
+#define RLIMIT_CPU			1
+#define RLIMIT_DATA			2
+#define RLIMIT_FSIZE		3
+#define RLIMIT_NOFILE		4
+#define RLIMIT_STACK		5
+#define RLIMIT_AS			6
+
+struct rlimit
+{
+	rlim_t rlim_cur;
+	rlim_t rlim_max;
+};
+
+
+
+#define	RUSAGE_SELF	0		/* calling process */
+#define	RUSAGE_CHILDREN	-1		/* terminated child processes */
+
+struct rusage {
+  	struct timeval ru_utime;	/* user time used */
+	struct timeval ru_stime;	/* system time used */
+};
+
+#endif
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/signal.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,333 @@
+/* sys/signal.h */
+
+#ifndef _SYS_SIGNAL_H
+#define _SYS_SIGNAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "_ansi.h"
+#include <sys/cdefs.h>
+#include <sys/features.h>
+#include <sys/types.h>
+#include <sys/_sigset.h>
+#include <sys/_timespec.h>
+
+#if !defined(_SIGSET_T_DECLARED)
+#define	_SIGSET_T_DECLARED
+typedef	__sigset_t	sigset_t;
+#endif
+
+#if defined(__CYGWIN__)
+#include <cygwin/signal.h>
+#else
+
+/* sigev_notify values
+   NOTE: P1003.1c/D10, p. 34 adds SIGEV_THREAD.  */
+
+#define SIGEV_NONE   1  /* No asynchronous notification shall be delivered */
+                        /*   when the event of interest occurs. */
+#define SIGEV_SIGNAL 2  /* A queued signal, with an application defined */
+                        /*  value, shall be delivered when the event of */
+                        /*  interest occurs. */
+#define SIGEV_THREAD 3  /* A notification function shall be called to */
+                        /*   perform notification. */
+
+/*  Signal Generation and Delivery, P1003.1b-1993, p. 63
+    NOTE: P1003.1c/D10, p. 34 adds sigev_notify_function and
+          sigev_notify_attributes to the sigevent structure.  */
+
+union sigval {
+  int    sival_int;    /* Integer signal value */
+  void  *sival_ptr;    /* Pointer signal value */
+};
+
+struct sigevent {
+  int              sigev_notify;               /* Notification type */
+  int              sigev_signo;                /* Signal number */
+  union sigval     sigev_value;                /* Signal value */
+
+#if defined(_POSIX_THREADS)
+  void           (*sigev_notify_function)( union sigval );
+                                               /* Notification function */
+  pthread_attr_t  *sigev_notify_attributes;    /* Notification Attributes */
+#endif
+};
+
+/* Signal Actions, P1003.1b-1993, p. 64 */
+/* si_code values, p. 66 */
+
+#define SI_USER    1    /* Sent by a user. kill(), abort(), etc */
+#define SI_QUEUE   2    /* Sent by sigqueue() */
+#define SI_TIMER   3    /* Sent by expiration of a timer_settime() timer */
+#define SI_ASYNCIO 4    /* Indicates completion of asycnhronous IO */
+#define SI_MESGQ   5    /* Indicates arrival of a message at an empty queue */
+
+typedef struct {
+  int          si_signo;    /* Signal number */
+  int          si_code;     /* Cause of the signal */
+  union sigval si_value;    /* Signal value */
+} siginfo_t;
+
+#define SA_NOCLDSTOP      (1<<0)
+#define SA_RESETHAND      (1<<1)
+#define SA_SIGINFO        (1<<2)
+#define SA_NODEFER        (1<<3)
+#define SA_TRAMPOLINE     (1<<4)
+
+typedef void (*_sig_func_ptr)(int);
+
+struct sigaction 
+{
+	void (* sa_trampoline)(void);
+	sigset_t sa_mask;
+	int sa_flags;
+
+  union {
+    _sig_func_ptr _handler;  /* SIG_DFL, SIG_IGN, or pointer to a function */
+    void        (*_sigaction)( int, siginfo_t *, void * );
+  } _signal_handlers;
+};
+
+#define sa_handler    _signal_handlers._handler
+#define sa_sigaction  _signal_handlers._sigaction
+
+#endif /* defined(__CYGWIN__) */
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+/*
+ * Minimum and default signal stack constants. Allow for target overrides
+ * from <sys/features.h>.
+ */
+#ifndef	MINSIGSTKSZ
+#define	MINSIGSTKSZ	2048
+#endif
+#ifndef	SIGSTKSZ
+#define	SIGSTKSZ	8192
+#endif
+
+/*
+ * Possible values for ss_flags in stack_t below.
+ */
+#define	SS_ONSTACK	0x1
+#define	SS_DISABLE	0x2
+
+#endif
+
+/*
+ * Structure used in sigaltstack call.
+ */
+typedef struct sigaltstack {
+  void     *ss_sp;    /* Stack base or pointer.  */
+  int       ss_flags; /* Flags.  */
+  size_t    ss_size;  /* Stack size.  */
+} stack_t;
+
+#define SIG_SETMASK 0	/* set mask with sigprocmask() */
+#define SIG_BLOCK 1	/* set of signals to block */
+#define SIG_UNBLOCK 2	/* set of signals to, well, unblock */
+
+int sigprocmask (int, const sigset_t *, sigset_t *);
+
+#if __POSIX_VISIBLE >= 199506
+int pthread_sigmask (int, const sigset_t *, sigset_t *);
+#endif
+
+#ifdef _COMPILING_NEWLIB
+int _kill (pid_t, int);
+#endif /* _COMPILING_NEWLIB */
+
+int kill (pid_t, int);
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4
+int killpg (pid_t, int);
+#endif
+
+int sigaction (int, const struct sigaction *, struct sigaction *);
+int sigaddset (sigset_t *, const int);
+int sigdelset (sigset_t *, const int);
+int sigismember (const sigset_t *, int);
+int sigfillset (sigset_t *);
+int sigemptyset (sigset_t *);
+int sigpending (sigset_t *);
+int sigsuspend (const sigset_t *);
+int sigwait (const sigset_t *, int *);
+
+#if !defined(__CYGWIN__) && !defined(__rtems__)
+/* These depend upon the type of sigset_t, which right now 
+   is always a long.. They're in the POSIX namespace, but
+   are not ANSI. */
+#define sigaddset(what,sig) (*(what) |= (1<<(sig)), 0)
+#define sigdelset(what,sig) (*(what) &= ~(1<<(sig)), 0)
+#define sigemptyset(what)   (*(what) = 0, 0)
+#define sigfillset(what)    (*(what) = ~(0), 0)
+#define sigismember(what,sig) (((*(what)) & (1<<(sig))) != 0)
+#endif /* !__CYGWIN__ && !__rtems__ */
+
+/* There are two common sigpause variants, both of which take an int argument.
+   If you request _XOPEN_SOURCE or _GNU_SOURCE, you get the System V version,
+   which removes the given signal from the process's signal mask; otherwise
+   you get the BSD version, which sets the process's signal mask to the given
+   value. */
+#if __XSI_VISIBLE && !defined(__INSIDE_CYGWIN__)
+# ifdef __GNUC__
+int sigpause (int) __asm__ (__ASMNAME ("__xpg_sigpause"));
+# else
+int __xpg_sigpause (int);
+#  define sigpause __xpg_sigpause
+# endif
+#elif __BSD_VISIBLE
+int sigpause (int);
+#endif
+
+#if __BSD_VISIBLE || __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+int sigaltstack (const stack_t *__restrict, stack_t *__restrict);
+#endif
+
+#if __POSIX_VISIBLE >= 199506
+int pthread_kill (pthread_t, int);
+#endif
+
+#if __POSIX_VISIBLE >= 199309
+
+/*  3.3.8 Synchronously Accept a Signal, P1003.1b-1993, p. 76
+    NOTE: P1003.1c/D10, p. 39 adds sigwait().  */
+
+int sigwaitinfo (const sigset_t *, siginfo_t *);
+int sigtimedwait (const sigset_t *, siginfo_t *, const struct timespec *);
+/*  3.3.9 Queue a Signal to a Process, P1003.1b-1993, p. 78 */
+int sigqueue (pid_t, int, const union sigval);
+
+#endif /* __POSIX_VISIBLE >= 199309 */
+
+#if defined(___AM29K__)
+/* These all need to be defined for ANSI C, but I don't think they are
+   meaningful.  */
+#define SIGABRT 1
+#define SIGFPE 1
+#define SIGILL 1
+#define SIGINT 1
+#define SIGSEGV 1
+#define SIGTERM 1
+/* These need to be defined for POSIX, and some others do too.  */
+#define SIGHUP 1
+#define SIGQUIT 1
+#define NSIG 2
+#elif defined(__GO32__)
+#define SIGINT  1
+#define SIGKILL 2
+#define SIGPIPE 3
+#define SIGFPE  4
+#define SIGHUP  5
+#define SIGTERM 6
+#define SIGSEGV 7
+#define SIGTSTP 8
+#define SIGQUIT 9
+#define SIGTRAP 10
+#define SIGILL  11
+#define SIGEMT  12
+#define SIGALRM 13
+#define SIGBUS  14
+#define SIGLOST 15
+#define SIGSTOP 16
+#define SIGABRT 17
+#define SIGUSR1	18
+#define SIGUSR2	19
+#define NSIG    20
+#elif !defined(SIGTRAP)
+#define	SIGHUP	1	/* hangup */
+#define	SIGINT	2	/* interrupt */
+#define	SIGQUIT	3	/* quit */
+#define	SIGILL	4	/* illegal instruction (not reset when caught) */
+#define	SIGTRAP	5	/* trace trap (not reset when caught) */
+#define	SIGIOT	6	/* IOT instruction */
+#define	SIGABRT 6	/* used by abort, replace SIGIOT in the future */
+#define	SIGEMT	7	/* EMT instruction */
+#define	SIGFPE	8	/* floating point exception */
+#define	SIGKILL	9	/* kill (cannot be caught or ignored) */
+#define	SIGBUS	10	/* bus error */
+#define	SIGSEGV	11	/* segmentation violation */
+#define	SIGSYS	12	/* bad argument to system call */
+#define	SIGPIPE	13	/* write on a pipe with no one to read it */
+#define	SIGALRM	14	/* alarm clock */
+#define	SIGTERM	15	/* software termination signal from kill */
+
+#if defined(__rtems__)
+#define	SIGURG	16	/* urgent condition on IO channel */
+#define	SIGSTOP	17	/* sendable stop signal not from tty */
+#define	SIGTSTP	18	/* stop signal from tty */
+#define	SIGCONT	19	/* continue a stopped process */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define	SIGCLD	20	/* System V name for SIGCHLD */
+#define	SIGTTIN	21	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define	SIGIO	23	/* input/output possible signal */
+#define	SIGPOLL	SIGIO	/* System V name for SIGIO */
+#define	SIGWINCH 24	/* window changed */
+#define	SIGUSR1 25	/* user defined signal 1 */
+#define	SIGUSR2 26	/* user defined signal 2 */
+
+/* Real-Time Signals Range, P1003.1b-1993, p. 61
+   NOTE: By P1003.1b-1993, this should be at least RTSIG_MAX
+         (which is a minimum of 8) signals.
+ */
+#define SIGRTMIN 27
+#define SIGRTMAX 31
+#define __SIGFIRSTNOTRT SIGHUP
+#define __SIGLASTNOTRT  SIGUSR2
+
+#define NSIG	32      /* signal 0 implied */
+
+#elif defined(__svr4__)
+/* svr4 specifics. different signals above 15, and sigaction. */
+#define	SIGUSR1	16
+#define SIGUSR2	17
+#define SIGCLD	18
+#define	SIGPWR	19
+#define SIGWINCH 20
+#define	SIGPOLL	22	/* 20 for x.out binaries!!!! */
+#define	SIGSTOP	23	/* sendable stop signal not from tty */
+#define	SIGTSTP	24	/* stop signal from tty */
+#define	SIGCONT	25	/* continue a stopped process */
+#define	SIGTTIN	26	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	27	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define NSIG	28	
+#else
+#define	SIGURG	16	/* urgent condition on IO channel */
+#define	SIGSTOP	17	/* sendable stop signal not from tty */
+#define	SIGTSTP	18	/* stop signal from tty */
+#define	SIGCONT	19	/* continue a stopped process */
+#define	SIGCHLD	20	/* to parent on child stop or exit */
+#define	SIGCLD	20	/* System V name for SIGCHLD */
+#define	SIGTTIN	21	/* to readers pgrp upon background tty read */
+#define	SIGTTOU	22	/* like TTIN for output if (tp->t_local&LTOSTOP) */
+#define	SIGIO	23	/* input/output possible signal */
+#define	SIGPOLL	SIGIO	/* System V name for SIGIO */
+#define	SIGXCPU	24	/* exceeded CPU time limit */
+#define	SIGXFSZ	25	/* exceeded file size limit */
+#define	SIGVTALRM 26	/* virtual time alarm */
+#define	SIGPROF	27	/* profiling time alarm */
+#define	SIGWINCH 28	/* window changed */
+#define	SIGLOST 29	/* resource lost (eg, record-lock lost) */
+#define	SIGUSR1 30	/* user defined signal 1 */
+#define	SIGUSR2 31	/* user defined signal 2 */
+#define NSIG	32      /* signal 0 implied */
+#endif
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#if defined(__CYGWIN__)
+#if __XSI_VISIBLE >= 4 || __POSIX_VISIBLE >= 200809
+#include <sys/ucontext.h>
+#endif
+#endif
+
+#ifndef _SIGNAL_H_
+/* Some applications take advantage of the fact that <sys/signal.h>
+ * and <signal.h> are equivalent in glibc.  Allow for that here.  */
+#include <signal.h>
+#endif
+#endif /* _SYS_SIGNAL_H */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/stat.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,188 @@
+#ifndef	_SYS_STAT_H
+#define	_SYS_STAT_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <time.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <sys/_timespec.h>
+
+/* dj's stat defines _STAT_H_ */
+#ifndef _STAT_H_
+
+/* It is intended that the layout of this structure not change when the
+   sizes of any of the basic types change (short, int, long) [via a compile
+   time option].  */
+
+#ifdef __CYGWIN__
+#include <cygwin/stat.h>
+#ifdef _COMPILING_NEWLIB
+#define stat64 stat
+#endif
+#else
+struct	stat 
+{
+  dev_t		st_dev;
+  ino_t		st_ino;
+  mode_t	st_mode;
+  nlink_t	st_nlink;
+  uid_t		st_uid;
+  gid_t		st_gid;
+  dev_t		st_rdev;
+  off_t		st_size;
+#if defined(__svr4__) && !defined(__PPC__) && !defined(__sun__)
+  time_t	st_atime;
+  time_t	st_mtime;
+  time_t	st_ctime;
+#else
+  struct timespec st_atim;
+  struct timespec st_mtim;
+  struct timespec st_ctim;
+  blksize_t     st_blksize;
+  blkcnt_t	st_blocks;
+#if !defined(__rtems__)
+  long		st_spare4[2];
+#endif
+#endif
+};
+
+#if !(defined(__svr4__) && !defined(__PPC__) && !defined(__sun__)) && !defined(__cris__)
+#define st_atime st_atim.tv_sec
+#define st_ctime st_ctim.tv_sec
+#define st_mtime st_mtim.tv_sec
+#endif
+
+#endif
+
+#define	_IFMT		0170000	/* type of file */
+#define		_IFDIR	0040000	/* directory */
+#define		_IFCHR	0020000	/* character special */
+#define		_IFBLK	0060000	/* block special */
+#define		_IFREG	0100000	/* regular */
+#define		_IFLNK	0120000	/* symbolic link */
+#define		_IFSOCK	0140000	/* socket */
+#define		_IFIFO	0010000	/* fifo */
+#define		_IFPORT	0160000	/* message port */
+#define		_IFIRQ	0150000	/* interrupt */
+
+#define 	S_BLKSIZE  1024 /* size of a block */
+
+#define	S_ISUID		0004000	/* set user id on execution */
+#define	S_ISGID		0002000	/* set group id on execution */
+#define	S_ISVTX		0001000	/* save swapped text even after use */
+#if __BSD_VISIBLE
+#define	S_IREAD		0000400	/* read permission, owner */
+#define	S_IWRITE 	0000200	/* write permission, owner */
+#define	S_IEXEC		0000100	/* execute/search permission, owner */
+#define	S_ENFMT 	0002000	/* enforcement-mode locking */
+#endif	/* !_BSD_VISIBLE */
+
+#define	S_IFMT		_IFMT
+#define	S_IFDIR		_IFDIR
+#define	S_IFCHR		_IFCHR
+#define	S_IFBLK		_IFBLK
+#define	S_IFREG		_IFREG
+#define	S_IFLNK		_IFLNK
+#define	S_IFSOCK	_IFSOCK
+#define	S_IFIFO		_IFIFO
+#define	S_IFPORT  _IFPORT /* message port */
+#define	S_IFIRQ	  _IFIRQ  /* interrupt */
+
+
+#ifdef _WIN32
+/* The Windows header files define _S_ forms of these, so we do too
+   for easier portability.  */
+#define _S_IFMT		_IFMT
+#define _S_IFDIR	_IFDIR
+#define _S_IFCHR	_IFCHR
+#define _S_IFIFO	_IFIFO
+#define _S_IFREG	_IFREG
+#define _S_IREAD	0000400
+#define _S_IWRITE	0000200
+#define _S_IEXEC	0000100
+#endif
+
+#define	S_IRWXU 	(S_IRUSR | S_IWUSR | S_IXUSR)
+#define		S_IRUSR	0000400	/* read permission, owner */
+#define		S_IWUSR	0000200	/* write permission, owner */
+#define		S_IXUSR 0000100/* execute/search permission, owner */
+#define	S_IRWXG		(S_IRGRP | S_IWGRP | S_IXGRP)
+#define		S_IRGRP	0000040	/* read permission, group */
+#define		S_IWGRP	0000020	/* write permission, grougroup */
+#define		S_IXGRP 0000010/* execute/search permission, group */
+#define	S_IRWXO		(S_IROTH | S_IWOTH | S_IXOTH)
+#define		S_IROTH	0000004	/* read permission, other */
+#define		S_IWOTH	0000002	/* write permission, other */
+#define		S_IXOTH 0000001/* execute/search permission, other */
+
+#if __BSD_VISIBLE
+#define ACCESSPERMS (S_IRWXU | S_IRWXG | S_IRWXO) /* 0777 */
+#define ALLPERMS (S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO) /* 07777 */
+#define DEFFILEMODE (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH) /* 0666 */
+#endif
+
+#define	S_ISBLK(m)	(((m)&_IFMT) == _IFBLK)
+#define	S_ISCHR(m)	(((m)&_IFMT) == _IFCHR)
+#define	S_ISDIR(m)	(((m)&_IFMT) == _IFDIR)
+#define	S_ISFIFO(m)	(((m)&_IFMT) == _IFIFO)
+#define	S_ISREG(m)	(((m)&_IFMT) == _IFREG)
+#define	S_ISLNK(m)	(((m)&_IFMT) == _IFLNK)
+#define	S_ISSOCK(m)	(((m)&_IFMT) == _IFSOCK)
+#define	S_ISPORT(m)	(((m)&_IFMT) == _IFPORT)
+#define	S_ISIRQ(m)	(((m)&_IFMT) == _IFIRQ)
+
+
+#if defined(__CYGWIN__)
+/* Special tv_nsec values for futimens(2) and utimensat(2). */
+#define UTIME_NOW	-2L
+#define UTIME_OMIT	-1L
+#endif
+
+int	chmod (const char *__path, mode_t __mode );
+int     fchmod (int __fd, mode_t __mode);
+int	fstat (int __fd, struct stat *__sbuf );
+int	mkdir (const char *_path, mode_t __mode );
+int	mkfifo (const char *__path, mode_t __mode );
+int	stat (const char *__restrict __path, struct stat *__restrict __sbuf );
+mode_t	umask (mode_t __mask );
+int mknod2 (char *path, uint32_t flags, struct stat *stat);
+
+#if defined (__SPU__) || defined(__rtems__) || defined(__CYGWIN__) && !defined(__INSIDE_CYGWIN__)
+int	lstat (const char *__restrict __path, struct stat *__restrict __buf );
+int	mknod (const char *__path, mode_t __mode, dev_t __dev );
+#endif
+
+#if __ATFILE_VISIBLE && !defined(__INSIDE_CYGWIN__)
+int	fchmodat (int, const char *, mode_t, int);
+int	fstatat (int, const char *__restrict , struct stat *__restrict, int);
+int	mkdirat (int, const char *, mode_t);
+int	mkfifoat (int, const char *, mode_t);
+int	mknodat (int, const char *, mode_t, dev_t);
+int	utimensat (int, const char *, const struct timespec *, int);
+#endif
+#if __POSIX_VISIBLE >= 200809 && !defined(__INSIDE_CYGWIN__)
+int	futimens (int, const struct timespec *);
+#endif
+
+/* Provide prototypes for most of the _<systemcall> names that are
+   provided in newlib for some compilers.  */
+#ifdef _COMPILING_NEWLIB
+int	_fstat (int __fd, struct stat *__sbuf );
+int	_stat (const char *__restrict __path, struct stat *__restrict __sbuf );
+int	_mkdir (const char *_path, mode_t __mode );
+#ifdef __LARGE64_FILES
+struct stat64;
+int	_stat64 (const char *__restrict __path, struct stat64 *__restrict __sbuf );
+int	_fstat64 (int __fd, struct stat64 *__sbuf );
+#endif
+#endif
+
+#endif /* !_STAT_H_ */
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STAT_H */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/statvfs.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,56 @@
+#ifndef	_SYS_STATVFS_H
+#define	_SYS_STATVFS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <_ansi.h>
+#include <time.h>
+#include <sys/types.h>
+
+
+struct statvfs 
+{
+  int f_type;
+  char *f_mntfromname;
+  char *f_mntonname;  
+	unsigned long f_bsize;    /* File system block size */
+	unsigned long f_frsize;   /* Fundamental file system block size */
+	fsblkcnt_t    f_blocks;   /* Num blocks in units of f_frsize */
+	fsblkcnt_t    f_bfree;    /* Num free blocks */
+	fsblkcnt_t    f_bavail;   /* Num free blocks for non-privileged process */
+	fsfilcnt_t    f_files;    /* Total number of file serial numbers */ 
+	fsfilcnt_t    f_ffree;    /* Total number of free file serial numbers */ 
+	fsfilcnt_t    f_favail;   /* ... for non-privileged process */ 
+	unsigned long f_fsid;     /* File system ID */ 
+	unsigned long f_flag;     /* Bit mask of f_flag values */  
+	unsigned long f_namemax ; /* Maximum filename length */ 
+};
+
+
+struct statfs 
+{
+  int f_type;
+  char *f_mntfromname;
+  char *f_mntonname;  
+	unsigned long f_bsize;    /* File system block size */
+	unsigned long f_frsize;   /* Fundamental file system block size */
+	fsblkcnt_t    f_blocks;   /* Num blocks in units of f_frsize */
+	fsblkcnt_t    f_bfree;    /* Num free blocks */
+	fsblkcnt_t    f_bavail;   /* Num free blocks for non-privileged process */
+	fsfilcnt_t    f_files;    /* Total number of file serial numbers */ 
+	fsfilcnt_t    f_ffree;    /* Total number of free file serial numbers */ 
+	fsfilcnt_t    f_favail;   /* ... for non-privileged process */ 
+	unsigned long f_fsid;     /* File system ID */ 
+	unsigned long f_flag;     /* Bit mask of f_flag values */  
+	unsigned long f_namemax ; /* Maximum filename length */ 
+};
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* _SYS_STATVFS_H */
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syscalls.h	2022-07-02 13:10:59.444940803 +0100
@@ -0,0 +1,214 @@
+#ifndef _SYS_KSYSCALLS_H
+#define _SYS_KSYSCALLS_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <sys/types.h>
+#include <stdint.h>
+#include <stdbool.h>
+#include <sys/stat.h>
+#include <sys/execargs.h>
+#include <sys/signal.h>
+#include <poll.h>
+
+
+typedef signed char 		int8;
+typedef unsigned char 		uint8;
+typedef signed short		int16;
+typedef unsigned short		uint16;
+typedef signed long			int32;
+typedef unsigned long		uint32;
+typedef signed long long 	int64;
+typedef unsigned long long 	uint64;
+typedef signed long			err32;
+typedef uint32_t				vm_offset;
+typedef uint32_t				vm_size;
+typedef unsigned char		bits8_t;
+typedef unsigned short		bits16_t;
+typedef unsigned long		bits32_t;
+typedef long long			uuid_t;
+
+
+
+/*
+ * Exit()/Join() Status
+ */
+#define EXIT_OK                 0
+#define EXIT_ERROR              1
+#define EXIT_FATAL              2
+#define EXIT_KILLED             3
+
+
+/*
+ * Time related structures
+ */
+struct TimeVal
+{
+	long long seconds;
+	long microseconds;
+};
+
+
+struct InterruptAPI;
+
+
+/*
+ * Timer types
+ */
+#define TIMER_TYPE_RELATIVE     0
+#define TIMER_TYPE_ABSOLUTE     1
+
+
+/*
+ * VirtualAlloc() protections
+ */
+#define PROT_NONE			    0
+#define PROT_READ			    (1<<0)
+#define PROT_WRITE			    (1<<1)
+#define PROT_EXEC			    (1<<2)
+#define PROT_ALL			    (PROT_READ | PROT_WRITE | PROT_EXEC)
+#define PROT_READWRITE 		    (PROT_READ | PROT_WRITE)
+#define PROT_READEXEC		    (PROT_READ | PROT_EXEC)
+
+#define MAP_FIXED				(1<<3)
+#define MAP_WIRED				(1<<4)
+#define MAP_NOX64				(1<<5)
+#define MAP_BELOW16M			(1<<6)
+#define MAP_BELOW4G				(1<<7)
+
+#define CACHE_DEFAULT	 		(0<<8)
+#define CACHE_WRITEBACK	 		(1<<8)
+#define CACHE_WRITETHRU	 		(2<<8)
+#define CACHE_WRITECOMBINE 		(3<<8)
+#define CACHE_UNCACHEABLE  		(4<<8)
+#define CACHE_WEAKUNCACHEABLE	(5<<8)
+#define CACHE_WRITEPROTECT		(6<<8)
+
+#define PROT_MASK				0x00000007
+#define CACHE_MASK   		0x00000f00
+
+
+
+struct stat;
+
+/*
+ * System call prototypes
+ */
+
+void _swi_debug (char *str);
+
+int _swi_fork (void);
+int _swi_exec (const char *filename, struct execargs *args);
+void _swi_exit (int status);
+int _swi_waitpid (int pid, int *loc_stat, int options);
+int _swi_kill (int pid, int sig);
+int _swi_setschedparams (int policy, int priority);
+
+void *_swi_virtualalloc (void *addr, size_t size, bits32_t flags);
+void *_swi_virtualallocphys (void *addr, size_t size, bits32_t flags, void *phys_addr);
+int _swi_virtualfree (void *addr, size_t sz);
+int _swi_virtualprotect (void *addr, size_t sz, bits32_t flags);
+void *_swi_virtualtophysaddr(void *addr);
+
+int _swi_close (int handle);
+
+int _swi_createtimer (void);
+int _swi_settimer (int handle, int type, struct TimeVal *tv);
+
+int _swi_createinterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api));
+int _swi_maskinterrupt (int irq);
+int _swi_unmaskinterrupt (int irq);
+
+int _swi_sleep(int seconds);
+int _swi_alarm(int seconds);
+
+int _swi_opendir(const char *path);
+ssize_t _swi_readdir (int fd, void *buf, size_t buf_sz);
+int _swi_rewinddir (int fd);
+
+off_t _swi_lseek(int fd, off_t offs, int whence);
+off64_t _swi_lseek64(int fd, off64_t *offs, int whence);
+
+int _swi_pivotroot(const char *new_root, const char *old_root);
+
+int _swi_receivemsg(int fd, int *ino, void *buf, size_t buf_sz);
+int _swi_replymsg(int fd, int ino, int status);
+int _swi_readmsg(int fd, int ino, void *buf, size_t buf_sz);
+int _swi_writemsg(int fd, int ino, void *buf, size_t buf_sz);
+int _swi_seekmsg(int fd, int ino, off_t offset);
+
+int _swi_stat(char *path, struct stat *stat);
+int _swi_fstat(int fd, struct stat *stat);
+
+int _swi_poll(struct pollfd *pfds, nfds_t nfds, int timeout);
+
+int _swi_signalnotify(int fd, int ino, int signal);
+int _swi_pollnotify(int fd, int ino, short events);
+
+int _swi_chdir(char *path);
+int _swi_fchdir(int fd);
+
+int _swi_fcntl(int fd, int cmd, int arg);
+int _swi_isatty(int fd);
+
+int _swi_fsync(int fd);
+int _swi_sync(void);
+int _swi_chmod(char *_path, mode_t mode);
+int _swi_chown(char *_path, uid_t uid, gid_t gid);
+
+int _swi_symlink(char *_path, char *_link);
+int _swi_readlink(char *_path, char *_link, size_t link_size);
+
+int _swi_ioctl(int fd, int cmd, void *arg);
+
+int _swi_sigprocmask(int how, const sigset_t *set, sigset_t *oset);
+int _swi_sigaction(int sig, const struct sigaction *act, struct sigaction *oact);
+int _swi_sigpending(sigset_t *set);
+int _swi_sigsuspend(const sigset_t *set);
+
+int _swi_mknod(char *_path, uint32_t flags, struct stat *stat);
+
+/*
+ * unistd.h 64-bit syscalls.
+ */
+ 
+off64_t lseek64 (int fd, off64_t offset, int whence);
+
+/*
+ *
+ */
+void *virtualalloc (void *addr, size_t size, bits32_t flags);
+void *virtualallocphys (void *addr, size_t size, bits32_t flags, void *phys_addr);
+int virtualfree (void *addr, size_t sz);
+int virtualprotect (void *addr, size_t sz, bits32_t flags);
+void *virtualtophysaddr(void *addr);
+
+/*
+ *
+ */
+int receivemsg(int fd, int *ino, void *buf, size_t buf_sz);
+int replymsg(int fd, int ino, int status);
+int readmsg(int fd, int ino, void *buf, size_t buf_sz);
+int writemsg(int fd, int ino, void *buf, size_t buf_sz);
+int seekmsg(int fd, int ino, off_t offset);
+
+
+/*
+ *
+ */
+
+int createinterrupt (int irq, void (*interrupt_handler)(int irq, struct InterruptAPI *api));
+int maskinterrupt (int irq);
+int unmaskinterrupt (int irq);
+
+
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/syslimits.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,47 @@
+/* "sys/syslimits.h"
+ * 
+ * Values in this file should match those in "limits.h"
+ */
+ 
+#ifndef _SYS_SYSLIMITS_H_
+#define _SYS_SYSLIMITS_H_
+
+
+
+
+/*
+ * Might be useful to make them match limits.h
+ */
+
+#define	ARG_MAX			 4096
+
+#ifndef CHILD_MAX
+#define	CHILD_MAX		    6
+#endif
+
+#define	LINK_MAX		    8
+#define	MAX_CANON		  255
+#define	MAX_INPUT		  255
+#define	NAME_MAX		  255
+#define	NGROUPS_MAX		   16
+
+#ifndef OPEN_MAX
+#define	OPEN_MAX		   64
+#endif
+
+#define	PATH_MAX		 1024
+#define	PIPE_BUF		  512
+#define	IOV_MAX			 1024
+#define	BC_BASE_MAX		   99
+#define	BC_DIM_MAX		 2048
+#define	BC_SCALE_MAX	   99
+#define	BC_STRING_MAX	 1000
+#define	COLL_WEIGHTS_MAX    0
+#define	EXPR_NEST_MAX	   32
+#define	LINE_MAX		 2048
+#define	RE_DUP_MAX		  255
+
+
+
+
+#endif /* !_SYS_SYSLIMITS_H_ */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/termios.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,245 @@
+/* termios.h
+ *
+ * termios.h is identical to /sys/termios.h.  Some applications appear to use
+ * different source directories, so this file exists in both directories.
+ */
+
+#ifndef _SYS_TERMIOS_H_
+#define _SYS_TERMIOS_H_
+
+#include <sys/types.h>
+#include <sys/cdefs.h>
+
+
+
+
+/*
+ * Control Characters in termios.c_cc[]
+ */
+ 
+#define	VEOF		0
+#define	VEOL		1
+#define	VEOL2		2
+#define	VERASE		3
+#define VWERASE 	4
+#define VKILL		5
+#define	VREPRINT 	6
+#define VINTR		8
+#define VQUIT		9
+#define VSUSP		10
+#define VDSUSP		11
+#define VSTART		12
+#define VSTOP		13
+#define	VLNEXT		14
+#define	VDISCARD	15
+#define VMIN		16
+#define VTIME		17
+#define VSTATUS		18
+#define	NCCS		20
+
+
+
+
+/*
+ * Input flags
+ */
+
+#define	IGNBRK		0x00000001
+#define	BRKINT		0x00000002
+#define	IGNPAR		0x00000004
+#define	PARMRK		0x00000008
+#define	INPCK		0x00000010
+#define	ISTRIP		0x00000020
+#define	INLCR		0x00000040
+#define	IGNCR		0x00000080
+#define	ICRNL		0x00000100
+#define	IXON		0x00000200
+#define	IXOFF		0x00000400
+#define	IXANY		0x00000800
+#define IMAXBEL		0x00002000
+
+
+
+
+/*
+ * Output flags
+ */
+
+#define	OPOST		0x00000001
+#define ONLCR		0x00000002
+#define OXTABS		0x00000004
+#define ONOEOT		0x00000008
+#define OCRNL		0x00000010
+#define ONOCR		0x00000020
+#define ONLRET		0x00000040
+
+
+
+
+/*
+ * Control flags - hardware control of terminal
+ */
+
+#define	CIGNORE		0x00000001
+#define CSIZE		0x00000300
+#define CS5		    0x00000000
+#define CS6		    0x00000100
+#define CS7		    0x00000200
+#define CS8		    0x00000300
+#define CSTOPB		0x00000400
+#define CREAD		0x00000800
+#define PARENB		0x00001000
+#define PARODD		0x00002000
+#define HUPCL		0x00004000
+#define CLOCAL		0x00008000
+#define	CRTSCTS		0x00010000
+#define	CRTS_IFLOW	CRTSCTS
+#define	CCTS_OFLOW	CRTSCTS
+#define	CDTRCTS		0x00020000
+#define	MDMBUF		0x00100000
+#define	CHWFLOW		(MDMBUF|CRTSCTS|CDTRCTS)
+
+
+
+
+/*
+ * Local flags 
+ */
+
+#define	ECHOKE		0x00000001
+#define	ECHOE		0x00000002
+#define	ECHOK		0x00000004
+#define ECHO		0x00000008
+#define	ECHONL		0x00000010
+#define	ECHOPRT		0x00000020
+#define ECHOCTL  	0x00000040
+#define	ISIG		0x00000080
+#define	ICANON		0x00000100
+#define ALTWERASE	0x00000200
+#define	IEXTEN		0x00000400
+#define EXTPROC     0x00000800
+#define TOSTOP		0x00400000
+#define FLUSHO		0x00800000
+#define	NOKERNINFO	0x02000000
+#define PENDIN		0x20000000
+#define	NOFLSH		0x80000000
+
+
+
+
+/*
+ * struct termios and types
+ */
+
+typedef unsigned int	tcflag_t;
+typedef unsigned char	cc_t;
+typedef unsigned int	speed_t;
+
+struct termios
+{
+	tcflag_t c_iflag;
+	tcflag_t c_oflag;
+	tcflag_t c_cflag;
+	tcflag_t c_lflag;
+	cc_t     c_cc[NCCS];
+	int      c_ispeed;
+	int      c_ospeed;
+};
+
+
+
+
+/*
+ * tcsetattr() action commands
+ */
+ 
+#define	TCSANOW		0
+#define	TCSADRAIN	1
+#define	TCSAFLUSH	2
+#define TCSASOFT	0x10
+
+
+
+
+/*
+ * Standard speeds
+ */
+
+#define B0	0
+#define B50	50
+#define B75	75
+#define B110	110
+#define B134	134
+#define B150	150
+#define B200	200
+#define B300	300
+#define B600	600
+#define B1200	1200
+#define	B1800	1800
+#define B2400	2400
+#define B4800	4800
+#define B9600	9600
+#define B19200	19200
+#define B38400	38400
+#define B7200	7200
+#define B14400	14400
+#define B28800	28800
+#define B57600	57600
+#define B76800	76800
+#define B115200	115200
+#define B230400	230400
+#define EXTA	19200
+#define EXTB	38400
+
+
+/*
+ * Line Control
+ */
+
+#define	TCIFLUSH	1
+#define	TCOFLUSH	2
+#define TCIOFLUSH	3
+#define	TCOOFF		1
+#define	TCOON		2
+#define TCIOFF		3
+#define TCION		4
+
+
+/*
+ * Ioctls
+ */
+ 
+#define TCSETS      (('T'<<8) | 1)
+#define TCSETSW     (('T'<<8) | 2)
+#define TCSETSF     (('T'<<8) | 3)
+#define TCGETS      (('T'<<8) | 4)
+
+#define TIOCGPGRP   (('T'<<8) | 5)
+#define TIOCSPGRP   (('T'<<8) | 6)
+#define TCXONC      (('T'<<8) | 7)
+#define TCFLSH      (('T'<<8) | 8)
+
+
+/*
+ * Prototypes
+ */
+
+int	cfsetispeed (struct termios *termios_p, speed_t speed);
+int	cfsetospeed (struct termios *termios_p, speed_t speed);
+int	tcgetattr (int fd, struct termios *termios_p);
+int	tcsetattr (int fd, int actions, const struct termios *termios_p);
+int	tcdrain (int fd);
+int	tcflow (int fd, int actions);
+int	tcflush (int fd, int queue_sel);
+int	tcsendbreak (int fd, int duration);
+pid_t tcgetsid (int fd);
+speed_t	cfgetispeed (const struct termios *termios_p);
+speed_t	cfgetospeed (const struct termios *termios_p);
+void cfmakeraw (struct termios *termios_p);
+int	cfsetspeed (struct termios *termios_p, speed_t speed);
+
+
+
+
+#endif /* !_SYS_TERMIOS_H_ */
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sys/utime.h	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,32 @@
+/*
+ *  $Id: utime.h,v 1.1 2002/11/07 19:27:36 jjohnstn Exp $
+ */
+
+#ifndef __UTIME_h__
+#define __UTIME_h__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *  POSIX 1003.1b 5.6.6 Set File Access and Modification Times
+ */
+
+struct utimbuf {
+  time_t  actime;   /* Access time */
+  time_t  modtime;  /* Modification time */
+};
+
+/* Functions */
+
+int utime(
+  const char           *path,
+  const struct utimbuf *times
+);
+
+#ifdef __cplusplus
+};
+#endif
+
+#endif /* _SYS_UTIME_H */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/syscall.S third_party/newlib-3.2.0/newlib/libc/sys/arm/syscall.S
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/syscall.S	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/syscall.S	2022-06-29 14:50:02.889945384 +0100
@@ -0,0 +1,126 @@
+.extern __real_set_errno
+
+.text
+
+#define SYSCALL_SWI(name, idx)  \
+.global name;                   \
+name:;                          \
+    swi idx;                    \
+    bx lr;
+
+#define SYSCALL0 SYSCALL_SWI
+#define SYSCALL1 SYSCALL_SWI
+#define SYSCALL2 SYSCALL_SWI
+#define SYSCALL3 SYSCALL_SWI
+#define SYSCALL4 SYSCALL_SWI
+
+SYSCALL1( _swi_debug, 1)
+SYSCALL1( _swi_fork, 2)
+SYSCALL1( _swi_exit, 3)
+SYSCALL3( _swi_waitpid, 4)
+SYSCALL0( _swi_kill, 5)
+SYSCALL2( _swi_setschedparams, 6)
+
+SYSCALL1( _swi_sleep, 7)
+SYSCALL1( _swi_alarm, 8)
+SYSCALL2( _swi_settimer, 9)
+SYSCALL0( _swi_gettimeofday, 10)
+SYSCALL1( _swi_settimeofday, 11)
+
+SYSCALL3( _swi_virtualalloc, 12)
+SYSCALL4( _swi_virtualallocphys, 13)
+SYSCALL2( _swi_virtualfree, 14)
+SYSCALL2( _swi_virtualprotect, 15)
+
+SYSCALL1( _swi_createinterrupt, 16)
+SYSCALL1( _swi_maskinterrupt, 17)
+SYSCALL1( _swi_unmaskinterrupt, 18)
+
+SYSCALL3( _swi_poll, 19)
+
+SYSCALL2( _swi_exec, 20)
+
+SYSCALL4( _swi_mount, 21)
+SYSCALL1( _swi_unmount, 22)
+
+SYSCALL3( _swi_seekmsg, 23)
+
+SYSCALL4( _swi_receivemsg, 24)
+SYSCALL3( _swi_replymsg, 25)
+SYSCALL4( _swi_readmsg, 26)
+SYSCALL4( _swi_writemsg, 27)
+
+SYSCALL3( _swi_open, 28)
+SYSCALL1( _swi_close, 29)
+SYSCALL1( _swi_dup, 30)
+SYSCALL1( _swi_dup2, 31)
+
+SYSCALL3( _swi_read, 32)
+SYSCALL3( _swi_write, 33)
+SYSCALL3( _swi_lseek, 34)
+SYSCALL3( _swi_lseek64, 35)
+
+SYSCALL2( _swi_truncate, 36)
+SYSCALL1( _swi_unlink, 37)
+
+SYSCALL2( _swi_mkdir, 38)
+SYSCALL1( _swi_opendir, 39)
+SYSCALL3( _swi_readdir, 40)
+SYSCALL1( _swi_rewinddir, 41)
+SYSCALL1( _swi_rmdir, 42)
+
+SYSCALL2( _swi_rename, 43)
+
+SYSCALL1( _swi_pipe, 44)
+SYSCALL1( _swi_socketpair, 45)
+
+SYSCALL1( _swi_chdir, 46)
+SYSCALL1( _swi_fchdir, 47)
+
+SYSCALL2( _swi_stat, 48)
+SYSCALL2( _swi_fstat, 49)
+    
+SYSCALL2( _swi_symlink, 50)
+SYSCALL2( _swi_readlink, 51)
+
+SYSCALL2( _swi_chmod, 52)
+SYSCALL2( _swi_chown, 53)
+SYSCALL2( _swi_access, 54)
+SYSCALL1( _swi_umask, 55)
+
+SYSCALL0( _swi_getpid, 56)
+SYSCALL0( _swi_getppid, 57)
+SYSCALL0( _swi_getuid, 58)
+SYSCALL0( _swi_getgid, 59)
+SYSCALL0( _swi_geteuid, 60)
+SYSCALL0( _swi_getegid, 61)
+SYSCALL1( _swi_setuid, 62)
+SYSCALL1( _swi_setgid, 63)
+
+SYSCALL0( _swi_setpgrp, 64)
+SYSCALL0( _swi_getpgrp, 65)
+
+SYSCALL1( _swi_virtualtophysaddr, 66)
+
+SYSCALL3( _swi_signalnotify, 67)
+
+SYSCALL3( _swi_pollnotify, 68)
+
+SYSCALL2( _swi_pivotroot, 69)
+
+SYSCALL3( _swi_fcntl, 70)
+SYSCALL1( _swi_isatty, 71)
+SYSCALL3( _swi_ioctl, 72)
+
+SYSCALL0( _swi_sync, 73)
+SYSCALL1( _swi_fsync, 74)
+
+SYSCALL3( _swi_sigaction, 75)
+SYSCALL3( _swi_sigprocmask, 76)
+SYSCALL1( _swi_sigpending, 77)
+SYSCALL1( _swi_sigsuspend, 78)
+SYSCALL3( _swi_mknod, 79)
+
+SYSCALL2( _swi_movemount, 80)
+SYSCALL1( _swi_chroot, 81)
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c third_party/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/syscalls.c	1970-01-01 01:00:00.000000000 +0100
@@ -1,716 +0,0 @@
-/* Support files for GNU libc.  Files in the system namespace go here.
-   Files in the C namespace (ie those that do not start with an
-   underscore) go in .c.  */
-
-#include <_ansi.h>
-#include <sys/types.h>
-#include <sys/stat.h>
-#include <sys/fcntl.h>
-#include <stdio.h>
-#include <time.h>
-#include <sys/time.h>
-#include <sys/times.h>
-#include <errno.h>
-#include <reent.h>
-#include <signal.h>
-#include <unistd.h>
-#include <sys/wait.h>
-#include "swi.h"
-
-/* Forward prototypes.  */
-int	_system		(const char *);
-int	_rename		(const char *, const char *);
-int	_isatty		(int);
-clock_t _times		(struct tms *);
-int	_gettimeofday	(struct timeval *, void *);
-void	_raise		(void);
-int	_unlink		(const char *);
-int	_link		(const char *, const char *);
-int	_stat		(const char *, struct stat *);
-int	_fstat		(int, struct stat *);
-void *	_sbrk		(ptrdiff_t);
-pid_t	_getpid		(void);
-int	_kill		(int, int);
-void	_exit		(int);
-int	_close		(int);
-int	_swiclose	(int);
-int	_open		(const char *, int, ...);
-int	_swiopen	(const char *, int);
-int	_write		(int, const void *, size_t);
-int	_swiwrite	(int, const void *, size_t);
-_off_t	_lseek		(int, _off_t, int);
-_off_t	_swilseek	(int, _off_t, int);
-int	_read		(int, void *, size_t);
-int	_swiread	(int, void *, size_t);
-void	initialise_monitor_handles (void);
-
-static int	wrap		(int);
-static int	error		(int);
-static int	get_errno	(void);
-static int	remap_handle	(int);
-static int	findslot	(int);
-static int	_kill_shared	(int, int, int) __attribute__((__noreturn__));
-
-/* Register name faking - works in collusion with the linker.  */
-register char * stack_ptr asm ("sp");
-
-
-/* following is copied from libc/stdio/local.h to check std streams */
-extern void   __sinit (struct _reent *);
-#define CHECK_INIT(ptr) \
-  do						\
-    {						\
-      if ((ptr) && !(ptr)->__sdidinit)		\
-	__sinit (ptr);				\
-    }						\
-  while (0)
-
-/* Adjust our internal handles to stay away from std* handles.  */
-#define FILE_HANDLE_OFFSET (0x20)
-
-static int monitor_stdin;
-static int monitor_stdout;
-static int monitor_stderr;
-
-/* Struct used to keep track of the file position, just so we
-   can implement fseek(fh,x,SEEK_CUR).  */
-typedef struct
-{
-  int handle;
-  off_t pos;
-}
-poslog;
-
-#define MAX_OPEN_FILES 20
-static poslog openfiles [MAX_OPEN_FILES];
-
-static int
-findslot (int fh)
-{
-  int i;
-  for (i = 0; i < MAX_OPEN_FILES; i ++)
-    if (openfiles[i].handle == fh)
-      break;
-  return i;
-}
-
-/* Function to convert std(in|out|err) handles to internal versions.  */
-static int
-remap_handle (int fh)
-{
-  CHECK_INIT(_REENT);
-
-  if (fh == STDIN_FILENO)
-    return monitor_stdin;
-  if (fh == STDOUT_FILENO)
-    return monitor_stdout;
-  if (fh == STDERR_FILENO)
-    return monitor_stderr;
-
-  return fh - FILE_HANDLE_OFFSET;
-}
-
-void
-initialise_monitor_handles (void)
-{
-  int i;
-  
-  /* Open the standard file descriptors by opening the special
-   * teletype device, ":tt", read-only to obtain a descriptor for
-   * standard input and write-only to obtain a descriptor for standard
-   * output. Finally, open ":tt" in append mode to obtain a descriptor
-   * for standard error. Since this is a write mode, most kernels will
-   * probably return the same value as for standard output, but the
-   * kernel can differentiate the two using the mode flag and return a
-   * different descriptor for standard error.
-   */
-
-#ifdef ARM_RDI_MONITOR
-  int volatile block[3];
-
-  block[0] = (int) ":tt";
-  block[2] = 3;     /* length of filename */
-  block[1] = 0;     /* mode "r" */
-  monitor_stdin = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
-
-  block[0] = (int) ":tt";
-  block[2] = 3;     /* length of filename */
-  block[1] = 4;     /* mode "w" */
-  monitor_stdout = monitor_stderr
-    = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
-#else
-  int fh;
-  const char * name;
-
-  name = ":tt";
-  asm ("mov r0,%2; mov r1, #0; swi %a1; mov %0, r0"
-       : "=r"(fh)
-       : "i" (SWI_Open),"r"(name)
-       : "r0","r1");
-  monitor_stdin = fh;
-
-  name = ":tt";
-  asm ("mov r0,%2; mov r1, #4; swi %a1; mov %0, r0"
-       : "=r"(fh)
-       : "i" (SWI_Open),"r"(name)
-       : "r0","r1");
-  monitor_stdout = monitor_stderr = fh;
-#endif
-
-  for (i = 0; i < MAX_OPEN_FILES; i ++)
-    openfiles[i].handle = -1;
-
-  openfiles[0].handle = monitor_stdin;
-  openfiles[0].pos = 0;
-  openfiles[1].handle = monitor_stdout;
-  openfiles[1].pos = 0;
-}
-
-static int
-get_errno (void)
-{
-#ifdef ARM_RDI_MONITOR
-  return do_AngelSWI (AngelSWI_Reason_Errno, NULL);
-#else
-  register int r0 asm("r0");
-  asm ("swi %a1" : "=r"(r0) : "i" (SWI_GetErrno));
-  return r0;
-#endif
-}
-
-/* Set errno and return result. */
-static int
-error (int result)
-{
-  errno = get_errno ();
-  return result;
-}
-
-static int
-wrap (int result)
-{
-  if (result == -1)
-    return error (-1);
-  return result;
-}
-
-/* file, is a valid user file handle.
-   ptr, is a null terminated string.
-   len, is the length in bytes to read. 
-   Returns the number of bytes *not* written. */
-int
-_swiread (int file, void * ptr, size_t len)
-{
-  int fh = remap_handle (file);
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-
-  block[0] = fh;
-  block[1] = (int) ptr;
-  block[2] = (int) len;
-
-  return do_AngelSWI (AngelSWI_Reason_Read, block);
-#else
-  register int r0 asm("r0") = fh;
-  register int r1 asm("r1") = (int) ptr;
-  register int r2 asm("r2") = (int) len;
-  asm ("swi %a4"
-       : "=r" (r0)
-       : "0"(r0), "r"(r1), "r"(r2), "i"(SWI_Read));
-  return r0;
-#endif
-}
-
-/* file, is a valid user file handle.
-   Translates the return of _swiread into
-   bytes read. */
-int __attribute__((weak))
-_read (int file, void * ptr, size_t len)
-{
-  int slot = findslot (remap_handle (file));
-  int x = _swiread (file, ptr, len);
-
-  if (x < 0)
-    return error (-1);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles [slot].pos += len - x;
-
-  /* x == len is not an error, at least if we want feof() to work.  */
-  return len - x;
-}
-
-/* file, is a user file descriptor. */
-off_t
-_swilseek (int file, off_t ptr, int dir)
-{
-  _off_t res;
-  int fh = remap_handle (file);
-  int slot = findslot (fh);
-
-  if (dir == SEEK_CUR)
-    {
-      off_t pos;
-      if (slot == MAX_OPEN_FILES)
-	return -1;
-      pos = openfiles[slot].pos;
-
-      /* Avoid SWI SEEK command when just querying file position. */
-      if (ptr == 0)
-	return pos;
-
-      ptr += pos;
-      dir = SEEK_SET;
-    }
-
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  if (dir == SEEK_END)
-    {
-      block[0] = fh;
-      ptr += do_AngelSWI (AngelSWI_Reason_FLen, block);
-    }
-
-  /* This code only does absolute seeks.  */
-  block[0] = remap_handle (file);
-  block[1] = ptr;
-  res = do_AngelSWI (AngelSWI_Reason_Seek, block);
-#else
-  register int r0 asm("r0");
-  register int r1 asm("r1");
-  if (dir == SEEK_END)
-    {
-      r0 = (int) fh;
-      asm ("swi %a2"
-	   : "=r" (r0)
-	   : "0"(r0), "i" (SWI_Flen));
-      res = r0;
-      ptr += res;
-    }
-
-  /* This code only does absolute seeks.  */
-  r0 = (int) fh;
-  r1 = (int) ptr;
-  asm ("swi %a3"
-       : "=r" (r0)
-       : "0"(r0), "r"(r1), "i" (SWI_Seek));
-  res = r0;
-#endif
-
-  if (slot != MAX_OPEN_FILES && res == 0)
-    openfiles[slot].pos = ptr;
-
-  /* This is expected to return the position in the file.  */
-  return res == 0 ? ptr : -1;
-}
-
-off_t
-_lseek (int file, off_t ptr, int dir)
-{
-  return wrap (_swilseek (file, ptr, dir));
-}
-
-/* file, is a valid internal file handle.
-   Returns the number of bytes *not* written. */
-int
-_swiwrite (int file, const void * ptr, size_t len)
-{
-  int fh = remap_handle (file);
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-
-  block[0] = fh;
-  block[1] = (int) ptr;
-  block[2] = (int) len;
-
-  return do_AngelSWI (AngelSWI_Reason_Write, block);
-#else
-  register int r0 asm("r0") = fh;
-  register int r1 asm("r1") = (int) ptr;
-  register int r2 asm("r2") = (int) len;
-
-  asm ("swi %a4"
-       : "=r" (r0)
-       : "0"(fh), "r"(r1), "r"(r2), "i"(SWI_Write));
-  return r0;
-#endif
-}
-
-/* file, is a user file descriptor. */
-int __attribute__((weak))
-_write (int file, const void * ptr, size_t len)
-{
-  int slot = findslot (remap_handle (file));
-  int x = _swiwrite (file, ptr, len);
-
-  if (x == -1 || x == len)
-    return error (-1);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles[slot].pos += len - x;
-
-  return len - x;
-}
-
-extern int strlen (const char *);
-
-int
-_swiopen (const char * path, int flags)
-{
-  int aflags = 0, fh;
-#ifdef ARM_RDI_MONITOR
-  int block[3];
-#endif
-
-  int i = findslot (-1);
-
-  if (i == MAX_OPEN_FILES)
-    return -1;
-
-  /* The flags are Unix-style, so we need to convert them.  */
-#ifdef O_BINARY
-  if (flags & O_BINARY)
-    aflags |= 1;
-#endif
-
-  if (flags & O_RDWR)
-    aflags |= 2;
-
-  if (flags & O_CREAT)
-    aflags |= 4;
-
-  if (flags & O_TRUNC)
-    aflags |= 4;
-
-  if (flags & O_APPEND)
-    {
-      aflags &= ~4; /* Can't ask for w AND a; means just 'a'.  */
-      aflags |= 8;
-    }
-
-#ifdef ARM_RDI_MONITOR
-  block[0] = (int) path;
-  block[2] = strlen (path);
-  block[1] = aflags;
-
-  fh = do_AngelSWI (AngelSWI_Reason_Open, block);
-
-#else
-  register int r0 asm("r0") = (int) path;
-  register int r1 asm("r1") = (int) aflags;;
-  asm ("swi %a3"
-       : "=r"(r0)
-       : "0"(r0), "r"(r1), "i" (SWI_Open));
-  fh = r0;
-#endif
-
-  if (fh >= 0)
-    {
-      openfiles[i].handle = fh;
-      openfiles[i].pos = 0;
-    }
-
-  return fh >= 0 ? fh + FILE_HANDLE_OFFSET : error (fh);
-}
-
-int
-_open (const char * path, int flags, ...)
-{
-  return wrap (_swiopen (path, flags));
-}
-
-int
-_swiclose (int file)
-{
-  int myhan = remap_handle (file);
-  int slot = findslot (myhan);
-
-  if (slot != MAX_OPEN_FILES)
-    openfiles[slot].handle = -1;
-
-#ifdef ARM_RDI_MONITOR
-  return do_AngelSWI (AngelSWI_Reason_Close, & myhan);
-#else
-  register int r0 asm("r0") = myhan;
-  asm ("swi %a2" : "=r"(r0): "0"(r0), "i" (SWI_Close));
-  return r0;
-#endif
-}
-
-int
-_close (int file)
-{
-  return wrap (_swiclose (file));
-}
-
-static int
-_kill_shared (int pid, int sig, int reason)
-{
-  (void) pid; (void) sig;
-#ifdef ARM_RDI_MONITOR
-  /* Note: The pid argument is thrown away.  */
-  int block[2];
-  block[1] = sig;
-  block[0] = reason;
-  int insn;
-
-#if SEMIHOST_V2
-  if (_has_ext_exit_extended ())
-    {
-      insn = AngelSWI_Reason_ReportExceptionExtended;
-    }
-  else
-#endif
-    {
-      insn = AngelSWI_Reason_ReportException;
-    }
-
-#if SEMIHOST_V2
-if (_has_ext_exit_extended ())
-  do_AngelSWI (insn, block);
-else
-#endif
-  do_AngelSWI (insn, (void*)block[0]);
-
-#else
-  asm ("swi %a0" :: "i" (SWI_Exit));
-#endif
-
-  __builtin_unreachable();
-}
-
-int
-_kill (int pid, int sig)
-{
-  if (sig == SIGABRT)
-    _kill_shared (pid, sig, ADP_Stopped_RunTimeError);
-  else
-    _kill_shared (pid, sig, ADP_Stopped_ApplicationExit);
-}
-
-void
-_exit (int status)
-{
-  /* The same SWI is used for both _exit and _kill.
-     For _exit, call the SWI with "reason" set to ADP_Stopped_ApplicationExit
-     to mark a standard exit.
-     Note: The RDI implementation of _kill_shared throws away all its
-     arguments and all implementations ignore the first argument.  */
-  _kill_shared (-1, status, ADP_Stopped_ApplicationExit);
-}
-
-pid_t
-_getpid (void)
-{
-  return (pid_t)1;
-}
-
-/* Heap limit returned from SYS_HEAPINFO Angel semihost call.  */
-uint __heap_limit = 0xcafedead;
-
-void * __attribute__((weak))
-_sbrk (ptrdiff_t incr)
-{
-  extern char   end asm ("end"); /* Defined by the linker.  */
-  static char * heap_end;
-  char *        prev_heap_end;
-
-  if (heap_end == NULL)
-    heap_end = & end;
-
-  prev_heap_end = heap_end;
-
-  if ((heap_end + incr > stack_ptr)
-      /* Honour heap limit if it's valid.  */
-      || (__heap_limit != 0xcafedead && heap_end + incr > (char *)__heap_limit))
-    {
-      /* Some of the libstdc++-v3 tests rely upon detecting
-	 out of memory errors, so do not abort here.  */
-#if 0
-      extern void abort (void);
-
-      _write (1, "_sbrk: Heap and stack collision\n", 32);
-
-      abort ();
-#else
-      errno = ENOMEM;
-      return (void *) -1;
-#endif
-    }
-
-  heap_end += incr;
-
-  return (void *) prev_heap_end;
-}
-
-extern void memset (struct stat *, int, unsigned int);
-
-int __attribute__((weak))
-_fstat (int file, struct stat * st)
-{
-  memset (st, 0, sizeof (* st));
-  st->st_mode = S_IFCHR;
-  st->st_blksize = 1024;
-  return 0;
-  file = file;
-}
-
-int __attribute__((weak))
-_stat (const char *fname, struct stat *st)
-{
-  int file;
-
-  /* The best we can do is try to open the file readonly.  If it exists,
-     then we can guess a few things about it.  */
-  if ((file = _open (fname, O_RDONLY)) < 0)
-    return -1;
-
-  memset (st, 0, sizeof (* st));
-  st->st_mode = S_IFREG | S_IREAD;
-  st->st_blksize = 1024;
-  _swiclose (file); /* Not interested in the error.  */
-  return 0;
-}
-
-int __attribute__((weak))
-_link (const char *__path1 __attribute__ ((unused)), const char *__path2 __attribute__ ((unused)))
-{
-  errno = ENOSYS;
-  return -1;
-}
-
-int
-_unlink (const char *path)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  block[0] = (int)path;
-  block[1] = strlen(path);
-  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-void
-_raise (void)
-{
-  return;
-}
-
-int
-_gettimeofday (struct timeval * tp, void * tzvp)
-{
-  struct timezone *tzp = tzvp;
-  if (tp)
-    {
-    /* Ask the host for the seconds since the Unix epoch.  */
-#ifdef ARM_RDI_MONITOR
-      tp->tv_sec = do_AngelSWI (AngelSWI_Reason_Time,NULL);
-#else
-      {
-	register int r0 asm("r0");
-	asm ("swi %a1" : "=r" (r0): "i" (SWI_Time));
-	tp->tv_sec = r0;
-      }
-#endif
-      tp->tv_usec = 0;
-    }
-
-  /* Return fixed data for the timezone.  */
-  if (tzp)
-    {
-      tzp->tz_minuteswest = 0;
-      tzp->tz_dsttime = 0;
-    }
-
-  return 0;
-}
-
-/* Return a clock that ticks at 100Hz.  */
-clock_t
-_times (struct tms * tp)
-{
-  clock_t timeval;
-
-#ifdef ARM_RDI_MONITOR
-  timeval = do_AngelSWI (AngelSWI_Reason_Clock, NULL);
-#else
-  register int r0 asm("r0");
-  asm ("swi %a1" : "=r" (r0): "i" (SWI_Clock));
-  timeval = (clock_t) r0;
-#endif
-
-  if (tp)
-    {
-      tp->tms_utime  = timeval;	/* user time */
-      tp->tms_stime  = 0;	/* system time */
-      tp->tms_cutime = 0;	/* user time, children */
-      tp->tms_cstime = 0;	/* system time, children */
-    }
-
-  return timeval;
-};
-
-
-int
-_isatty (int fd)
-{
-#ifdef ARM_RDI_MONITOR
-  int fh = remap_handle (fd);
-  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
-#else
-  return (fd <= 2) ? 1 : 0;  /* one of stdin, stdout, stderr */
-#endif
-}
-
-int
-_system (const char *s)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[2];
-  int e;
-
-  /* Hmmm.  The ARM debug interface specification doesn't say whether
-     SYS_SYSTEM does the right thing with a null argument, or assign any
-     meaning to its return value.  Try to do something reasonable....  */
-  if (!s)
-    return 1;  /* maybe there is a shell available? we can hope. :-P */
-  block[0] = (int)s;
-  block[1] = strlen (s);
-  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
-  if ((e >= 0) && (e < 256))
-    {
-      /* We have to convert e, an exit status to the encoded status of
-         the command.  To avoid hard coding the exit status, we simply
-	 loop until we find the right position.  */
-      int exit_code;
-
-      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
-	continue;
-    }
-  return e;
-#else
-  if (s == NULL)
-    return 0;
-  errno = ENOSYS;
-  return -1;
-#endif
-}
-
-int
-_rename (const char * oldpath, const char * newpath)
-{
-#ifdef ARM_RDI_MONITOR
-  int block[4];
-  block[0] = (int) oldpath;
-  block[1] = strlen(oldpath);
-  block[2] = (int) newpath;
-  block[3] = strlen(newpath);
-  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
-#else
-  errno = ENOSYS;
-  return -1;
-#endif
-}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c third_party/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/sysconf.c	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,15 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <unistd.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+long sysconf (int c)
+{
+  	return -1;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/termios.c third_party/newlib-3.2.0/newlib/libc/sys/arm/termios.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/termios.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/termios.c	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,140 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <unistd.h>
+#include <termios.h>
+#include <sys/termios.h>
+
+
+/*
+ *
+ */
+int isatty(int fd)
+{   
+    int sc;
+    sc = _swi_isatty(fd);  
+
+    if (sc < 0)
+    {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+/*
+ *
+ */
+int tcgetattr(int fd,struct termios *termios_p)
+{
+    return ioctl(fd, TCGETS, termios_p);
+}
+
+/*
+ *
+ */
+int tcsetattr(int fd,int optional_actions, const struct termios *termios_p)
+{
+    int cmd;
+
+    switch (optional_actions) {
+        case TCSANOW:
+            cmd = TCSETS;
+            break;
+        case TCSADRAIN:
+            cmd = TCSETSW;
+            break;
+        case TCSAFLUSH:
+            cmd = TCSETSF;
+            break;
+        default:
+            errno = EINVAL;
+            return -1;
+    }
+
+    return ioctl(fd, cmd, termios_p);
+}
+
+/*
+ *
+ */
+pid_t tcgetpgrp(int fd)
+{
+    int p;
+
+    if (ioctl(fd,TIOCGPGRP,&p) < 0) {
+        return (pid_t)-1;
+    }
+
+    return (pid_t)p;
+}
+
+/*
+ *
+ */
+int tcsetpgrp(int fd, pid_t pid)
+{
+    int p = (int)pid;
+    return ioctl(fd,TIOCSPGRP, &p);
+}
+
+/*
+ *
+ */
+int tcflow (int fd, int action)
+{
+    return ioctl(fd, TCXONC, action);
+}
+
+/*
+ *
+ */
+int tcflush (int fd, int queue_selector)
+{
+    return ioctl(fd, TCFLSH, queue_selector);
+}
+
+/*
+ *
+ */
+int cfsetispeed (struct termios *termios_p, speed_t speed)
+{
+	  termios_p->c_ispeed = speed;
+	  return 0;
+}
+
+/*
+ *
+ */
+int cfsetospeed (struct termios *termios_p, speed_t speed)
+{
+	  termios_p->c_ospeed = speed;
+	  return 0;
+}
+
+/*
+ *
+ */
+speed_t cfgetispeed (const struct termios *termios_p)
+{
+  	return termios_p->c_ispeed;
+}
+
+/*
+ *
+ */
+speed_t cfgetospeed (const struct termios *termios_p)
+{
+  	return termios_p->c_ospeed;
+}
+
+/*
+ *
+ */
+char *ttyname(int fildes)
+{
+  	return "/dev/tty";
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/time.c third_party/newlib-3.2.0/newlib/libc/sys/arm/time.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/time.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/time.c	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,29 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/time.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <utime.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+time_t time (time_t *tloc)
+{
+	struct timeval tv;
+	
+	gettimeofday (&tv, NULL);
+	
+	return tv.tv_sec;
+}
+
+
+/*
+ *
+ */
+int utime(const char *path, const struct utimbuf *times)
+{
+	return 0;
+}
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/times.c third_party/newlib-3.2.0/newlib/libc/sys/arm/times.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/times.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/times.c	2022-06-30 11:15:44.966852097 +0100
@@ -0,0 +1,16 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <sys/times.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+clock_t times (struct tms *buf)
+{
+    errno = ENOSYS;
+    return -1;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/trap.S third_party/newlib-3.2.0/newlib/libc/sys/arm/trap.S
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/trap.S	2020-01-02 19:56:24.000000000 +0000
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/trap.S	1970-01-01 01:00:00.000000000 +0100
@@ -1,95 +0,0 @@
-        /* Run-time exception support */
-#ifndef __ARM_EABI__
-#include "swi.h"
-
-/* .text is used instead of .section .text so it works with arm-aout too.  */
-	.text
-        .align 0
-        .global __rt_stkovf_split_big
-        .global __rt_stkovf_split_small
-
-/* The following functions are provided for software stack checking.
-   If hardware stack-checking is being used then the code can be
-   compiled without the PCS entry checks, and simply rely on VM
-   management to extend the stack for a thread.
-
-   The stack extension event occurs when the PCS function entry code
-   would result in a stack-pointer beneath the stack-limit register
-   value.  The system relies on the following map:
-
-        +-----------------------------------+ <-- end of stack block
-        | ...                               |
-        | ...                               |
-        | active stack                      |
-        | ...                               | <-- sp (stack-pointer) somewhere in here
-        | ...                               |
-        +-----------------------------------+ <-- sl (stack-limit)
-        | stack-extension handler workspace |
-        +-----------------------------------+ <-- base of stack block
-
-   The "stack-extension handler workspace" is an amount of memory in
-   which the stack overflow support code must execute.  It must be
-   large enough to deal with the worst case path through the extension
-   code.  At the moment the compiler expects this to be AT LEAST
-   256bytes.  It uses this fact to code functions with small local
-   data usage within the overflow space.
-
-   In a true target environment We may need to increase the space
-   between sl and the true limit to allow for the stack extension
-   code, SWI handlers and for undefined instruction handlers of the
-   target environment.  */
-
-__rt_stkovf_split_small:
-        mov     ip,sp   @ Ensure we can calculate the stack required
-        @ and fall through to...
-__rt_stkovf_split_big:
-        @ in:   sp = current stack-pointer (beneath stack-limit)
-        @       sl = current stack-limit
-        @       ip = low stack point we require for the current function
-        @       lr = return address into the current function
-        @       fp = frame-pointer
-        @               original sp --> +----------------------------------+
-        @                               | pc (12 ahead of PCS entry store) |
-        @               current fp ---> +----------------------------------+
-        @                               | lr (on entry) pc (on exit)       |
-        @                               +----------------------------------+
-        @                               | sp ("original sp" on entry)      |
-        @                               +----------------------------------+
-        @                               | fp (on entry to function)        |
-        @                               +----------------------------------+
-        @                               |                                  |
-        @                               | ..argument and work registers..  |
-        @                               |                                  |
-        @               current sp ---> +----------------------------------+
-        @
-        @ The "current sl" is somewhere between "original sp" and "current sp"
-        @ but above "true sl". The "current sl" should be at least 256bytes
-        @ above the "true sl". The 256byte stack guard should be large enough
-        @ to deal with the worst case function entry stacking (160bytes) plus
-        @ the stack overflow handler stacking requirements, plus the stack
-        @ required for the memory allocation routines.
-        @
-        @ Normal PCS entry (before stack overflow check) can stack 16
-        @ standard registers (64bytes) and 8 floating point registers
-        @ (96bytes). This gives a minimum stack guard of 160bytes (excluding
-        @ the stack required for the code). (Actually only a maximum of
-        @ 14standard registers are ever stacked on entry to a function).
-        @
-        @ NOTE: Structure returns are performed by the caller allocating a
-        @       dummy space on the stack and passing in a "phantom" arg1 into
-        @       the function. This means that we do not need to worry about
-        @       preserving the stack under "sp" even on function return.
-        @ 
-        @        Code should never poke values beneath sp. The sp register
-        @        should always be "dropped" first to cover the data. This
-        @        protects the data against any events that may try and use
-        @        the stack.
-
-        SUB     ip, sp, ip      @ extra stack required for function
-        @ Add stack extension code here.  If desired a new stack chunk
-        @ can be allocated, and the register state updated suitably.
-
-        @ We now know how much extra stack the function requires.
-        @ Terminate the program for the moment:
-        swi     SWI_Exit
-#endif
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/truncate.c third_party/newlib-3.2.0/newlib/libc/sys/arm/truncate.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/truncate.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/truncate.c	2022-06-30 11:15:52.426981206 +0100
@@ -0,0 +1,53 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <sys/stat.h>
+#include <sys/syscalls.h>
+
+
+/* @brief Truncate an already open file
+ *
+ */
+int ftruncate (int fd, off_t size)
+{
+    int sc;
+    
+    sc = _swi_truncate(fd, size);
+    
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/* @brief Truncate a file
+ *
+ */
+int truncate (const char *path, off_t size)
+{
+    int fd;
+    int sc;
+    
+    fd = open(path, O_WRONLY);
+    
+    if (fd < 0) {
+      errno = -fd;
+      return -1;
+    }
+        
+    sc = _swi_truncate(fd, size);
+    close(fd);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/unlink.c third_party/newlib-3.2.0/newlib/libc/sys/arm/unlink.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/unlink.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/unlink.c	2022-06-30 11:15:57.535069301 +0100
@@ -0,0 +1,23 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/* @brief Remove a file
+ *
+ */
+int unlink (char *path)
+{
+    int sc;
+    
+  	sc = _swi_unlink(path);
+  	
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;	
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/update.sh third_party/newlib-3.2.0/newlib/libc/sys/arm/update.sh
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/update.sh	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/update.sh	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,7 @@
+# When adding files to this directory, add the name
+# of the object file to makefile.am then run the following
+# script in this directory.
+
+aclocal -I ../../..
+autoconf
+automake --cygnus Makefile
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c third_party/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/user_strerror.c	2022-06-30 11:16:31.767653797 +0100
@@ -0,0 +1,20 @@
+#include <_ansi.h>
+#include <sys/syscalls.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+
+
+
+char * _user_strerror (int errnum)
+{
+    char *error;
+
+    switch (errnum) {
+        default:
+        error = NULL;
+    }
+
+    return error;		
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/virtualalloc.c third_party/newlib-3.2.0/newlib/libc/sys/arm/virtualalloc.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/virtualalloc.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/virtualalloc.c	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,69 @@
+#include <_syslist.h>
+#include <sys/types.h>
+#include <sys/syscalls.h>
+#include <stdlib.h>
+#include <errno.h>
+
+
+/*
+ *
+ */
+void *virtualalloc (void *addr, size_t size, bits32_t flags)
+{
+    return _swi_virtualalloc(addr, size, flags);
+}
+
+
+/*
+ *
+ */
+void *virtualallocphys (void *addr, size_t size, bits32_t flags, void *phys_addr)
+{
+    return _swi_virtualallocphys(addr, size, flags, phys_addr);
+}
+
+
+/*
+ *
+ */
+int virtualfree (void *addr, size_t size)
+{
+    int sc;
+      
+    sc = _swi_virtualfree(addr, size);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+int virtualprotect (void *addr, size_t sz, bits32_t flags)
+{
+    int sc;
+      
+    sc = _swi_virtualprotect(addr, sz, flags);
+
+    if (sc < 0) {
+        errno = -sc;
+        return -1;
+    }
+    
+    return 0;
+}
+
+
+/*
+ *
+ */
+void *virtualtophysaddr(void *addr)
+{
+    return _swi_virtualtophysaddr(addr);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/wait.c third_party/newlib-3.2.0/newlib/libc/sys/arm/wait.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/wait.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/wait.c	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,32 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+
+/* @brief Wait for a process terminate
+ * 
+ */
+pid_t waitpid (pid_t pid, int *status, int options)
+{
+  pid_t rpid;
+  
+  rpid = _swi_waitpid (pid, status, options);
+  
+  if (rpid < 0) {
+    errno = -rpid;
+    return -1;
+  }
+  
+  return rpid;
+}
+
+
+/* @brief Wait for any process to terminate
+ * 
+ */
+int wait (int *status)
+{
+ return waitpid (-1, status, 0);
+}
+
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/warning.h third_party/newlib-3.2.0/newlib/libc/sys/arm/warning.h
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/warning.h	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/warning.h	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,43 @@
+#ifndef __WARNING_H__
+#define __WARNING_H__
+
+#ifdef HAVE_GNU_LD
+# ifdef HAVE_ELF
+
+/* We want the .gnu.warning.SYMBOL section to be unallocated.  */
+#  ifdef HAVE_ASM_PREVIOUS_DIRECTIVE
+#   define __make_section_unallocated(section_string)   \
+  asm(".section " section_string "; .previous");
+#  elif defined (HAVE_ASM_POPSECTION_DIRECTIVE)
+#   define __make_section_unallocated(section_string)   \
+  asm(".pushsection " section_string "; .popsection");
+#  else
+#   define __make_section_unallocated(section_string)
+#  endif
+
+#  ifdef HAVE_SECTION_ATTRIBUTES
+#   define link_warning(symbol, msg)                     \
+  __make_section_unallocated (".gnu.warning." #symbol)  \
+  static const char __evoke_link_warning_##symbol[]     \
+    __attribute__ ((section (".gnu.warning." #symbol))) = msg;
+#  else
+#   define link_warning(symbol, msg)
+#  endif
+
+#else /* !ELF */
+
+#  define link_warning(symbol, msg)             \
+  asm(".stabs \"" msg "\",30,0,0,0\n"   \
+      ".stabs \"" __SYMBOL_PREFIX #symbol "\",1,0,0,0\n");
+# endif
+#else /* !GNULD */
+/* We will never be heard; they will all die horribly.  */
+# define link_warning(symbol, msg)
+#endif
+
+/* A canned warning for sysdeps/stub functions.  */
+#define stub_warning(name) \
+  link_warning (name, \
+                "warning: " #name " is not implemented and will always fail")
+
+#endif /* __WARNING_H__ */
diff -aurN third_party_original/newlib-3.2.0/newlib/libc/sys/arm/write.c third_party/newlib-3.2.0/newlib/libc/sys/arm/write.c
--- third_party_original/newlib-3.2.0/newlib/libc/sys/arm/write.c	1970-01-01 01:00:00.000000000 +0100
+++ third_party/newlib-3.2.0/newlib/libc/sys/arm/write.c	2022-06-29 14:50:02.893945506 +0100
@@ -0,0 +1,22 @@
+#include <_ansi.h>
+#include <_syslist.h>
+#include <errno.h>
+#include <sys/syscalls.h>
+
+/* @brief Write to a file
+ * 
+ */
+ssize_t write (int fd, const void *buf, size_t nbyte)
+{
+    ssize_t sz;
+    
+    sz = _swi_write(fd, buf, nbyte);
+    
+    if (sz < 0) {
+        errno = -sz;
+        return -1;
+    }
+	
+	return sz;
+}
+
